Item(by='eru', descendants=None, kids=[24988937], score=None, time=1604482570, title=None, item_type='comment', url=None, parent=24987183, text='&gt; And Go let&#x27;s you communicate by copying. That&#x27;s what a Channel is. Pass a struct and that is copied. Pass a pointer and the pointer is copied. The thing it points to isn&#x27;t copied for glaringly obvious reasons.<p>I&#x27;m not sure what those glaringly obvious reasons are.  In Erlang, you just send a copy of the whole struct.  Not some kind of references or pointers.<p>See eg <a href="https:&#x2F;&#x2F;play.golang.org&#x2F;p&#x2F;P3qUtFenp2q" rel="nofollow">https:&#x2F;&#x2F;play.golang.org&#x2F;p&#x2F;P3qUtFenp2q</a><p>But as I am saying, if you want to send pointers (or references) over a channel, they should support marking things as immutable.<p>&gt; And what would you suggest is a good alternative for returning multiple parameters. Currently this basically forces you to handle any possible errors and results in software you can very easily reason about.<p>Go doesn&#x27;t force you to handle errors at all.  The compiler will happily mix up the branches of your `if` that checks for errors, or let you get away without checking anything at all.<p>My suggestion would be eg algebraic data types.  Especially sum-types.  Or in more C inspired terms: tagged unions plus pattern matching.  Or &#x27;an enum with parameters&#x27;.<p>&gt; Not sure what you mean about human reviewers needing to check errors.<p>In a language without any checking at all like JavaScript, human authors and reviewers have to make sure that you don&#x27;t accidentally eg add a string to an int.  Or otherwise, have to make sure that at least you have enough test coverage.<p>In Go, the compiler can yell at you when you are trying to add an int to a string.<p>In OCaml or Haskel or Rust (or any language with algebraic data types), the compiler can make sure that you check your errors.  So in eg Haskell syntax that looks like this:<p><pre><code>    case someFunctionThatMightGoWrong(someParameter) of\n        Error errorDetails -&gt; handleErrors(errorDetails)\n        Success someValue -&gt; doSomethingSensible(someValue)\n</code></pre>\nCrucially, `someValue` is only in scope in the branch where we match the right pattern.  So you can&#x27;t accidentally go on computing with that variable in the wrong branch.<p>Does this make sense?  If not, I can try to explain in some other way.')