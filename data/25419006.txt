Item(by='loup-vaillant', descendants=None, kids=[25422870], score=None, time=1607961555, title=None, item_type='comment', url=None, parent=25417649, text='&gt; <i>defer just changes the problem from forgetting to write free to forgetting to write defer.</i><p>That&#x27;s the case only the first time you write code:<p><pre><code>  {\n      foo *f = new_foo();  &#x2F;&#x2F; step 1\n      &#x2F;* lots of code *&#x2F;   &#x2F;&#x2F; step 3\n      free(f);             &#x2F;&#x2F; step 2\n  }\n</code></pre>\nvs<p><pre><code>  {\n      foo *f = new_foo();  &#x2F;&#x2F; step 1\n      defer free(f);       &#x2F;&#x2F; step 2\n      &#x2F;* lots of code *&#x2F;   &#x2F;&#x2F; step 3\n  }\n</code></pre>\nSure, in both cases you can forget step 2. But what about <i>review</i>? With defer, the init and cleanup code are besides each other, and a missing defer would be immediately suspicious. <i>Without</i> defer, you&#x27;d have to check the end of the block to make sure the cleanup code is there. The absence of the cleanup code wouldn&#x27;t jump to your eyes the same way the absence of defer would. In the long run, this makes defer significantly harder to forget.<p>---<p>Another significant advantage of defer is that it can handle several exit points.  Imagine this code:<p><pre><code>  Foo f = new_foo();\n  defer free(f);\n  if (!f) {\n      return FAIL_FOO;\n  }\n  Bar b = new_bar();\n  defer free(b);\n  if (!b) {\n      return FAIL_BAR;\n  }\n  Baz z = new_baz();\n  defer free(z);\n  if (!z) {\n      return FAIL_BAZ;\n  }\n  &#x2F;* business logic *&#x2F;\n  &#x2F;* business logic *&#x2F;\n  &#x2F;* business logic *&#x2F;\n  return SUCCESS;\n</code></pre>\nNow the same, without defer:<p><pre><code>  Foo f = new_foo();\n  if (!f) {\n      free(f);\n      return FAIL_FOO;\n  }\n  Bar b = new_bar();\n  if (!b) {\n      free(f);\n      free(b);\n      return FAIL_BAR;\n  }\n  Baz z = new_baz();\n  if (!z) {\n      free(f);\n      free(b);\n      free(z);\n      return FAIL_BAZ;\n  }\n  &#x2F;* business logic *&#x2F;\n  &#x2F;* business logic *&#x2F;\n  &#x2F;* business logic *&#x2F;\n  free(f);\n  free(b);\n  free(z);\n  return SUCCESS;\n</code></pre>\nYou really don&#x27;t want to repeat yourself like that, you&#x27;d be liable to forget something. Now we <i>could</i> use `goto` and a return value:<p><pre><code>      ReturnValue retval = SUCCESS;\n      Foo f = new_foo();\n      if (!f) {\n          retval = FAIL_FOO;\n          goto cleanup;\n      }\n      Bar b = new_bar();\n      if (!b) {\n          retval FAIL_BAR;\n          goto cleanup;\n      }\n      Baz z = new_baz();\n      if (!z) {\n          retval FAIL_BAZ;\n          goto cleanup;\n      }\n      &#x2F;* business logic *&#x2F;\n      &#x2F;* business logic *&#x2F;\n      &#x2F;* business logic *&#x2F;\n  cleanup:\n      free(f);\n      free(b);\n      free(z);\n      return retval;\n</code></pre>\nBetter, except maybe the fact that Q&#x2F;A hates you. All is not lost, you can still please them with a single exit point (pattern seen in the real world):<p><pre><code>  ReturnValue retval = SUCCESS;\n  Foo f = new_foo();\n  if (f) {\n      Bar b = new_bar();\n      if (b) {\n          Baz z = new_baz();\n          if (z) {\n              &#x2F;* business logic *&#x2F;\n              &#x2F;* business logic *&#x2F;\n              &#x2F;* business logic *&#x2F;\n          } else {\n              retval FAIL_BAZ;\n          }\n          free(z);\n      } else {\n          retval FAIL_BAR;\n      }\n      free(b);\n   } else {\n      retval = FAIL_FOO;\n  }\n  free(f);\n  return retval;\n</code></pre>\nTo be honest this may be the worst of them all.<p>---<p>The only real contenders for this use case are defer and goto, and even then I think I prefer defer.')