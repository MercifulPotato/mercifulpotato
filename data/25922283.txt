Item(by='musicale', descendants=None, kids=[25923171, 25922430, 25922774], score=None, time=1611703663, title=None, item_type='comment', url=None, parent=25921592, text='&gt; But if sudo were written in Rust, it could have the same level of complexity and not be vulnerable<p>I&#x27;m puzzled that we don&#x27;t have a memory-safe ABI (e.g. amd64-safe) and runtime for C so we could just compile things with<p><pre><code>    clang -safe sudo.c\n</code></pre>\nto avoid memory errors. I&#x27;m fine with sudo (or whatever) taking a 60% performance hit to be more reliable - processors are thousands of times faster now than they were in 1980 when sudo was written. If we had a memory-safe ABI for C&#x2F;C++ in common use its performance overhead could probably be reduced significantly over time due to implementation improvements, and we might see hardware acceleration for it as well.<p>There are a number of proof-of-concept memory-safe compilers for C using fat pointers, etc., but memory safety hasn&#x27;t made it into gcc or clang. 64-bit CPUs can help because you can repurpose address bits. Even Pascal (which is largely isometric to C) supported a degree of memory safety via array bounds checking. I believe Ada compilers also support memory safety. PL&#x2F;I was actually memory safe and is why Multics never had any buffer overflows. Obviously Rust is memory safe, but for a lot of legacy C code it is impractical to rewrite everything in Rust but eminently practical to recompile it with memory safety turned on.')