Item(by='dwohnitmok', descendants=None, kids=[25038472], score=None, time=1604946037, title=None, item_type='comment', url=None, parent=25036467, text='I think you&#x27;ve swung way hard the other way. Specifically you&#x27;re overlooking various classes of analysis that do get easier with more restricted languages and focusing too hard on the general analysis of &quot;let me prove an arbitrary statement about an arbitrary program&quot; (i.e. the same pitfall people fall into when they point to Rice&#x27;s theorem and say &quot;ah so static analyzers are a worthless waste of time&quot;).<p>For example, with a strongly normalizing lambda calculus, I can prove intentional equality for any two functions and also have the nice property that extensional and intentional equality coincide.<p>This means that I can prove e.g. that refactors that aren&#x27;t supposed to change behavior in fact don&#x27;t. A specific class of analysis to be sure that&#x27;s not as useful as a general &quot;prove anything about this function,&quot; but still quite useful. This specific property happens to be true of dhall.<p>From the viewpoint of state machines, this is also true of FSMs. In that case, another way to think of it is that you get optimization for free. You can construct the minimal FSM with the same behavior as once you&#x27;ve created (this is also true for the lambda calculus case but generally it seems the lambda calculus isn&#x27;t thought of usually in operational terms the same way FSMs are).<p>Moreover, your last comment also illustrates that there are indeed classes of programs that are quite easy to analyze. When you say &quot;many specific instances of programs&quot; I presume you don&#x27;t literally mean hard-coded single instances of a program, but rather classes of programs that all are structurally similar. These classes do not always align nicely along with the usual classes in theoretical CS, but that doesn&#x27;t mean they aren&#x27;t useful.<p>For example a language consisting entirely of the holonomic functions with the usual semantics of them preserves symbolic integration, a nice little bit of analysis in the world of mathematical computing.')