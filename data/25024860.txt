Item(by='lyxsus', descendants=None, kids=[25024989], score=None, time=1604833036, title=None, item_type='comment', url=None, parent=25024429, text='lol, no. but nice cherry-picking, btw. too bad the original (and unedited) post is still available.<p># part 1\nLet me break it down for you:<p>&gt; (This example is pretty silly, but I have very similar and not silly examples that I just can&#x27;t share because of respect for my employer&#x27;s NDA).\nSo that&#x27;s an example, an illustration. Like a metaphor, it works if other person is willing to communicate. It doesn&#x27;t work if you cut and stretch it to fit your agenda. That&#x27;s not an object of discussion, it is a pointer. Ok?<p>&gt; If you just need to get one user object, it&#x27;s not different from rest.\nThat simply says if you need some data, you have to get some that data. That statement is correct no matter what protocol you use. What would you do in rest, btw? Have a single endpoint, where you&#x27;re trying to make a guess about what&#x27;s the structure of this data would be? Having separate endpoints and have client cycle them to get what he needs? Limit his ability to traverse domain schema? In my opinion, these are f-off solutions. Because you&#x27;re basically saying, that&#x27;s the structure I know how to optimise on a backend, live with it. Look, it works great! What does it matter that you can&#x27;t efficiently get your data? Not my problem, see, each of my endpoint is fast and simple.<p>&gt; If you need to get user, then 5 of his posts, then 50 of comments for each post and then 100 reactions for each post, all connected by IDs in your DB, GraphQL allows you to do all of this in a single HTTP request, single SQL query and with 0 lines written by backend developer.\nYes, yes. That&#x27;s exactly what will effectively work for that toy example. You actually can do that. Now, of course real-life is much more complicated and even if you&#x27;re going to map gql to database, you don&#x27;t want to map its structure as-is. It could be an interesting conversation on how to do that, but unfortunately, it&#x27;s not.\nBut back on track, I believe the idea behind the quoted sentence is to illustrates, that you can do it, you can optimise a sequential and hierarchical query if that&#x27;s possible. And in more complex cases, because you have a lot of information statically available and at query time you have a full structured query, you can know ahead its complexity and you know exactly what resolvers can be possibly executed to resolve the query. That gives you options:\n1. Dumb and naive. Just call each resolver separately. That probably mirrors what would happen in rest. Because I&#x27;ll repeat myself once again: you need the data, you have to get the data. In terms of transferring, transformation and querying, there should be zero difference.\n2. A slightly smarter one. You can compose certain resolvers by grouping requests of same edges. That&#x27;s fairly easy and should I explain why it&#x27;s better than trying to do the same thing using rest, probably relying on intricacies of some query language a wise backend developer invented to solve a solved problem?\n3. You can optimise for requests patterns. Yeah, that&#x27;s right. You know that in order to satisfy gql client for such and such use-case, it needs certain data. So instead of making a separate endpoint with arbitrary degrees of freedom, you can have a better, cooler resolver that will perform your complex, which is exactly what you need. And if client requirement changes, he can extend that query and your optimised resolver will now work as a scaffold and additional resolvers will run on unexpected leafs. Which, again, you can optimise if you&#x27;ll need. But that doesn&#x27;t change the fact that client needs data. And he&#x27;ll get it&#x27;ll certainly get it anyway.\nNow a reasonable combinations of these 3 options are required in reality. But that toy problem in topic illustrates exactly that: you can have a nice computer-assisted solution. And I don&#x27;t think anybody doubt that in this particular case computer <i>can</i> generate a query almost as good as an average backend dev with &quot;with 0 lines written by backend developer.&quot;.')