Item(by='kazinator', descendants=None, kids=None, score=None, time=1611793414, title=None, item_type='comment', url=None, parent=25933121, text='The author has just replaced one mechanism for OO with another one.<p>If you think you don&#x27;t need OO, then prove it by doing this:<p><pre><code>  # [0] is the root_url\n  # [1] is the url_layout for formatting it: must contain {entity}.\n\n  client_a = [ &quot;https:&#x2F;&#x2F;client-a&quot;, &quot;{root_url}&#x2F;{entity}&quot; ]\n</code></pre>\nIf you have client.root_url type stuff in your program, then it&#x27;s using some degree of OO.<p>In he new program, this is obviously OOP:<p><pre><code>  def construct_url(client: Client, entity: str) -&gt; str:\n      return client.url_layout.format(root_url=client.root_url,  entity=entity)\n</code></pre>\nIn the original program, inheritance was used to specialize the formatting behavior.  That had to be somehow preserved.<p>How it was preserved was by <i>aggregating</i> a layout string and <i>delegating</i> the formatting task to its layout. (I smell a Design Pattern, but we are not doing OO!)<p>But that can be back-ported to the original program:<p><pre><code>  class ApiClient:\n    def __init__(self, root_url: str, session_cls: sessionmaker, layout: str):\n        self.root_url = root_url\n        self.session_cls = session_cls\n        self.layout = layout\n\n    def construct_url(self, entity: str) -&gt; str:\n        return self.layout.format(root_url=self.root_url,  entity=entity)\n\n    def get_items(self, entity: str) -&gt; List[Item]:\n        resp = requests.get(self.construct_url(entity))\n        resp.raise_for_status()\n        return [Item(**n) for n in resp.json()[&quot;items&quot;]]\n\n    def save_items(self, entity: str) -&gt; None:\n        with scoped_session(self.session_cls) as session:\n            session.add(self.get_items(entity))\n\n  client_a = ApiClient(&quot;https:&#x2F;&#x2F;client-a&quot;, session_cls,\n                       &quot;{root_url}&#x2F;{entity}&quot;)\n  client_b = ApiClient(&quot;https:&#x2F;&#x2F;client-a&quot;, session_cls, &quot;{root_url}&#x2F;a&#x2F;special&#x2F;place&#x2F;{entity}&quot;)\n\n  client_a.save_items(&quot;bars&quot;)\n</code></pre>\nAlso, the author eliminated the session_cls member variable, which is only used in the save_items function. That also can be done to the original:<p><pre><code>  class ApiClient:\n    def __init__(self, root_url: str, layout: str):\n        self.root_url = root_url\n        self.layout = layout\n\n    def construct_url(self, entity: str) -&gt; str:\n        return self.layout.format(root_url=self.root_url,  entity=entity)\n\n    def get_items(self, entity: str) -&gt; List[Item]:\n        resp = requests.get(self.construct_url(entity))\n        resp.raise_for_status()\n        return [Item(**n) for n in resp.json()[&quot;items&quot;]]\n\n    def save_items(self, session_cls: sessionmaker, entity: str) -&gt; None:\n        with scoped_session(self.session_cls) as session:\n            session.add(self.get_items(entity))\n\n  client_a = ApiClient(&quot;https:&#x2F;&#x2F;client-a&quot;,\n                       &quot;{root_url}&#x2F;{entity}&quot;)\n  client_b = ApiClient(&quot;https:&#x2F;&#x2F;client-a&quot;,\n                        &quot;{root_url}&#x2F;a&#x2F;special&#x2F;place&#x2F;{entity}&quot;)\n\n  client_a.save_items(session_cls, &quot;bars&quot;)\n</code></pre>\nIn the end, all the author shows it that if all we need is minor variations in formatting some string by sticking values into a template string, we might want to do exactly that and not whip out inheritance.<p>But, note, that the original code can <i>compile</i>:<p>The following performs the formatting job using <i>code</i> that can compile:<p><pre><code>  class ClientA(ApiClient):\n      def construct_url(self, entity: str) -&gt; str:\n          return f&quot;{self.root_url}&#x2F;{entity}&quot;\n</code></pre>\n(If an f-string doesn&#x27;t map to compiled code that doesn&#x27;t interpret the format string at run-time, someone in Python-land has obvious work to do.)<p>This uses run-time interpretation of a dynamically supplied format string&quot;:<p><pre><code>    def construct_url(self, entity: str) -&gt; str:\n        return self.layout.format(root_url=self.root_url,  entity=entity)\n</code></pre>\nThough that could be optimized by, say, storing JIT-ted code into the layout string the first time format is called, it probably isn&#x27;t.')