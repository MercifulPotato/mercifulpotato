Item(by='hajile', descendants=None, kids=[24892325], score=None, time=1603674051, title=None, item_type='comment', url=None, parent=24891382, text='Are you familiar with unsafe IO?<p>It&#x27;s used pervasively in low-level code because the idealism of monads just doesn&#x27;t cut it. In my opinion, this proves that the pragmatism of side effects is a necessary evil for actually getting things done in a performant way.<p>Lazy evaluation has the same kind of issues. Most humans don&#x27;t think that way, so performance suffers. This may be a universal problem as in my experience, Haskell doesn&#x27;t have good tooling to help with this issue.<p>Always immutable is another large issue. Yes, there&#x27;s a ton of safety in immutability and it&#x27;s the right tool for MOST code. Compilers aren&#x27;t prefect and there seem to be an endless stream of situations where the compiler can&#x27;t figure out if it is safe to mutate &quot;immutable&quot; data to gain performance. For the foreseeable future, the ability to mutate can have huge performance dividends.<p>Finally, Haskell and it&#x27;s libraries are prone to rather academic programming styles and techniques. These are amazing and beautiful. They also can be hard to grep even if you know the math. When you consider that the overwhelming majority of programmers don&#x27;t know the math, it seems plain that these constructs are a detriment to pragmatic, non-academic usage.')