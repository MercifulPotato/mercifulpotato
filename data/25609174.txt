Item(by='amw-zero', descendants=None, kids=[25614247, 25609398, 25610966], score=None, time=1609549656, title=None, item_type='comment', url=None, parent=25608632, text='First of all, that sounded negative and I&#x27;m totally not knocking Xstate. I&#x27;m pro any library that encourages people to think about state machines :D<p>I&#x27;m really speaking tactically about how best to represent the machine, more of an optimization thing. For that, the features that you mentioned do help, no question there. Statecharts is a great formalism overall. But in my opinion, they help more at the macro level, like when thinking about the entire UI as a single state machine and how to modularize that.<p>Hierarchy and orthogonality are not always present - sometimes state variables truly interact. I&#x27;m speaking more about that scenario. I&#x27;ll take an example right from the Xstate documentation:<p><pre><code>  list: {\n    initial: &#x27;none&#x27;,\n    states: {\n      none: {\n        on: { BULLETS: &#x27;bullets&#x27;, NUMBERS: &#x27;numbers&#x27; }\n      },\n      bullets: {\n        on: { NONE: &#x27;none&#x27;, NUMBERS: &#x27;numbers&#x27; }\n      },\n      numbers: {\n        on: { BULLETS: &#x27;bullets&#x27;, NONE: &#x27;none&#x27; }\n      }\n    }\n  }\n</code></pre>\nHere, we have a state machine that looks like it powers some logic in a word processor, where a user can create lists. You can toggle bulleted or numbered lists on and off, as well as switch between them once either has been selected. Since each state can transition to each other state, each state references each other state in the transition description. What happens when you add another state there, let&#x27;s say we can have a list with letters as indexes. You&#x27;d have to add another transition from each existing state to the new one, and add a transition from the new state to all the other ones. This is an O(N) operation as we agreed since every new state means there are N possible edges from it to all other states, and each existing state can have an edge to the new state. I believe this is what people mean when state machines are &quot;hard to modify.&quot;<p>What if instead we used variables to represent the state, and had a single function which determined the next state to go to based on the existing state:<p><pre><code>  type State = {\n    showingBullets: Boolean,\n    showingNumbers: Boolean,\n  } \n\n  enum Action {\n    ToggleBullets,\n    ToggleNumbers,\n  }\n\n  function next(state: State, action: Action): State {\n    let nextState = { showingBullets: false, showingNumbers: false };\n\n    switch (action) {\n    case Action.ToggleBullets:\n      nextState.showingBullets = !state.showingBullets;\n      break;\n    case Action.ToggleNumbers:\n      nextState.showingNumbers = !state.showingNumbers;\n      break;\n    };\n\n    return nextState;\n  }\n</code></pre>\nNow, the process of adding a new state would be just adding a new case in the switch statement. That&#x27;s constant time, O(1). This is because the next function is actually a relation - it can map a single state to multiple next states.<p>I will admit, this may be personal preference. With the Xstate approach, where you specify all transitions explicitly, there&#x27;s no thinking. You just read which state maps to which next state. A relation has logic, which means you have to compute in your head all of the possible next states. It&#x27;s the tradeoff between expressive power and explicitness.')