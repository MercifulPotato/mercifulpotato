Item(by='judofyr', descendants=None, kids=[25643815], score=None, time=1609835096, title=None, item_type='comment', url=None, parent=25642062, text='I looked a bit into this code and here&#x27;s a short summary:<p>- The API supports GET&#x2F;PUT&#x2F;DELETE (no range queries).<p>- It uses 1 master server and N volume servers.<p>- The master server keeps track of all keys and all requests need to go through this server. The values are stored in one or more volume servers using rendezvous hashing.<p>- The volume servers are just Nginx + DAV which stores data on disk.<p>- There&#x27;s no live support for rebalancing. If you change the backend volumes, then you need to take the master server down, run a re-balancing job and then bring it up again.<p>- Objects are locked in the master server during modification. This means that while a server is processing PUT&#x2F;DELETE all GET requests for that key will be blocked.<p>- There&#x27;s no handling of errors from the volume servers. E.g. if one volume server fails to store data, then it won&#x27;t rollback the changes done to the other volume servers nor do anything in the master server.<p>- The benchmarking tool (thrasher.go) does &quot;10000 write&#x2F;read&#x2F;delete&quot; in 16 threads&#x2F;goroutines. This means that it generates 10k random keys (i.e. no contention at all), and for each key it does a PUT, then a GET and then a DELETE. Their result show that it&#x27;s capable of handling 3815.40 keys&#x2F;sec (i.e. multiply this by 3 to get the request count).')