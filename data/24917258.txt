Item(by='vindarel', descendants=None, kids=None, score=None, time=1603881692, title=None, item_type='comment', url=None, parent=24915100, text='or do the reverse, call Python from Lisp: <a href="https:&#x2F;&#x2F;github.com&#x2F;bendudson&#x2F;py4cl" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;bendudson&#x2F;py4cl</a> or call Lisp from Python: <a href="https:&#x2F;&#x2F;github.com&#x2F;marcoheisig&#x2F;cl4py" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;marcoheisig&#x2F;cl4py</a><p>(or if it&#x27;s because of Numpy, see NumCL <a href="https:&#x2F;&#x2F;numcl.github.io&#x2F;numcl&#x2F;" rel="nofollow">https:&#x2F;&#x2F;numcl.github.io&#x2F;numcl&#x2F;</a>)<p>in my taste Hy lacks a good lot of Lisp advantages… no closures with &quot;let&quot; by default, no image-based development and the excellent Lisp REPL, no Lisp&#x27;s interactivity (in Hy or Python a process must restart after a code change, whereas in Lisp you compile one function with a keystroke and voilà, it&#x27;s here to test), no Lisp&#x27;s efficiency, no Lisp object system, etc. <a href="https:&#x2F;&#x2F;lisp-journey.gitlab.io&#x2F;pythonvslisp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lisp-journey.gitlab.io&#x2F;pythonvslisp&#x2F;</a>')