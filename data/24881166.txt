Item(by='nerdtime', descendants=None, kids=[24881531], score=None, time=1603565596, title=None, item_type='comment', url=None, parent=24879763, text='Functional programs tend to be more modular than imperative or OOP counter parts but nobody really knows why nor do they understand the cases where FP becomes less modular.<p>FP is only modular when you use combinators. If you use closures then it&#x27;s no longer modular.<p><pre><code>   f x y = x + y\n   g y = y * 2\n   w x = (f x) . g\n</code></pre>\ng and f are combinators and modular and w is the composition of both of those combinators.<p><pre><code>   w = \\x -&gt; (\\y -&gt; (x + y) * 2)\n</code></pre>\nIn this case the above is not modular because it doesn&#x27;t use combinators. The above style is actually kind of promoted by haskell when you need to do things with side effects. It actually makes FP more complex than it needs to be without improving modularity.')