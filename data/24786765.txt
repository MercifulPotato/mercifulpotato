Item(by='tluyben2', descendants=None, kids=None, score=None, time=1602755691, title=None, item_type='comment', url=None, parent=24786222, text='We prototype everything in a higher level language first and then &#x27;translate it&#x27; (manually) to something that fits the production platform.<p>For instance, for our current iteration of our product, we created a first &#x27;visual prototype&#x27; with Flutter (this contains all algorithms and data-structures already to almost translate 1-1 to C++ and C&#x2F;asm), then we worked down to C++ (next time we are going to try Rust for this phase) on a powerful mcu but with the (mostly) identical peripherals as the final product. Final step (currently ongoing) is the translation to C&#x2F;asm to fit the MCU&#x27;s we use (2mhz&#x2F;24kb).<p>Over the decades we have seen that this process is the fastest and least bug prone way. We already think in low level structures and algorithm implementations when coding the high level &#x27;visual&#x27; model (or sales&#x2F;investor pitch model often) (which used to be Java desktop applications, but now with smart phones it&#x27;s far closer to what the end product will be) so that when we move down towards production components (which means basically as cheap as possible BOM for 1m+ runs; every cent counts, also, we have never had the experience where, after the fact, we encountered this common thing in software; &#x27;people are more expensive than hardware&#x27;. Even for a few cents difference we can pay more people than we needed. But yes, that means optimising every byte...), we don&#x27;t have to spend <i>that</i> much time on those. It&#x27;s just on hardware specific stuff for the C++ &#x27;big&#x27; mcu version and then it&#x27;s just bit-fiddling&#x2F;optimising for the lowest level version.')