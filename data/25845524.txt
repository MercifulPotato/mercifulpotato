Item(by='vindarel', descendants=None, kids=[25852324], score=None, time=1611145000, title=None, item_type='comment', url=None, parent=25843064, text='&gt; magic<p>I&#x27;d say yes, this, though you don&#x27;t actually manipulate a proper AST, but a list (tree) of program instructions. An AST would be given by a &quot;code walker&quot;. Plus, the syntax is small and coherent, the language is stable, the syntax makes it straightforward to add new language constructs that would need a language release for another classical language. With most implementations of Common Lisp, you code against a live image, so you get instant feedback: compile a <i>function</i> with a keybinding, see compiler warnings or errors instantly, try it right away in the REPL (no process had to restart), get an interactive debugger on an error, fix it and resume the execution from a chosen frame (no stack unbinding), inspect objects, change a class definition and have existing objects being (lazely) updated, given rules in the standard that you can control… when ready, build a binary, and deploy. Today, SBCL&#x27;s compile-time type-inference warnings are very helpful.<p>Of course, some companies use CL in a million-sized codebase (if that helps as a counter example): Google (ITA software), SISCOG (underground and rail transport optimisation), ACL2 (industry-strength theorem prover)…<p><a href="https:&#x2F;&#x2F;lisp-lang.org&#x2F;success&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lisp-lang.org&#x2F;success&#x2F;</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;azzamsa&#x2F;awesome-lisp-companies" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;azzamsa&#x2F;awesome-lisp-companies</a> (disclaimer: these resources are not complete)')