Item(by='zanecodes', descendants=None, kids=[24743670], score=None, time=1602378858, title=None, item_type='comment', url=None, parent=24742995, text='In Haskell (I know, I know) I would probably write something like this, if I were porting the example one-to-one:<p><pre><code>  getInsuranceAmount status = case\n      [hasInsurance,  isTotaled,  isDented,   isBigDent   ] &lt;*&gt; [status] of\n      [False,         _,          _,          _           ] -&gt;        1\n      [True,          True,       _,          _           ] -&gt;    10000\n      [True,          False,      False,      _           ] -&gt;        0\n      [True,          False,      True,       True        ] -&gt;      270\n      [True,          False,      True,       False       ] -&gt;      160\n</code></pre>\nPersonally, I&#x27;m not a fan of the early return pattern, since it forces me to read the entire function top to bottom (and possibly simulate a state machine in my head) to understand under what circumstances it returns each possible value, and I&#x27;m far too lazy for that.\nIn contrast, my example makes it very straightforward to see what set of conditions leads to which value, and vice versa.<p>Tangentially, this probably wouldn&#x27;t be a very idiomatic piece of code to write in Haskell, since some of the conditions are likely to be mutually exclusive (what does it mean when isDented is False but isBigDent is True?)\nMy instinct would be to model the status as a sum type, and then to pattern match on its inhabitants instead of writing helpers for &#x27;hasInsurance,&#x27; &#x27;isTotaled,&#x27; etc, but someone with proper professional Haskell experience might have an even slicker way to think of it.')