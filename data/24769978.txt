Item(by='ivanbakel', descendants=None, kids=None, score=None, time=1602621033, title=None, item_type='comment', url=None, parent=24767910, text='&gt;It&#x27;s just, why would you want to edit the proof term manually?<p>Because you want to produce a <i>particular</i> proof term, because you are programming, not proving. Even with the CHC, there is a distinction between the two.<p>&gt;Not only do you lose out on information about the generation (Why&#x2F;How was it generated?), if you change the code it was generated from, you&#x27;ll have to either manually edit the generated code (especially troublesome because the information of how it was generated was thrown away!)<p>This is a standard part of programming. Very rarely does editing code come with the complement of how&#x2F;why the code itself was written - and even it does (like through doc comments) editing the code can then invalidate that information because the motivation can become outdated.<p>&gt;Tactics aren&#x27;t &#x27;opaque&#x27;, it&#x27;s just a pain to manually look at the generated code and I don&#x27;t see how the same doesn&#x27;t apply here.<p>Because you <i>want</i> to look at the code, because the generated code is the objective of writing the tactics. You are not programming with tactics, you are <i>writing code</i> with tactics.<p>The point is this: if you wanted to prove `a -&gt; a -&gt; a`, then `intros; assumption` is a fine proof. But if you want to define `min :: (Ord a) =&gt; a -&gt; a -&gt; a`, then `intros; assumption` would typecheck without doing what you want. Tactics are not a good fit for programming, in general, because they fit the very different purpose of finding inhabitants rather than specifying them.<p>By contrast, actually writing code does seem like a good fit for tactics, because the steps you might take to iteratively program the particular term you want fit nicely with individual tactics.')