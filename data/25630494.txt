Item(by='thu2111', descendants=None, kids=[25631069], score=None, time=1609763599, title=None, item_type='comment', url=None, parent=25624695, text='I don&#x27;t think that&#x27;s really the case anymore. You have to separate three things:<p>1. Using the JVM for its capabilities, like the JITC and GC engines, which are very powerful.<p>2. Using the JVM for Java interop.<p>3. Using the JVM for generic cross-language interop.<p>The nice thing about the JVM especially now with Graal&#x2F;Truffle is it lets you explore and choose almost any point on the spectrum between &quot;we&#x27;re totally alien and the JVM is just our runtime&quot; and Kotlin-esque &quot;we are basically Java v2 with perfect interop&quot;. Modern JVMs are capable of running languages as diverse as Haskell, JavaScript, Kotlin, Ruby, WebAssembly, LLVM bitcode etc. Obviously if you&#x27;re coding in C or Rust and running it on the JVM via Sulong, your interop is going to be limited to creating objects and invoking simple functions on them. If you&#x27;re in Ruby or Python your interop gets better: you can expect automatic translation of things like Java-world collections to a vaguely native-language like collection via the Polyglot interop layer. And if you&#x27;re Kotlin then you don&#x27;t even create your own collections at all, just use the JDK standard library.<p>The point is, you don&#x27;t <i>have</i> to use the Java bytecode type system to interop with Java or other languages anymore. Graal has fixed that. Your language can have any arbitrary semantics and it will still be JIT compiled, GCd and it can still call into other languages. The closeness of the type system is now a choice you make that trades off ease of use of Java libraries vs whatever divergence you want to have.')