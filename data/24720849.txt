Item(by='seg_lol', descendants=None, kids=None, score=None, time=1602175187, title=None, item_type='comment', url=None, parent=24720562, text='&gt; API versioning is orthogonal to how you organize your code<p>They are, but they aren&#x27;t, because we have to basically increment two counters when things change.  If you want to be statically correct, you now have a distributed transaction to update both systems.<p>There is some path through a call graph (in-proc and rpc) that is statically valid. Then there are duck-typed results that are only additive, which you are describing. Provided the system can handle this (dictionaries over structs). You see this in protobuf and other static centric serialization systems. They start to encode dynamic information using the static building blocks. GCCs internal IR is like this.  I think what you are advocating for only applies to the domain of microservices, loosely connected using languages and formats that are open under union. Other systems without those properties will not fare so well.<p>The folks using the monorepos probably don&#x27;t disagree, but having atomic commits with hashes makes the identity function a useful crutch. I believe there are other solutions where the VCS could actually make this problem a non-issue.')