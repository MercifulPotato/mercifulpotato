Item(by='chriswarbo', descendants=None, kids=None, score=None, time=1612205281, title=None, item_type='comment', url=None, parent=25990985, text='See the Curry Howard Correspondence: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Curry%E2%80%93Howard_correspondence" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Curry%E2%80%93Howard_correspon...</a><p>Essentially: all programming languages are logics, and all logics are programming languages; all programs are proofs, and all proofs are programs; all (static) types are propositions, and all propositions are (static) types; and so on for every facet of computer programming and theorem proving.<p>It&#x27;s usually pointless to apply this to <i>existing</i> languages&#x2F;logics&#x2F;etc., since they end up being pretty terrible. For example, in a dynamically typed language like Python there is only one <i>static</i> type; hence if we view it as a logic there is only a single proposition; all Python programs are proofs of that same proposition, including trivial programs like &#x27;42&#x27;, and hence the logic is completely trivial.<p>More sophisticated languages can still end up being pretty trivial. For example, in Java the value &#x27;null&#x27; is a member of every type; hence from a logical perspective &#x27;null&#x27; is a proof of every proposition. Hence Java also collapses into triviality (from the programming perspective: no matter how complicated we make our class hierarchy, or how long we make the dependency chains between our constructors, users of our API can just give &#x27;null&#x27; for every argument and Java&#x27;s type checker will gladly accept it)<p>Even more &#x27;hardcore&#x27; languages like Haskell, which don&#x27;t have the &#x27;null&#x27; problem (but do have a less-severe problem called &quot;bottom&quot;, see <a href="http:&#x2F;&#x2F;chriswarbo.net&#x2F;blog&#x2F;2020-02-09-bottom.html" rel="nofollow">http:&#x2F;&#x2F;chriswarbo.net&#x2F;blog&#x2F;2020-02-09-bottom.html</a> ), end up being pretty trivial too. For example, Curry-Howard tells us that function types correspond to implication propositions, so &#x27;T1 -&gt; T2&#x27; is a function type with argument type T1 and return type T2, and also the proposition that T1 implies T2 (i.e. if T1 is true, then T2 is true).<p>At first glance this looks really useful, e.g. we if we have a function with type &#x27;CustomerRecord -&gt; JSON&#x27; it&#x27;s tempting to think of this as proof that CustomerRecords can be represented as JSON. Yet that&#x27;s <i>not</i> what it says: in particular, the return type doesn&#x27;t have any relationship to the input type. This function is <i>actually</i> stating that &quot;if you give me <i>any</i> CustomerRecord, I can give you <i>some</i> JSON value&quot;. This is much less useful; e.g. we could implement this function by always returning the JSON value &#x27;&quot;hello world&quot;&#x27;.<p>Hence the Curry Howard Correspondence only tends to be useful for languages which were designed to take advantage of it. Lean is one example; others are Agda, Coq and Idris. In all of these languages, proofs and programs are the same thing; functions and implications are the same thing; conjunctions and tuples are the same thing; and so on. This lets us prove propositions about programs, programatically generate proofs, and any combination of the two.<p>Incidentally, the way that these languages avoid being trivial is by having <i>dependent types</i>. These let us state relationships between the input and output types of a function, like &#x27;(x: Int) -&gt; Even (Double x)&#x27; (&quot;if x has type Int, then doubling x is even&quot;), or between the elements of a tuple, like &#x27;(x: Int, Even x)&#x27; (&quot;a value x of type Int, and a proof that x is even&quot;). I wrote a bit about this at <a href="http:&#x2F;&#x2F;chriswarbo.net&#x2F;blog&#x2F;2017-11-03-dependent_function_types.html" rel="nofollow">http:&#x2F;&#x2F;chriswarbo.net&#x2F;blog&#x2F;2017-11-03-dependent_function_typ...</a><p>The logic equivalent of a dependent function type is a universally quantified proposition (i.e. &quot;for all x, ...&quot;). The logic equivalent of a dependent tuple type is an existentially quantified proposition (i.e. &quot;there exists an x such that...&quot;). This tuple idea can also be extended to name&#x2F;value records too.')