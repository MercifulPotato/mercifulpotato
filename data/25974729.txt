Item(by='bmm6o', descendants=None, kids=[25975400], score=None, time=1612055391, title=None, item_type='comment', url=None, parent=25972641, text='Right. Often there are 2 types of interfaces in a project. The first are &quot;natural&quot; interfaces, that you have put some design into and are meant to be reusable. Things like Streams or Collections. When you write a function that uses one of these, you really are expecting to be able to use any implementation. If you want to go to the implementation of Stream.Read, obviously the IDE isn&#x27;t going to be able to do it, it&#x27;s abstract and there are any number of implementations.<p>You get the other kind of interface when you want to loosely-couple your code, and so you define interfaces for many classes. Often, there is only a single class that implements the interface in your project, though there may be mock implementations in your test code. Even though there is a single &quot;real&quot; implementation, the IDE can&#x27;t&#x2F;won&#x27;t jump to that implementation in the same way it won&#x27;t in the first case. This is frustrating though, because it would have worked if you hadn&#x27;t extracted the interface for improved testability.')