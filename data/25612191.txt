Item(by='captainmuon', descendants=None, kids=None, score=None, time=1609588699, title=None, item_type='comment', url=None, parent=25611563, text='For a long time, I struggled with endianness, because I thought that bitshifting and masking would be different on BE vs. LE:<p><pre><code>    &#x2F;&#x2F; wrong\n    uint32_t num = ...;\n    &#x2F;&#x2F; num is set to 0x10203040\n    num &gt;&gt; 24 == 0x10; &#x2F;&#x2F; On little endian\n    num &gt;&gt; 24 == 0x10; &#x2F;&#x2F; On big endian\n</code></pre>\nOf course that is wrong, and the second one is always the case. In a way, you could say C&#x2F;C++ is big endian - the higher valued byte is first (left in English reading order). In fact, if you avoid reinterpreting via casting &#x2F; punning &#x2F; memcpy, you don&#x27;t have to think about it at all [1].<p>One thing I have to do frustratingly often is to implement a bunch of functions like &quot;read_uint32_le&quot;, it is a pity that there is no comprehensive standard.<p>([1] On the other hand, I miss the good old days where you could treat C like &quot;high level assembler&quot;, a pointer was just a number that indexed memory, and you could reinterpret bytes with impunity - sometimes had to to get decent performance!)')