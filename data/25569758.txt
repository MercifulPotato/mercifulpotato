Item(by='CraigJPerry', descendants=None, kids=[25589008], score=None, time=1609250357, title=None, item_type='comment', url=None, parent=25569148, text='&gt; In 1986, perhaps I would have used telnet or ftp instead of scp.<p>In 1986 you would probably have used rcp (the thing that inspired scp). A lot less secure but with one benefit - when Dan did this mass scp i bet his local CPU was absolutely pegged well before network saturation?<p>Ssh imposes a hefty cpu overhead because of encryption that i didn’t appreciate until around 2005 when i was updating an rcp centric script to use scp.<p>&gt; Modern scripting languages didn&#x27;t exist yet (perl was created in 1987 and perl5, the first version that some argue is modern, was released in 1994), so writing code that would do this with parallelism and &quot;good enough&quot; error handling would have taken more than an order of magnitude more time than it takes today<p>You could have used ksh (a popular scriptable shell that heavily inspired Perl).<p>rcp errors are denoted by return code and thats also the natural error handling approach in ksh.<p>As for the grep &#x2F; sed &#x2F; awk part of the problem, it’s possible the 1986 local machine was uniprocessor - it might have been faster to do the processing locally on each node (via rsh) then only network transfer the result set back to the local node.<p>EDIT - job control (the thing that makes parallelism trivial in ksh) was only added in 1989. To easily get parallelism you would have had to write the script in csh - life’s too short for scripting in csh (or its descendants) so i conclude everything i said before is wrong and in 1986 i’d have said sod this and went and brewed a cuppa tea instead :-) (not strictly true since i was coming up on 2 years old at that time...)')