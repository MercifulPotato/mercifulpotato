Item(by='wahern', descendants=None, kids=[24799705], score=None, time=1602807612, title=None, item_type='comment', url=None, parent=24793289, text='&gt; [msync] checks whether this range is in the allocated virtual memory region. .... [L]et&#x27;s write a function that will check whether the memory area is allocated by the process or not.<p>The range of memory mmap&#x27;d into a process is a superset of ranges allocated <i>by</i> <i>the</i> <i>process</i>--e.g. returned by malloc.<p>Furthermore, even if you queried the process&#x27; internal allocation state, it would only be useful, if at all, for diagnostic purposes. In a threaded program it poses a TOCTTOU race; for example, it could asynchronously become &quot;invalid&quot; immediately after the test but before actually operating on the data.<p>More generally, what use is it knowing alone whether a pointer is part of an allocated region or not? You have no idea of its type or logical validity. Reading it might accidentally result in divulging sensitive secrets, and writing to it (which you could attempt using read(2)) might corrupt your program state.<p>Please, do not employ a trick like this. It&#x27;s very typical for new C programmers to take an interest in low-level memory semantics and play around with the possibilities, but it&#x27;s just as typical to go off the rails and implement a solution (as in this case) which is wrong and broken in almost every conceivable way. Both the technique and the premise (that the technique can be gainfully employed) are fatally flawed.<p>Coarse validity checks can have a role in bug and exploit mitigation, but 1) the example technique is woefully inadequate, and 2) such techniques must be applied, if they&#x27;re to be effectively applied at all, outside the logical structure of the program, as part of a compiler or runtime (e.g. malloc&#x2F;free implementation) or, at least, whatever component has a distinct, special relationship to the data.')