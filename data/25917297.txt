Item(by='brundolf', descendants=None, kids=[25918249, 25917412, 25918116], score=None, time=1611676825, title=None, item_type='comment', url=None, parent=25916628, text='I sure hope things continue to progress, but right now, having come from TypeScript, Python is quite a ways behind when it comes to static types. A few major differences:<p>- Library support for static types is not very good. This can be fixed, of course, but it&#x27;s also very hard to fix in a concerted way. It&#x27;ll just depend on the community getting on board.<p>- The syntax is limited. There isn&#x27;t proper support for declaring generics, you have to declare a separate TypeVar, as a Python variable, somewhere else in scope and it just... gets used to approximate a generic. It mostly works, but sometimes it doesn&#x27;t, and it&#x27;s very unintuitive and awkward. And then concepts like Callable, Union, TypedDict, and Optional don&#x27;t have dedicated syntax for readability; they&#x27;re generic types that you have to import and parameterize. Etc.<p>- Support isn&#x27;t great for highly &quot;dynamic&quot; data. TypeScript gives you powerful features for reasoning about dynamic property-sets of objects (dicts), combining and separating them, duck-typing, doing really complex inference, etc. These features in Python are usually some combination of unreliable, third-party, syntactically awkward, and so on.<p>- Inconsistency between different type-checkers. You&#x27;d think the fact that Python has standardized type syntax would help with consistency, but what it actually means is that everyone gets to define their own semantics for the same syntax. Different checkers mostly orbit around the same semantics, but there are always gaps. So for example, MyPy does a pretty good job of being strict and smart, but it&#x27;s really slow. So you&#x27;ll end up using an IDE-optimized checker for development, like Pytorch, but Pytorch will allow some things that MyPy doesn&#x27;t and not allow some things that MyPy does. So you can use your IDE to get <i>most</i> of the way there, but you always have to remember to run a &quot;real&quot; type-check before you commit, or you may break the build in CI.<p>I should point out the one big advantage that Python has here: unlike TypeScript you don&#x27;t need a build step, because Python interpreters can parse (and throw away) the type annotations. That&#x27;s pretty nice, especially for gradual adoption&#x2F;casual typing of scripts.<p>All of the problems (except maybe the syntax) are solvable, and I genuinely hope they get solved. For now, if you stick to primitives and core or class-based data structures you&#x27;ll have a great experience with Python types. If you do anything more complex, the results will be mixed. This is of course much better than nothing, but it could be a lot better still. If you&#x27;re picking between typed Python and TypeScript for a new project, it&#x27;s worth factoring in.')