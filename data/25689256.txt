Item(by='mcguire', descendants=None, kids=[25691228], score=None, time=1610134776, title=None, item_type='comment', url=None, parent=25687569, text='You are entirely correct[1]. Which is why the Scheme standard says,<p>&quot;<i>Implementations of Scheme must be properly tail-recursive. Procedure calls that occur in certain syntactic contexts called tail contexts are tail calls. A Scheme implementation is properly tail-recursive if it supports an unbounded number of active tail calls. A call is active if the called procedure may still return. Note that this includes regular returns as well as returns through continuations captured earlier by call-with-current-continuation that are later invoked. In the absence of captured continuations, calls could return at most once and the active calls would be those that had not yet returned. A formal definition of proper tail recursion can be found in Clinger&#x27;s paper [5]. The rules for identifying tail calls in constructs from the (rnrs base (6)) library are described in section 11.20.</i>&quot;<p>in Chapter 5, Semantic Concepts (<a href="http:&#x2F;&#x2F;www.r6rs.org&#x2F;final&#x2F;html&#x2F;r6rs&#x2F;r6rs-Z-H-8.html#node_chap_5" rel="nofollow">http:&#x2F;&#x2F;www.r6rs.org&#x2F;final&#x2F;html&#x2F;r6rs&#x2F;r6rs-Z-H-8.html#node_cha...</a>). Clinger&#x27;s paper is &quot;Proper Tail Recursion and Space Efficiency&quot; (<a href="https:&#x2F;&#x2F;www.cs.tufts.edu&#x2F;~nr&#x2F;cs257&#x2F;archive&#x2F;will-clinger&#x2F;proper-tail-space.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.tufts.edu&#x2F;~nr&#x2F;cs257&#x2F;archive&#x2F;will-clinger&#x2F;prop...</a>).<p>The Rationale for &quot;properly tail recursive&quot; is,<p>&quot;<i>Intuitively, no space is needed for an active tail call, because the continuation that is used in the tail call has the same semantics as the continuation passed to the procedure containing the call. Although an improper implementation might use a new continuation in the call, a return to this new continuation would be followed immediately by a return to the continuation passed to the procedure. A properly tail-recursive implementation returns to that continuation directly.</i><p>&quot;<i>Proper tail recursion was one of the central ideas in Steele and Sussman&#x27;s original version of Scheme. Their first Scheme interpreter implemented both functions and actors. Control flow was expressed using actors, which differed from functions in that they passed their results on to another actor instead of returning to a caller. In the terminology of the report, each actor finished with a tail call to another actor.</i><p>&quot;<i>Steele and Sussman later observed that in their interpreter the code for dealing with actors was identical to that for functions and thus there was no need to include both in the language.</i><p>&quot;<i>While a proper tail recursion has been a cornerstone property of Scheme since its inception, it is difficult to implement efficiently on some architectures, specifically those compiling to higher-level intermediate languages such as C or to certain virtual-machine architectures such as JVM or CIL.</i><p>&quot;<i>Nevertheless, abandoning proper tail recursion as a language property and relegating it to optional optimizations would have far-reaching consequences: Many programs written with the assumption of proper tail recursion would no longer work. Moreover, the lack of proper tail recursion would prevent the natural expression of certain programming styles such as Actors-style message-passing systems, self-replacing servers, or automata written as mutually recursive procedures. Furthermore, if they did not exist, special “loop” constructs would have to be added to the language to compensate for the lack of a general iteration construct. Consequently, proper tail recursion remains an essential aspect of the Scheme language.</i>&quot;<p>(<a href="http:&#x2F;&#x2F;www.r6rs.org&#x2F;final&#x2F;html&#x2F;r6rs-rationale&#x2F;r6rs-rationale-Z-H-7.html#node_sec_5.3" rel="nofollow">http:&#x2F;&#x2F;www.r6rs.org&#x2F;final&#x2F;html&#x2F;r6rs-rationale&#x2F;r6rs-rationale...</a>)<p>The language specification describes, indirectly, all of the valid programs in the language. With proper tail call elimination as part of the language semantics, simple recursion is a valid iteration technique in those programs. Without proper tail call elimination as part of the language semantics, it is not.<p>[1] Technically, a hardware stack is not required. However, any programming language with a &#x27;function&#x27; abstraction will be required to record the return location <i>somewhere</i> (if not function arguments and other stuff); without tail call elimination, the space for those records grows linearly with function call depth, no matter how it is stored.')