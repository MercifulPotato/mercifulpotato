Item(by='curryst', descendants=None, kids=None, score=None, time=1612024094, title=None, item_type='comment', url=None, parent=25964922, text='You can just define them as functions that are part of the class.<p>Something like:<p>@dataclass\nclass AuthMethod:\n  credentials: typing.Any\n  cache: typing.Any\n  apply_to_request: typing.Callable[[typing.Any, typing.Any, Request], None]<p>@dataclass\nclass AuthMapping:\n  method: AuthMethod\n  matches: typing.Callable[[str], bool]<p>class Client:\n  root_url: str\n  url_format: str\n  auth_methods: typing.List[AuthMethod]<p>def auth_request(client: Client, req: Request):\n  applies = filter(client.auth_methods, lambda x: x.matches(req))\n  if len(applies) &gt; 1:\n    raise Exception(&quot;multiple auth methods found&quot;)\n  elif len(applies) == 1:\n    method = applies[0]\n    method.apply_to_request(method.credentials, method.cache, req)<p>Then you would statically define your service&#x27;s auth methods by URL, so users can just do:<p><pre><code>    my_client = Client(auth_methods=MyServicesAuthMethods)\n</code></pre>\nor you can create a helper function like:<p>def create_client_a(base_url: str):\n    return Client(base_url, auth_methods=[...])<p>Alternately I think you can use closures, but I&#x27;m not totally positive about the scoping.<p>AuthMethod = typing.Callable[[Request], None]<p>def auth_method_a(username, password) -&gt; AuthMethod:\n    my_token = None<p><pre><code>    def __auth_method_a(req: Request):\n        if my_token is None:\n            my_token = do_login(username, password)\n        req.headers[&#x27;token&#x27;] = my_token\n    return __auth_method\n</code></pre>\nThat creates a standard interface (a function that accepts a Request), without assuming anything about the underlying protocol.')