Item(by='jcranmer', descendants=None, kids=[25609110, 25611222, 25612604, 25611076, 25609404], score=None, time=1609547019, title=None, item_type='comment', url=None, parent=25608241, text='One of the big mistakes I see in the list is choosing to ignore the developments in software that are old. For example, the author cites Python as pre-1996, yet the adoption of Python as a mainstream language largely postdates 1996.<p>Taking a very narrow view of software (i.e., looking <i>only</i> at compiler-related technologies), I can easily list several advancements that the author neglects:<p>* Profile-guided and link-time optimization aren&#x27;t really feasible until circa 2010.<p>* Proper multithreaded memory models in programming languages don&#x27;t come into existence until Java 5, from whence the C&#x2F;C++11 memory model derives.<p>* Compiler error messages have improved <i>a lot</i> since the release of Clang around 2011.<p>* Generators, lambdas, and async&#x2F;await have been integrated into many major programming languages.<p>* Move-semantics, as embodied by C++11 and Rust.<p>* OpenMP came out in 1997.<p>* Automatically-tuned libraries, e.g., ATLAS and FFTW are also late 90s in origin.<p>* Superoptimization for peephole optimizers (Aiken&#x27;s paper is 2006; souper is 2013).<p>* Heterogeneous programming, e.g., CUDA.<p>* Undefined behavior checkers, such as IOC, ASAN. Even Valgrind only dates to 2000!')