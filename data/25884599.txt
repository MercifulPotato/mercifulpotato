Item(by='grzm', descendants=None, kids=[25884835], score=None, time=1611425062, title=None, item_type='comment', url=None, parent=25884532, text='I think the existing int64, microsecond-precision timestamptz type is a good compromise of space and performance for precision for many use cases. Indeed, there are use cases where greater precision is desired. One of the features of PostgreSQL I appreciate is the ability to extend its types. There are a number of type extensions available. See <a href="https:&#x2F;&#x2F;pgxn.org" rel="nofollow">https:&#x2F;&#x2F;pgxn.org</a> for a list of popular extensions.<p>I don&#x27;t know of an existing nanosecond-precision timestamptz type, but it&#x27;s not that much of a lift to create one yourself. I&#x27;ve muddled through C a couple of times to do so. Often I pick an existing extension that&#x27;s similar to what I want to do, and modify it.<p>And if Rust is more to your liking, there&#x27;s a toolkit for building extensions in Rust as well: <a href="https:&#x2F;&#x2F;github.com&#x2F;zombodb&#x2F;pgx" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;zombodb&#x2F;pgx</a><p>A drawback of using custom extensions is you&#x27;re often limited to then managing your own PostgreSQL installation as most PostgreSQL SaaS offerings don&#x27;t support installation of third-party C extensions. If nanosecond precision is a core aspect of your work, then it may very well be worth the effort.<p>Another option is to store nanoseconds in an additional integer column. If you want, you can create a composite type (<a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;13&#x2F;rowtypes.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;13&#x2F;rowtypes.html</a>) of timestamptz and integer, which might make things more manageable (or less, depending on your PostgreSQL driver support for composite types). This allows you to use stock PostgreSQL while you handle the data stitching in your application.')