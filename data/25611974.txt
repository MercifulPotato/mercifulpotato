Item(by='pm215', descendants=None, kids=None, score=None, time=1609585673, title=None, item_type='comment', url=None, parent=25611563, text='Yes, it&#x27;s totally possible to write good abstractions for this sort of basic operation, which handle both endianness and alignment.  (QEMU&#x27;s version of them uses memcpy(), again relying on the compiler to optimise this to a simple load where the host CPU supports unaligned accesses.) I agree that doing that kind of thing so code can be endian-agnostic and keeping the ifdefs to a minimum is better style and easier to understand.<p>But if the big-endian case isn&#x27;t run through CI then bugs will still creep in, where people forget to use the abstraction and just cast a buffer pointer to do a 32-bit read, or where they don&#x27;t keep the distinction between &#x27;a 32 bit value in host endianness&#x27; and &#x27;a 32-bit value in host-independent endianness (eg network data, or pixel data)&#x27; straight and forget a conversion step. QEMU&#x27;s testing on s390 and ppc64 catches a steady trickle of this kind of bug before it goes into the codebase.<p>(You can catch unaligned-access bugs on x86 with clang&#x2F;gcc address-sanitizer, I think, but it can&#x27;t help with endianness bugs.)')