Item(by='choeger', descendants=None, kids=None, score=None, time=1602273256, title=None, item_type='comment', url=None, parent=24732389, text='Sure, that is an absolutely sensible design decision. But for other cases completeness is vital. Consider for instance the trivial case of the map function over lists (constructed by :: and []), often abbreviated as * :<p><pre><code>  f * [ ] = [ ]\n\n  f * a::as = (f a)::(f * as)\n</code></pre>\nEven if that is a nearly trivial case, it is easy to see that one could forget the first case, as all the interesting bits happen elsewhere. Now imagine, I would want to have a lazy reversal of lists, that I store as an alternative until I need to deconstruct it. I write that x~xs, meaning &quot;x added to the end of xs&quot;.<p>Now I have to expand my map function as follows (because map does not care about ordering):<p><pre><code>  f * a~as = (f a) ~ (f * as)\n</code></pre>\nIf I miss <i>that</i> case (or method on Julia&#x27;s case) my extension of the datatype is plain wrong.')