Item(by='pron', descendants=None, kids=[24963860], score=None, time=1604264220, title=None, item_type='comment', url=None, parent=24962366, text='&gt; It should be noted dafny and Verdi are better here.<p>The problem is that the scale and complexity of systems that are verifiable by Dafny and Verdi, or dozens of not hundreds of other code-level tools, is drastically smaller than those specifiable by TLA+. You are very limited in the scale of the systems you write and verify, and so those tools are much more limited in applicability. It is true that if your program is <i>very</i> small and&#x2F;or the properties you wish to prove are simple or very specific, then there are tools that can handle them at the code level, and that might be more convenient than TLA+ in those very specific circumstances. Also, Verdi and Dafny are research tools; TLA+ is used in the field by ordinary engineers at Amazon, Microsoft, Oracle, MongoDB and a growing number of other companies to help write software you use quite a lot (most AWS services, for example).<p>&gt; However there appears to be a philosophical difference: tla+ finds counter examples to the spec. Absence up to the number of states checked shows the code is bug free. Dafny, Verdi seem to proceed by showing the spec is proved through various proof checking (semi) automation. As such they don&#x27;t explore state.<p>That&#x27;s not the philosophical difference, just a difference in available tooling. Both TLA+ and Dafny are just languages. Both have proof tools that employ SMT solvers for deductive proofs. TLA+ <i>also</i> has a model checker, and perhaps so could Dafny. The philosophical difference is that Dafny is a code-level tool, and so gives you &quot;full cover&quot; but only in limited circumstances, while TLA+ gives you a more partial cover but in a much wider range of use-cases.<p>&gt; But if you tell the same team we&#x27;ll be using formal methods there&#x27;s a lot of complaining because FM can&#x27;t check everything ... Not down to the real final code ... So why bother? I find this dichotomy disingenuous by programmers.<p>I don&#x27;t know if I&#x27;d use the word disingenuous. I think it&#x27;s just unfamiliarity. The goal of FM tools aimed at &quot;ordinary&quot; software is not to produce perfect software but to eliminate more bugs more cheaply than with tests alone. They shouldn&#x27;t be compared to a hypothetical perfection, but to what developers use now.')