Item(by='madhadron', descendants=None, kids=None, score=None, time=1609867817, title=None, item_type='comment', url=None, parent=25647143, text='There are a few things to know about this.<p>First, the framework you probably want to think about this is Parnas&#x27;s Trace Assertion Method. It gives you the tools to think about the problem without getting caught in particular details.<p>There was a paper that looked at serious failures in distributed systems, and found that most of them were caused by a small number of factors. So you get a lot of power without going into all possible sequences. I am completely failing to find it, but it&#x27;s well known so hopefully someone whose memory is doing better than mine can post it. Or if I remember, I&#x27;ll come back and add a comment.<p>I like to think of it as separating the input space into boundaries and bulk (I&#x27;ve described it further here: <a href="https:&#x2F;&#x2F;madhadron.com&#x2F;posts&#x2F;easier_faster_testing.html" rel="nofollow">https:&#x2F;&#x2F;madhadron.com&#x2F;posts&#x2F;easier_faster_testing.html</a> ). No actions, empty lists, lists with one element, two actions of different kinds --- these are all the boundary of the input space. For the kind of systems we write as programmers, behavior tends to be fairly uniform once you&#x27;re into the bulk, so you sample it and then closely test the boundary where stuff changes a lot. Now, you may have boundaries in the middle of the bulk as well (and in numerical work, the boundaries can move around a lot if you don&#x27;t have a good mathematical understanding of the system), but it is still usually possible to test the various regions of bulk and get good coverage on the boundaries.<p>QuickCheck and other property based testing libraries have been used for this. The Erlang QuickCheck library was used for testing phone handsets by throwing random event streams at them until they crashed. It&#x27;s a very powerful tool for this purpose.')