Item(by='alpaca128', descendants=None, kids=None, score=None, time=1610840427, title=None, item_type='comment', url=None, parent=25805833, text='&gt; My theory is that this removes direct understanding what happens and instead shifts the focus on how to get the task done while not violating the type system rules<p>In my experience it is in fact still a requirement to understand\nwhat&#x27;s happening in order to write clean and fast Rust code. It\nis possible to satisfy the compiler using a lot of clone() calls\nand similar shortcuts, but once you understand what data\nstructure is allocated when and where and how the whole\nownership principle works in practice you can suddenly avoid a\nton of unnecessary heap allocations and other pitfalls. I&#x27;d say\nmy experience with Rust improved a lot once I started grasping\nwhat&#x27;s happening in memory and why certain syntax elements\nexist, as this makes fixing compiler errors more intuitive and\nless a blind trial and error session with the borrow checker.<p>Some of Rust&#x27;s syntax can look weirdly unfamiliar at the\nbeginning, but everything is there for a good reason. Nothing is\ndone implicitly, and much of the pattern matching and\nOption&#x2F;Result related stuff is Rust&#x27;s way of replacing the\nconcept of `null` with thoroughly type-checked expressions.')