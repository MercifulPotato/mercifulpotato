Item(by='bob1029', descendants=None, kids=[25970839, 25970628, 25973883, 25971196, 25971008, 25972051, 25972560, 25972612, 25970620, 25972954, 25972920, 25970645, 25973563, 25974544, 25971089, 25971490, 25976207, 25974340], score=None, time=1612025379, title=None, item_type='comment', url=None, parent=25969976, text='Language constraints aside, the real world is not something that can be cleanly modeled without the notion of circular dependencies between things. Not very many real, practical activities can be truly isolated from other closely-related activities and wrapped up in some leak-proof contract.<p>Consider briefly the domain model of a bank. Customers rely on Accounts (I.e. have one or many). Accounts rely on Customers (i.e. have one or many). This is a simple kind of test you can apply to your language and architecture to see if you have what it takes to attack the problem domain. Most approaches lauded on HN would be a messy clusterfuck when attempting to deal with this. Now, if I can simply call CustomerService from AccountService and vice versa, there is no frustration anymore. This is the power of reflection. It certainly has other caveats, but there are advantages when it is used responsibly.<p>If you want to understand why functional-only business applications are not taking the world by storm, this is the reason. If it weren&#x27;t for a few &quot;messy&quot; concepts like reflection, we would never get anything done. Having 1 rigid graph of functions and a global ordering of how we have to compile these things... My co workers would laugh me off the conference call if I proposed these constraints be imposed upon us today.')