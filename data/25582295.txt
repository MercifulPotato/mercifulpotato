Item(by='chrisseaton', descendants=None, kids=[25582743], score=None, time=1609341087, title=None, item_type='comment', url=None, parent=25582218, text='&gt; It is inevitable that someFunction can only be called once someFuture has completed successfully. No language or technology can change that<p>This is just not a true statement - and that was the point of the original thread - the original paper on futures had them implemented transparently and able to be passed down into library code not expecting futures. It&#x27;s also how Haskell&#x27;s par works today. So it demonstrably can be implemented.<p>&gt; I believe that the user (at the callsite) should both _know_<p>Ok but this is just a &#x27;don&#x27;t do that&#x27; argument. If a user tells us they have a good reason to do it, I&#x27;m interested in how we can enable them to do that.<p>&gt; with a library function that just expects 3 values, this is not possible<p>But it is in Haskell using par, and other languages with more traditional futures.<p>&gt; Here is how I would write it<p>Great... but you&#x27;ve rewritten the library code with &#x27;two separate functions instead of one.&#x27; My original point was &#x27;because it means existing code that expects a T cannot accept a Future&lt;T&gt;&#x27; and you&#x27;re proving that back to me so hard that you&#x27;ve accepted you need to completely rewrite the code to do it!<p>Languages with traditional futures would let you just call the original, unmodified library code, with future values instead of actual values, and it would just work.<p>If you had library code like this, you could pass in future values of T for a, b, and c, and it would execute the expensive_operation on a and b as soon as it could, while c completes.<p><pre><code>    def foo(T a, T b, T c)\n        expensive_operation(a, b) + expensive_operation(b, c)\n    end\n</code></pre>\n&gt; For instance, in your example: what happens if the library decides to always evaluate &quot;c&quot; eagerly even though &quot;a&quot; and &quot;b&quot; often fail and the whole calculation is aborted?<p>Yes this is a problem with transparent futures, as is the ordering issue you raised. But I wasn&#x27;t arguing they didn&#x27;t have their own issues. You&#x27;re saying it&#x27;s <i>impossible</i> and that is demonstrably false, because languages do do it.<p>(I did half of my PhD on these topics, and the other half on Ruby.)')