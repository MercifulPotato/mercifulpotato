Item(by='mitchellh', descendants=None, kids=[24889554, 24889277, 24889187], score=None, time=1603648297, title=None, item_type='comment', url=None, parent=24887521, text='Wow! 10 years already. I&#x27;m the founder of HashiCorp and I&#x27;d love to share my thoughts.<p>Credentials: I started using Go around 9 years ago and since then I&#x27;ve built a company of over 1,000 employees with ~250 engineers that write Go full time. We maintain dozens of open source projects and libraries (Terraform, Vault, etc. etc.) all written in Go. We&#x27;ve shipped commercial products that are used by a significant percentage of the F500. Vault for example serves trillions of secrets per year for _one_ company that we know of.<p>I could probably write pages and pages so I&#x27;ll try to highlight a few things. Go is not a perfect language or community by any means but I love it.<p>NOTE: Folks often read this feedback with the opinion of &quot;but language X can also...&quot; or some variant and I hope that doesn&#x27;t come across. My feedback is not against any other language unless I&#x27;m specifically using an example. Another language might solve all these same problems for you! I&#x27;m just sharing how Go has been fantastic at these aspects for us.<p>== Junior and new-hire friendliness<p>Go is a very simple language. From the beginning of the company until now, we can hire people who have never used Go, point them at a couple resources (i.e. Tour of Go), and they can be committing to production-grade projects within a week. It is incredible.<p>Go makes it really hard to do anything that isn&#x27;t obvious. The cost of this is often verbosity or repetition. But the benefit above is well worth it in my opinion. I know lots of people disagree with this but I personally prefer to repeat &quot;if err != nil&quot; 1,000 times versus introducing new control flow options that now must be educated.<p>I love telling new folks (junior or not): read the file top to bottom, that&#x27;s how it&#x27;ll execute. And for the most part, that&#x27;s true.<p>As someone who built a rapidly growing team&#x2F;company around Go, this has been indispensable.<p>== Flexible<p>Any &quot;general purpose language&quot; can theoretically write any software. However, I&#x27;m sure we&#x27;ll all agree that its easier to write some software in certain languages, and that&#x27;s a good thing.<p>However, I&#x27;ve been blown away by how flexible Go has been without feeling forced. We&#x27;ve written desktop CLIs, web APIs, distributed systems, security software, networking software, infrastructure software, accounting software, bots, etc. all in Go.<p>And most of these categories are at a scale of millions of downloads per year and successfully in production.<p>It&#x27;s very cool to see that coming from a prior major background in Ruby where there were significant tradeoffs when doing these things. It was _possible_ of course but you had to really understand the tradeoffs you were making. In Go, there&#x27;s certainly some tradeoffs but they&#x27;ve been minimal and Go has just worked.<p>As both an individual contributor and manager, this flexibility has been awesome in building a company around.<p>== Cross-platform Compilation and Statically-Linked Binaries<p>Since the first day I adopted Go 9 years ago, Go has encouraged and simplified static binary compilation and simple cross-platform compilation. Today you basically set an env var of what platform you want to target, run `go build`, and it usually works.<p>You still have to learn of various gotchas around platforms (API availability, filepath awkwardness, subprocess&#x2F;signal behavior, etc.) but the compilation aspect alone makes it so much easier to tackle this task.<p>My previous experience of at-scale software I built was Vagrant in Ruby, and making that work across platforms was a constant, enormous challenge. I had to spend a few months full time just to get installers to help setup the proper runtime environment across platforms.<p>Looking at this also from the perspective of rising popularity with ARM systems and other less standard architectures (even Power for enterprises...), this property of Go has been very important.<p>== Culture<p>The culture surrounding the Go community is generally one that is very philosophically aligned with how I view software. I would roughly describe it as pragmatic &amp; measured.<p>I think this culture is exactly why many people dislike Go (or seem to &quot;hate&quot; it which I think is a pretty wild emotional reaction to a language for programming computers but I digress).<p>The Go community doesn&#x27;t chase the next hot thing or rush to implement the &quot;state-of-the-art&quot; without a very measured, pragmatic approach. Some view this as Go being inferior by some definition but I view it as a huge benefit. Go core in particular appears to me (I&#x27;m not part of the core team so purely an opinion) to be a measure-twice-cut-once (or maybe measure like 8 times) approach. And I love that.<p>== Fun<p>At the end of the day, the language is generally fun for me. I like writing it. And that&#x27;s important, too.<p>== Conclusion<p>I&#x27;m very lucky that Go took off as a language in the industry I built my company in. It certainly wasn&#x27;t that way when we started using it (it was pre-1.0, pre-Docker, pre-K8S, the majority of infra sw was still in Ruby).<p>I feel that the language is super productive (we built Vault 0.1 in ~6 weeks for example), it has shown to scale to the largest needs and does so stably (Vault is in the hot path of every trade in one of the major US stock exchanges and has never gone down there), and we&#x27;ve been able to build a large company and active OSS community around it.<p>Hands down a successful choice for us with zero regrets.')