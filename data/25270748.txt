Item(by='013a', descendants=None, kids=None, score=None, time=1606860944, title=None, item_type='comment', url=None, parent=25268215, text='You can run any container. It just wouldn&#x27;t run as you expect if you don&#x27;t implement the lambda runtime api.<p>&gt; Google Cloud Run, which everyone keeps comparing this with, works exactly like that.<p>Everyone does keep comparing this to GCR, wrongly. Not just because Lambda is not &quot;bring any container&quot; whereas GCR is, but more importantly because GCR and Lambda have very different operational models. GCR is a serverless platform for hosting web servers. Lambda is a serverless platform for event handling. The latter is a super-set of the former and thus requires more specific tools.<p>Yes, theoretically there could be a setup whereby you expose a port, and some lambda intermediary translates the invocation payload to an HTTP message your container can read. But I am endlessly fascinated why <i>anyone</i> would want that. I laugh a bit on how we&#x27;ve hit peak AWS where people here are legitimately asking for an HTTP request to hit an ALB, the ALB translates it into a lambda payload object, then a lambda component re-translates that payload back into an HTTP request, so your application can translate it into an object. Do you understand how insane that is?<p>The only tactile advantage lambda has over fargate is scale-to-zero. I think saving $7 per month is a pretty bad trade-off for the insane performance overhead and complexity a true docker-in-lambda solution would necessitate, and thus be unattractive to most consumers.')