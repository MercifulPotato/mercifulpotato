Item(by='MauranKilom', descendants=None, kids=[25051326], score=None, time=1605028946, title=None, item_type='comment', url=None, parent=25048000, text='Maybe the password is not the best example. I am also not an expert and just took it from the article.<p>As someone explained elsethread:<p>&gt; iO gives you a circuit that is as hard to reverse engineer as the hardest circuit of a given size that computes the same function, but it doesn&#x27;t give you a guarantee on how hard that actually is<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25048220" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25048220</a><p>To answer your thoughts though:<p>&gt; If it is not needed, flow analysis, tree shaking and const evaluation coulg get rid of it.<p>Those are methods you could try to apply, but there is no reason why this would be sufficient in the general case.<p>&gt; Why does any of those programs contain the password anyway if it is not needed for achieving the goal?<p>Maybe the problem your program is trying to solve is significantly easier given the knowledge of a secret. As long as you know that it&#x27;s possible (but potentially harder) to solve the same problem without the secret, with iO you can distribute your obfuscated binary and nobody can recover the secret.<p>For example (if I understand correctly), if your secret program contained an oracle to reverse SHA256 hashes[0], then applying iO to it you could be sure that nobody can recover this secret oracle, because applying iO to a <i>different</i> program that uses brute-force search should yield an indistinguishable obfuscated program. I doubt that&#x27;s how it actually works (because oracle and brute force are probably not the same &quot;circuit hardness&quot;), but I hope you see the point.<p>[0]before someone complains about lack of bijectivity, read this as &quot;find the smallest integer&#x2F;bitstring that has the same hash&quot;')