Item(by='mrkeen', descendants=None, kids=None, score=None, time=1604272978, title=None, item_type='comment', url=None, parent=24959798, text='&gt; The problem for novices is that a program that behaves correctly looks a lot like a correct program. Until one day it doesn’t.<p>&gt; And because you’re in production and getting random spurious failures, the panicked (but common) reaction is to wrap every shared resource in a synchronized block.<p>Yep yep - that&#x27;s the Java + Threads model.  It&#x27;s (relatively) harder to take single-threaded logic and make it behave in a multi-threaded setting.  Compared to the SQL model, where it&#x27;s (relatively) easier to take single-threaded logic, wrap it in BEGIN&#x2F;END TRANSACTION, and have it perform exactly as expected.<p>OK I get you now.  In saying that SQL concurrency was easy and Java concurrency was hard I didn&#x27;t think about what would happen if you tried to write a mixed Java&#x2F;SQL transaction; I didn&#x27;t realise there was a bunch of Java running between your SQL statements.  So what would my fix be?  Get rid of the Java and replace it with SQL.<p>&gt; Note that you can end up with deadlocks and transaction failures on any level stricter than READ COMMITTED, so the application needs to be able to deal with both of these.<p>That&#x27;s cool - transactions proceed completely or not at all.<p>About the &quot;not transactional&quot; thing, I was applying (a =&gt; b) =&gt; (^b =&gt; ^a).  That is, since transactions are isolated, and you demonstrated code that wasn&#x27;t isolated, I can conclude that it wasn&#x27;t a transaction.  Maybe I need to adjust my thinking a bit:<p><pre><code>    assumption i) Atomicity says &quot;The series of operations cannot be separated with only some of them being executed&quot;.\n\n    assumption ii) Isolation says &quot;Isolation ensures that concurrent execution of transactions leaves the database in the same state that would have been obtained if the transactions were executed sequentially.&quot;\n\n    assumption iii) I use transactions because they&#x27;re atomic and isolated.\n\n    A *SELECT balance* was run, passing its value out to the real world before the commit succeeded.  This breaks assumptions i and iii.\n\n    &quot;That is only one of the possible ways for transactions to work&quot; breaks assumption ii and iii.\n\n    So, I can only conclude I should not use transactions.</code></pre>')