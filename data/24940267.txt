Item(by='disposedtrolley', descendants=None, kids=None, score=None, time=1604046805, title=None, item_type='comment', url=None, parent=24939227, text='Quality documentation is very difficult to produce and maintain.<p>On top of adopting a different mindset when writing docs (you&#x27;ll need to phrase concepts and provide examples to cater for users who probably don&#x27;t share the same intimate knowledge you have of the codebase), there&#x27;s a high cost associated with upkeep. Ensuring that your docs always align with the implementation might be straightforward for smaller applications, but as your API surface grows so will the cracks that outdated documentation will slip through.<p>There are a few examples of tools which are designed to lessen the burden (that I know of):<p>- To generate usage examples from your code, Go has the idea of testable examples (<a href="https:&#x2F;&#x2F;blog.golang.org&#x2F;examples" rel="nofollow">https:&#x2F;&#x2F;blog.golang.org&#x2F;examples</a>) which get rendered in the documentation but are declared as normal functions. These can be easily unit tested.<p>- To provide usage examples in code without resorting to unit tests, Clojure has `comment` forms (<a href="https:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;comment" rel="nofollow">https:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;comment</a>) which are normal expressions but ignored by the compiler. You can define arbitrary expressions within a comment form (e.g. to execute another function), so these can be used to define usage examples and placed next to the functions they call.')