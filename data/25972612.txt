Item(by='valand', descendants=None, kids=None, score=None, time=1612038185, title=None, item_type='comment', url=None, parent=25970583, text='In the functional paradigm, language constraints aside, to model this &quot;story&quot; would need these:<p>- The definition of Account<p>- The definition of Customer<p>- A ledger consisting of: \nList of Account, \nList of Customer, \nList of Account-Customer relations<p>A clerk works on the records on the ledger with one hand and one pen, a metaphor for the service process working on the data in the database.<p>An act, such as money transfer, would be described as a function.<p>A customer creating a new account for himself is written as `fn createAccount(Customer, NewAccountData)` because from the perspective of the clerk&#x2F;bank manager&#x2F;service the customer, newAccountData, and the existing data in the ledger as objects which the clerk&#x2F;bank manager&#x2F;service must move around in a precise way.<p>The module which has &#x27;fn createAccount` depends on the types `Account` and `Customer`.<p>In english it roughly sounds like,<p>&quot;the success of writing the rule of creating an account for a customer depends on knowing the definition of Account and Customer.&quot;<p>The function is not written as `customer.accountService.createAccount(newAccountData)`, because the clerk doesn&#x27;t schizophrenically pretend to be the customer and create an account for himself. The clerk just receive request from the actual customer, writes new account entry and customer-account-relation entry into the ledger, that&#x27;s it.<p>There&#x27;s simply no need to call CustomerService from AccountService and vice versa. There&#x27;s no need for reflections because data types are all available at compile time.')