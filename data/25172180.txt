Item(by='jlokier', descendants=None, kids=None, score=None, time=1605987320, title=None, item_type='comment', url=None, parent=25171756, text='No it isn&#x27;t.<p>That&#x27;s to commit the directory change, which updates directory entries pointing to the file inode.  File creation, renaming and deletion are directory changes, and are unconnected with the file size.<p>As the article says: &quot;open and fsync() the containing directory in or to ensure that the file will <i>still be there</i> following reboot from a power loss&quot;.<p>Without the fsync() on the directory, after reboot a newly created file <i>name</i> may not exist at all in the target directory.  That&#x27;s separate from whether the inode size is updated.  If you just create the file at its target location, fsync() and then abruptly reboot, it may not be found, yet fsck may find it and put it into &#x2F;lost+found with the data and size intact, because data and size were committed by the file fsync() while the directory entry was not.<p>Another way to show this is by creating the file elsewhere and using link() or rename().  Then you can see the committed file data at the old name, while the target of link() or rename() may be missing after abrupt reboot.  This is why some atomic+durable file write patterns: Open a file under a temporary alternate name in the same directory, write(), fsync() on the file to commit data and metadata to the inode, then rename() to atomically replace the target filename, then fsync() on the directory after rename() to commit the directory change.  (Some particularly careful programs go further than that because rename() is not atomic on some network filesystems.)<p>(In the article, there are what appear to be typos where it says fdatasync() on the containing directory in some places and fsync() in others.  It should always be fsync() on a directory.)')