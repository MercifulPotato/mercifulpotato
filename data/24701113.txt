Item(by='joshuamorton', descendants=None, kids=[24701620], score=None, time=1602010521, title=None, item_type='comment', url=None, parent=24700861, text='&gt; In contrast, Java uses all the types to perform type-checking, making them ascriptions.<p>Javac uses them to perform type checking, prior to runtime. Exactly the same way that mypy uses them to perform type checking prior to runtime.<p>&gt; The reason I disagreed with this is because in statically typed languages you&#x27;re not relying on annotations for anything. Keep in mind that we&#x27;ve established that annotations are specifically artifacts in the code that the language itself doesn&#x27;t care about, because when the language does care they are called ascriptions. Annotations are supplied by the programmer by desire, not by necessity of the language proper.<p>But Scala&#x27;s annotations <i>are</i> used for type checking. Much as python&#x27;s are if you enable mypy.<p>&gt; But you cannot release a Java library that doesn&#x27;t have all its types specified in some manner. Because the Java language requires the types to be present, meaning they aren&#x27;t annotations like they are in Python.<p>Of course you can. You can write a functional java library that specifies that all functions take `Object`. Your argument comes down to that syntactically, java requires you stick <i>something</i> in the place-where-type-declarations-go, while python does not.<p>This ultimately doesn&#x27;t have any impact on the strictness of the type checking done, because you can stick useless annotations (Any, Object) in the syntactic spot in either case. The semantics are the same.<p>Ultimately, your argument comes down to &quot;I trust that more third party libraries will have useful types in Java than in python&quot;, but that isn&#x27;t implicit to the type system, it&#x27;s because the type ecosystem has been around longer.<p>Which, like, sure. But to say that python doesn&#x27;t have static typing is silly. Nearly all the python I write is statically typed.<p>&gt; In Python the language, types are just annotations which are completely ignored, and this is not the case in statically typed languages.<p>This is a uselessly semantic argument. Much as if you <i>choose</i> to not typecheck your python, you can <i>choose</i> to write essentially untyped java using Object and casts. Are you really <i>certain</i> that no library you depend on does that, or uses reflection to access dynamic and non-statically-verifiable features?<p>The safety you get from any static analysis tool, whether a type system or a linter or whatever, relies on your dependencies not trying to subvert the tool (or doing so correctly).<p>This is essentially the argument about rust&#x27;s Unsafe. You, or any of your dependencies, is free to subvert the borrow checker and do &quot;unsafe&quot; things.<p>You either have to trust that they are doing so responsibly, or manually verify the correctness of their unsafe code. Having to opt-in to unsafe access is, indeed, an advantage since it makes static analysis of how much &quot;unsafety&quot; there is easy (much as it&#x27;s easier to find non-static things in vanilla Java than in python), but you can (and some do!) use static analysis to enforce type annotations in python throughout the entire code base.<p>&gt; so it&#x27;s an extra burden on the libraries&#x27; developers.<p>It&#x27;s exactly the same burden as they would have in Java. So I&#x27;m not clear on what the point is. Worth noting though, that mypy supports stub files, so you can annotate a third party api yourself (<a href="https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;typeshed" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;typeshed</a>, <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;pytype&#x2F;tree&#x2F;master&#x2F;pytype&#x2F;pytd&#x2F;stdlib" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;pytype&#x2F;tree&#x2F;master&#x2F;pytype&#x2F;pytd&#x2F;std...</a>), so even this claim is ultimately untrue.')