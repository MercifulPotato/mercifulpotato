Item(by='KMag', descendants=None, kids=[25924476, 25924739], score=None, time=1611719999, title=None, item_type='comment', url=None, parent=25918103, text='Most static type checkers prove (to the limits of the soundness of the type system) that the types of the values at run time will always be compatible with the operations performed on those values.  For these checkers, any program that&#x27;s not provably sound (to the limits of the type system soundness) will be rejected.  In other words, most static type checkers answer &quot;is this definitely correct?&quot;<p>However, it&#x27;s possible to have a more lenient static type checker that only looks for cases where you&#x27;re guaranteed to get an illegal operation at runtime.  They answer the question &quot;is this definitely wrong?&quot;<p>For instance, if we have:<p><pre><code>  def f(x):\n      g(x)\n      h(x)\n\n  def g(x):\n      x.a()\n\n  def h(x):\n      x.b()\n</code></pre>\nIf we&#x27;re doing whole program analysis and there&#x27;s no type that has both a() and b() methods, then f is guaranteed to call a non-existing method at one place or the other.<p>This sort of &quot;this is clearly wrong&quot; type checking is much less intrusive than the more common &quot;I&#x27;m not positive this is correct&quot; type checking.<p>If you&#x27;re not doing whole-program analysis, then you may restrict the type search to the types imported into the transitive closure of the module and its dependencies.  This makes type checking slightly more intrusive by sometimes forcing more module imports, but it&#x27;s still much less intrusive than common type checkers.')