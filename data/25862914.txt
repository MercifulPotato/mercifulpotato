Item(by='brundolf', descendants=None, kids=[25863643], score=None, time=1611256867, title=None, item_type='comment', url=None, parent=25862781, text='Yes, but in Rust there are two independent axes here:<p>- Whether or not a library calls unsafe code internally<p>- Whether or not a library declares its public API to be unsafe (<a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#call...</a>)<p>It&#x27;s very much possible (essential, even) to be able to present a safe API to external callers of your code, despite using unsafe code under the hood. In this case you&#x27;re making a human-checked assertion of safety, which is not guaranteed to be without bugs, but the important thing is that you&#x27;re minimizing the surface area of un-safety and declaring a contract with your users. You&#x27;re &quot;stopping the buck&quot; of unsafety rather than passing it on. The parts that really have to be unsafe can enjoy extra scrutiny, and everything else (including the caller&#x27;s code) can be checked by the compiler. This is not uncommon in the standard library and other low-level libraries.<p>More information here: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#creating-a-safe-abstraction-over-unsafe-code" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#crea...</a>')