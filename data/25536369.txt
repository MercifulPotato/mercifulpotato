Item(by='pdimitar', descendants=None, kids=None, score=None, time=1608903191, title=None, item_type='comment', url=None, parent=25536328, text='Yes they do but that won&#x27;t help you if one bad actor (literally and figuratively) takes a long time to execute a single function call. Erlang&#x27;s VM has machinery to multiplex actors on separate CPU cores and keeps around several different kinds of thread pools -- native (as in Erlang bytecode) actors, dirty I&#x2F;O threads (where potentially long-lived I&#x2F;O will live) and dirty CPU threads (where CPU intensive tasks go) -- and can move actors between them (although let&#x27;s be honest, nobody can make that work reliably and Erlang makes mistakes there as well).<p>Basically, as they call it, several different schedulers, each with its own pre-warmed thread pool.<p>An event loop is a step in the right direction. I am just worried that Ruby 3.0 might turn out how OCaml Multicore is turning out -- an endless saga.')