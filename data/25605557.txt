Item(by='rndgermandude', descendants=None, kids=[25605976], score=None, time=1609526984, title=None, item_type='comment', url=None, parent=25605089, text='Languages with garbage collection and&#x2F;or tons of reflection (requiring memory for bookkeeping) and&#x2F;or JIT (requiring memory for on-the-fly jitted code) would indeed be a problem due to the overhead of those technologies.<p>Python is not as &quot;bad&quot; as dotnet and go I&#x27;d think, as most of python is reference counted garbage collection (with a &quot;full&quot; GC just to break up cycles) while go and dotnet use essentially mark-and-sweep GC strategies which require a lot of object moving and thus scratch space.<p>Running a dotnet hello-world (on x86_64 linux admittedly) gives an RSS of 26MB, most of it mapped libraries and .net assemblies, some libraries shared between processes of course, like libc&#x2F;libm&#x2F;ld.so. But it also maps a ton memory for the JIT and the GC (including scratch space to move objects into during gc). With some swap, it may survive on a system with 25MB of free memory, but I&#x27;d think there&#x27;d be plenty of swap-thrashing and gc thrashing going on, making that less fun.<p>Running a python3&#x27;s hello world comes in at 10MB RSS, but a large part of that is the shared libraries like libc&#x2F;libm&#x2F;ld.so. With some memory-conserving programming some real python programs may run just fine without excess swapping.<p>For comparison, a hello world in C maps about 1M RSS, while a rust one maps 2MB RSS, both times a big chunk in shared libraries specially libc.')