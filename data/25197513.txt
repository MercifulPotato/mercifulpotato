Item(by='marcan_42', descendants=None, kids=None, score=None, time=1606217594, title=None, item_type='comment', url=None, parent=25195982, text='From the very first few lines of the description I was wondering how this could be possible. The problem isn&#x27;t the NOR gate - that&#x27;s definitely enough for all computation - but how to <i>drive it</i>. Looking at the schematic, it is only wired to bit 0 in the data bus, which is 8 bits. So how do you perform ALU ops on all the other bits? There is no shift data path. How can an 8-bit CPU use a 1-bit ALU with no barreling&#x2F;bit multiplexing?<p>It took me a while to find the answer in the description of the add instruction:<p><a href="http:&#x2F;&#x2F;www.mynor.org&#x2F;downloads&#x2F;The_MyNOR_ADD_Instruction.pdf" rel="nofollow">http:&#x2F;&#x2F;www.mynor.org&#x2F;downloads&#x2F;The_MyNOR_ADD_Instruction.pdf</a><p>It uses a lookup table to perform bit rotates. Unfortunately, this kind of breaks the entire idea of a one-NOR ALU data path. Now you have a table-driven 8-bit rotate ALU op (which is the same amount of table space needed for a 4-bit add!), and at that point you might as well ditch the NOR gate and implement everything else in microcode tables too. You can use lookup tables to implement any logic function, of course.<p>IOW I bet you could just modify the microcode of this thing to make it much faster by replacing the core of the ADD with another table.<p>Conversely, you can also just implement the NOR operation (or anything else) as control flow in the microcode sequencer, if you have any way to test bits instead, giving you a &quot;zero-gate&quot; ALU (ed: yeah, there is a conditional jump microinstruction).<p>So while this is definitely a very cool project and interesting design, I do find the claim of one-NOR purity questionable. It cheats. In a fun way, but this isn&#x27;t a 1-NOR ALU CPU, it&#x27;s a highly microcoded table-driven CPU that uses a two-transistor NOR gate as a gimmicky ALU component :-)<p>For implementing a faster ADD with the existing design, tables, and ditching the NOR, the tricky bit is mixing the inputs. One simple optimization would be to have a table that implements &quot;rotate and add one&quot; and one that implements &quot;rotate&quot;. Then you can just test bit 0 of one operand, use that to select a table (via control flow) to apply to the second operand, then rotate the first operand, and repeat (2 table lookups). No NOR ops necessary. You could test two bits and cut it down to 3 table lookups per 2 bits added, or 5 table lookups per 4 bits added by just adding more tablespace. The issue here is you still need the flop+NOR to mix inputs bit by bit (even if just as control flow), but since addresses are split into halves, you could also have a table that converts one operand into the right table address MSB to index a 4-bit addition with rotate, for each nybbke. That gives you 8-bit addition in 4 table lookups, 256+256+4096 bytes of tables, and no conditional jumps, flip-flop, or NOR necessary. I bet there are other better ways of doing this too.')