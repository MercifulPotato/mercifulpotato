Item(by='cesarb', descendants=None, kids=[25554888], score=None, time=1609106711, title=None, item_type='comment', url=None, parent=25554530, text='It&#x27;s more than just limiting the number of possible instruction lengths; it&#x27;s also that you only need the first few bits of the instruction to determine its length. With x86, you have to decode the first byte to know if the instruction has more bytes, decode these bytes to know if the instruction has even more bytes, and so on.<p>But since I&#x27;m not a hardware designer, I don&#x27;t know if the RISC-V design is enough to make a high-performance wide decoder. With 64-bit ARM it seems very easy; once you loaded a n-byte line from the cache, the first decoder gets the first four bytes, the second decoder gets the next four bytes, and so on. With compressed RISC-V, the first decoder gets the first four bytes (0-3); the second decoder gets either bytes 4-7 or bytes 2-5; the third decoder can get bytes 8-11, 6-9, or 4-7, depending on how many of the preceding instructions were compressed; and so on. Determining <i>which</i> bytes each decoder gets seems very easy (it&#x27;s a simple boolean formula of the first two bits of each pair of bytes), but I don&#x27;t know enough about hardware design to know if the propagation delay from this slows things down enough to need an extra pipeline step once the decode gets too wide (for instance, the eighth decoder would have 8 possible choices for its input), or if there are tricks to avoid this delay (similar to a carry-skip adder).')