Item(by='dgb23', descendants=None, kids=[25376972], score=None, time=1607619512, title=None, item_type='comment', url=None, parent=25375105, text='&gt; 1) All data flows through your system on separate tracks. Foo’s come in from foo endpoints and go to the foo database, and very rarely do data sets cross paths. Differences in business logic can be separated by API endpoint, kafka topic, or some other difference that lets you separate the call paths thoroughly.<p>My instinct is that you could solve general &quot;where does this come from&quot; and &quot;where does this go&quot; questions with metadata. I believe that was one of the driving reasons for metadata in the first place.<p>&gt; 2) Every type of data in your system looks different, so that you can easily determine whether or not a given piece of data is a foo or a bar once and send it down the right call path in one place.<p>Clojure spec, malli, schema are libraries that deal with this kind of problem. They are very expressive.<p>&gt; 3) In any case where similar types of data must be treated differently, it’s possible to organize your code in such a way that you only have to build up the cond-tree once, and you can use different call paths to treat the data differently.<p>A combination of spec (or others) and multimethods (arbitrary dynamic dispatch) would come to mind here as a solution.<p>I assume these things are known and were discussed. Are there specific trade-offs that didn&#x27;t work out?')