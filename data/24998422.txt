Item(by='wires', descendants=None, kids=None, score=None, time=1604586084, title=None, item_type='comment', url=None, parent=24998187, text='Hm,<p>our starting point is that there is very good mathematics for expressions like 1 + 2 * 3 which can also be interpreted as a type.<p>programmers do not know what a product&#x2F;coproduct is, partly because the existing systems do not properly use that concept.<p>so what this tool does for you is<p><pre><code>  1) decide on a simple theory of types and allows you to define types in this.\n  2) implemented that theory in dependent types, so that you can work with typedefs without losing typesafety.\n</code></pre>\nwe need this in statebox because we construct diagrams of boxes and typed wires:<p><pre><code>      +--+\n    A-|f |______ C\n    B-|  |\n      +--+ +--+\n           |g |__ E\n    D------|  |\n           +--+\n</code></pre>\nhere we have two boxes (functions) f : A * B -&gt; C and g: D -&gt; E\nwhen we compose (tensor) those as pictures, we get a bigger box [f * g] which has type<p><pre><code>  [f * g] : A*B*D -&gt; C*E\n</code></pre>\nIn typedefs you can compute this and have compile time guarantees. You cannot do this in protocol buffers (other than at runtime using &quot;dynamic&quot; typing)<p>so it is really more of a typesystem for finite types (things that can be (de)serialized).<p>we do have (de)serialization for Idris and Haskell (and working on others). In the Idris version you have a proof that<p><pre><code>    serialize . deserialize = id\n\n</code></pre>\nEither way, we have a while to go before this becomes as user friendly as it should be. We have dane work on a different language frontend that looks more like Haskell which may clear things up a bit.')