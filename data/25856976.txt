Item(by='lifthrasiir', descendants=None, kids=[25858047], score=None, time=1611220181, title=None, item_type='comment', url=None, parent=25856160, text='&gt; Stuff [...] all combine to give you a certain amount of dependent types in Typescript but also a very rich way of doing type level computations [...].<p>I think this is a wrong use of the term &quot;dependent types&quot;. For example, you can&#x27;t write this in TypeScript (yet):<p><pre><code>    function concat&lt;alen: number, blen: number&gt;(\n        a: ArrayOfLength&lt;alen&gt;,\n        b: ArrayOfLength&lt;blen&gt;,\n    ): ArrayOfLength&lt;alen + blen&gt; {\n        return [...a, ...b];\n    }\n</code></pre>\nSure, you can have a type-level object that corresponds to the numbers and use the type-level expression to compute the equivalent of alen + blen, but they are not dependent types. You have just shifted values to the type level. The type-level expression <i>is</i> awesome---but not because they are dependent types.<p>TypeScript is also not a typical type system you can compare with others. Most famously it is intentionally unsound [1], meaning that it can mostly but not entirely prevent a certain class of runtime errors, because it can&#x27;t guarantee the behavior of external JS code anyway. Most static type systems are or at least try to be sound because that&#x27;s what users expect them to be: preventing a wrong code beforehand. Dependent type systems are complex because they also want to be sound. TypeScript has an entirely different goal for a reason and you can&#x27;t compare it with other type systems not sharing that goal.<p>[1] <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;type-compatibility.html#a-note-on-soundness" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;type-compatibil...</a>')