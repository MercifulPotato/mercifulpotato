Item(by='om2', descendants=None, kids=None, score=None, time=1603502799, title=None, item_type='comment', url=None, parent=24865244, text='&gt; Safety, maybe not 100%, but this could be fixed with extensions, and transformations. The same transformations that WGSL compilers will apply.<p>What I’m telling you is that defining these checks and transformations is the hard part, not the syntax. If your claim is that WebGPU is taking longer because of WGSL, I don’t think that holds up.<p>&gt; I&#x27;m unsure of what you mean by &quot;interoperability&quot;.<p>Consistent behavior across browsers and platforms. Some thing in SPIR-V are not specified with as much precision as modern web standards like HTML or ECMAScript.<p>&gt;&gt; or the advantages of text formats that the web has benefitted from.\n&gt; ??? Nobody has ever enumerated these to me.<p>These have been discussed to death in the WebGPU WG. I’m not sure why you think someone owes you personally a direct explanation. But here are some. Ease of debugging. Learning via “view source” ability to develop and publish with no compile step if desired.<p>&gt; why Apple has not advocated for a text-based formats for &lt;audio&gt; and &lt;video&gt;<p>There is no textual source format for a media file. Media files also need bespoke compression to transmit efficiently. Gripping a text format would not work. Gzip transfer-encoded WGSL is more compact than gzip transfer-encoded SPIR-V, so the transfer size advantage cuts the other way (but not clear this really matters for shader programs)<p>&gt; Binary formats are widely becoming more standard on the web ... even code in the form of WebAssembly<p>WebAssembly is intended for a very specific use case, porting native apps to the web. Even so, many in the WebAssembly WG think it was a mistake to make it a binary format instead of text, in retrospect.<p>&gt; Bloomberg&#x2F;Facebook&#x27;s JS AST proposal improved performance by removing parsing cost<p>We (WebKit team) think they got their results only be starting with a JS engine that had a slow parser. JavaScriptCore parses much faster than SpiderMonkey and is faster than SpiderMonkey + AST prototype. And the proposal is not really getting buy-in at ECMA.<p>&gt; If you want a text format, take the text serialization of SPIR-V. It&#x27;s there, it&#x27;s standard, it exists.<p>There is no standard text serialization format of SPIR-V. There’s an unofficial format supported by spirv-cross, but it’s not a standard. WGSL was created by starting with that serialization format, and progressively adding concessions to human-authorability while preserving a mapping to SPIR-V semantics. We (WebGPU CG) hope to make it a standard and perhaps even make that standard usable beyond the domain of WebGPU.<p>&gt; But you won&#x27;t bother answering me, because every time you bring this up, we ask the same questions, repeat the same evidence, and you ignore us, preferring just to reply &quot;text is more webby&quot;.<p>I just answered you comprehensively. I feel like 0% of what I said is new information beyond what has been stated many times before in many venues. So I think the problem here may be on the reader side, not the writer side.<p>&gt; Not to mention that you&#x27;re currently pressuring the WG to add new APIs to avoid the heavy front-end cost of Apple&#x27;s own MSL shader compiler.<p>This has nothing to do with share language choice per se. That said, the WebGPU CG charter includes the goal of working naturally and efficiently on top of Metal, along with Vulkan and DirectX. This proposal, based on perf measurements, is a way of removing overhead for Metal that won’t affect the other two WebGPU target underlying APIs. Do you feel that WebGPU should not work efficiently on top of Metal? You may not care about this personally, but the CG charter disagrees. Is it bad faith “pressuring” to share perf info about how WebGPU maps to Metal, or just the normal way the standards process is supposed to work? To me it looks like the latter.')