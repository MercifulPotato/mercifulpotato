Item(by='Geminidog', descendants=None, kids=[25270378], score=None, time=1606842830, title=None, item_type='comment', url=None, parent=25264655, text='Why is changing an integer to a class an improvement? Isn&#x27;t that like my last example where every tiny thing is encapsulated by a class?<p>&gt;and play with them if you desire, without an aggregation class managing them.<p>This is my point. Within a class you have several entities that are managed by the class. I&#x27;m saying take away the management layer all together. Take away classes which is exactly what you said.<p>You say you can do this:<p><pre><code>      List&lt;Banana&gt; bananas;\n      List&lt;Gorilla&gt; gorrillas;\n\n      removeBanana(banana):\n         bananas.remove(banana); \n</code></pre>\nbut you can simplify even further and take away the concept of classes all together.:<p><pre><code>      int bananas;\n      int gorrillas;\n\n      void removeBanana(int&amp; bananas):\n         bananas --;\n</code></pre>\nThis isn&#x27;t my point though. The point is in your designs you can never expect your methods to be defined like that.<p>What if for the space station but not jungle... if you remove a banana you have to remove a gorilla too? What do you do? You edit the space station method to account for that. Suddenly the house class requires this too. How do you account for that in the house without copying your logic? How do you account for that without refactoring SpaceStation? Refactoring is simple in these cases but more often then not OOP causes situations where the dependencies are much more tangled and complex.<p>Only if removeBananaAndGorrila(int&amp; banana, int&amp; gorilla) was already written outside the context of a class will you be able to reuse the concept and share it between two classes. So Why not remove the concept of classes all together? That way whenever something needs it, anything can use it.<p>Not to mention that your style requires something called dependency injection which greatly complicates code.<p>removeBanana in all OOP cases can never be reused outside of a class. You must always be redefining it and wrapping banana.remove. You can fix by taking this definition outside the context of the original class with a super class (inheritance) or you can just define it outside of a class all together with no restrictions. Why restrict the ability to reuse something? This is all a class does. Better to let the type parameters of a function to restrict usage.')