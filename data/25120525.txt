Item(by='mikewarot', descendants=None, kids=None, score=None, time=1605590544, title=None, item_type='comment', url=None, parent=25118212, text='I&#x27;m a Pascal programmer, so I come from a different heritage.... anytime I go to look at OOP in C++ or Java, etc... I see a fog of things about factories, and namespaces, and far, far too much code just to set up objects, which are glorified data structures with the code that manages it.<p>I strongly agree with your conclusion that Composition, Interfaces, Aggregation, and Delegation are the real value in OOP.<p>They all play very nicely together.  Composition avoids the need to restructure everything into a single hierarchy.<p>Interfaces make it possible to separate concerns, which lets you treat each library as a black box.<p>Example: Imagine the electrical breaker panel in your home. The exact principles that cause the breaker to trip are irrelevant, nobody cares if it&#x27;s thermal, magnetic, hydraulic, or whatever new tech comes down the block... all that matters is that it does the job in the described manner. It meets the goals of its interface.<p>In hiding implementation behind the interface, you  fend off premature optimization, and stave off technical debt by keeping things small enough to refactor at will. It is this standardization that allows you to add a Ground Fault Interrupter to a box that was designed before they became available.<p>Aggregation is how you can have a series of fields in a form, all of different types, yet it all is a form. If one of those fields has a list of strings... nothing breaks, and you don&#x27;t have to re-arrange everything to make it work.<p>Example: Your breaker panel has any mix of 120 and 240 and GFI breakers, some even do 3phase power.<p>Delegation is how the fields in a form let the details of where on the screen, and how to resize, just work.<p>Example: Your breaker panel has X number of slots, provides a UL approved housing for them, with a reliable User interface.<p>OOP isn&#x27;t the problem, the teaching is.')