Item(by='matt_d', descendants=None, kids=[25389698], score=None, time=1607707001, title=None, item_type='comment', url=None, parent=25387841, text='Compilers books: I&#x27;d start with &quot;Engineering a Compiler&quot; by Keith Cooper and Linda Torczon. <a href="http:&#x2F;&#x2F;craftinginterpreters.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;craftinginterpreters.com&#x2F;</a> is also a pretty great, programming-oriented intro, which may be good to work through alongside. For more on the analysis &amp; compiler optimization side, &quot;SSA-based Compiler Design&quot; (<a href="http:&#x2F;&#x2F;ssabook.gforge.inria.fr&#x2F;latest&#x2F;;" rel="nofollow">http:&#x2F;&#x2F;ssabook.gforge.inria.fr&#x2F;latest&#x2F;;</a> GitHub Mirror: <a href="https:&#x2F;&#x2F;github.com&#x2F;pfalcon&#x2F;ssabook" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;pfalcon&#x2F;ssabook</a>) is a good follow-up.<p>Further readings: Book recommendations in <a href="https:&#x2F;&#x2F;github.com&#x2F;MattPD&#x2F;cpplinks&#x2F;blob&#x2F;master&#x2F;compilers.md#books" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;MattPD&#x2F;cpplinks&#x2F;blob&#x2F;master&#x2F;compilers.md#...</a> as well as program analysis resources (in particular lattice theory, type systems and programming languages theory, related notation): <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;MattPD&#x2F;00573ee14bf85ccac6bed3c0678ddbef#program-analysis-resources" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;MattPD&#x2F;00573ee14bf85ccac6bed3c0678dd...</a><p>Courses: I can recommend the following: <a href="https:&#x2F;&#x2F;github.com&#x2F;MattPD&#x2F;cpplinks&#x2F;blob&#x2F;master&#x2F;compilers.md#courses" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;MattPD&#x2F;cpplinks&#x2F;blob&#x2F;master&#x2F;compilers.md#...</a><p>Particularly (in alphabetical order--I think these are all great, so including highlights of what I&#x27;ve liked about them):<p>- IU P423&#x2F;P523: Compilers (Programming Language Implementation) - Jeremy Siek, with the course book &quot;Essentials of Compilation: An Incremental Approach&quot; (pretty interesting approach, with programming language features developed incrementally having a fully working compiler at each step, cf. <a href="http:&#x2F;&#x2F;scheme2006.cs.uchicago.edu&#x2F;11-ghuloum.pdf;" rel="nofollow">http:&#x2F;&#x2F;scheme2006.cs.uchicago.edu&#x2F;11-ghuloum.pdf;</a> implementation language Racket),<p>- KAIST CS420: Compiler Design - Jeehoon Kang (good modern treatment of SSA representation itself, including the use of block arguments, <a href="https:&#x2F;&#x2F;mlir.llvm.org&#x2F;docs&#x2F;Rationale&#x2F;Rationale&#x2F;#block-arguments-vs-phi-nodes" rel="nofollow">https:&#x2F;&#x2F;mlir.llvm.org&#x2F;docs&#x2F;Rationale&#x2F;Rationale&#x2F;#block-argume...</a>, as well as SSA-based analysis and optimization; Rust as an implementation language),<p>- UCSD CSE 131: Compiler Construction - Joseph Gibbs Politz, Ranjit Jhala (great lecturers, both Haskell and OCaml edition were interesting; fun extra: one of the Fall 2019 lectures (11&#x2F;26) has an interesting discussion of the trade-offs between traditional OOP and FP compiler implementation),<p>- UCSD CSE 231: Advanced Compiler Design - Sorin Lerner (after UCSD CSE 131: for more on analysis &amp; optimization--data flow analysis, lattice theory, SSA, optimization; fun extra: the final Winter 2018 lecture highlighted one of my favorite papers, <a href="https:&#x2F;&#x2F;pldi15.sigplan.org&#x2F;details&#x2F;pldi2015-papers&#x2F;31&#x2F;Provably-Correct-Peephole-Optimizations-with-Alive" rel="nofollow">https:&#x2F;&#x2F;pldi15.sigplan.org&#x2F;details&#x2F;pldi2015-papers&#x2F;31&#x2F;Provab...</a>),<p>- UW CSE CSEP 501: Compilers - Hal Perkins (nice balanced introduction, including x86-64 assembly code generation, with the aforementioned &quot;Engineering a Compiler&quot; used as the course textbook).')