Item(by='siraben', descendants=None, kids=[25516819], score=None, time=1608724914, title=None, item_type='comment', url=None, parent=25516426, text='You can do this with the tagless-final encoding, which has a similar flavor to Data types à la carte&#x27;s concept of open data types. As an example, define<p><pre><code>  class ExpSYM a where\n     add :: a Int → a Int → a Int\n     lit :: Int → a Int\n  class MulSYM a where\n     mul :: a Int → a Int → a Int\n</code></pre>\nNow suppose we extend with booleans and so on. We can freely combine addition and multiplication. As we add new data variants, old code need not be recompiled. We get the openness of OOP&#x27;s class extensions with the flexibility of ADTs.<p><pre><code>  ex1 :: (ExpSYM a, MulSYM a) =&gt; a Int\n  ex1 = add (lit 3) (mul (lit 4) (lit 5))\n</code></pre>\nNot enough space here but you can also pattern match over final terms and interpret them in different ways (e.g. CBN vs CBV interpreters).<p>Then as you go through your compiler pass you can see through the types that &quot;capabilities&quot; get reduced more and more until you reach some base language (sounds like free monads doesn&#x27;t it?).<p>Tangentially if I were to design an FP language I would use tagless final for everything, and deforest as much as I can (if possible) to reduce overhead. How this affects other aspects (e.g. automatically translating pattern matching) I have not looked into, but it&#x27;s interesting nonetheless.')