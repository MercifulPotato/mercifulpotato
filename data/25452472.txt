Item(by='KMag', descendants=None, kids=None, score=None, time=1608179379, title=None, item_type='comment', url=None, parent=25451859, text='[I&#x27;ve incorrectly put some of the statements from Part 2 in the Part 1 summary, but I&#x27;ve already sunk enough time into summarizing, and the flow feels a bit better this way.]<p>Part 1: definitions and motivation.<p>&quot;Radical novelty&quot; describes something new that is so different from everything that came before it that analogical thinking is misleading and new phrases built by analogy with old phrases are inadequate at best.  Thinkers in the middle ages were greatly held back by over-use of analogies.  There are many cases where modern society has dealt poorly with radical novelty: relativity, quantum mechanics, atomic weapons and birth control pills.  The way our civilization has learned to deal with great complexity is to specialize professions, where each profession abstracts away some amount of information, typically expressed in the range of physical scale of their work.  The architect deals with a certain amount of complexity: not having to deal with the large scale of the town planner or the small scale of the metallurgist working for the I-beam manufacturer (my interpretation of &quot;solid state physicist&quot; in this context).  Computing is radically novel in the scale of complexity handled by a single profession.  The terms &quot;software maintenance&quot; (as if time or use alone, rather than shifting requirements, degraded software), &quot;programmers workbench&quot;, etc. are evidence that analogies are misleading and software is radically novel.<p>Part 2: consequences [this summary is more abbreviated than part 1]<p>History has shown the natural human reaction to radical novelty is to pretend analogies still hold and to pretend that rapid progress isn&#x27;t possible.  We can&#x27;t keep treating software like it&#x27;s just some kind of mechanical device and programmers as assembly line workers stamping out widgets.  We can&#x27;t treat software production as just a new type of manufacturing.  Manufacturing-style quality control (testing) is a misleading analogy for software quality control, and formal methods are needed for software.  Software engineering isn&#x27;t about designing new widgets, but about fixing the impedance mismatch between humans as assigners of tasks and computers and executors of tasks.  There are a variety of vested interests (Mathematicians, businesses, the military, those teaching software development as widget building, etc.) working against advancement of Computer Science as a field.  We need to start by fixing our terminology to stop encouraging misleading analogies. (&quot;Software bug&quot; encourages us to think of programmer errors as things that passively happen, like insects crawling into relays, etc.)  The job of a software developer is to show that their designs and implementations are correct, not to correctly execute some set of operations that create a software widget.')