Item(by='creata', descendants=None, kids=[25348602, 25342748], score=None, time=1607402922, title=None, item_type='comment', url=None, parent=25340629, text='I agree that union-typed null was the best solution for Dart, but I think many of the article&#x27;s criticisms of option types aren&#x27;t good.<p>&gt; We can’t perform arithmetic on an Option&lt;int&gt; any more than we could on a List&lt;int&gt;.<p>Why not? One sensible definition is<p><pre><code>    Some(x) + Some(y) = Some(x + y)\n    _       + _       = None()\n</code></pre>\n&gt; In fact, with Dart, we’ve found that most existing code is already statically null safe<p>This is a very good reason to use union types — lots of programs and lots of people are used to thinking this way, and pulling that out from under their feet wouldn&#x27;t be very nice.<p>&gt; Nullable types, since they have no explicit runtime representation, are implicitly flattened.<p>Yes, flattening things that shouldn&#x27;t be flattened is the biggest problem with union types. Different people will assign different meanings to null, and it&#x27;s a real headache when trying to write generic code. Discriminated unions make this a no-brainer.<p>&gt; With nullable types, since there is no representation difference, you can pass a value of the underlying type directly: takesMaybeInt(3);<p>That&#x27;s a very minor difference, but if it&#x27;s that important, Rust lets you write<p><pre><code>    fn takesMaybeInt(x: impl Into&lt;Option&lt;i32&gt;&gt;) { ... }</code></pre>')