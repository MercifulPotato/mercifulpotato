Item(by='bonoboTP', descendants=None, kids=[24749794], score=None, time=1602451172, title=None, item_type='comment', url=None, parent=24747095, text='&gt; so I have to juggle with multiple dialects (pandas, numpy, pytorch, tensorflow)<p>NumPy should be enough for general computation. If you need autodiff or GPU then add in PyTorch. Pandas is more about various metadata than the actual numerical computing. If you want those types of features, the complexity doesn&#x27;t disappear if you go to a different language.<p>There&#x27;s an effect where a new generation of developers see complexity built by the earlier generation, say it&#x27;s too complicated and mess up, we don&#x27;t need all that, so start over clean and it all looks so easy. But it&#x27;s deceptive, because it will get complicated again once you put in all the features but it will look familiar now to this generation of developers as they grow side-by-side with the new language&#x2F;framework. After a few years the cycle repeats and a new generation says &quot;what&#x27;s all this mess, why do I need to juggle all this, I <i>just</i> need XY.&quot;<p>&gt; Also Python for a dynamic language has pretty mediocre interactive story (using ptpython since the default repl is unusable), even simple things like copy pasting to a REPL can end up being a pain because of indenting, and the repl is far away from Lisp, Clojure and even Julia and Elixir.<p>Use Jupyter Notebooks (or IPython if you don&#x27;t want to leave the shell).<p>&gt; disappointed with Python&#x27;s multithreading story<p>Thread pools (executors, futures etc.) and process pools (multiprocessing module) work quite nicely.')