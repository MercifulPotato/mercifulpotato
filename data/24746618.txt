Item(by='scroot', descendants=None, kids=None, score=None, time=1602431657, title=None, item_type='comment', url=None, parent=24745747, text='I would argue that the more CS education has become about training people to perform the jobs of the present (and thus work in the languages and systems of the present), it has become a kind of Unix training ground. There is certainly now a whole generation of programmers and CS graduates who never got to experience these other systems, and perhaps know very little about them (CS doesn&#x27;t like to teach its own history).<p>I have argued elsewhere on this forum that the environment is ripe for completely new OSes, and that we have advantages over this &quot;previous era.&quot; The first is the wide adoption and availability of data interchange formats (think JSON, XML, hell even TCP&#x2F;IP) that were not as common &#x2F; didn&#x27;t exist in the heady days of RiscOS or classic Mac. This gets a new OS much further in the &quot;compatibility problem.&quot; Our current &quot;App Culture&quot; also absolves us of the need for true application compatibility. For example, so long as your new OS has a somewhat standards-compliant web browser (no small task), you get perhaps up to 90% of the capabilities most people need.<p>Another factor is that, while our hardware has really fit itself to C and Unix in often frustrating ways, we have RISCV on the horizon. And though all the writing online about it seems to revolve around getting *nix systems to run (boring), there is enough openness for people to experiment without 40 years of cruft getting in the way.<p>People really should be asking &quot;what is the point of an operating system? What is actually needed here?&quot; A glance in the direction of Lisp machines or Smalltalk or Oberon would provide a lot of guidance in that regard.<p>I still believe that one day we can move past the teletype metaphor.')