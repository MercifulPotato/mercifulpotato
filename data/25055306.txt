Item(by='phillipcarter', descendants=None, kids=[25056312], score=None, time=1605066369, title=None, item_type='comment', url=None, parent=25053716, text='&gt; this means the compiler can&#x27;t infer the type for a function argument event though I pass it an `int` later in the file.<p>That&#x27;s demonstrably untrue by the simplest of code snippets.<p><pre><code>    let f x = ()\n    f 12\n</code></pre>\nHere, &#x27;f&#x27; is generic becuase &#x27;x&#x27; isn&#x27;t used in a way that would constrain it in any way.<p><pre><code>    let inline f x = x + 1\n    f 12\n</code></pre>\nHere, &#x27;f&#x27; is constrained to be generic over any type that defines how &#x27;+&#x27; works for it.<p><pre><code>    let f x = x + 1\n    f 12\n</code></pre>\nHere, &#x27;f&#x27; is constrained to be &#x27;int&#x27; because that&#x27;s what&#x27;s passed in and assumed as the type given that it&#x27;s not marked as &#x27;inline&#x27;.<p>The article you link to is referring to type inference for <i>.NET Object types</i>, because member lookup is not used as a means to inform how type constraints are solved.<p>When any primitive or any F# type (records, unions, anonymous records, etc.) is passed in the lookup is not indeterminate.')