Item(by='Chris_Newton', descendants=None, kids=None, score=None, time=1606157767, title=None, item_type='comment', url=None, parent=25182576, text='<i>Honestly, in the Haskell world, no one really complains about broken APIs</i><p>I don’t believe that’s true. The very existence of Stack and Stackage is testament to how significant the compatibility problems had become in the Haskell ecosystem.<p>Even if it were true, Haskell world is tiny and (in)famously has the motto “Avoid success at all costs”, so it isn’t <i>necessarily</i> a representative example of practices that would be effective in other contexts.<p>The advantage with a type system as explicit as Haskell’s is that at least if there is a breaking change in an interface you depend on, you get quite good information about where the problem is and what you need to do to fix it.<p><i>Also, breaking API changes happen in every language, on every codebase, ask the time.</i><p>Some people take backwards compatibility extremely seriously, and code that depends on their interfaces still works just fine many years after it was written. The pace of development is usually slower when robust standardisation is part of the process, but that isn’t necessarily a bad thing given the stability you get in return.<p><i>At least with static types and a common linter I can refactor and be a hundred percent sure it works since it compiles</i><p>This is a common claim in the Haskell world, but of course it’s not really true. It always reminds me of Knuth’s famous quip, “Beware of bugs in the above code; I have only proved it correct, not tried it.”')