Item(by='Dylan16807', descendants=None, kids=None, score=None, time=1604863782, title=None, item_type='comment', url=None, parent=25027870, text='&gt; &#x27;pretend X doesn&#x27;t exist&#x27; is in my mind &#x27;speculate that X isn&#x27;t enabled&#x27;. It really means the same thing doesn&#x27;t it?<p>Not when you&#x27;re talking about needing &quot;dynamic analysis&quot;, which is what made me not understand the way you were using that word.<p>&gt; It does make compilation more complicated because you need to be able to restore the full debug state of the application, which means storing some results you may not choose to do otherwise, and storing extra meta-data.<p>You don&#x27;t <i>need</i> to, in the general case.<p>&gt; Debuggers can be a formally or informally specified part of the language, and their behaviour may have to follow rules about which intermediate results are visible which may constrain your compilation.<p>&gt; My argument is: if you do treat debugging as speculation then your model is simpler and easier to work with and you don&#x27;t need two kinds of deoptimisation. Real languages are implemented this way.<p>I suppose, but that&#x27;s only one option.  You could make the deoptimization for debugging much weaker or nonexistent, and that would be a valid option too, without having to give up simplicity.<p>And separately, wanting to change the value of a const while debugging is a valid use case too.  But once you support that, there&#x27;s no reason a never-written let needs to be optimized differently from a const.')