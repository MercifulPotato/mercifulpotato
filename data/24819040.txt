Item(by='brundolf', descendants=None, kids=[24819218, 24820280, 24821457, 24821497, 24819185, 24820177, 24821638, 24821843, 24821646, 24819848], score=None, time=1603038895, title=None, item_type='comment', url=None, parent=24817594, text='To summarize:<p>1) Rust&#x27;s standard idioms (in this case, Results and Iterators) encourage less bug-prone or ambiguous APIs (standard and otherwise)<p>2) Rust&#x27;s ecosystem makes it easy to find and integrate solutions not offered by the standard API<p>3) And then finally, Rust&#x27;s borrow checker prevented a threading issue<p>Others are rightly pointing out that only #3 is fundamentally unique to Rust. All of these other things could be done for C++. But, importantly, they haven&#x27;t.<p>This raises an interesting dimension to the comparison which is that many of Rust&#x27;s advantages don&#x27;t really come down to its unique traits (heh) but to the simple fact that it&#x27;s &quot;C++ without baggage&quot;. It had a fresh start when it came to establishing standard idioms for everyone to use, providing cross-platform tooling for everyone to use, providing centralized package management for everyone to use, etc. If you introduced to C++ a Result type, or a package manager (I assume people have done this already), most C++ developers wouldn&#x27;t end up using them. Most libraries wouldn&#x27;t be using the same vocabulary. It would be arduous to even move the standard library over, because it would be a breaking change. Much of the tooling out there would probably never get specialized support.<p>I don&#x27;t think these network effects and cultural forces get talked about enough. Sure, this stuff is &quot;just a library&quot;, and C++ has libraries. But the culture and the baggage and the stakeholders around a language have a huge impact on what ends up being practical to do with it, independent from what&#x27;s technically possible.')