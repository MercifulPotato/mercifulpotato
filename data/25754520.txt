Item(by='benlivengood', descendants=None, kids=[25755763], score=None, time=1610488836, title=None, item_type='comment', url=None, parent=25753773, text='&gt; So how do we guard against this type of attack? How do we know this hasn&#x27;t already happened to some of us? What is the potential fallout from this hack, it seems quite significant.<p>Verified builds.  That means deterministic builds (roughly, from a given git commit the same binaries should result no matter who compiles them.  It requires compiler support and sometimes changes to the code) plus trusted build infrastructure.<p>To verify that you haven&#x27;t been compromised do a verified build from two independent roots of trust and compare the resulting binaries.  Add more roots of trust to reduce the probability that all of them are compromised.<p>Establishing a trusted root build environment is tricky because very little software has deterministic builds yet.  Once they do it&#x27;ll be much easier.<p>Here&#x27;s my best shot at it:<p>Get a bunch of fresh openbsd machines.  Don&#x27;t network them together.  Add some windows machines if you&#x27;re planning to use VS.<p>Pick 3 or more C compilers.  Grab the source, verify with pgp on a few machines using a few different clients.  For each one, compile it as much as possible with the others.  This won&#x27;t be possible in whole due to some extensions only available in a particular compiler used in its source, but is the best we can do at this point.  Build all your compilers with each of these stage-2 compilers.  Repeat until you have N-choose-N stage-N compilers.  At this point any deterministic builds by a particular compiler (gcc, llvm, VS) should exactly match despite the compilers themselves being compiled in different orders by different compilers.  This partially addresses Ken Thompson&#x27;s paper &quot;reflections on trusting trust&quot; by requiring any persistent compiler backdoors to be mutually compatible across many different compilers otherwise it&#x27;ll be detected as mismatched output from some compiler build ancestries but not others.  Now you have some trusted compiler binaries.<p>Git repository hashes can be the root of trust for remaining software.  Using a few different github client implementations verify all the hashes match on the entire merkle tree.  Build them with trusted compilers of your choice on multiple machines and verify the results match where possible.<p>At this point you should have compilers, kernels, and system libraries that are most likely true to the verified source code.<p>Make a couple build farms and keep them administratively separate. No common passwords, ssh keys, update servers, etc.  Make sure builds on both farms match before trusting the binaries.<p>The good news is that most of this can be done by the open source community; if everyone starts sharing the hashes of their git trees before builds and the hashes of the resulting binaries we could start making a global consensus of what software can currently be built deterministically and out of those which are very likely to be true translations from source code.<p>EDIT: <a href="https:&#x2F;&#x2F;wiki.debian.org&#x2F;ReproducibleBuilds" rel="nofollow">https:&#x2F;&#x2F;wiki.debian.org&#x2F;ReproducibleBuilds</a> is Debian&#x27;s attempt at this.')