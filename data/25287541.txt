Item(by='_ph_', descendants=None, kids=None, score=None, time=1606991128, title=None, item_type='comment', url=None, parent=25286218, text='I disagree on many levels. I firmly think (being both a developer and a project lead) that the developers which build an application, should have the beefiest and fastest machine that money can buy. Especially if you want to have a fast product. Why is this?<p>- First of all, faster hardware means better productivity. If you want the developers have time to optimize for speed, better give them the time for this. Cutting their productivity usually means, less time is spend on optimizing, all &quot;features&quot; need to be implemented first. Only when all &quot;features&quot; have been implemented, quality improvements get scheduled. You want developers to be productive enough that they get time to improve quality&#x2F;speed.<p>- Developers are running the application completely differently than the end users. If an application is run for hours if not even days at a time, startup speed doesn&#x27;t count much. A developer might have to restart an application for debugging something every minute[1]. Having the developer waiting on startup would be a bad waste of time. While it might be nice to optimize startup times, the really might not be customer-relevant.<p>- Developers often run unoptimized code with debug code present or even inside a debugger. This makes the code often slower than the customer experience.<p>- Developers might have to run several instances of the application at the same time, requiring the neccessary compute resources, also the development environments need to be powered.<p>- And to some extend, which gets revived by the power of these new chips, development often happens years before a product ships. What is an exotic and expensive machine at the project start, might be a medium range for the customer when the product ships. So the development machine was actually a good match of the deployment platform.<p>These are some of the reasons why developers should have powerful machines. Of course, there are also a lot of reasons to test the product on less powerful machines and set performance goals according to these tests. But this doesn&#x27;t mean the developer has to do the development work on those machines. If a product doesn&#x27;t get tested enough and on the right systems, it is rather a project management issue.<p>1: I am fortunate to do quite a bit of my work in Lisp and it is one huge productivity boost that I can update every single function redefinition in the running code. Which gives me increadibly short iteration cycles. The cost of starting up an application to test a change isn&#x27;t just the startup time but also the interaction needed until you get to the point where the function is called, I am doing quite UI-centric work. This becomes very noticable, whenever I actually have to restart the application to get a meaningful test. Even worse are the situations where I even have to wait for a longer compilation run (with non-Lisp languages, like C++)')