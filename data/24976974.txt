Item(by='dwohnitmok', descendants=None, kids=[24978106, 24980500], score=None, time=1604385280, title=None, item_type='comment', url=None, parent=24976206, text='It&#x27;s a bit more subtle than that. Almost every language has a sliding scale of discipline rather than a binary one.<p>E.g. you could decide to write extremely mutable code in OCaml, but it&#x27;s highly discouraged and the happy path is generally to default to immutability.<p>So you need comparatively little, although not none, discipline to have a pervasively immutable codebase, since there&#x27;s nothing preventing you at a language level from introducing crazy mutation everywhere.<p>Haskell goes further, where you have to use functions named &quot;unsafe*&quot; to introduce mutability. Something like Elm goes further still, where, barring bugs in low-level libraries or heavy abuse of the JavaScript runtime (e.g. redefining prototypes of basic types), you essentially have to fork the compiler to introduce mutability (Dark moved away from Elm because, as I understand it, it actually became too restrictive on this front).<p>On the other hand, in something like Java, you need a lot of discipline to have pervasive immutability and you have to go out of your way to avoid using otherwise common constructs (e.g. if statements since those are statements rather than expressions) that require very kludgey workarounds (encoding an algebraic data type as a fold and using that in place of if statements).<p>Kotlin is in the middle. If you don&#x27;t use certain parts of the standard library and don&#x27;t use things like var, you have pervasive immutability. At a language level this is quite similar to Scala (Scala has a more immutably focused standard library than Kotlin does).')