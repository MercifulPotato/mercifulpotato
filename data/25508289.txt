Item(by='brundolf', descendants=None, kids=[25510261], score=None, time=1608655952, title=None, item_type='comment', url=None, parent=25505138, text='Purity is a question of mutability, nothing more. If the function mutates its arguments (or its closure, or its global environment), it is impure. Any useful program will of course need to do these things at some point, but there&#x27;s a lot of logic that just goes from A -&gt; B (or A, B, C -&gt; D, or whatever), that doesn&#x27;t need to concern itself with these things, and should be insulated from them. There&#x27;s nothing inherently impure about taking large data structures as arguments, though it does make it trickier to <i>enforce</i> immutability in most languages (compared to primitive values).<p>It&#x27;s worth noting that it&#x27;s entirely possible to write &quot;pure methods&quot;. Unfortunately most languages don&#x27;t really let you a) have mutable structures, and b) write enforced-immutable methods on them. Rust is the only one I know of: a method can take a &amp;self instead of a &amp;mut self, which prevents it from mutating self (recursively, which requires knowledge about ownership unless your language is 100% immutable like Haskell or Clojure, which is why this feature is so rare). What I tend to do in other languages like JavaScript, C#, or Python is to use property-getters as a convention that strongly suggests purity; unfortunately that&#x27;s about the best you can do.<p>In multi-paradigm languages the decision on whether to make something a pure &quot;getter&quot; method or a standalone function is mostly one of aesthetics. Standalone functions give you a bit more flexibility in use, but sometimes the foo.prop syntax is more readable.')