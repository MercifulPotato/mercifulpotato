Item(by='joncampbelldev', descendants=None, kids=None, score=None, time=1609716100, title=None, item_type='comment', url=None, parent=25624301, text='Regarding REPL restarts: You don&#x27;t need to use stuff like component. There are far lighter weight alternatives with no requirements for app structure. I use &quot;mount&quot; [0] for this. You define &quot;start&quot; and optionally &quot;stop&quot; code for anything in your app that you consider stateful and would like to reboot (like db conn pools, config loaded from files &#x2F; env etc). No interfaces &#x2F; protocols, easy app restarts within the same repl, no enforced structure in your app. You just use the resources as if they were def&#x27;d vars in a namespace (because they are).<p>Regarding ecosystem and interop, in my experience (using clojure for about a third of the stuff at my job) I&#x27;ve rarely encountered a problem directly interop-ing with a java library, things like &quot;doto&quot; and &quot;reify&quot; do a good job of smoothing the rough java edges off.<p>More importantly I&#x27;ve usually had the choice of either directly using the using a pure clojure alternative or direct interop with java lib or using a clojure wrapper around the java lib. Incidentally those are my preferred choices in order (assuming the features I&#x27;m interested in are supported equally).<p>Perhaps I have been lucky in my requirements from the clojure &#x2F; java ecosystems. I find the most important lesson I learned was to only use clojure wrappers if they are of a supremely high quality (either auto generated like cognitects aws lib or with a massive amount of momentum behind them like clj-http (wrapping on java http components)). An average quality or not super actively maintained wrapper is much worse than direct interop (again leaning heavily on the provided macros for interop to sand off the nastiness).<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;tolitius&#x2F;mount" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;tolitius&#x2F;mount</a>')