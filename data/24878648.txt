Item(by='tlamponi', descendants=None, kids=[24878829], score=None, time=1603540902, title=None, item_type='comment', url=None, parent=24877739, text='&gt; Rust is too hard to learn<p>Complaints about Rust&#x27;s learning curve is something I really do not get.<p>Yes, it forces you do actually think of what you&#x27;re doing, which most devs seem to consider a Bad Thingâ„¢, but in the mid to long run it helps one enormously and it&#x27;s one of the first languages of the last 30 years which actually makes lots of things better as a whole, while not being in a walled closed ecosystem.<p>&gt; compiles too slow<p>There&#x27;s definitively room for improvement here, but honestly, it&#x27;s way faster than most C++ projects, and the fact that I have native support for nicely separating stuff in sub crates or workspaces, which dramatically improve iterative compiling, makes this a non-issue as long as one does not dump everything together as a pig pile.<p>&gt; hard to interop with C<p>This is just plain wrong, it&#x27;s very easy to interop with C - we&#x27;re doing so with some projects, among other a library interoperating with QEMU, where the rust stuff is async (using tokio) and we can nicely integrate this into the C code of QEMU. Automatic binding generation allows you to do this quickly, albeit not very idiomatic most of the time. But manual binding generation is seldom hard, either already done on more popular stuff or one time cost, which, if one knows the code they want to bind too (they should) is rather small.<p>&gt; less safe than VM-based languages<p>Hardly so. One is much more exposed to dynamic runtime errors in those, GC is a PITA and the VM is normally not safer than the rust std lib, as most of it is written in safe rust already and is around, battle tested for up to 5 or even 10 years.')