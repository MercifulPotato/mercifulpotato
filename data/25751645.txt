Item(by='Animats', descendants=None, kids=[25751723, 25751724], score=None, time=1610477930, title=None, item_type='comment', url=None, parent=25750582, text='Two more levels of blogs down, the actual proposal.[1] Definition:<p><pre><code>    &#x2F;&#x2F; Print has a type parameter T and has a single (non-type)\n    &#x2F;&#x2F; parameter s which is a slice of that type parameter.\n    func Print[T any](s []T) { ... }\n</code></pre>\nCall:<p><pre><code>    Print[int]([]int{1, 2, 3})\n</code></pre>\nAbove, &quot;any&quot; is really just a synonym for &quot;interface{}&quot;.  You can have more restrictive type constraints on parameterized types by specifying other Go interfaces. This is vaguely similar to how Rust does it, and quite different from the C++ approach.<p><i>&quot;This design does not support template metaprogramming or any other form of compile time programming.&quot;</i><p>[1] <a href="https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;design&#x2F;go2draft-type-parameters.md" rel="nofollow">https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;des...</a>')