Item(by='musicale', descendants=None, kids=None, score=None, time=1606009632, title=None, item_type='comment', url=None, parent=25170645, text='A full Oberon system image is about 1MB, including GUI, utilities, and the compiler, though a 100KB image can boot and run a text editor.<p><a href="https:&#x2F;&#x2F;schierlm.github.io&#x2F;OberonEmulator&#x2F;" rel="nofollow">https:&#x2F;&#x2F;schierlm.github.io&#x2F;OberonEmulator&#x2F;</a><p>The original Oberon system was something like 12,000 lines of code, something you could imagine reading in its entirety.<p>IIRC most of the Linux kernel source code is device drivers; the linux kernel also has a huge amount of functionality, much more than you need just to boot a PC into a GUI. Much of Linux user code is bloated libraries with a good deal of duplicated functionality.<p>Many GUI-based systems from the 1980s and 1990s were very compact by modern standards. (Even a full Smalltalk-80 system image is less than 2MB including the source code.) You can still run RISC OS on the Raspberry Pi to try out a 1980s&#x2F;90s-style PC OS.  Classic text-based UNIX OSes were obviously also dramatically smaller than modern Linux distributions.<p>Regarding device drivers, I wonder if the BIOS approach is better - assume the hardware vendor supplies the device drivers, and let the OS use those drivers rather than supplying its own. Someone will probably argue that &quot;oh legacy BIOS is 16-bit, doesn&#x27;t support [caching&#x2F;acceleration&#x2F;scatter-gather&#x2F;async&#x2F;polling&#x2F; feature x] or hardware vendors don&#x27;t know how to write drivers or it&#x27;s closed source or blah blah blah&quot; but that would be missing the point that the <i>idea</i> of separating the driver subsystem from the OS might not be such a bad one.')