Item(by='eutectic', descendants=None, kids=None, score=None, time=1607545651, title=None, item_type='comment', url=None, parent=25355580, text='I was inspired to write a solver for this kind of puzzle (it&#x27;s not pretty but it seems to work well):<p><pre><code>    import numpy as np\n    import z3\n    import matplotlib.pyplot as plt\n    from sklearn.svm import LinearSVC\n    from sklearn.cluster import KMeans\n\n    def normalize(v):\n        return v &#x2F; np.sqrt(np.dot(v, v))\n\n    def line_normal(v):\n        return np.array([v[1], -v[0]])\n\n    def line_segment_intersection_test(e0, e1):\n        a, c, b, d = e0[0], e1[0], e0[1] - e0[0], e1[1] - e1[0]\n        n = line_normal(b)\n        l = np.dot(n, d)\n        if l == 0:\n            return False\n        t1 = np.dot(n, a - c) &#x2F; l\n        if not 0 &lt;= t1 &lt;= 1:\n            return False\n        if b[0] == 0:\n            return False\n        t0 = (c[0] + t1 * d[0] - a[0]) &#x2F; b[0]\n        return 0 &lt;= t0 &lt;= 1 \n\n    def min_cover(n, subsets):\n        #some simple pruning makes z3 run much faster\n        subsets = list(enumerate(map(set, subsets)))\n        subsets.sort(key=lambda t: len(t[1]))\n        redundant = set([])\n        for i, (_, s) in enumerate(subsets):\n            for j in range(i + 1, len(subsets)):\n                _, s1 = subsets[j]\n                if all(x in s1 for x in s):\n                    redundant.add(i)\n                    break\n        subsets = [t for i, t in enumerate(subsets) if i not in redundant]\n        s = z3.Solver()\n        included_subsets = [z3.Bool(&#x27;subset_%d_included&#x27; % i) for i, _ in subsets]\n        for i in range(n):\n            covering_subsets = [j for j, (_, s) in enumerate(subsets) if i in s]\n            s.add(z3.Or(*[included_subsets[j] for j in covering_subsets]))\n        for bound in range(len(subsets)+1):\n            print(&quot;trying %d cut%s...&quot; % (bound, &#x27;s&#x27; * (bound != 1)))\n            s.push()\n            s.add(z3.PbEq([(v, 1) for v in included_subsets], bound))\n            if s.check() == z3.sat:\n                model = s.model()\n                return [subsets[i][0] for i, v in enumerate(included_subsets) if model.eval(v)]\n            s.pop()\n        return []\n    \n    def solve(islands):\n        edges = []\n        islands = [[np.array(v) for v in island] for island in islands]\n        print(&quot;enumerating edges...&quot;)\n        for island in islands:\n            for i, v_i in enumerate(island):\n                for j, v_j in enumerate(island):\n                    if j == i:\n                        break\n                    edges.append((v_i, v_j))\n        vertices = np.array([v for island in islands for v in island])\n        x, y = vertices.T\n        x_min, y_min = np.min(vertices, axis=0)\n        x_mean, y_mean = np.mean(vertices, axis=0)\n        x_max, y_max = np.max(vertices, axis=0)\n        d_max = 2 * np.sqrt((y_max - y_min) ** 2 + (x_max - x_min) ** 2)\n        cuts = []\n        print(&quot;enumerating cuts...&quot;)\n        for i, v_i in enumerate(vertices):\n            for j, v_j in enumerate(vertices):\n                if j == i:\n                    break\n                dv = normalize(v_j - v_i)\n                n = line_normal(dv)\n                eps = 1e-7\n                #try both cut orientations (left+right and right+left), and extend the cuts to poke out of the domain\n                c0 = (v_i + eps * n - d_max * dv, v_j - eps * n + d_max * dv)\n                c1 = (v_i - eps * n - d_max * dv, v_j + eps * n + d_max * dv)\n                cuts.append(c0)\n                cuts.append(c1)\n        print(&quot;finding intersections...&quot;)\n        cut_sets = [[] for _ in cuts]\n        for i, cut in enumerate(cuts):\n             for j, edge in enumerate(edges):\n                 if line_segment_intersection_test(cut, edge):\n                     cut_sets[i].append(j)\n        print(&quot;solving for min-cover...&quot;)\n        included_cuts = [cuts[i] for i in min_cover(len(edges), cut_sets)]\n        print(&quot;refining cuts using SVM...&quot;)\n        refined_cuts = []\n        for cut in included_cuts:\n            v0, v1 = cut\n            dv = v1 - v0\n            n = line_normal(dv)\n            side = (np.sum((vertices - v0) * n, axis=-1) &gt; 0).astype(np.long)\n            svm = LinearSVC(C=1e9, loss=&#x27;hinge&#x27;, max_iter=10000)\n            svm.fit(vertices, side)\n            if svm.score(vertices, side) == 1:\n                m, c = svm.coef_[0], svm.intercept_[0]\n                dv = np.array([m[1], -m[0]])\n                if m[1] == 0:\n                    v0 = np.array([-c&#x2F;m[0], y_mean])\n                else:\n                    v0 = np.array([x_mean, -(c+m[0] * x_mean)&#x2F;m[1]])\n            else:\n                print(&quot;SVM fitting failed: (falling back to grazing cut)&quot;)\n            dv = normalize(dv)\n            proj = np.sum((vertices - v0) * dv, axis=-1)\n            proj_min, proj_max = np.min(proj), np.max(proj)\n            proj_range = proj_max - proj_min\n            refined_cuts.append([v0 + (proj_min - 0.1 * proj_range) * dv, v0 + (proj_max + 0.1 * proj_range) * dv])\n        return refined_cuts\n\n    vertices = np.random.uniform(-1, 1, (15, 2))\n    n_clusters = 5\n    k_means = KMeans(n_clusters=n_clusters).fit(vertices)\n    labels = k_means.labels_\n    islands = [[v for j, v in enumerate(vertices) if labels[j] == l] for l in range(n_clusters)]\n    cuts = solve(islands)\n    for island in islands:\n        plt.scatter(*np.array(island).T, marker=&#x27;+&#x27;)\n    for cut in cuts:\n        plt.plot(*np.array(cut).T, color=&#x27;black&#x27;)\n    plt.show()</code></pre>')