Item(by='coder543', descendants=None, kids=[24743684], score=None, time=1602196254, title=None, item_type='comment', url=None, parent=24724580, text='These scenarios are so hypothetical that it’s pointless to give an answer. What if the library requires you to pass in values in a custom struct they defined? What if the library requires all sorts of arbitrary nonsense?<p>The reality is that the conversion cost to just `map` one Vec to another is extremely low on anything but maybe a microcontroller —- and even then, maybe not.<p>If you benchmark things and can’t find a safe way to do things, there are unsafe methods, but I am <i>highly</i> skeptical that they would be needed.<p>It’s also extremely possible to fork such a library, change a few lines to use the dimensionally correct type, and be done with the issue.<p>If all of your heavy lifting is being done by this external library anyways, and that library just uses raw floats... why bother with the ceremony of using a dimensionally safe float in your own code if the performance cost of mapping between types is too high?<p>The real benefit of dimensional safety is when you’re actually doing computations, not some external library you pulled in.<p>Rust allows for these zero cost wrapper types that will do exactly the correct computations as if they were done with hand written code... but you have to actually have computations that <i>you</i> want to do. The type system intentionally doesn’t want you to treat these typed floats as regular floats. That’s the point.<p>But there are ways to transmute certain types for no performance penalty, they’re just footguns you should avoid except as an option of last resort.')