Item(by='twic', descendants=None, kids=[24689458, 24687506], score=None, time=1601899509, title=None, item_type='comment', url=None, parent=24686809, text='For me, it&#x27;s the other way round: minor updates like spelling, renaming, or test fixes during initial development can really clutter the major updates.<p>If i am making a commit that makes a complex but important change to some significant application logic, i want that commit to contain that change <i>and only that change</i>, so that when i have to re-read it a year later, it&#x27;s completely obvious what i did and why. Bundling a load of refactoring and cleanup in there is a significant speedbump for my understanding.<p>Years ago, a sage pointed out the argument for squashing is really an argument for better tools. Imagine if you could flag commits as being of two types - major&#x2F;minor, significant&#x2F;insignificant, feature&#x2F;refactoring, foreground&#x2F;background, melody&#x2F;rhythm, etc. Then imagine if the tools would by default hide, roll up, or otherwise de-emphasise the commits of the latter kind. This whole apparent dichotomy would go away in a flash.<p>This idea is floating around in the Wiki world. I believe it was Ward&#x27;s Wiki that introduced a &#x27;minor edit&#x27; checkbox in the editor; if a change was marked as a minor edit, it wouldn&#x27;t be show on the recent changes feed.<p>You can imagine other ways to get somewhere similar. For example, you could have a special kind of commit that just groups a previous run of commits, and the tools could show that and hide the members of the group by default. There are probably many other ways to do this.')