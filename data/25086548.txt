Item(by='openasocket', descendants=None, kids=None, score=None, time=1605296852, title=None, item_type='comment', url=None, parent=25083870, text='Yes and no, because a module can be a much more complicated thing than a class. A module allows you to define not just one type but several types and how they interact. In regular OOP you can have a &quot;FooInterface&lt;A, B, C&gt;&quot; where you are defining a type of object, and defining it&#x27;s behaviors in the context of types A, B, and C. A module defining only one type is pretty much an interface but when you define a module in terms of multiple types it takes on a different shape. While you can probably always replace a module with a series of interfaces (ignoring the part about constructors), those interfaces will be more unwieldy and awkward.<p>Here&#x27;s an example. This example is a bit contrived, because I couldn&#x27;t think of a better example that was simple and yet demonstrated the power of modules. So this example can be re-phrased and re-structured into a more natural OO fit, but try to look past that. Suppose you want to make a module or set of interfaces that describe a classic board game (i.e. Chess or Checkers). So you have a Board. A Board has a series of Pieces, and each Piece has a set of valid moves on the board. And a move can be applied to a Board to modify the state of the game. Again, very much glossing over the details here to get to the meat of it. So you could write a series of interfaces<p><pre><code>    interface Board {\n        List&lt;Piece&gt; getPieces();\n    }\n    interface Piece {\n        List&lt;Move&gt; getValidMoves(b: Board);\n    }\n    interface Move {\n        void apply(b: Board);\n    }\n</code></pre>\nBut on it&#x27;s own that isn&#x27;t enough, because you don&#x27;t want to be able to mix-and-match different interfaces for different games, like trying to find the set of valid moves for a chess piece on a checker board. So you need to apply generics.<p><pre><code>    interface Board&lt;P&gt; {\n        List&lt;P&gt; getPieces();\n    }\n    interface Piece&lt;B, M&gt; {\n        List&lt;M&gt; getValidMoves(b: B);\n    }\n    interface Move&lt;B&gt; {\n        void apply(b: B);\n    }\n</code></pre>\nOnly that&#x27;s not enough either, because on it&#x27;s own these parametric definitions don&#x27;t enforce that the set of pieces a board returns are actually valid pieces for that game. With constraints you end up with this (in a psuedo-language where you can use a special Self type, I don&#x27;t know typescript and don&#x27;t think this can actually be implemented in plain Java)<p><pre><code>    interface Board&lt;P extends Piece&lt;Self,Move&lt;Self&gt;&gt;&gt; {\n        List&lt;P&gt; getPieces();\n    }\n    interface Piece&lt;B extends Board&lt;Self,M&gt;, M extends Move&lt;B&gt;&gt; {\n        List&lt;M&gt; getValidMoves(b: B);\n    }\n    interface Move&lt;B extends Board&lt;?&gt;&gt; {\n        void apply(b: B);\n    }\n</code></pre>\nAnd so you have a bunch of these weird circular definitions to get these components to play together nicely. Meanwhile, you can define a module for this without using Functors or type substitutions or anything terribly complicated (Note the below is sort of mixing OCaml with more Java-like syntax just because I&#x27;m not super familiar with OCaml):<p><pre><code>     module type Game = sig\n         type Board\n         type Piece\n         type Move\n         val getPieces: Board -&gt; List&lt;Piece&gt;\n         val getValidMoves: Piece -&gt; Board -&gt; List&lt;Move&gt;\n         val apply: Move -&gt; Board -&gt; unit\n    end\n</code></pre>\nAnd I think that&#x27;s the really interesting thing you can do with modules that is more awkward with the traditional OOP interfaces. It makes it more natural to talk about multiple different data types all working together.<p>The only way to implement that as nicely with an OOP interface would be to wrap everything in a top-level object<p><pre><code>    interface Game&lt;B, P, M&gt; {\n        List&lt;P&gt; getPieces(b: B);\n        List&lt;M&gt; getMoves(p: P, b: B);\n        void apply(m: M, b: B);\n    }\n</code></pre>\nThough now you have to make a singleton Game object and pass that around everywhere you need it, which may or may not be idiomatic or obvious depending on the language and your preferences.')