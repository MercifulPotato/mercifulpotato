Item(by='est31', descendants=None, kids=None, score=None, time=1608059601, title=None, item_type='comment', url=None, parent=25433395, text='&gt; This only affects servers that do indeed serve the &quot;anybody can talk to me&quot; CORS headers.<p>Again, even if these CORS headers are not sent, the browser still does a request to the server in order to find out whether the headers are being sent. Check running <i>python3 -m http.server</i> in your terminal, and then do <i>var v = fetch(&quot;<a href="http:&#x2F;&#x2F;localhost:8000&#x2F;hellllllo" rel="nofollow">http:&#x2F;&#x2F;localhost:8000&#x2F;hellllllo</a>&quot;)</i> in your browser&#x27;s console. You will get a big red CORS error in the console, because the builtin python http server does not send these headers. But the web server will <i>still</i> receive and respond to the &quot;hellllllo&quot; GET request! It will show up in your terminal&#x27;s log. For some insecure servers, getting a specifically crafted request might be enough to exploit security bugs. Like I said, take a server that has a limited size buffer for the URL after which it overflows letting you write data to whatever is beyond that on the stack.<p>&gt; This change doesn&#x27;t actually increase this risk<p>Alright you have a point here, but it&#x27;s still bad this feature exists in the first place.<p>&gt; This is a pretty common pattern for lots of popular software that has a desktop component<p>Because it&#x27;s used doesn&#x27;t mean it&#x27;s a bad idea.<p>&gt; There&#x27;s ongoing work to restrict this further<p>Huh that&#x27;s very nice. Indeed this would resolve my concerns:<p><pre><code>    In the future, whenever a public website is trying to fetch resources from a private or a local network, Chrome will send a preflight request before the actual request.\n</code></pre>\nPreflight requests are hardcoded and barely have any attacker controlled data (except for the ip address maybe, as 127.0.0.2 is as valid as 127.0.0.1).')