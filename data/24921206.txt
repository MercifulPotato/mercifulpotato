Item(by='gen220', descendants=None, kids=None, score=None, time=1603904516, title=None, item_type='comment', url=None, parent=24915497, text='Sometimes, the complexity of the world you&#x27;re modelling requires there to be many, many `build_url`s and `pluck_definition`s piping into and out of each other.<p>I&#x27;ve found these organizing principles to be quite useful.<p>1. identify the <i>key</i> that your application is processing (in this case, it&#x27;s `word`)<p>2. make it so that as many functions as possible take this &quot;key&quot; as their only argument.<p>3. whenever you are fetching data about a model, it is either directly or transitively in terms of this key.<p>4. push model-fetching (technically the I part of I&#x2F;O) as far to the <i>leaves</i> of your program-tree as possible, hiding them behind &quot;model client&quot; classes, that are passed in to your job at construction.<p>5. Perform all upserts idempotently, atomically, and in the bottom-right corner of the execution tree. This makes it easy to reason about mutations, and also easy to omit when you&#x27;re wanting to do &quot;dry runs&quot; or read-only local runs.<p>6. (4) means you will occasionally fetch the exact the same model more than once in the scope of one execution. This is OK. You can optimize this later with execution-tree-scoped caching.<p>With this approach, the user-directed I&#x2F;O (imperative shell) is at the root of your tree, and very narrowly-defined to be the key of computation. You can build a run-loop on top of this, or a CLI tool, or an rpc service. It&#x27;s narrowness is kind to all kinds of interfaces.<p>The functional core is everything that isn&#x27;t the leaves of the execution tree. These functions essentially compose model client calls, and only take the keys as inputs.<p>The leaves are a collection of reusable one-to-five-liner RPC requests &#x2F; data base queries. If you like, you can wrap these in a class that caches the queries, as described in (5).<p>The tests for leaves mock nothing if they target a DB. They mock the rpc service if they target an RPC service.<p>The tests for the functional core functions mock the model-clients (leave functions).<p>With this structure, as long as your tests are brittle enough to break when an RPC contract or data model changes, you do not need integration tests.<p>I do this in Python, but it would work just as well in any language with structs&#x2F;interfaces. I&#x27;ve observed the same benefits proclaimed in the article, although my approach is a bit different.<p>If people are interested, I could write more on this, with examples. Let me know!')