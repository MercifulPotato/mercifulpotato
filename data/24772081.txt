Item(by='thamer', descendants=None, kids=None, score=None, time=1602636935, title=None, item_type='comment', url=None, parent=24771883, text='It was a long regex, made of multiple parts with two OR&#x27;d together that looked very similar except for the last few characters. These two parts were trying to match a structured format, think of something like a domain name for example; it&#x27;s not just [a-z0-9.-]+ since you can&#x27;t have the - or . at the start or at the end, and maybe the end part has a limited length (say you want to match only short TLDs). I can&#x27;t really say what these strings were but they had these sorts of restrictions and a range that was a bit larger than what domains can use (like capital letters).<p>So they had something like this for this structured part:<p><pre><code>    [a-zA-Z]+[a-zA-Z0-9-.]*[a-zA-Z0-9]?(\\.[a-zA-Z]{2,3})?\n\n</code></pre>\nActually kind of like that, but with multiple ()? and (){N} wrapping the different layers.<p>Let&#x27;s call the regex above STRUCTURED. Now how do you match either one of these structured strings followed by either `.foo` or `.bar`? They had it as:<p><pre><code>    STRUCTURED\\.foo|STRUCTURED\\.bar\n</code></pre>\n(again, where STRUCTURED is replaced with the whole long regex from above).\nMeaning that the regex engine, as it consumes the first characters that potentially match the structured string, can&#x27;t tell whether it&#x27;s in the left or right branch of this OR until it reaches either the `.foo` or `.bar` suffix.<p>The change I made was simply to match it with:<p><pre><code>    STRUCTURED(\\.foo|\\.bar)\n</code></pre>\nIn this case the engine can consume each character of the input and make its way through STRUCTURED without having to maintain k branches per character (given as k=2 in the example above but it was much more than that).<p>I hope the general idea still comes through despite the simplification and required obfuscation.')