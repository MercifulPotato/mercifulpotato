Item(by='lmm', descendants=None, kids=[25516713, 25517616], score=None, time=1608720588, title=None, item_type='comment', url=None, parent=25516005, text='&gt; The issue is not one of memory holing: non-merge commit reverts work as people expect (and leave a historical record). I think the right way handle this in git, in most cases, is to just avoid merging altogether. Do work on feature branches and rebase those into master (possibly adding some meta-info like Feature: 123 to the individual commits as you do the rebase). Apart from not having to explain the semantics of merge reverts to everyone in your team this saves a lot of other conceptual overhead as well.<p>That&#x27;s a non-answer and sacrifices most of the benefits of using a DVCS at all; if you&#x27;re going to do that you might as well just use SVN. What are the semantics you would want&#x2F;expect reverting a merge to have? As far as I&#x27;m concerned, other than having to pointlessly pass &quot;-m 1&quot; every time, reverting a merge does exactly what I&#x27;d expect it to.<p>&gt; I disagree that git deals well with non linear history, everything about dealing with non-linear history in git is pretty painful, from bisecting to querying (compare to revsets in mercurial, for example) or logging.<p>Bisect works fine. Could you be more specific?<p>&gt; Unless your org is large enough to hit scalability problems monorepo seems the way to go with git -- it makes it easy for everyone to find stuff and use a consistent shared &quot;timeline&quot;.<p>IMO the repo is the unit of versioning; things that are released together should go in the same repo, while things with separate lifecycles should have their own repositories. That way your tags and history work the way you&#x27;d expect, but you avoid showing a misleading global timeline if that doesn&#x27;t actually exist (e.g. if a project depends on a previous release of an internal library, it&#x27;s misleading to have that internal library in the same repository as that project, because you&#x27;d see the &quot;current&quot; version rather than the code you were actually using).<p>&gt; However, other than submodules and co in git being a tire fire, I see no reason why the same purpose could not be served by subrepos in many cases; what makes you think they are inherently problematic?<p>I see them as inherently problematic because they hugely complicate the model. I don&#x27;t want to think about different parts of the checkout being on different revisions, branches, or tags.')