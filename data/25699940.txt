Item(by='danidiaz', descendants=None, kids=None, score=None, time=1610196512, title=None, item_type='comment', url=None, parent=25699574, text='I disagree with this:<p>&gt; One, types are a concretion. If you’re looking for higher level of abstractions to get flexible behaviour, you’re ultimately going to have a world of pain<p>I don&#x27;t see why types should be in the way of flexible behaviour. Frameworks like Spring in Java use types to direct dependency injection and it works well.<p>Also this:<p>&gt; Types wrap data and treat it like a black box whereas schema describes the shape and content of data.<p>Types can be made abstract and blackboxy, and sometimes that&#x27;s what you want. But doesn&#x27;t a record type give info about its fields? Doesn&#x27;t a sum type give info about possible alternatives in the values?<p>&gt; As such haskell ultimately suffers a lot when they have to interact with the real world. Suddenly they are left reeling as they find out that the real world is, in fact, dynamic.<p>The trick is to know what we are really modelling. If we are deserializing domain objects from JSON, it makes sense to have types for the domain objects. If we are writing a tool like, say, jq, perhaps we should merely have a datatype for the JSON tree itself: <a href="http:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;aeson-1.5.5.1&#x2F;docs&#x2F;Data-Aeson.html#t:Value" rel="nofollow">http:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;aeson-1.5.5.1&#x2F;docs&#x2F;Data-A...</a><p>&gt; Bottom up design is something we’ve learnt collectively as a good way to be much more flexible in responding to change.<p>Even if you want to design bottom-up, the moment you want to <i>add</i> anything to your program, you need a little top-down thinking, if only at the micro-level. You want to create something new that isn&#x27;t there, and then think how to accomplish that with the tools you have.')