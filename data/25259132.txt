Item(by='ithkuil', descendants=None, kids=[25259773, 25261520], score=None, time=1606771281, title=None, item_type='comment', url=None, parent=25256102, text='That is a perfectly reasonable approach to that answer indeed. Registers do hold state and saving restoring them is burden of program code (user, compiler, lib, os).<p>Contrast this with a hypothetical cpu that has only one register &quot;base&quot; and allows to address 32 words after the address at that base register. i.e. things like arithmetic instructions would have 5 bits to address operands which will be interpreters as base+8*n. To make things even more interesting this architecture&#x27;s instruction pointer lives at base+0.<p>Such an architecture would have one register under your metric (as only one register needs to be saved&#x2F;restored to context switch an entire &quot;register file&quot;).<p>However, implementations (microarchitecture) could actually shadow that memory range into hardware registers,  and page in&#x2F;out the whole register bank upon writes of the base register (effectively performing a hardware assisted context switch; hello TSS).<p>However, since each instruction in this hypothetical ISA must have enough space in the encoding to address these operands, for all intents and purposes this architecture would have 32 registers.<p>Deciding instructions, addressing operands, dealing with consequences of code density (icache misses), ... are all way more frequent events than context switches.<p>Hence I do agree with TFA that operand encoding should be the default metric to count registers. And this also includes sub&#x2F;overlapping registers, if they are independently addressed.')