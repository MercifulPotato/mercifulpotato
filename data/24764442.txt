Item(by='atq2119', descendants=None, kids=None, score=None, time=1602588345, title=None, item_type='comment', url=None, parent=24761332, text='&gt; individual maintainers squash the detail of the commits as it passes up through developer-&gt;Maintainer A-&gt;Uber Maintainer B-&gt;Super Uber Maintainer C-&gt;Linus<p>This is not how Linux kernel development works. Instead, once a series of patches has been reviewed and accepted by the first maintainer, there will be no more rebasing -- the commits will eventually flow into Linus&#x27; copy via pull requests that are reflected in the DAG as merge commit.<p>The point here is that the kernel actually does code review, and commits often go through several versions before being accepted. That&#x27;s where `git rebase` comes in, because as a developer, you need it during this revision process as you amend and fixup the individual commits of the patch series that you&#x27;re working on.<p>Of course, if you don&#x27;t do proper code reviews on your projects, and&#x2F;or you&#x27;re sloppy with how changes make it into the code base, then you may get away without using `git rebase`. That may be acceptable for smaller projects, or perhaps for larger projects that are easier to test; and larger commercial projects may be able to afford the cost of papering over the inefficiencies that come with a sloppy review and development process. But it&#x27;s just not feasible for something like the Linux kernel, and so `git rebase` really <i>is</i> essential.')