Item(by='lmm', descendants=None, kids=[24763702], score=None, time=1602574226, title=None, item_type='comment', url=None, parent=24762987, text='You can implement monads yourself if you have higher-kinded types, but Rust doesn&#x27;t. Without them you can&#x27;t implement any of the standard helper functions that you need generically (e.g. monadic versions of control flow functions like ifM, whileM), you&#x27;d have to implement them by hand for each different monadic type instead. Thus the control flow problems in the #[dehandle]-based code.<p>And if you look at what #[dehandle] is doing, it&#x27;s blatantly an ad-hoc implementation of do notation for these handle types. It&#x27;s doing the same thing as async&#x2F;await, or try!, but in (present-day) Rust everyone implementing a new &quot;context-like&quot; type has to write their own &quot;very complicated procedural macro&quot; to implement a specific variant for that context-like type.<p>(I don&#x27;t think you necessarily need do notation to write maintainable monadic code - I&#x27;m a big fan of railway-oriented programming style i.e. (Kleisli) arrow composition. But of course you can&#x27;t do that in Rust either, except by writing ad-hoc implementations of all the operators and helper functions for every different type you want to work with).')