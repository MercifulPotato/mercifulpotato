Item(by='jleahy', descendants=None, kids=[25558707, 25555147, 25557877, 25557653, 25555858, 25555274, 25556240], score=None, time=1609108515, title=None, item_type='comment', url=None, parent=25554413, text='Macro-op fusion is something that is really quite painful to implement in the front-end. Essentially once you have both macro-op fusion and potentially multiple micro-ops for a single instruction you have fully variable length instructions. Potentially it becomes worse than x86, where macro-op fusion has no need to be pervasive, you just have to cover very few simple cases (eg. cmp+jmp). For RISC-V even trivial things like &#x27;load a 32 bit constant&#x27; need macro-op fusion to be competitive with x86.<p>An 8 wide front-end for ARM64 needs to run a decoder every 4 bytes (so 8 in total), then combine the results. It&#x27;s an entirely trivial affair.<p>For RISC-V, without any macro-op fusion, you first need a unit every 2-bytes that determines the instruction length using the first 2 bits (16 of these), then you need a very wide mux to expand out any compressed instructions (the last one can come from 7 or 8 different offsets) so you have 8x 32b instructions, then you need your 8 decoders. It&#x27;s looking much more unpleasant because of that very wide muxing (8x 8:1 32-bit muxes is not a pleasant sight). Alternatively you could do it the brute force way and have 16 decoders followed by a 16-&gt;8 reduction layer (ignoring the decode results that were at bad offsets). The designer is going to have a hard time choosing between those two bad options (personally I would go with the latter I think).<p>Now let&#x27;s throw in macro-op fusion, suddenly rather than have two possible lengths (16b or 32b) you can have 16b+16b, 32b+32b, 16b+32b, 32b+16b. Complexity just explodes. If anybody really tried to implement a 8 wide RISC-V front-end with pervasive macro-op fusion then it would be a truly nasty thing.')