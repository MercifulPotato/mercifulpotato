Item(by='teraflop', descendants=None, kids=None, score=None, time=1604683123, title=None, item_type='comment', url=None, parent=25008884, text='&gt; To be truly Turing complete requires infinite memory. That clearly doesn&#x27;t hold for any current programming language.<p>&gt; Indeed I have a simple algorithm (although relatively inefficient) to solve the halting problem where memory size is fixed and finite: enumerate every state until either a state is repeated or the program halts. This completes in O(2^N) time where N is the size of the memory.<p>&quot;Relatively inefficient&quot; is a colossal understatement. Anything that we would nowadays categorize as a &quot;computer&quot; has a state space so huge that, while technically finite, it is effectively infinite for all practical purposes.<p>For example: the ATmega328 microcontroller in an Arduino has 2KB of RAM (assuming we ignore registers and the possibility of storing data in Flash). That&#x27;s a total of 2^16384 possible states. If every cubic Planck length of the observable universe was capable of checking one of these states per Planck time, and did so from the Big Bang until the heat death of the universe (let&#x27;s say 10^100 years in the future), they would still have enumerated only a googol&#x27;th of a googol&#x27;th of a googol&#x27;th of a googol&#x27;th [... repeat about 10 more times...] of the state space.<p>We could of course imagine trying to find a better algorithm, but since this problem is easily shown to be NP-hard, it is very unlikely that we will find something that guarantees good enough performance to make this kind of analysis possible.<p>We haven&#x27;t &quot;given up&quot; on automated program analysis. It&#x27;s just that the fully general case is intractable, and it takes a lot of hard work and ingenuity to find strategies that can separate the tractable problems we care about from the intractable ones.')