Item(by='marcan_42', descendants=None, kids=[25265798], score=None, time=1606832883, title=None, item_type='comment', url=None, parent=25262186, text='This reminds me of some lock-free code I fixed recently (by introducing a very peculiar kind of lock):<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Ardour&#x2F;ardour&#x2F;blob&#x2F;master&#x2F;libs&#x2F;pbd&#x2F;pbd&#x2F;rcu.h" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;Ardour&#x2F;ardour&#x2F;blob&#x2F;master&#x2F;libs&#x2F;pbd&#x2F;pbd&#x2F;rc...</a><p>The goal of the code is to allow a producer thread to update a pointer to an object in memory, which may be used lazily by consumer threads. Consumers are allowed to use stale versions of the object, but must not see inconsistent state. Obsolete objects must eventually be freed, but only after all consumers are done using them. And here&#x27;s the catch: consumers are real-time code, so they must never block on a lock, nor are they allowed to free nor allocate memory on their own.<p>The design is based around Boost&#x27;s shared_ptr, so that had to stay. But the original code was subtly broken: the object is passed around by passing a pointer to a shared_ptr (so double indirection there) which gets cloned, but there was a race condition where the original shared_ptr might be freed by the producer while the consumer is in the process of cloning it.<p>My solution ended up being to introduce a &quot;lopsided spinlock&quot;. Consumers aren&#x27;t allowed to block, but producers are. So consumers can locklessly signal, via an atomic variable, that they are currently inside their critical section. Then the producer can atomically (locklessly) swap the pointer at any time, but <i>must</i> spin (is this a half-lock?) until no consumers are in the critical section before freeing the old object. This ensures that any users of the old pointer have completed their clone of the shared_ptr, and therefore freeing the old one will no longer cause a use-after-free. Finally, the producer holds on to a reference to the object until it can prove that no consumers remain, to guarantee that the memory deallocation always happens in producer context. shared_ptr then ensures that the underlying object lives on until it is no longer needed.<p>It&#x27;s kind of weird to see a half-spinlock like this, where one side has a &quot;critical section&quot; with no actual locking, and the other side waits for a &quot;lock&quot; to be released but then doesn&#x27;t actually lock anything itself. But if you follow the sequence of operations, it all works out and is correct (as far as I can tell).<p>For various reasons this code has to build with older compilers, hence can&#x27;t use C++ atomics. That&#x27;s why it&#x27;s using glib ones.<p>(Note: I&#x27;m not 100% sure there are no hidden allocations breaking the realtime requirement on the reader side; I went into this codebase to fix the race condition, but I haven&#x27;t attempted to prove that the realtime requirement was properly respected in the original code; you&#x27;d have to carefully look at what shared_ptr does behind the scenes)')