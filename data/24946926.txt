Item(by='jrockway', descendants=None, kids=None, score=None, time=1604092232, title=None, item_type='comment', url=None, parent=24945892, text='I wrote this authorization code last night: <a href="https:&#x2F;&#x2F;github.com&#x2F;jrockway&#x2F;jsso2&#x2F;blob&#x2F;master&#x2F;pkg&#x2F;internalauth&#x2F;internalauth.go#L128" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;jrockway&#x2F;jsso2&#x2F;blob&#x2F;master&#x2F;pkg&#x2F;internalau...</a><p>Obviously it&#x27;s quite natural to just add interceptors as you need them and no doubt there are hundreds of things like this across the Internet.<p>To some extent, I can&#x27;t get over how much of a mess you can make by doing things like this.  Because generated service definitions have a fixed schema (func (s <i>Service) Method(context.Context, Request) (Reply, error)), you have to resort to hacks like propagating the current user through the context, instead of the easy-to-read and easy-to-test alternative of just passing in the parameters explicitly, as in func (s </i>Service) Method(context.Context, types.Session, Request) (Reply, error).  If I was going to spend time on infrastructure, that&#x27;s the thing I&#x27;d fix first.<p>Some other frameworks do a little better here.  We use GraphQL at work, and the methods are typically of the pattern:<p><pre><code>    func AutogeneratedMethod(context.Context, ...) {\n       foo := MustGetFoo(ctx)\n       bar := MustGetBar(ctx)\n       return ActualThingThatDoesTheWork(ctx, foo, bar, ...)\n    }\n</code></pre>\nThis makes testing the Actual Thing That Does The Work easier, and the reader of that method knows exactly what sort of state the result depends on (the most important goal in my opinion).')