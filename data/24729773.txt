Item(by='ddragon', descendants=None, kids=None, score=None, time=1602250626, title=None, item_type='comment', url=None, parent=24729375, text='Python is a high bar to beat though, since no one understands beating Python as beating some hypothetical Python-only numerical library, it&#x27;s beating mature precompiled C&#x2F;C++&#x2F;Fortran libraries with a small overhead in Python. And there are very few dynamic languages that can even compete on this level (without needing the FFI), and even static languages will have trouble dealing with the level of optimization that went on those libraries.<p>But everything has compromises, and in Julia case is the JIT lag from aggressively optimizing compilation, making it a slow language for simple do once tasks (which is the part that is usually written in Python) and a fast language for when runtime performance is the most important (which is the part done by the libraries in C&#x2F;C++&#x2F;Fortran), making it slower in some situations. Though new releases are attacking this issue, including the ability to not optimize this do once tasks (like plotting) and improving pre-compiling.<p>But as for now, the ability to not have black boxes and not being required to twist my code to a particular style in order to not be prohibitive slow makes up for the slow startup (plus using Revise.jl to automatically compile code in a REPL, and keep the session alive for all my programming routine makes it not that much of a deal during development).')