Item(by='TeMPOraL', descendants=None, kids=[25227805], score=None, time=1606476350, title=None, item_type='comment', url=None, parent=25227583, text='Yes, you can. A good way to think about it is that a floating point number has a fixed amount of significant digits. A 32-bit float has between 6 to 9 significant digits[0]; a 64-bit float (&quot;a double&quot;) can represent just double that - i.e. ~16 significant figures.<p>This means you can represent 12345678 and 0.12345678 as 32-bit floats just fine, but if you try to add the two, you&#x27;ll just get 12345678. But there&#x27;s also a more subtle case, in which you try to add 1234.5678 to 0.12345678, and lose half of the significant digits from the smaller number.<p>These types of errors are common in calculations dealing with large differences in orders of magnitude, and a part of the common wisdom to not use floats for anything involving money.<p>Another common occurrence of precision errors happens when modelling large 2D or 3D environments in video games. The simplest approach starts with a global coordinate system, in which calculations take place. Since the number of significant digits remains fixed, the further you are from origin, the less precision you have available for your unit of measure of position - meaning the same calculations happening far away from (0, 0, 0) will have more errors than those happening close.<p>A somewhat well-known example of that was[1] Kerbal Space Program - a game that models realistic spaceflight within a fictional solar system. As you ventured further out and visited the most distant celestial bodies, you&#x27;d notice your ships would spontaneously shake apart and&#x2F;or explode, as if physics stopped working. Affectionately called a &quot;Kraken attack&quot;, it was due to floating point precision errors - that far out, in the global coordinate system, the difference between two closest representable positions became comparable with the size of parts from which the ships were built. With that big of a delta, physical calculations would round some forces down to zero, and massively magnify others, as simulated objects could suddenly only move in increments comparable with their own size.<p>--<p>[0] - The limitation is in binary, which doesn&#x27;t map cleanly to base 10.<p>[1] - I think they got around to mitigating this eventually. One way you can approach such mitigation is by dividing your space into cells (and possibly subcells), each with its own coordinate system, and do as many calculations as you can within these cells, so that everything is close to the origin of their local coordinate system. Then, for (hopefully few) remaining calculations that involve multiple distant cells, you can use larger-precision representations, which are much more computationally expensive.')