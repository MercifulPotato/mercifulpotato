Item(by='edflsafoiewq', descendants=None, kids=[25974568], score=None, time=1612053437, title=None, item_type='comment', url=None, parent=25969976, text='The simplest case where I&#x27;d want a circular dependencies is I have a module that defines some data types and functions on those types<p><pre><code>  mod widget\n\n  struct Widget\n\n  fn show(Widget) { ... }\n  fn join(Widget) { ... }\n  fn calc_box(Widget) { ... }\n</code></pre>\nand one function is getting very long and complicated so I want to spin it out into its own module<p><pre><code>  mod widget                   mod calc_box\n  import calc_box              from widget import Widget\n\n  struct Widget                fn calc_box(Widget) { ... }\n\n  fn show(Widget) { ... }\n  fn join(Widget) { ... }\n</code></pre>\nThe reason the article gives that this is &quot;evil&quot; is that there is no hierarchy between the modules; the cycle is <i>really</i> just one big supermodule. That&#x27;s true... but that was basically the point. Where is the &quot;evil&quot; here?')