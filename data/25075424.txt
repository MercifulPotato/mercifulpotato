Item(by='HereBeBeasties', descendants=None, kids=None, score=None, time=1605217017, title=None, item_type='comment', url=None, parent=25073874, text='I also write both Go code and C#, amongst other things. I find your assertion that C# has lots of ceremony and ends up with more code than Go frankly pretty strange.<p>Go is well known for having laborious error handling (prompted by a lack of exceptions) and masses of boilerplate and verbosity precipitated by the lack of various other features, the most glaring of which is an absence of generics. This means implementing custom data structures is generally an exercise in copy paste, or ignoring type safety.<p>Things like the lack of extension methods, JSON and YAML serialisers that require explicit annotations everywhere instead of conventions, the lack of OO&#x2F;polymorphism, no ternary operators, null chaining operators, etc. etc. also contribute to the verbosity.<p>Simplicity is good, but the lack of expressivity and the need for such boilerplate is bad. A pretty poor type system makes it worse. Go has many strengths, but I massively prefer C# for the majority of non-trivial situations.<p>Regarding performance, it depends heavily on what you&#x27;re doing. For example, Go&#x27;s allocator and GC is designed to optimise for low pause latency, whereas dotnet is optimised more for high throughput and good cache coherency. Given the extent to which most apps are stalled waiting for memory, the lack of good cache coherence in Go allocations, and the lack of a generational GC can absolutely decimate performance. DotNet is capable of allocating at 25x the speed of Go, for example.<p>Go read <a href="https:&#x2F;&#x2F;medium.com&#x2F;servicetitan-engineering&#x2F;go-vs-c-part-3-compiler-runtime-type-system-modules-and-everything-else-faa423dddb34" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;servicetitan-engineering&#x2F;go-vs-c-part-3-c...</a>')