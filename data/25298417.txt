Item(by='throwaway346346', descendants=None, kids=None, score=None, time=1607050857, title=None, item_type='comment', url=None, parent=25290339, text='Using a throwaway because I don&#x27;t want anyone to guess the product&#x2F;company.<p>I&#x27;m CTO at a company who&#x27;s product makes heavy use of stored procedures for business logic. It&#x27;s constantly the cause of all the biggest headaches. I inherited this architecture, I didn&#x27;t design it myself. I believe the original rationale behind the design boils down to &#x27;SQL is better at the type of set based operations this product does a lot&#x27;. i.e. If you&#x27;ve got an array of 100k values, and you want to perform an operation against a second array of 100k operands, you can do that much faster in SQL with a join than you can by loading them all into memory&#x2F;code, looping over to do the operations, and saving them again. This is kind of true in the simple cases, but once it grows to require lots of logic and conditionals in those operations, and then chained operations you start to lose the benefit.<p>Upgrades and versioning are generally a bit awkward, we&#x27;ve got it fairly smooth now, but it still causes pain reasonably frequently when something in the upgrade process breaks. It was worse when I started as many upgrades were a bodged together folder of scripts with lots of &#x27;if exists&#x27; type checks in them. Now at least we use a mostly automated diff based upgrade process for the database. Some types of changes still require manual upgrade scripts though. The articles solution of a folders of numbered scripts doesn&#x27;t really look viable if you need to manage upgrades from different versions to the current latest version. Re-creating customer databases doesn&#x27;t really go down well when they tend to like to keep their data.<p>Debugging is awkward. There are tools, but none of them compare to code debuggers.<p>SQL isn&#x27;t easily composable, we have repeated SQL all over the place (or nearly repeated with small changes which is kind of worse because you don&#x27;t spot the differences). Finding a bug in one of these repeated blocks means spending the next few hours hunting down any similar SQL to check over the the same bug.<p>Performance is unpredictable and all over the place. Stored procs that run fine one release will suddenly start performing like a dog the next release. We often never discover the actual &#x27;cause&#x27;, the thing that changed that made it slow down. We just end up finding a way to make it fast again by adding a new index, or changing the way a join is composed, or splitting something up. I&#x27;ve not yet got evidence, but I&#x27;m convinced that we&#x27;ve made performance improvements in one release only to reverse the exact changes several releases later also as a &#x27;performance improvement&#x27;. It feels like playing wack-a-mole. Because of query plan caching, parameter sniffing and other optimizations the DB we have had scenarios where the performance of feature x, depends on if you used feature y before hand in the same session or not. We have some exact duplicates of stored procedures that are only there to ensure that two different code paths that use them don&#x27;t share the same plan cache because when they do we get problems. Performance characteristics are often very different between dev setup and customer setup. Performance characteristics are different for customers that choose to host on cloud servers compared to customers that host on physical hardware. I don&#x27;t just mean cloud is slower, I mean it&#x27;s different. Some things are faster on cloud servers, but it&#x27;s never predictable what will be what. It makes testing for performance very hard.<p>The articles statement about &#x27;a database spends 96% of it&#x27;s time logging and locking&#x27; is totally irrelevant. So what if that&#x27;s what it spends 96% of it&#x27;s time on. It&#x27;s still spending that time. And as soon as your database has multiple users all those locks are going to start getting in the way of each other and causing delays or deadlocks.<p>It doesn&#x27;t scale at all. Our DB severs are <i>powerful</i> and we can&#x27;t realistically go much bigger (CPU &amp; RAM wise), yet better performance is probably one of our customers biggest requests.<p>Deadlocks are not uncommon, hard to defend against, hard to fix, and half the time introduce other deadlocks in other places.<p>Maybe it&#x27;s good in some scenarios, but once you have a growing evolving product being built by a team, it&#x27;s far far harder to manage if a large chunk of the logic is in SQL.')