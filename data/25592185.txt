Item(by='didibus', descendants=None, kids=[25608743, 25593319], score=None, time=1609419146, title=None, item_type='comment', url=None, parent=25586523, text='It&#x27;s not as complicated as the lingo. A type is just metadata about variables and values tracked by the compiler on the static code, as it compiles it.<p>Normally types are used to indicate the set of values a variable is allowed to contain or not. And that info can be used by the compiler to detect mismatch in the code, like if a value is being assigned to a variable that doesn&#x27;t match its type.<p>But like I said, this is all just metadata about variables and values. So what else could you track and enforce? Well you could also track that some values are never assigned to more than one variable. That would be Uniqueness types. A value of such type is supposed to always have a unique variable pointing to it. So you can&#x27;t have two variables pointing to it, if you did, the compiler would throw an error.<p>Linear types are similar, with some small differences in the edge case. Specifically, you can cast a value that is non linear to be linear. In effect it means a value that is made linear can not have more references to it after it has been made linear, but it could have many references pointing to it from before it was made linear. Where as a value of a unique type would not allow that.<p>To recap, Uniqueness guarantees that a value has no other references to it, while linearity guarantees that no more references can be made to a value.<p>Finally you have Affine types, which are also just a small difference to the above two. One detail I ommited is Linear and Unique types will also fail if the value is never assigned to any variable. They basically enforce that a value having a linear or unique type must be used at least once. An Affine type is like a linear type that doesn&#x27;t have to be used at all, thus they say it needs to be used at most once.<p>I&#x27;ll add one more, Ownership types, like in Rust. Those are like a mix of unique and affine. In that a value with an ownership type can only be refered to by its current owner, but doesn&#x27;t have to be. It&#x27;s different to unique types in that the owner is free to refer to it many times, but no other owners can refer to it at the same time.<p>So you see, all of this is just lingo to say, could we come up with some constraints around how many references to the same values we&#x27;re allowed to have. Then create a type for them so we can tell the compiler to enforce those constraints on values of that type.<p>Now it gets complicated to actually find a way to implement a compiler to track these types and enforce their constraints. That&#x27;s where the research and challenge is. And it&#x27;s also tricky to figure out how the programming language can use these and how to make them pleasant to use and not feel like annoying constraint that prevent you from doing things easily.')