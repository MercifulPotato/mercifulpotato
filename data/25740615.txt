Item(by='dan-robertson', descendants=None, kids=[25740644], score=None, time=1610411952, title=None, item_type='comment', url=None, parent=25739635, text='So the first issue I have with the paper is that I am not convinced that the results should be relevant to the programming languages I work with. It is a survey of the behaviour of people who aren’t particularly expert programmers, who don’t know the language, and who are trying to do things very quickly rather than thoroughly. That sounds like the opposite of the kind of person I would want my work optimised for. But maybe optimising for these people makes things easier for expert users too. It’s true in other parts of life that eg writing websites for people with poor literacy makes them faster for people with good literacy.<p>————————<p>I find the dynamic scoping[1] experiment pretty unconvincing. The other way to get their “believes dynamic scoping” result is to assume that their language has JavaScript-like semantics and the variables are global. I think an example program to test this might be:<p><pre><code>  func f(x):\n    return g()\n  \n  func g():\n    return x + 2\n  \n  print(f(3))\n</code></pre>\nBut I realise that is then not independent from some of the other tests.<p>I think a separate problem is that usually when I read code, I’m not thinking “well this code might just not work at all” because 1. It’s just not my prior, and 2. It seems a bit rude to start from such an oppositional position to someone else’s code. Instead I’ll try to assume that it works and work out why it works. This is especially true for code written in languages I’m unfamiliar with. I remember enjoying this especially before I learned any haskell when the haskell blogposts were frequent on HN. But this position puts me at odds with the study where for many examples you are supposed to guess Error whereas I want to figure out what assumptions make it not an error, then which is most reasonable, then what results those assumptions would imply. But maybe my expectations of how a programming language behaves wouldn’t be so useful for designing languages as I already have pretty strong expectations for this.<p>[1] perhaps I just disagree about the definition of dynamic scoping here.')