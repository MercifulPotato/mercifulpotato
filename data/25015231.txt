Item(by='dmitriid', descendants=None, kids=[25015423], score=None, time=1604759219, title=None, item_type='comment', url=None, parent=25014078, text='&gt;  You can use GET requests and GET requests are cacheable.<p>GET requests are a crutch added to GraphQL precisely because of limitation of POST requests.<p>And the backend still has to normalise the GET request, and possibly peek inside it to make sure that it is the same as some previous request.<p>&gt; how to auth data (anyone has access to everything) -&gt; Authentication or authorization? What do you mean with anyone has access to everything?<p>Your schema is a single endpoint with all the fields you need exposed. Oh, but a person X with access Y might not have access to fields A, B, C, and D.<p>Too bad, these fields can appear at any level of the hierarchy in the request, deal with it.<p>&gt; how to... -&gt; yes?<p>A GraphQL query is ad-hoc. It can have unbounded complexity and unbounded recursion. Ooops, now you have to build complexity analysers and things to figure out recursion levels.<p>A GraphQL service usually collects data from several external services and&#x2F;or a database (or even several databases). But remember, a GraphQL query is both ad-hoc <i>and</i> with potential unbounded complexity. Oh, suddenly we have to think how much data and at what time to we retrieve, how do we get the data without retrieving too much, and without hammering the external services and the database with thousands of extra requests.<p>That&#x27;s just from the top of my head.<p>Ans so you end up with piles of additional solutions of various quality and availability on top of GraphQL servers and clients: caching, persisted queries etc. etc.')