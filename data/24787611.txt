Item(by='Multicomp', descendants=None, kids=[24787981], score=None, time=1602762938, title=None, item_type='comment', url=None, parent=24782047, text='TLDR: I say several blunt opinions in hopes that it will spark discussion since I want to hear what people think of this article.<p>I was hoping this would be cyclone the programming language.<p>Just summarize the article, this goes through a brief history of programming languages that focus on memory safety, including cyclone, early c++  raii features, rust, Midori &#x2F; M#, pony, checked C, and finally, cone programming languages.<p>I am curious what the tipping point will be for c and c++, the fact of the matter is that they seem to have such a grip on the embedded and large open source projects like the Linux kernel, that newer languages such as any of the above that improve memory safety seem to be slow getting started, at least in terms of people using one of the above languages in their day jobs...maybe rust is in the same ballpark as mainstream proglangs? But the rest are definitely in the frontier camp trailhead, or even hidden out in some forest temple only the most  intrepid proglang explorers manage to discover. I&#x27;m currently on the hunt for gleam.<p>I have no experience with c or c++, with the exception of reading the first half of the k &amp; r book. These programming languages power Windows, Linux kernel, embedded thingies, probably some military infrastructure too, and seem to be the first thing ported to a new processor architecture.<p>But like Star Treks 22nd century, where the romulans were able to hack earth&#x27;s forces left right n center during the first romulan war until they moved to more manually verified duotronic systems (maybe their electronics were still using C?), I&#x27;m not certain that C or C++ will retire and compare notes with BCPL and C with classes anytime soon, which means there will not be a rising tide of memory safety anytime soon.<p>Do I think we should rewrite everything in x? Impossible. Not the goal.<p>Do I think that the cost benefit analysis of memory safety versus performance and changing conventions and syntax that people have been using for decades is now worth it? Yes.<p>Fortran, Cobol, BCPL, C with classes were all shelved when better more capable languages appeared. Not immediately, and they are still around to support their legacy installation bases, but most new stuff is not written with them nowadays, it&#x27;s in C or C++. Time for someone else to take up the mantle.<p>C and c++ have a massive installation base, and the computer industry as a whole risks being captured in the orbit of those programming languages, tooling and paradigm,  unable to break out.<p>I don&#x27;t make that statement flippantly, especially considering how. many. things. are. written in those languages.<p>But once one of the programming languages has enough critical mass and developer experience tooling, I do hope that mindshare begins to include that language in the fields of systems programming and embedded programming and high performance programming and wherever else C reigns supreme.<p>The security implications of not moving forward, let alone continuing to ossify the field with a 1970s era toolset (yes it&#x27;s been tweaked over time, caveats abound, but the value prop is still manually managed unsafe memory unless you do superhuman conventions...the hacking and vulns of the past decades proves this to be impossible) are such a huge cost to pay.')