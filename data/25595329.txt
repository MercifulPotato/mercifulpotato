Item(by='jakevoytko', descendants=None, kids=[25599366, 25598002], score=None, time=1609438617, title=None, item_type='comment', url=None, parent=25594898, text='&gt; Developers don&#x27;t like having to have their work parceled out so specifically. But it&#x27;s not for them. It&#x27;s for managers and stakeholders who have to report progress and who are responsible for budgets.<p>As someone who dislikes JIRA but likes process, I agree with this. The way that JIRA structures projects has specific tradeoffs that disadvantage developers and advantage middle managers because it&#x27;s entirely based around short-term thinking.<p>First, it provides multiple negotiations for every work stream: &quot;What tickets are part of this project?&quot; and inevitably &quot;what tickets do we need to cut to get this project out the door faster?&quot; The developer quality of life tickets are the easiest for non-engineers to jettison. What&#x27;s worse, sometimes they&#x27;re right to want to get rid of those tickets. Quite honestly, developers often don&#x27;t do the math on &quot;Will we ever get the time back we spend fixing this?&quot;<p>Second, JIRA-based systems are designed to try to make everything take the minimum possible time. This is a good thing, but developers can bear the burden of it. Quick iteration is good, but it turns into a situation where the most you can undershoot a task is by hours or a few days, but if something is much harder than you expect, it could overrun by weeks. I think this is a necessarily reality of business, and that &quot;evidence-based scheduling&quot; a-la Joel Spolsky is an innovation that could have eased this pain by introducing &quot;how bad are long-tail effects?&quot; into project planning. But as-is, you&#x27;re in a situation where you&#x27;re either meeting expectations (since the ticket took more-or-less what people thought), or you&#x27;re visibly holding a project back (because it was tightly scheduled to within an inch of its life). So the development experience becomes this weird commodity that sometimes has really visible failure modes.<p>And finally, since JIRA projects&#x2F;epics&#x2F;whatever are often prioritized by expected value, it&#x27;s difficult to raise large engineering concerns. Again, this is a good thing, because time spent engineering is time not spent helping the customer. But because the focus of JIRA is so granular, it&#x27;s difficult to break out of that. Imagine a company in the 80s that wrote desktop software in assembly, and some engineer is like, &quot;This is crazy, we should invest the time to write modules in C&quot;. How do you climb out of that? In the language of agile development, you actually need a lot of foresight to break out of this local maxima, because your prototype will be demonstrably worse - &quot;so we need to set up this compiler toolchain everywhere, and interface with our existing assembly code, which the compiler toolchain doesn&#x27;t make easy, and it introduces ABI concerns, and your prototype looks worse than just going with this. I think we can safely call this a failed experiment.&quot; When the only project language you have is trees, it&#x27;s difficult to talk about forest. I think this is why healthy engineering organizations that I&#x27;ve worked for tend to spend about 30% of their time working on more ambitious stuff. But it&#x27;s something that needs to come from the top-down, because the tools won&#x27;t provide it.<p>So to developers, the structure imposes a system where successes are minor, failures are visible, it&#x27;s hard to get negotiation leverage, you lose the forest for the trees, and they need to fight tooth-and-nail for quality of life improvements (or they get a week thrown down from above, as a treat, to address any technical debt).')