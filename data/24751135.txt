Item(by='jlokier', descendants=None, kids=[24752036], score=None, time=1602473218, title=None, item_type='comment', url=None, parent=24749419, text='The arithmetic should either work, or be type checked.<p>Multiplying a Q8.24 with another Q8.24 makes a Q16.48.<p>In C that&#x27;s not the same as the &#x27;âˆ—&#x27; operator; you&#x27;d generally cast both arguments to 64-bit first, and rely on the compiler being smart enough to use a 32x32-&gt;64 instruction if available instead of 64x64-&gt;64.  But even that&#x27;s ambiguous - is it signed or unsigned widening multiplication?<p>Adding a Q8.8 to a Q4.12 needs a 4-bit shift before the addition.  So does adding a Q5.27 to Q1.31.<p>The right thing to do is, unfortunately, ambiguous.<p>E.g. when adding Q5.27 to Q1.31, do you need to keep the full range and precision and end up with Q6.31?  Or do you right shift the second argument, ignore overflow, and call it a day with a Q5.27 result that is implemented in C as (uint32_t)(a + (b &gt;&gt; 4)?  (Though if it&#x27;s signed, which it usually is, (b &gt;&gt; 4) is dodgy in C anyway as it&#x27;s implementation-defined.)  If you do ignore overflow, is that a saturating addition (like used for audio&#x2F;graphics) or wraparound (like in C)?<p>Really, those decisions depend on what the numbers <i>mean</i>, as well as range and precision assumptions the author may already know are valid for numerical reasons.  So maybe there&#x27;s a case for traits on number types which specify whether they are default-saturating, default-precision-maintaining, default-range-maintaining.<p>Another operation is to change the representation, either to truncate&#x2F;round some precision bits, reduce range bits (saturating or assuming), or expand range bits prior to doing some sums (because addition doesn&#x27;t expand the range bits in real implementations, you have to explicitly do that yourself in advance of adding).<p>The way I see this done in <i>careful</i> DSP in C or C-like languages is as a series of function or macro calls that specify input and output formats, avoiding operators and the ambiguity they imply.')