Item(by='jasode', descendants=None, kids=[25571298], score=None, time=1609256914, title=None, item_type='comment', url=None, parent=25570340, text='<i>&gt;, Visual Basic and Access. Excel was released in 1987, and we had spreadsheets in the early &#x27;80s, too. When generalised, Brooks&#x27;s prediction amounts to diminishing returns due to reduction of accidental complexity, and we&#x27;re seeing exactly that.</i><p>The &quot;diminishing returns&quot; of _what_ exactly?<p>That&#x27;s what I&#x27;m trying to make clear.  Let me try and restate another way:<p>(1) 10x improvement in programming tasks<p>vs<p>(2) 10x improvement in completing business projects<p>I&#x27;m emphasizing that (1) has been achieved many times in multiple areas but it&#x27;s overshadowed by <i>not seeing</i> (2) happen.<p>I previously mentioned some things that I&#x27;m more than 10x faster on now:  <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23758199" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23758199</a><p>Visual Basic is another good example.  When I first used VB Winforms in 1990s, it was <i>more than 10x faster</i> than hand-coding the raw C &quot;Wndproc()&quot; message loop.  But that legitimate productivity gain is dwarfed by the <i>business wanting new complexity</i> (the app needs to connect to the internet, it needs to be new-fangled web app for browsers instead of a desktop exe, it needs to work on mobile phones, etc, etc).  Our new desires for new business functionality multiply faster than the time-savings progress in tools.<p>And <i>&quot;accidental complexity&quot;</i> isn&#x27;t fixed either.  And new deployment environments, new features <i>also add a new set of accidental complexity</i>.  E.g. if next generation of apps need to interface to virtual reality (headsets, etc), the programming code will have logic that doesn&#x27;t have direct business value.  So we&#x27;ll then get new 10x programming tool&#x2F;library to <i>manage that accidental complexity in the VR environment</i> but then.... we&#x27;re on to the neural implants SDK and we have no silver bullets for <i>that new thing</i> which means we revisit this topic again.<p><i>&gt;while we may see a 10x reduction for specific simple task, we won&#x27;t see it for large, complex software, which is where most of the effort in software is invested.</i><p>I agree.  But again to be clear, today&#x27;s expectation of <i>&quot;large, complex software&quot;</i> -- has also changed.<p>EDIT reply to:  <i>&quot;I&#x27;m saying that (1) has not been achieved even within a period of time that&#x27;s 3x Brooks&#x27;s prediction, &quot;</i><p>Raw Windows SDK C language WndProc() was late 1980s and by 1993, I was using Visual Basic 3 drag &amp; drop buttons on to Winforms.  Just that one example was 10x improvement within a decade.  For line-of-business apps, VB was 10x+ more productive because of the paradigm shift (in addition to things like not worrying about mental bookkeeping of malloc()&#x2F;free() etc.)<p><i>&gt;But most tasks cannot be achieved today 10x faster than in 1986</i><p>For discussion purposes, I don&#x27;t know why we have to constantly refer to 1986 even though the paper has that date.  It&#x27;s repeated submission for discussion makes it seem like people consider it an <i>evergreen topic</i> that transcends Brook&#x27;s days of the IBM 360 mainframe.<p>As another example, the productivity improvement is the writing and deploying complex apps using Ruby on Rails or Javascript frameworks and deployed on AWS.  That&#x27;s more than is more 10x faster than the 1990s CGI days of having C Language code writing to stdout to output HTML.  Those early web apps were <i>simpler</i> and yet they were so utterly tedious and slow to code.')