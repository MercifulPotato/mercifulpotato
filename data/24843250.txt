Item(by='a1369209993', descendants=None, kids=[24846397], score=None, time=1603235564, title=None, item_type='comment', url=None, parent=24836461, text='&gt; &gt; compile-time execution of regular zig code<p>The problem with this is that it&#x27;s incompatible with a well-designed compiled[0] programming language; a cross compiler can&#x27;t replicate the architecture-specific behaviour of the compiled code because the target architecture is unavailable or possibly even nonexistent at the place and time the compiler runs.<p>Consider, eg, a compiler on ARM targeting x86, when the code uses x86-specific assembly or intrinsics, or more subtly depends on x86-specific handling of things like pointers or integer overflow. If you instead compile the compile-time code for ARM, you a: need two different codegens (soon to become three when you compile the compiler to run on RISC-V), and b: now the compile-time code is depending on ARM-specific semantics, which is even worse.<p>Giving up on cross compilers means your language isn&#x27;t well-designed. Giving up on architecture-specific behaviour means your language isn&#x27;t designed for (direct[0]) compilation. (The latter is a legitimate choice, of course, but its negation is also a legitimate choice, and thus a legitimate reason not to support same-language metaprogramming.)<p>0: in the sense of C-like compiling directly to equivalent machine code; obviously any language <i>can</i> be compiled in the more general sense of producing a working executable')