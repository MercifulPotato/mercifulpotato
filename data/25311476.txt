Item(by='catwind7', descendants=None, kids=[25312934, 25312760, 25312568], score=None, time=1607139288, title=None, item_type='comment', url=None, parent=25311006, text='Sure!<p>One typical example is a component that collects (and displays) education history provided by the user. I&#x27;ll list out just a few key UI behavior:<p>* A &quot;read&quot; view which represents a list of containers with titles that show each instance of a users answer (for example, if you provided 5 sets of answers, such as 5 universities you attended, we need to show those 5 in some sort of preview form on the page)<p>* A button that when clicked opens up a modal which contains multiple &quot;steps&quot; - each step is a small set of form inputs that range from simple ones like date to more complex ones involving search &#x2F; autocomplete or file uploading.<p>* A button inside the modal that lets you navigate through the various steps &#x2F; groups of form inputs.<p>* A &quot;save&quot; button inside the modal that persists your answers. This closes the modal and shows your set of answers as an instance in the list view (see the first bullet).<p>* In-line validation errors as the user is filling out each step of the modal<p>* Messages to notify the user that a modal needs to be opened and completed (Like if the user closed the modal before filling everything out, we want to let them know it&#x27;s not fully completed).<p>Where some of the biggest complexity crop up:<p>* Form input data handling and general state management. As I mentioned, we can have upwards of maybe 20 controls in this component. At minimum, we need to write code to listen to input changes and make sure this new information is kept in sync with both internal component state and other parts of the UI. If you gave us a valid answer, we need to make sure to update the UI to show a checkmark (in the simple case). We also have controls that show or hide based on your answers to other form controls, so we&#x27;ll need to handle inputs by potentially hiding or showing other inputs.<p>* Ok, so what if we need to write some UI updating code? Well, updating any part of the UI requires manual DOM manipulation. At minimum, this can be something simple like toggling visibility of an element by adding or removing a class. At worst, this involves appending html template strings (like if we need to show a list of errors on top of the modal) when the user attempts to save bad answers.<p>* Cross-component communication is difficult. Want to add a subcomponent? And it needs to communicate with the parent? For example, each step in our view is sort of a &quot;sub form&quot; and it needs to talk to the parent &quot;modal&quot; to keep global state - you&#x27;ll need to roll some basic event handling code between the two.<p>* Testability. All these DOM changes - how do we test that our component is behaving? At the time we adopted stimulus, there wasn&#x27;t a standard way of testing our stimulus controller so we&#x27;ve mostly leaned on (expensive) UI integration tests.<p>Some of this complexity is sort of inherent to forms - forms are complex UI components. There are hosts of libraries in other frameworks for dealing with form inputs alone (in order to cut down on the boilerplate you have to write). For example, formik in react helps cut down on a ton of boilerplate you have to write in order to wire the form control DOM state to react state.<p>Some of this complexity is also our own doing - we keep A LOT of state in the DOM. If a user blanks out an answer, we need to update the DOM with an additional form control whose value will get passed back to the backend to persist the change in the DB. Moving over to ReactJS won&#x27;t help us here - this will require changes to our backend vs frontend API&#x27;s.<p>However, having to handle the bulk of those DOM changes yourself requires a lot of code, is pretty error prone, and quite hard overall to maintain (as anyone who has rolled apps using vanilla javascript can attest to). StimulusJS doesn&#x27;t offer many facilities for changing your UI in a declarative way.<p>Finally, cross-component communication is very common and while there is a number of ways to pass data back and form between stimulus controllers, there isn&#x27;t really a nice way to do it outside of passing events. This is fine for simple cases, but error prone for our use cases. In reactjs, invoking callbacks that change parent state feels much more straightforward and has been easier to test.<p>Hope that helps')