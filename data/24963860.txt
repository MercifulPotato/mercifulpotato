Item(by='doonesbury', descendants=None, kids=[24964050], score=None, time=1604277274, title=None, item_type='comment', url=None, parent=24962443, text='&gt;I don&#x27;t know if I&#x27;d use the word disingenuous.<p>Point taken. Programmers may see project uncertainly as less pressing&#x2F;difficult while formal methods are onerous. How much one or the other depends on details, and how the team frames risk and methods to reduce it. Even on the project side, for example, the Chaos report from the 1990s shows some 40% (60% at small companies) of software projects are cancelled before delivering anything mainly due to scope change and lack of executive support. Both require attention. Both are non-trivial.<p>While we&#x27;re on formal methods I&#x27;d like to solicit your opinion a bit more. I am working on a distributed KV store which I&#x27;d like to formally certify. I started with TLA+ except that compared to Dafny, Verdi the gap between spec and implementation is higher. I don&#x27;t like that. Verdi, in particular, comes with formally verified, shimmable network layers plus the ability to produce runnable code from the Coq spec. My practical assessment is,<p>+ Dafny: pros: Refine spec to implementation; provides safety and liveness checks. Can produce runnable code towards testing, Q&#x2F;A experimentation.<p>- Dafny: cons: The Dafny GIT repo is a mess --- extremely disorganized and therefore hard to simulate examples in papers with the real thing. It&#x27;s very hard to see what libraries to build on.<p>+ Verdi: pros: Like Dafy which came after Verdi, it&#x27;s focused on refinement: go from spec to more and more implementation detail. It&#x27;s based on Coq proofs and Coq has tons of books, examples, exercises. See <a href="https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu&#x2F;" rel="nofollow">https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu&#x2F;</a> for five solid write-ups concluding with formally certified C code. So I do not see Verdi as overly academic. It has formally verified libraries that can be re-used esp. in the area of message passing, marshalling which models reliable and non-reliable packet delivery. Moreover, and this is important for distributed programming, proofs can be done in terms of traces. Not sure if TLA+ and it&#x27;s model checker TLC can do that.<p>- Verdi: Cons: I have to learn Coq, not the end of the world but it&#x27;s another chunk of work. Also Verdi can&#x27;t help with liveness checks while TLA+ and Dafny or Spin can. I initially worked with SPIN and TLA+: those specs are checked in a model checker which looks for counter examples. I have a certain feel for that. On the other hand as I understand it out the box, Dafny or Verdi or FRAMA-C use proofs. Now a proof is formal and is help, however, I am unclear if Dafny, or Verdi will give me a counter example if a refinement goes wrong. More specifically, if a refinement is wrong which happens: one is unable to prove a claim - and that&#x27;s your head&#x27;s up ... or at some point a run of the executables made will assert a violation of a safety property. I&#x27;m not sure.<p>+ TLA is of course much used in industry -- so I won&#x27;t plough that field again. But I wish I knew if it can prove system properties through traces like Verdi because it seems such a natural way to reason about distributed systems. TLA+ of course does liveness and safety checks.<p>All of these are free tools ... including SPIN ... so if one can put the time in you can get a lot of power. That&#x27;s good to know. Navigating some of the finer details as I suggest here is not so easy when choosing one.<p>For my little project I was thinking Verdi for safety and TLA+ for liveness checks when needed.<p>Please weight in ... I&#x27;d love to hear more perspectives.')