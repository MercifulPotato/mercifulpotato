Item(by='gsnedders', descendants=None, kids=None, score=None, time=1609584846, title=None, item_type='comment', url=None, parent=25611637, text='A lot of it is simply the prevalence of little-endian systems, initially with x86, but now with the vast majority of other systems too; code is developed on the developer&#x27;s system, and works there. As big-endian systems have become increasingly rare, an ever larger amount of code has stopped working (or never worked) on big-endian systems, thus it&#x27;s become harder and harder to ship big-endian systems. If you want desktop-class applications, they&#x27;ve typically either been little-endian only, or have been little-endian only since Apple migrated to Intel.<p>We&#x27;ve seen POWER largely migrate to little-endian, as IBM was struggling with sales due to the difficulty in porting software to it, partly due to the endianness difference. (Note that POWER and PowerPC were technically always bi-endian architectures, but the majority of historic hardware had its endianness set by the motherboard in use, and almost everything shipped with big-endian. Systems running Windows NT on PowerPC were some of the very few that ran in little-endian mode.)<p>We&#x27;ve also seen a similar shift in embedded hardware; bi-endian architectures like ARM and MIPS are now more commonly used in little-endian mode, despite historically being used in big-endian mode.')