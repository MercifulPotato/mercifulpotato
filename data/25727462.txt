Item(by='dmitriid', descendants=None, kids=[25727754, 25727685, 25727879, 25729034, 25727660], score=None, time=1610363928, title=None, item_type='comment', url=None, parent=25726588, text='I dislike Haskell. But this article goes out of its way to make the worst possible case for Haskell imaginable.<p>&gt; Many programmers encounter statically typed languages like Java or C++ and find that the compiler feels like an annoyance. By contrast, Haskell’s static type system, in conjunction with compile-type time checking, acts as an invaluable pair-programming buddy that gives instantaneous feedback during development.<p>Many programmers find that Java or C++&#x27;s static type system, in conjunction with with compile-type time checking feels like an annoyance. Unlike... the very same statement about Haskell? That&#x27;s... that&#x27;s quite a weak claim, to say the least.<p>&gt; a signature like Int -&gt; Int -&gt; Bool indicates that a function takes two integers and returns a boolean value... this allows a programmer reading Haskell code to look only at type signatures when getting a sense of what a certain piece of code does. For example, one would not use the type signature above when looking for a function that manipulates strings, decodes JSON, or queries a database.<p>So... Type signature `Int -&gt; Int -&gt; Bool` can be used for a function that does any of the following things: manipulates strings, decodes JSON, or queries a database? How does that make it easier to deduce what a function does by &quot;looking only at type signature&quot;?<p>&gt; Another feature of a pure functional programming paradigm is higher-order functions, which are functions that take functions as parameters.<p>As in: available in almost any language these days, and not exclusive to a &quot;pure functional programming paradigm&quot;.<p>&gt; One of the common development workflows we employ is relies on a tool called ghcid, a simple command line tool that relies on the Haskell repl to automatically watch code for changes and incrementally recompile. This allows us to see any compiler errors in our code immediately after saving changes to a file. It’s not uncommon for us to open only a terminal with a text editor and ghcid while developing applications in Haskell.<p>As in: Modern IDEs don&#x27;t require you to run external tools to monitor your code for changes and highlight errors.<p>&gt; a common refactoring workflow is to make a desired change in one location and then fix one compiler error at a time until the program compiles again.<p>As in: Modern IDEs let you do large-scale refactoring in one go, at a press of a button.<p>&gt; The type system can protect us from making mistakes when changing the rules of our domain.<p>It can&#x27;t. The example provided can&#x27;t stop you from doing `case status of Paid -&gt; delete invoiceNumber`. You have to invest significantly in a type-based DSL to prevent that from happening. But then, who will test your DSL?<p>&gt; Haskell enables domain-specific languages, which foster expressiveness and reduce boilerplate<p>DSLs where all the rage 5-10 years ago. In reality, they are overhyped and are used very sparingly, for obvious reasons: DSLs are <i>languages</i>. They have to be designed, developed, maintained. Errors in your DSL will most likely harder to find and debug than in your regular program.')