Item(by='dasyatidprime', descendants=None, kids=[24873965, 24871925], score=None, time=1603474495, title=None, item_type='comment', url=None, parent=24871547, text='What phoe-krk mentions is indeed the main thing that blocks “real” integration into existing languages with exceptions: they always unwind before executing the handler. (JWZ even complained about this while writing about Java.)<p>To expand on their comment: if `throw` in Java or C++ is similar to `error` in CL (or `throw` in some special cases), a `catch` clause in Java or C++ is equivalent to a label, where the `try` binds a handler that exits to it immediately. There&#x27;s no equivalent of putting code in the handler other than a single unwind-and-jump, and there&#x27;s no equivalent of restarts.<p>In CL, a condition handler gets called <i>on top of</i> the existing stack and can inspect what&#x27;s going on before choosing where to exit to. Other functions in the call stack can provide alternative exits (restarts), like “continue processing anyway” or “substitute a placeholder value”; these are dynamically named, rather than lexically bound like `catch` . So there&#x27;s a lot more possible decoupling, at least in theory. The equivalent of `finally`&#x2F;destructors is `unwind-protect`, which has to interoperate with the condition mechanism but doesn&#x27;t deal with conditions itself.<p>In C++ or Java, you could implement the restarts with a (thread-local) stack of restart descriptions plus try&#x2F;finally or constructor&#x2F;destructor, and the same for handlers, and then do your nonlocal exits with specialized throwables. I did something similar in Lua, in fact, while trying to extend it into a fancier language. But a “normal” `throw` will bypass all of that. That&#x27;s not <i>dangerous</i> if you do the unwind-protects properly, but none of your existing libraries will be built for it, and the results will be kind of anemic.<p>In the Java-style objects+throw&#x2F;catch world, similar things can be achieved by toggling “what to do if X happens” state or plumbing callback pointers through the object graph beforehand, which is similar but more ad-hoc, and possibly harder to add to existing systems. That said, the CL style proper is very tied to the call stack, which can also make things tricky.')