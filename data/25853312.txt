Item(by='chmod775', descendants=None, kids=None, score=None, time=1611185477, title=None, item_type='comment', url=None, parent=25847815, text='&gt; Oh come one now, don&#x27;t be silly.<p>Don&#x27;t be snarky.<p>I mentioned it&#x27;s theoretically possible and outlined the specific conditions for optimizations to happen.<p>But I also mentioned that in reality various things often prevent compilers (assuming it&#x27;s a compiled language, and not interpreted, like that LUA implementation) from applying such optimizations:<p>- you&#x27;re programming against an API or are compiling an API (i.e. non-static functions).<p>- you have time-constraints for emitting optimized code, like most JITs - you can&#x27;t afford any deep analysis that would enable such optimizations, you&#x27;re mostly pattern-matching for lower hanging fruits.<p>Since pictures say more than a thousand words, here&#x27;s the actual disassembly of that lua function I linked earlier, as shipped by my Linux distribution: <a href="https:&#x2F;&#x2F;i.imgur.com&#x2F;DnqVC8E.png" rel="nofollow">https:&#x2F;&#x2F;i.imgur.com&#x2F;DnqVC8E.png</a><p>The green stuff is the &quot;fast path&quot;. For 0-based indexing you would completely drop the first LEA and replace those last MOV&#x2F;SHL&#x2F;LEA with a (faster?) MOV <i>r,r</i>&#x2F;SHL&#x2F;ADD <i>r,m</i> - which is what GCC is likely to generate.<p>So that&#x27;s Lua (one implementation at least) in practice. No compiler magic making arrays fast here.<p>LuaJIT (from my current reading) goes the different route of just pretending the first array element doesn&#x27;t exist, meaning that in memory they have an element &#x27;0&#x27;, but they simply don&#x27;t use it. This trades some memory for speed.<p>From lj_tab.c:<p><pre><code>   ** The array size is non-inclusive. E.g. asize=128 creates array slots            \n   ** for 0..127, but not for 128. If you need slots 1..128, pass asize=129          \n   ** (slot 0 is wasted in this case).\n</code></pre>\nPersonally I quite like this approach. A lot better than hoping compilers will magically fix everything and quite hard to argue with, considering LuaJIT&#x27;s performance. Though it would be a ludicrous design for a lower-level language.')