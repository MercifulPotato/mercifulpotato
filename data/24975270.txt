Item(by='theptip', descendants=None, kids=None, score=None, time=1604365436, title=None, item_type='comment', url=None, parent=24963742, text='I like this way of thinking about services; decoupling the &quot;project model&quot; from the &quot;deployment model&quot; is a good way of thinking about things.<p>Some random thoughts:<p>* What build toolchains are suited to these arbitrary DAG arrangements? Bazel? Perhaps I missed a reference in the article, but I&#x27;d be interested in the author&#x27;s take on this, and of course any thoughts from the community here.<p>* The &quot;testing monolith&quot; is a pattern that I&#x27;ve used in a less well-named fashion, and it&#x27;s great for cases where lots of code-services need to execute a business process that might span weeks or months; building a test rig to mock time across an ensemble of microservices sounds like an interesting challenge; mocking time inside a single process running the combined logic of all the services is much more palatable. (This isn&#x27;t really possible if you use multiple languages though, so it only gets you so far).<p>* DDD bounded contexts as service boundary -- this is a good starting point, especially if you take a loose definition of &quot;service&quot;. Under the DDD definition of &quot;Service&quot; you can actually have multiple deployables running; for example a typical Django&#x2F;Rails monolith will have a DB (SQL) and an async worker (Celery&#x2F;Sidekiq via Redis&#x2F;RMQ) and perhaps a cache (Redis) so it&#x27;s really a bunch of different deployables, even if we refer to it as a &quot;monolith&quot;. Likewise with smaller services. If you think of the Service as being a constellation of processes with an external API, then you can start splitting out parts into separate deployables without the outside world caring, say to scale a particular workload independently of the rest of the Service logic. This is kind of the direction that Uber ended up moving in with their &quot;Domain Oriented Architecture&quot; (<a href="https:&#x2F;&#x2F;eng.uber.com&#x2F;microservice-architecture&#x2F;" rel="nofollow">https:&#x2F;&#x2F;eng.uber.com&#x2F;microservice-architecture&#x2F;</a>). This is actually how Django monoliths already work; you use the same codebase to specify your sync API workers, and your async Celery tasks, and you&#x27;ll deploy them as separate deployables from the same repo.')