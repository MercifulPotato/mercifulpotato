Item(by='FridgeSeal', descendants=None, kids=None, score=None, time=1602052442, title=None, item_type='comment', url=None, parent=24705126, text='&gt; Your comments are surprising since you seem to have experience F# and other languages and yet it sounds like you haven&#x27;t used any modern .NET version.<p>Most of the stuff I&#x27;ve written in .net(core) has been in F# and C# (v8) and runtime v3.1. So much pain playing 20 questions with libs whose runtime requirements were thoroughly and widely distributed across all the runtime versions in a quest to get them to co-operate. I guess I&#x27;m just not a huge fan of the language in general, it&#x27;s all a bit too enterprise-design-pattern-clunky-objects and implicit-mutation all the way down, not to mention verbose. I know it&#x27;s finally, finally getting a half-decent implementation of pattern matching and immutable records, but there&#x27;s nothing that stands out to me about it that makes me want to use it over literally any other language I know, which I guess is fine as it&#x27;s primary target is being a &quot;boring&quot; enterprise language, which it excels at.<p>&gt; AOT doesn&#x27;t have anything to do with performance but helps with startup time and packaging.<p>Not sure I&#x27;d agree with this: putting code through an optimising compiler like LLVM ahead-of-time means you can apply more performance optimisations for runtime.<p>&gt; The .NET JIT now has tiered compilation with secondary passes that optimize hot methods with much more input about the environment, including knowing that it&#x27;s a hot path. AOT can&#x27;t do this.<p>That&#x27;s fair, but if you type-system and language design already tells you everything you need to know, you don&#x27;t need to wait until code gets hot-enough to swap it in, you just pay the compile-time cost and have it go at peak speed the whole time, my argument here might be veering dangerously close to the &#x27;sufficiently-advanced-compiler&#x27; argument hahaha.<p>&gt; Saying &quot;built for speed&quot; doesn&#x27;t really mean much. .NET created the async Task model that other languages adopted and has all kinds of performance related features from Span&#x2F;Memory APIs to SIMD vector operations.<p>Sure, it&#x27;s got some fast bits but in my experience very few libraries make any use of them and by default most things are heap allocated, with plenty of pointer-indirection right? Compare that to Rust where far more is stack-allocated and numerous other optimisations and shortcuts get applied so the things you&#x27;re accessing on the heap still aren&#x27;t too slow. The async-task model is just a model and has nothing to do with actual run-time performance though right? I had a go playing around with Span when I last wrote stuff in C#, but I found it difficult to do much with it as the compiler either wanted way more things to operate on Span-types (some of which was out of my control) or I needed to do things with iterators that required me to turn it right back into a &#x27;heavyweight&#x27; IEnumerable class, which kind of defeated the purpose. Entirely plausible I was using it wrong though.<p>&gt; RavenDB is an example of an fast document database built in .NET Core: <a href="https:&#x2F;&#x2F;ravendb.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ravendb.net&#x2F;</a><p>Ok that&#x27;s cool, I hadn&#x27;t heard of this, I&#x27;ll check it out.')