Item(by='valbaca', descendants=None, kids=[25120525, 25120763, 25118437], score=None, time=1605567633, title=None, item_type='comment', url=None, parent=25118024, text='Just to set some context, I&#x27;m of the &quot;OOP Generation&quot; where I learned to program when OOP was at its zenith. Every major language was Class-based OOP (C++, C#, Java, Python, Ruby) and it was just THE way to code for all things in the foreseeable future.<p>That said, I&#x27;ve since looked into and learned other methods of programming: classic C, prototype-based JS, functional Clojure, and Go.<p>From what I can gather, even from the SOLID principles and other Class-based OOP advice (prefer composition over inheritence) is that Interfaces (as abstraction and reuse), Aggregation (that objects can have other objects), and Delegation (which allows of ergonomic aggregation) are the real winners of OOP.<p>In this way, Go gets it mostly right IMO, though at the risk of &quot;initial hype&quot; I&#x27;m still cautious on it.<p>It feels so backward that OOP is taught with a focus on abstract &amp; subclasses, with very little emphasis on interfaces, which is really how we achieve the goals of abstraction and reuse.<p>What&#x27;s funny is seeing languages like Java trying to &quot;undo&quot; the arguable &quot;mistake&quot; of abstract classes by adding more and more power into interfaces: default methods, etc.<p>To your original conversation, there&#x27;s a mix going on with &quot;model.&quot; Are they talking about the Service&#x27;s API Model, the internal model representation, or the database model? The outer layers (API &amp; Database) of your code should be plain structs (POJOs in Java), but you&#x27;re absolutely right that within the business code itself, you should have logic within the classes. Otherwise, you&#x27;re not coding much different than C passing around struct pointers.<p>Related terms: MVC, Data access object')