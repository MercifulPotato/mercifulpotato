Item(by='hardwaresofton', descendants=None, kids=None, score=None, time=1604549759, title=None, item_type='comment', url=None, parent=24972271, text='I&#x27;d love to use this (and probably will try eventually) , but the try.typedefs.com[0] example is hard to penetrate.<p><pre><code>    ; Booleans correspond to a sum of unit types.\n    (name Bool (+ 1 1))\n</code></pre>\nI&#x27;m familiar with Lisp&#x2F;S-Expressions, Haskell, ADTs and this <i>still</i> threw me for a loop, even with the generated Haskell code on the right. Why have you chosen terseness at the cost of approachability? Without looking at the intro page[1], I couldn&#x27;t figure out how in the world this syntax created a boolean type. Here&#x27;s my thought process:<p>- OK, we&#x27;re making a name (I guess that&#x27;s a type? why is it not called that?)<p>- &quot;Bool&quot; -- OK we&#x27;re making the haskell Boolean type<p>- &quot;(+ 1 1)&quot; -- What? Bool is 2?<p>- (At this point I looked over to the right at the Haskell code, read it to discover that it&#x27;s 0&#x2F;1)<p>- Oh OK, &#x27;+&#x27; must be sum? but why would I sum 1 with itself? is it a 1 and 1? 1 must not be numeral...<p>At this point I went back and read the introduction and it was clear but please, don&#x27;t point people to the try page without giving them a brief syntax intro. That, or change the syntax to actually be a bit more approachable -- why not `unit` instead of `1` or `sum` instead of `+`? At least the option would be nice..<p>I wonder if there&#x27;s been consideration of leaving some space&#x2F;ability for people to add custom implementations&#x2F;overrides for some of the translations? Less so in the Haskell case since it just compiles to something byte-encodable, but I don&#x27;t want booleans in my JSON to be represented by {&quot;case0&quot;: &quot;singleton&quot;} and {&quot;case1&quot;: &quot;singleton&quot;}. I know this breaks the purity and generality of the solution but if it&#x27;s going to see real-world use I think this complaint will come up.<p>Also, there&#x27;s the distinction when structure is included or not -- it looks like there is a discrepancy between haskell and jsonschema in that one is structure&#x2F;schema included and the other is not, is that intended? Any client can read the JSON schema, but not any Haskell client can read the haskell code -- AFAICT boolean is just... 0&#x2F;1 sitting in a byte stream, untagged. I guess this is another thing that goes against the generality and purity of the solution, but I sure would like to be able to have tooling that can tell me I&#x27;m dealing with Product type containing two bools... I tried it out:<p><pre><code>    ; Booleans correspond to a sum of unit types.\n    (name Bool (+ 1 1))\n\n    (name BoolTuple (* Bool Bool))\n</code></pre>\nThe code that came out on the haskell side looks like this:<p><pre><code>   -- ... snip ....\n\n   encodeBoolTuple :: Serialiser BoolTuple\n   encodeBoolTuple x = case x of\n                      (y,y0) -&gt; mconcat [(encodeBool y),(encodeBool y0)]\n\n    decodeBoolTuple :: Deserialiser BoolTuple\n    decodeBoolTuple = do\n                    x &lt;- decodeBool\n                    x0 &lt;- decodeBool\n                    return (x,x0)\n</code></pre>\nSo just... two 0&#x2F;1s on the wire and that&#x27;s it? Efficient yes, but I think it&#x27;d be nice to be able to tell I got handed a tuple with 2 elements (even if I don&#x27;t necessarily know they&#x27;re both booleans, though it&#x27;d be nice to know they were a well-known boolean type).<p>[0]: <a href="https:&#x2F;&#x2F;try.typedefs.com" rel="nofollow">https:&#x2F;&#x2F;try.typedefs.com</a><p>[1]: <a href="https:&#x2F;&#x2F;typedefs.com&#x2F;introduction&#x2F;" rel="nofollow">https:&#x2F;&#x2F;typedefs.com&#x2F;introduction&#x2F;</a>')