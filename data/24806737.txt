Item(by='john_moscow', descendants=None, kids=None, score=None, time=1602898022, title=None, item_type='comment', url=None, parent=24806307, text='&gt;In other words type casting can be written as (foo)2 or as foo(2). Just to make it harder to understand what is going on.<p>Or to make it easy to describe high-level behavior where you don&#x27;t care about the details. In your example, <i>foo</i> and <i>bar</i> could be some complex vector or matrix types with custom allocation&#x2F;deallocation logic.<p>So this line:<p><pre><code>  int x = foo(2) + bar(3);\n</code></pre>\nIs an equivalent of 7 lines in Plain C:<p><pre><code>  foo tmp_foo;\n  bar tmp_bar;\n  construct_foo_from_int(&amp;tmp_foo, 2);\n  construct_bar_from_int(&amp;tmp_bar, 3);\n  int x = add_foo_and_bar(&amp;tmp_foo, &amp;tmp_bar);\n  free_foo(&amp;tmp_foo);\n  free_bar(&amp;tmp_bar);\n</code></pre>\nSure, if you don&#x27;t know what <i>foo</i> and <i>bar</i> are, it&#x27;s confusing. But if you want to decompose <i>what</i> you are doing from <i>how</i> you are doing it, this syntax rocks.<p>BTW, <i>(foo)2</i> syntax is preserved for backward compatibility with C and is deprecated in favor of <i>static&#x2F;dynamic&#x2F;reinterpret_cast&lt;&gt;()</i> (that many people don&#x27;t use due to clunkiness) and <i>foo(2)</i> is unavoidable if foo&#x27;s constructor has more than 1 argument.')