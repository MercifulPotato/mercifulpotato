Item(by='chrismsimpson', descendants=None, kids=None, score=None, time=1607996245, title=None, item_type='comment', url=None, parent=25414534, text='You can&#x27;t be a purest OOP <i>or</i> functional developer and also hold high the values of launching early and often (in my opinion). Instead, I think the pragmatic path ahead is codebases that balance and blend these two disciplines well, and largely use the GC (or reference counting&#x2F;whatever mechanism exists) for managing resource allocation across an entire stack.<p>That is to say, you intentionally use classes and all the baggage of OOP when you know a part of a given implementation resource and throughput heavy. Otherwise, the default &#x27;starting point&#x27; when implementing something is to start with value semantics.<p>It&#x27;s fair to say many mainstream languages are adopting this approach. Swift is extremely functional, C# 9.0 adds record types, Go and Rust are largely functional but you can do OOP style things with them.<p>Java I feel has reached an evolutionary dead end and will be the 90&#x27;s answer to COBOL.')