Item(by='arcticbull', descendants=None, kids=None, score=None, time=1605647737, title=None, item_type='comment', url=None, parent=25127768, text='You don&#x27;t need to specify the lifetime annotations on print_refs because the references aren&#x27;t returned and are unambiguously just the lifetime of the function. The compiler will fill those in for you -- even if the lifetimes of x and y are different, just so long as x and y live at least as long as the function.<p><pre><code>  fn print_refs(x: &amp;i32, y: &amp;i32) {\n      println!(&quot;x is {} and y is {}&quot;, x, y);\n  }\n</code></pre>\nIn general you only need to specify lifetime parameters when there&#x27;s an ambiguous situation. For instance, the following builds and runs just fine.<p><pre><code>  fn make_substring_of(input: &amp;str) -&gt; &amp;str {\n    &amp;input[1 .. ]\n  }\n</code></pre>\nI&#x27;ll be the first to admit it takes a while to ramp up into Rust. Part of that is learning to let go and trust the compiler. Unlike many other languages, it won&#x27;t hurt you haha. It&#x27;s on your side. Sometimes you need to you know, give it a little more info so it can do it&#x27;s job.<p>The Rust team has made huge strides in improving writability of the language, especially with non-lexical lifetimes.<p>Soon, `fn` and `impl` and `Vec` fade into the background, like `char` and `short` and `long`.')