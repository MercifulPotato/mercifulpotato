Item(by='mehrdadn', descendants=None, kids=[25418173], score=None, time=1607956440, title=None, item_type='comment', url=None, parent=25417721, text='Well you could create a pipe from the shell if you&#x27;re spawning it (just create a pipe() when you fork() it), assuming it&#x27;s inheriting your stdio so you can&#x27;t already just wait on those. This is what I&#x27;ve done in the past.<p>That said, if your child process has genuine potential to acting adversarially, I don&#x27;t believe even pidfds would be enough; you&#x27;ll need to make sure it doesn&#x27;t spawn e.g. a child process to break away.<p>However, I would guess that&#x27;s not your actual use case? Rather, I&#x27;d assume you&#x27;re trying to prevent against accidents. If you&#x27;re in this boat like I&#x27;m assuming, I&#x27;d suggest thinking over whether the scenario you proposed is actually plausible. The only real-world instances I&#x27;ve seen a process playing &quot;games&quot; with file descriptors it did not previously open itself are (a) closing FDs after a fork, and (b) user code in a shell, doing something like exec 2&gt;&amp;3 or whatever. I assume you&#x27;re worried about the latter given the former isn&#x27;t relevant. In that case, you could work around it via dup2() after you fork(), by duping into a random high FD that nobody would be likely to mess with (like a random high number plus its own PID). This should solve it for practical purposes.<p>Not that you shouldn&#x27;t use pidfds necessarily, but I&#x27;m just throwing these out there because I&#x27;ve been in this situation before and these might help you solve your problem on other systems that don&#x27;t support that.')