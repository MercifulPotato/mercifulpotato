Item(by='skohan', descendants=None, kids=[25526452], score=None, time=1608800536, title=None, item_type='comment', url=None, parent=25523074, text='&gt; the state machines are handled by the compiler<p>I think this is the aspect of modern approaches async which I am most ambivalent about.  One of the things I have learned about programming over the past 10 years is that I, as the programmer, really want to own the flow of control of my program.  Once I hand that over to some other system, usually in the name of convenience, I will start to have issues which are difficult to understand and solve.<p>For instance, a while ago, I was working on a project which was using making heavy use of RXJava.  One of my colleagues pushed a commit, and suddenly CI was failing on a unit test which passed when run locally.  It turns out the problem was because the CI server was running tests with a different scheduler, so GC was happening at a different time, creating an NPE which didn&#x27;t happen locally.  Imo when you start to see unit tests behaving inconsistently based on a factor which is completely outside the actual code you yourself have written, this is a sign you are going down the wrong path.<p>I also wonder how much a lot of the buzz around async actually has to do with the fact that it&#x27;s a bit brain-bending to wrap your head around at first, as compared to its actual utility.  I think for a lot of us as programmers, we enjoy that feeling of understanding something difficult - like when you really get recursion for the first time - and we&#x27;re attracted to the idea of really fundamentally new concepts being introduced to programming.<p>But it seems to me that async is one of those concepts which brings us farther away from actually programming the hardware, and puts a kind of middle-man between us and the CPU, and I&#x27;m not sure that has ever been a good thing.')