Item(by='eyelidlessness', descendants=None, kids=[25446034], score=None, time=1608076315, title=None, item_type='comment', url=None, parent=25433659, text='Let me give you a head start: what you want in TypeScript is type guards. You pair runtime validation with type refinement, and if you start with good composable primitives, you can declare runtime structures and get compile time safety for “free”. That’s how io-ts and the various other libraries in that space work.<p>If you combine that with generics on whatever function defines your routes, you can validate API boundaries and business logic boundaries in the compiler. This applies to any boundary (I could link to Gary Bernhardt on that topic but I’m on phone), and you can do it as generically (like you said, io-ts) or specifically (take a look at zapatos for type safe SQL) as you like.<p>For HTTP boundaries, I’ll drop some pseudocode of how I’m doing this in my library:<p><pre><code>    type HTTPVerb =\n      | &#x27;delete&#x27;\n      | &#x27;get&#x27;\n      | &#x27;head&#x27;\n      | &#x27;options&#x27;\n      | &#x27;patch&#x27;\n      | &#x27;post&#x27;\n      | &#x27;put&#x27;\n      | &#x27;trace&#x27;;\n\n    interface HTTPRequest {\n      readonly method: HTTPVerb;\n      &#x2F;&#x2F; ...\n    }\n\n    type HTTPRequestDecoder&lt;I&gt;     = (request: HTTPRequest) =&gt; I;\n    type HTTPResponseEncoder&lt;O, R&gt; = (output: O) =&gt; R;\n    type HTTPRoute                 = IrrelevantForThisPost;\n\n    type Handler&lt;I, O&gt; = (input: I) =&gt; O;\n\n    type HTTPRouteFactory = &lt;I, O, R&gt;(\n      path:    string,\n      decoder: HTTPRequestDecoder&lt;I&gt;,\n      handler: Handler&lt;I, O&gt;,\n      encoder: HTTPResponseEncoder&lt;O, R&gt;\n    ) =&gt; HTTPRoute;\n\n    type Route = {\n      readonly [K in HTTPVerb]: HTTPRouteFactory;\n    };</code></pre>')