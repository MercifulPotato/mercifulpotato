Item(by='KMag', descendants=None, kids=None, score=None, time=1610078585, title=None, item_type='comment', url=None, parent=25678245, text='Honestly, the next version of TLS should have a mandatory variant of certificate caching [0], except instead of putting the cached_info in the ClientHello message, the final handshake message (which is encrypted) would include the hash of the cached certificate.  If the hash doesn&#x27;t match, then the server would send the certificate (the connection is now in an encrypted but unauthenticated state).<p>If nothing is cached, the client sends randomly generated bits in place of a cached certificate hash, which eliminates one case to be handled in the protocol.  (Handle an empty cache and a stale cache in the same code branch.)  This provides more privacy than sending an &quot;I have nothing cached&quot; and it&#x27;s more likely to be struck by lightning and a meteor simultaneously than get a 256-bit collision.  The consequences of a hash collision are only that the connection needs to be reset.<p>In the case of nothing being cached, again to reduce the number of special cases to handle, the client would need to make a guess as to the ECDH&#x2F;RLWE&#x2F;etc. parameters in its initial handshake message.  The mechanism for handling stale cached ECDH&#x2F;RLWE&#x2F;etc. parameters would then apply to the non-cached case.  (In this case, the server just sends back a message saying &quot;Those are stale. Here are my parameters for a method in your provided list of supported methods, and here, also have my first side of the handshake.&quot;).  Again, eliminating special cases by faking it&#x2F;guessing if nothing is cached slightly increases privacy by requiring information outside of the handshake to detect if this is a repeat visit.<p>[0] <a href="https:&#x2F;&#x2F;tools.ietf.org&#x2F;html&#x2F;rfc7924" rel="nofollow">https:&#x2F;&#x2F;tools.ietf.org&#x2F;html&#x2F;rfc7924</a>')