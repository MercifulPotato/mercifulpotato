Item(by='rleigh', descendants=None, kids=[25881344], score=None, time=1611395916, title=None, item_type='comment', url=None, parent=25880687, text='Absolutely.  It makes perfect sense, and in an ideal world this would be the direction which would benefit many, if not most, projects using C and&#x2F;or GLib2.  Unfortunately, there are far too many people who are wedded to the philosophy that C is perfect for every task, and C++ is the devil.  Despite the fact that GLib&#x2F;GObject are more complex than C++, more error-prone than C++, slower than C++ and make static code analysis impossible (due to all of the unsafe typecasting).<p>A few years ago now, I ported a C GLib&#x2F;GObject-based application to C++.  In removing all of the unnecessary typecasts I found a couple of minor (but real) bugs which were previously hidden from the compiler.  Simple use of real classes, along with basic containers like vector and map, was the vast majority of the C++ usage in the whole application.  It benefitted greatly in becoming smaller, simpler, easier to read, easier to maintain, and having the compiler able to typecheck everything.<p>Like yourself, I&#x27;ve also used C++ on MCUs.  Some vendors even provide an &quot;Embedded C++&quot; C++ subset you can use, which is &quot;safe&quot; for safety-critical real-time code.  Works fine.  A lot of C embedded projects would benefit from the extra safety it provides.  So long as you don&#x27;t go overboard with the features; stick to a simple and easy to understand subset.')