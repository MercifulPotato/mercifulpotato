Item(by='ProfHewitt', descendants=None, kids=[25539698, 25540507], score=None, time=1608924059, title=None, item_type='comment', url=None, parent=25536600, text='This is an excellent summary of rationale for<p>Erlang with the goals stated at the beginning of the article!<p>However, the Erlang language itself is now rather dated :-(<p>In order to implement next generation Universal<p>Intelligent Systems [Hewitt 2019], the following extensions<p>to Erlang are needed:<p>• Automatic reclamation of processes. For example,<p>Erlang uses Process Identifiers (PIDs) to communicate between<p>processes. However, a process that has a process identifier<p>(say ProcessIdentifier) of a process with which it<p>communicates can launch a denial of service attack to kill<p>that process using exit(ProcessIdentifier, kill). An Erlang<p>process can be orphaned if its Process Identifier (PID)<p>becomes inaccessible. By default, the send operation in<p>Erlang always succeeds (even if the target is a non-existing \nprocess).<p>• Strong parameterized types with no type Any.<p>• Region of mutual exclusion for an Erlang process.<p>An Erlang process does not have a region of mutual exclusion,<p>which can lead to internal conflicts within processes.<p>• Behavior change using variables in a region of mutual<p>exclusion instead of having to create auxiliary processes to<p>hold state with callbacks. [Swain 2014] In particular,<p>o Better support for holes in the region of mutual exclusion<p>of an Actor implementation.  For example, in Erlang it is<p>necessary for application programmers to explicitly code a<p>request handler for each re-entry into the region of mutual<p>exclusion potentially enabling cyberattacks from outside the<p>process.<p>o Better ways to upgrade Actors in place without losing work in progress.')