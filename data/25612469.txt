Item(by='smcameron', descendants=None, kids=[25612557, 25612553], score=None, time=1609591643, title=None, item_type='comment', url=None, parent=25611563, text='But that code isn&#x27;t portable for a different endian machine.  To write portable endian clean code, you want to write functions&#x2F;macros named like:<p><pre><code>  cpu_to_le32(),\n  cpu_to_be32(),\n  be32_to_cpu(),\n  le32_to_cpu(),\n</code></pre>\netc. (and similar for 16, and 64 bit quantities) similar to what&#x27;s described here: <a href="https:&#x2F;&#x2F;kernelnewbies.org&#x2F;EndianIssues" rel="nofollow">https:&#x2F;&#x2F;kernelnewbies.org&#x2F;EndianIssues</a>)<p>These functions will either swap, or not, depending on the endianness of the target machine, and this decision is made at compile time, so the &quot;no swap&quot; case imposes no performance penalty.)<p>That way, the intent is clear, and the code works on big endian and little endian.  So instead of what you propose, which I imagine you might use via:<p><pre><code>  x = some_value; &#x2F;* say this is big endian, and we want it little endian, because we&#x27;re on Intel. *&#x2F;\n  uint32_t y = read_int((char *) &amp;x);\n</code></pre>\nyou&#x27;d have:<p><pre><code>  y = be32_to_cpu(x);\n</code></pre>\nNow the intent is clear, and the code is portable, x is big endian, and we want native CPU (whether that be big endian or little endian).<p>Likewise, you could write:<p><pre><code>  x = cpu_to_be32(y);\n</code></pre>\nsay before writing it out to disk or network for some purpose that requires big endian.<p>This is similar to htonl(), ntoh(), htons(), ntohs(). (host to network&#x2F;network to host long&#x2F;short).')