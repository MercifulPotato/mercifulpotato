Item(by='reverseblade2', descendants=None, kids=[25990513], score=None, time=1612197367, title=None, item_type='comment', url=None, parent=25990018, text='OP here, it&#x27;s a great question indeed! Now let&#x27;s forget about elm&#x2F;elmish but we are to write a stateful application. It doesn&#x27;t have to be a web app, just any application needs to hold some state. And that state should be modifiable (Not to mention we will have side-effects as well.) in order to do something useful but we also want to stay on the Functional programming realm to get benefit from things like immutability and other functional goodies.<p>So you see these two goals are contradictory. How FP tackles this state problem? One solution is to use actors and agents. And that&#x27;s precisely what elmish is. Unlike the conventional apps where you mutate the state directly, an agent in F# is a recursive call which can await for further messages.<p>So just like Flip Flop holds the state in memory, an agent hold the state in a recursive function. And how is this connected to elmish? Let&#x27;s see how elmish v2 is implemented:\n<a href="https:&#x2F;&#x2F;github.com&#x2F;elmish&#x2F;elmish&#x2F;blob&#x2F;5330f52153d5181923bb3cb065436748dc38231e&#x2F;src&#x2F;program.fs#L90" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;elmish&#x2F;elmish&#x2F;blob&#x2F;5330f52153d5181923bb3c...</a>\nYou can see an agent there and that&#x27;s the core of elmish.<p>So basically elm and elmish is a way to handle state changes \nin a functional manner along with side effect support via commands.<p>I cannot emphasis importance of elmish, because not only it \nhelps for isolating the state functionally but it helps you to keep your business logic separate from UI. So you don&#x27;t end up messing your code like you use React hooks or context.')