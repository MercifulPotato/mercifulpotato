Item(by='tsimionescu', descendants=None, kids=[25430172], score=None, time=1608022552, title=None, item_type='comment', url=None, parent=25423167, text='For your first example, I think most people want integer overflow to be unspecified behavior instead of undefined behavior - this is how most other languages treat it, it is how all C compilers behaved for a long time, and it is unreasonably difficult to actually write C code that makes sure not to cause integer overflow.<p>Your example is in fact perfect for why that should be the case: consider the following code:<p><pre><code>  int n = 0;\n  scanf(&quot;%d&quot;, &amp;n)\n  factorial(n); &#x2F;&#x2F;using your definition of factorial(int)\n</code></pre>\nA standard-compliant C compiler is apparently free to optimize this program to format your hard-drive.<p>For your second example, I would say that, rather than omitting the NULL check, a helpful compiler could do one of two things:<p>1. Don&#x27;t reason from strlen(s) to s != NULL, so the NULL check must be left in (unless it has even more context and can see a non-NULL assignment to s)\n2. Wherever trying to optimize away a comparison to NULL based on UB reasoning, put in a new comparison to NULL at the place you applied that reasoning. For this example, optimize the program as if it looked like this:<p><pre><code>  &#x2F;&#x2F;first, the inline version  \n  void puts_with_len(const char *s) {\n    s_len = strlen(s);\n    printf(&quot;len = %zu\\n&quot;, s_len);\n    const char* puts_arg = s == NULL ? &quot;(null)&quot; : s\n    puts(puts_arg)\n  }\n  &#x2F;&#x2F;after optimization\n  void puts_with_len(const char *s) {\n    s_len = strlen(s);\n    const char* puts_arg;\n    if (s != NULL) {\n      puts_arg = s;\n    } else {\n      puts_arg = &quot;(null)&quot;; &#x2F;&#x2F;could also explicitly signal a segfault or assert here instead\n    }\n    printf(&quot;len = %zu\\n&quot;, s_len);    \n    puts(puts_arg);\n  }\n</code></pre>\nIn this case we didn&#x27;t gain anything, but if puts_with_len were itself inlined the check would be moved further back, potentially replacing many NULL checks with a single one.<p>I would note that there is a third option here that goes in a different direction: now that compilers are extremely aggressive with NULL check removal optimizations, a lot of unsafe C functions could be made safe by manually adding the missing NULL checks to the stdlib and other major libraries. This wouldn&#x27;t affect the semantics, and it wouldn&#x27;t hurt performance assuming the optimizer really is doing its business.<p>For example, strlen() could itself raise an assertion&#x2F;exit on strlen(NULL). If called from a context where it is known that s != NULL, the null check can be optimized away by the aggressive optimizer; if not, better safe than sorry.')