Item(by='Galanwe', descendants=None, kids=[25414278], score=None, time=1607916334, title=None, item_type='comment', url=None, parent=25408494, text='I would like to be able to upvote this answer 10 times.<p>I often remember that old joke:<p>When asked to pass you the salt, 1% of developers will actually give it to you, 70% will build a machine to pass you a small object (with a XML configuration file to request the salt), and the rest will build a machine to generate machines that can pass any small object from voice command - the latter being bootstrapped by passing itself to other machines.<p>Also makes me remember the old saying<p>- junior programmer find complex solutions to simple problems<p>- senior programmers find simple solutions to simple problems, and complex solutions to complex problems<p>- great programmers find simple solutions to complex problems<p>To refocus on the original question, I often find the following misconceptions&#x2F;traps in even senior programmers architecture:<p>1) a complex problem can be solved with a declarative form of the problem + a solving engine (i.e. a framework approach). People think that complexity can be hidden in the engine, while the simple declarative DSL&#x2F;configuration that the user will input will keep things apparently simple.<p>End result:<p>The system becomes opaque for the user which has no way to understand how things work.<p>The abstraction quickly leaks in the worst possible way, the configuration file soon requires 100 obscure parameters, the DSL becomes a Turing complete language.<p>2) We have to plan for future use cases, and abstract general concepts in the implementation.<p>End result:<p>The abstraction cost is not worth it. You are dealing with a complex implementation for no reason since the potential future use cases of the system are not implemented yet.<p>3) We should factor out as much code as possible to avoid duplication.<p>End result:<p>Overly factored code is very hard to read and follow. There is a sane threshold that should not be reached in the amount of factorization. Otherwise the system becomes so spaghetti that understanding a small part requires untangling dozens and dozens of 3 lines functions.<p>---<p>When I have to argue about these topics with other developers, I often make them remember the worst codebase they had to work on.<p>Most of the time, if you work on a codebase that is _too_ simplistic and you need to add a new feature to it, it&#x27;s a breeze.<p>The hard part, is when you have an already complex system and you need to make a new feature fit in there.<p>I&#x27;d rather work on a codebase that&#x27;s too simple rather that too complex.')