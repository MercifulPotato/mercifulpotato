Item(by='tobias3', descendants=None, kids=[25222516], score=None, time=1606415796, title=None, item_type='comment', url=None, parent=25220892, text='Intuitively one should be able to approach the max speed for sequential reads via some tuning (queue&#x2F;read_ahead_kb) even with the traditional, blocking posix interface. This would require a large enough read-ahead and large enough buffer size. Not poisoning the page cache&#x2F;manually managing the page cache is an orthogonal issue and only relevant for some applications (and the additional memory copy barely makes a difference in OPs post).<p>One advantage of using high level (Linux) kernel interfaces is that this &quot;automatically&quot; gets faster with newer Linux versions without a need of large application level changes. Maybe in a few years we&#x27;ll have an extra cache layer, or it stores to persistent memory now. Linux will (slowly) improve and your application with it. This won&#x27;t happen if it is specifically tuned for Direct I&#x2F;O with Intel Optane in 2020.<p>But yeah, random IO is (currently) another issue, and as said the usual advice is to avoid them. And with the old API this still holds. If one currently wants fast random IO one needs to use io_uring&#x2F;aio (with Direct-IO) or just live with the performance not being optimal and hope that the page cache does more good than bad (like Postgresql).')