Item(by='eigenspace', descendants=None, kids=[24676833, 24679317], score=None, time=1601788444, title=None, item_type='comment', url=None, parent=24676405, text='&gt; Python will gain usecases as a meta-language as the ability to automatically wrap lower abstraction libaries improves. I see Julia eating much of Python&#x27;s lunch, then python abstracting its way over julia, just because it can.<p>A big problem for Python as a glue language is interproceedural optimizations. In many important high performance applications, you really need the compiler to be able to make optimizations that cross function barriers, often barriers between user-written and developer-written functions.<p>e.g. in differential equation solving, you can have a very fast integrator, and your user can have a very fast integrand, but if you don&#x27;t have a compiler that&#x27;s able to see and reason about both simultaneously, you&#x27;re in trouble.<p>This is why slapping Numba on a differential equation and sticking it in scipy integrators isn&#x27;t even close to julia DifferentialEquation solvers. This is a very hard problem to solve in an ecosystem where there&#x27;s so many different siloed compilers used by different Python packages. You&#x27;ll always end up paying a performance price of the context switch.<p>In julia, most things are written in pure julia, so the same compiler is seeing the entire program top to bottom. It&#x27;s very nice.<p>Furthermore, Julia has much power powerful metaprogramming facilities than Python does. It&#x27;ll eat Python&#x27;s lunch on that front too.')