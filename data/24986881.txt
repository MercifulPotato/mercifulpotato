Item(by='dwohnitmok', descendants=None, kids=None, score=None, time=1604472423, title=None, item_type='comment', url=None, parent=24978106, text='1. Isn&#x27;t that just a reflection that union types don&#x27;t form monads? I find it&#x27;s not a big deal most of the time and when it is just convert so that you have legitimate maybe types, for example like the Option type provided by Kotlin Arrow. You don&#x27;t lose type safety either way since the type system won&#x27;t let you use one in place of another.<p>2. I assume you&#x27;re talking about `do` notation (bind&#x2F;return + ap&#x2F;pure if ApplicativeDo is turned on) and `for` comprehensions (flatMap and map + filter&#x2F;filterMap if you use `if` statements) respectively? It&#x27;s a minor pain that they don&#x27;t exist, but ultimately not something that I find is a huge deal. Besides I&#x27;m not actually a huge fan of those syntaxes. They force you to rewrite code in A-normal form, which means that wrapping monadic types can cause large rewrites to your original code.<p>I much prefer an approach like Scala&#x27;s monadless (<a href="https:&#x2F;&#x2F;github.com&#x2F;monadless&#x2F;monadless" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;monadless&#x2F;monadless</a>), perhaps with additional syntactic markers indicating that this is a syntactic macro rather than a function, which does not force users to rewrite their code entirely in A-normal form. Kotlin has something similar to this (coroutines) which is what Arrow Fx uses, but again, like many other things in Kotlin, it&#x27;s hard-coded to be only one thing and cannot be generalized to other monads. However, it&#x27;s a nice middle ground for marking side effectful code and syntactically much nicer from my point of view than either do notation or for comprehensions.<p>3. Honestly pattern matching isn&#x27;t a huge deal for me. Destructuring gets me a lot of what I want and the much bigger deal is exhaustive sum type checks, which Kotlin provides in its `when` declarations. Experimental inline types are fine with me. They&#x27;re stable enough and I&#x27;ve never really regarded `AnyVal` in Scala to be any more stable (it fails in a bunch of corner cases to the point that some codebases entirely eschew it in their style guides). Opaque types in Scala 3 will hopefully fix this and Haskell&#x27;s newtypes are great. The two main differences in type systems for day-to-day code are lack of higher-kinded types and lack of typeclasses. As Elm and F# demonstrate I don&#x27;t think either are fatal blows.<p>Speaking of Scala 3 I really hope it goes well. I&#x27;m still a tad nervous about introducing indentation-based syntax since it seems like a needlessly divisive choice for little benefit, but we&#x27;ll see how it goes.')