Item(by='scottlamb', descendants=None, kids=[24678447, 24677999], score=None, time=1601787101, title=None, item_type='comment', url=None, parent=24674588, text='&gt; The % of programmers that <i>actually</i> need to know any of these numbers is tiny.<p>Context is key. This list was originally written by Jeff Dean, as noted in the credits. He&#x27;s a legendary [1] Google engineer who (usually side-by-side with the under-credited Sanjay Ghemawat) created such systems as MapReduce, GFS, Bigtable, and Spanner. I&#x27;d read &quot;numbers every programmer should know&quot; as &quot;numbers every programmer who wants to be like Jeff Dean would benefit from learning about&quot;. I can see how folks might interpret it as gatekeepingâ€”if you can&#x27;t rattle off these numbers exactly from memory, you aren&#x27;t a real programmer. I don&#x27;t think that&#x27;s the spirit in which it&#x27;s intended.<p>These numbers are useful in designing efficient systems in Google datacenters, making decisions like &quot;is it better for all of my stateless servers to keep this on local disk or to send an RPC to an in-cluster server that has it in RAM?&quot; or &quot;do I have sufficient deadline to fail over to another cluster in the 99.999%ile case?&quot; You don&#x27;t really need to have the entire list memorized, but it helps to know the appropriate operations to consider when deciding if something is suitable from efficiency and latency standpoints. It helps to have intuition for the orders of magnitude. It&#x27;s okay to look at the cheat sheet. You can do math on these numbers to get a surprisingly accurate idea of a design&#x27;s performance&#x2F;feasibility long before you work up a prototype, moving more quickly. Comparing these expectations to experiment helps you spot implementation flaws and get closer to achieving the theoretical performance. And if nothing else, being familiar with the ideas here will help you ace a Google system design interview.<p>Many of these numbers are also useful in other contexts in which performance matters and you have fairly direct control over what expensive operations are performed. (They&#x27;re less useful say in an interpreted programming language in which much happens behind your back and you may not care much about performance anyway.) It certainly wouldn&#x27;t hurt any programmer to know these numbers.<p>[1] see the &quot;Jeff Dean facts&quot; for an idea of how Google engineers view him: <a href="https:&#x2F;&#x2F;www.informatika.bg&#x2F;jeffdean" rel="nofollow">https:&#x2F;&#x2F;www.informatika.bg&#x2F;jeffdean</a>')