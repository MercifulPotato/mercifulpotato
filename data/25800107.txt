Item(by='lewisl9029', descendants=None, kids=None, score=None, time=1610772194, title=None, item_type='comment', url=None, parent=25798922, text='The fact that mutation is more ergonomic in JS and that React isn&#x27;t doing that much by default to take advantage of immutability is a fair point. But an important distinction to make is that React is actually not _able_ to take full advantage of immutability by default today in the JS ecosystem because it depends on passing around mutable JS data structures, that don&#x27;t have value equality semantics outside of primitive types like strings and numbers.<p>In the case of React wrappers in functional languages, such as ClojureScript&#x27;s Om and Reagent (and probably many others, but those are the ones I&#x27;m personally familiar with), components actually have the PureComponent optimization enabled by default. This is because deep equality checking comes for free due to value equality semantics of the underlying persistent data structures offered by the language.<p>The PureComponent optimization itself ends up becoming a much more effective global optimization in these languages, as it ends up benefiting the vast majority of use cases, whereby rerenders get optimized away as long as the _values_ getting passed around aren&#x27;t changing, regardless of how or when those values are produced.<p>Contrast that to the case with JS&#x27;s mutable data structures, where the only time when PureComponent can save you from rerendering is if no references (as opposed to values) change, which is much rarer to come across in practice (in fact they change by default for every computation you make on every render), so it&#x27;s something you end up having to deliberately optimize for (although the ergonomics of the tools for actually making these optimizations has come a long way since the class component days with hooks like useMemo and useCallback).<p>This is why PureComponent is not enabled by default as a global optimization for React in JS, because a vast majority of use cases won&#x27;t actually benefit from it. As such, the cost of actually checking for equality for every component ends up over-weighting the benefits of a tiny handful of potentially skipped renders.')