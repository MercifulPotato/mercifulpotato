Item(by='ddragon', descendants=None, kids=None, score=None, time=1603284109, title=None, item_type='comment', url=None, parent=24845965, text='It&#x27;s a form of function overloading, but works on runtime types. for example let&#x27;s say we have a Dog and Cat, both subclass of Animal. And you define f(Cat, Dog), f(Animal, Animal). In languages without multiple dispatch, if you call it with a Cat object and a Dog object it will choose the first as expected, but if you pass with two Animal objects&#x2F;pointers it will dispatch to the second regardless of what runtime values they are.<p>If the language is single dispatch though, animal1.f(animal2) will accurately call the Cat or Dog method for the first argument (before the dot), but the second argument will work like above, it will call the Animal version and not the Cat or Dog ones. If you want a method to call Cat or Dog method based on runtime information you&#x27;d have to redispatch on runtime within f(Animal), which is basically a pattern known as Visitor Pattern [1].<p>In Julia (and multiple dispatch languages) defining f(Cat, Dog) and f(Animal, Animal) means that even when I call f(animal1, animal2) the compiler will convert to the runtime values and if the first animal is Cat and the second is Dog it will call the first method (as a form of specialization) and otherwise it will go for f(Animal, Animal) (which is the more general method). And the Julia compiler is really good at inferring runtime types at compile time, so even though it&#x27;s runtime values it&#x27;s still static dispatch (that&#x27;s why it&#x27;s also fast).<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Visitor_pattern" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Visitor_pattern</a>')