Item(by='benfrederickson', descendants=None, kids=None, score=None, time=1603815836, title=None, item_type='comment', url=None, parent=24906587, text=' &gt; you can either race with the program and hope that you read its memory to get the function stack before it changes what function it&#x27;s running (and you&#x27;re likely to win the race, because C is faster than Python), or you can pause the program briefly while taking a sample.<p>Py-spy defaults to blocking because the results can be pretty wrong otherwise: <a href="https:&#x2F;&#x2F;github.com&#x2F;benfred&#x2F;py-spy&#x2F;issues&#x2F;56" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;benfred&#x2F;py-spy&#x2F;issues&#x2F;56</a> . You can see this problem profiling a program like <a href="https:&#x2F;&#x2F;github.com&#x2F;benfred&#x2F;py-spy&#x2F;blob&#x2F;master&#x2F;tests&#x2F;scripts&#x2F;recursive.py" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;benfred&#x2F;py-spy&#x2F;blob&#x2F;master&#x2F;tests&#x2F;scripts&#x2F;...</a> with or without the nonblocking flag in py-spy - the nonblocking version produces garbage output.<p>Somewhat interestingly, this problem doesn&#x27;t seem to occur with Ruby - and rbspy can get away without pausing the target program with only minor errors seen when profiling a similar function. I suspect this is because of differences between how the Ruby and Python interpreters store call stack information, but haven&#x27;t had a chance to dig into the specifics.')