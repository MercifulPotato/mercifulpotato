Item(by='chrismorgan', descendants=None, kids=[25256848], score=None, time=1606752733, title=None, item_type='comment', url=None, parent=25254137, text='For a language like Rust, exceptions wouldn’t be very nice. Actually, scratch that: for a <i>type system</i> like Rust’s (specifically, algebraic data types and static typing), exceptions aren’t very nice. Conversely, for a type system like Python’s, Rust’s result-based errors would be downright terrible.<p>I’ve steadily been concluding that, in a vacuum, result-based errors are vastly superior to exceptions for potentially-recoverable errors, but that you absolutely require static typing before the ergonomics become acceptable.<p>One important thing to also realise is that result-based errors aren’t actually incompatible with stack traces, chaining or being verbose by default, though Rust chose to eschew those features in its standard library, because it wasn’t clear (and still isn’t) exactly how it’s best to do that, especially if you’re trying to minimise cost, which a language like Rust is. That’s why there are so many experiments, such as anyhow.<p>Result-based errors is also <i>excellent</i> at some forms of composition that exceptions are completely useless for; for example, in Rust an iterator can yield results, and most file system stuff does that, so you can use things like map, filter, <i>&amp;c.</i> on the iterator—you can even collect `impl Iterator&lt;Item=Result&lt;T, E&gt;&gt;` to `Result&lt;Vec&lt;T&gt;, E&gt;`, easy early return semantics. Anything like this is not at all elegant in Python.')