Item(by='steveklabnik', descendants=None, kids=[25167643], score=None, time=1605896033, title=None, item_type='comment', url=None, parent=25162573, text='No problem. :)<p>That&#x27;s not <i>quite</i> it. It&#x27;s more about compile time vs runtime. Arc and GC are <i>runtime</i> tracking of &quot;when can this be freed.&quot; Ownership is compile-time tracking of the same. Rust has refcounted types in its standard library, but you only need to use them relatively rarely. Here&#x27;s a small example with not <i>too</i> much syntax. The core idea:<p><pre><code>    fn main() {\n        &#x2F;&#x2F; String is a heap allocated, mutate-able string type\n        let s = String::from(&quot;foo&quot;);\n        \n    } &#x2F;&#x2F; s goes out of scope here, and so will be freed here;\n      &#x2F;&#x2F; the compiler generates the code to free the heap allocation at this point\n</code></pre>\ns is the &quot;owner,&quot; and there&#x27;s only one, so this can be tracked fully at compile time.<p>Onwership can move, too. Let&#x27;s introduce a function:<p><pre><code>    fn foo(bar: String) {\n        &#x2F;&#x2F; body would go here, elided to keep this simple\n        \n    } &#x2F;&#x2F; because bar is of type &quot;String&quot;, this function &quot;takes ownership&quot; of the\n      &#x2F;&#x2F; value passed as &#x27;s&#x27;, and so the compiler will generate the code to free\n      &#x2F;&#x2F; its heap allocation at this point\n\n    fn main() {\n        let s = String::from(&quot;foo&quot;);\n        \n        &#x2F;&#x2F; we pass s to foo...\n        foo(s);\n        \n    } &#x2F;&#x2F; ... and because we did, it no longer exists in main, and the compiler\n      &#x2F;&#x2F; knows this, so no code to free the allocation is generated here. if\n      &#x2F;&#x2F; it were, this would lead to use-after-free.\n</code></pre>\nAll of this is trackable, 100%, at compile time. So there&#x27;s no runtime overhead here at all.<p>But imagine that foo() creates a new thread inside of it, and we want to access said string from inside that thread, as well as from within main. Now we have <i>multiple</i> owners, not a single one, and it&#x27;s not possible at compile time to know when the string should be freed. The simplest solution here is to reach for reference counting, and you&#x27;d end up with Arc&lt;String&gt;, that is, a String that&#x27;s wrapped in an atomic reference count.<p>(Also, references <i>don&#x27;t</i> take ownership, so if you didn&#x27;t want to have foo free its argument, you&#x27;d have it accept a reference, rather than a String directly. This would let you temporarily access the string, without freeing the backing storage when the function&#x27;s body has run its course.')