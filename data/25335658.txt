Item(by='klodolph', descendants=None, kids=[25335864], score=None, time=1607367306, title=None, item_type='comment', url=None, parent=25334510, text='&gt; How is reference counting slower than say, mark-and-sweep?<p>That’s a good question! The answer is pretty interesting. It turns out that there are a number of factors. Speaking in generalities here: reference counting touches pages precisely when you are done using them (thwarting possibly <i>multiple</i> LRU caches), and the deallocation must run interleaved with the mutator, which is a classic slowdown. Garbage collection algorithms like mark&#x2F;sweep or copying collectors can avoid writing to dead objects, can put any state needed for garbage collection in a contiguous space, and can run “all at once” so the deallocator is not constantly competing with the mutator for cache, etc.<p>And then there’s the fact that with reference counting you still have to increment &#x2F; decrement the reference count, and even if you only incref &#x2F; decref each object once, there are still faster garbage collectors out there (measured by throughput &#x2F; amortized costs).<p>This is the explanation for the empirical observation that reference counting is generally not very fast, although there are cases where it works well.<p>To get back to the original point—the claim that “Rust does use garbage collection” should not be controversial. The fact that you could beat Rust into submission until a garbage collector comes out is not really a counterargument I care to entertain.<p>&gt; Rust (like all languages) has the capability to build a mark-and-sweep collector if you need it, …<p>You would have to build a fairly primitive mark-and-sweep collector, or rely heavily on unsafe constructs. You wouldn’t be able to compete with, say, Go or Java, which insert instructions into the generated code to make concurrent garbage collection work (synchronization points).<p>You would probably be able to compete with implementations like CPython, which has stable pointers, reference counting, and uses mark-and-sweep to collect cycles.<p>&gt; You can&#x27;t accidentally get a GC pause in Rust, which is a feature.<p>It comes with tradeoffs. For example, Rust lets you leak memory, and allocation is slower than in GCed languages.<p>&gt; …and the answer is very popular and used in enterprises heavily.<p>That’s selling Java short. There are a lot of reasons why Java is popular, and explaining it in terms of OOP really doesn’t do it justice.')