Item(by='pavehawk2007', descendants=None, kids=None, score=None, time=1606860381, title=None, item_type='comment', url=None, parent=25270183, text='I don&#x27;t understand how you get that SATP is a non-leaf PTE. SATP is a register, and a fence is for memory ordering. A register is a particular kind of memory, but in this context, I do not believe the authors are talking about register memory rather than RAM itself.<p>The SFENCE.VMA instruction is used to force in-memory ordering, meaning that all loads and stores are completed or updated and marked dirty (aka invalid) so the MMU knows not to rely on its cache, as seen in the spec here: &quot;The supervisor memory-management fence instruction SFENCE.VMA is used to synchronize updates to in-memory memory-management data structures with current execution.&quot; The keyword that sticks out in my mind is &quot;in-memory&quot;. The SATP register is a register, and is not in-memory.<p>If a write to the SATP register requires a fence, then it should do so, much like how writing to the CR3 register in Intel&#x2F;AMD X86&#x2F;64 forces a flush. However, this is specifically not the behavior the authors of the specification went for to avoid one of the biggest problems with flushing every time--TLB thrashing. A fast context switch, like Linux&#x27;s 1000 HZ, would mean that a larger TLB would be no help since a context switch--even to the kernel--would force a TLB flush. Furthermore, that would nullify the 5 cases that the specification lays out which would &quot;typically&quot; require an SFENCE.VMA.<p>Additionally, the specification makes clear the reason they chose this was to improve context switch performance: &quot;We store the ASID and the page table base address in the same CSR to allow the pair to be changed atomically on a context switch. Swapping them non-atomically could pollute the old virtual address space with new translations, or vice-versa. This approach also slightly reduces the cost of a context switch.&quot; This to me means that the SATP &quot;register&quot; itself is immediate, whereas the memory addresses it points to (the PPN) is not. Otherwise, this couldn&#x27;t possibly be the case.<p>The spec goes on to state that &quot;If the new address spaceâ€™s page tables have been modified, or if an ASID is reused, it may be necessary to execute an SFENCE.VMA instruction (see Section 4.2.1) after writing satp.&quot; There is nothing I can find in the specification that states that writing to the SATP register alone necessitates an SFENCE.VMA. I also can gather from context that this is on purpose in order to preserve the TLB across context switches, which is the only reason I can tell to use ASIDs in the first place.<p>I might be wrong, and there are a ton of issues in the github repository for this specification asking for clarification on a number of other things. I&#x27;m not sure we can divine the author&#x27;s intent more than we&#x27;ve done here.')