Item(by='oconnor663', descendants=None, kids=None, score=None, time=1604543174, title=None, item_type='comment', url=None, parent=24991848, text='&gt; Let&#x27;s see if I can explain this. When you&#x27;re writing an async, multi-threaded server in using the tokio runtime, async processes can be moved between threads. This means the memory can be copied, and so you need to ... pin things? OK, that&#x27;s as much as I remember. Look in the HN comments after I publish this and I&#x27;m sure someone will explain better.<p>Ok, here&#x27;s my attempt to explain Pin. First a smidgen of background. In garbage collected languages, we can more or less say &quot;everything is a pointer&quot;. And given how garbage collection works, we can extend that a little bit to say &quot;anything can keep anything else alive, by holding onto a pointer to it.&quot; Now in C&#x2F;C++&#x2F;Rust, this is very much not the case. The most common example is if you try to return a pointer to one of your local variables. Your pointer cannot keep that variable alive, it becomes a &quot;dangling pointer&quot;, and your code definitely does not work (but might appear to for a while). Nothing new so far.<p>Now Rust comes along and decides to try to catch most of these bugs at compile time. So it makes you keep careful track of who points to what, and how long everything is planning on staying alive. As an important special case of this, one of the things Rust will essentially never let you do, is create object that holds a pointer to itself. It&#x27;s basically the same problem we just mentioned: you might try to do something like returning that object, and the original memory location you took a pointer to would be destroyed, and the pointer in the returned copy would now be dangling. It&#x27;s almost never safe, so Rust almost never allows it. That was pretty much the whole story for a while.<p>But then things got trickier. Folks started working on async, and designing the new &quot;await&quot; keyword. Like in most other languages, the goal there was that you could write something that looked a lot like a regular function, but secretly the compiler would generate some sort of struct for you, and the variables in your function would actually be the fields of that struct. (Why anyone wants to do this is a long topic, but the reason is the same as in many other languages, basically because having lots of threads is slow.) And this runs is into a very tricky problem: Having one variable point to another variable is perfectly legal. We do that all the time. You can&#x27;t write normal code without doing that. But now that variables are actually struct fields...that means we&#x27;ve got an object that points to itself. And we just said that was forbidden.<p>The solution the Rust team landed on for this problem is called Pin. When you &quot;pin&quot; an object, you&#x27;re essentially swearing that it will always stay in the same spot in memory, so that any pointers it has to itself will never become dangling. The exact way this is implemented involves a lot of Rust specifics (Pin is a struct, but Unpin is a trait), and the fact that it sits right at the boundary of safe code and unsafe code makes things trickier. But that&#x27;s the general idea of pinning: a promise that I will never move this object or copy its bits somewhere else in memory.')