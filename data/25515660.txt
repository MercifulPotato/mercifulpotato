Item(by='lmm', descendants=None, kids=[25517062, 25516005, 25516078], score=None, time=1608712367, title=None, item_type='comment', url=None, parent=25515487, text='&gt; What&#x27;s more troubling is that git can&#x27;t do some very basic stuff well, like merging branches. I mean you can do the merge, but good luck trying to revert it[+] or trying to get git to deal intelligently with non-linear history in general.<p>IME Git handles non-linear history pretty well. AFAICT any DVCS will inherently have the same problem; you can&#x27;t necessarily memory-hole the fact that the merge has happened because other people may already have your merge. What are you claiming is the &quot;right&quot; way to handle that case?<p>&gt; In theory it would be possible to work around that by everyone agreeing on a canonical first commit to start each repo with, but in practice that&#x27;s of course unlikely to happen.<p>I believe there is a known commit hash that&#x27;s there in the datamodel. So it would be possible to treat this as NIL with just changes an the UI level. I agree it&#x27;s a deficiency, though I don&#x27;t think it&#x27;s the most important problem with git (the huge inconsistencies around the staging area are much more important IMO).<p>&gt; Lastly, and not entirely unrelated: many, but no good solutions for sub-repositories.<p>I don&#x27;t think a good solution is possible, personally. The repository is the unit of history, branching, tagging and so on, and that makes for a nice model that I don&#x27;t want to change. If you have multiple repositories, it&#x27;s better to deal with them as such.')