Item(by='arghwhat', descendants=None, kids=[25862245], score=None, time=1611238419, title=None, item_type='comment', url=None, parent=25856318, text='1. Accept that printf (preferably over serial) is The One True Debugger. It is the tool you always have - if you can&#x27;t get a print over serial, you&#x27;re in too deep to use a debugger anyway.<p>2. Play around with embedded. You can use <i>an</i> arduino, but get rid of the Arduino IDE. Once you&#x27;ve ridded yourself from their weird environment and code in C, you&#x27;re pretty close to what kernel programming is: Direct hardware control, debugging over a serial console, and if you mess up you don&#x27;t get saved by a segfault.<p>You can upgrade to playing with ARM boards later if you want. Things like a Raspberry Pi can also be useful to boot random kernels you&#x27;ve built later on for HW stuff, otherwise you can use VMs. QEMU can boot a kernel file directly, which makes debugging easier.<p>3. Look at one of the tutorial for writing hello-world kernel modules. There&#x27;s also usually smaller cleanup tasks you can do to get started submitting work. Looking at Linux and FreeBSD both can be useful, and things like Plan9 have very small kernels that can be used as reference. Linux and FreeBSD are not that different. (Windows is a pain with really weird interfaces, but it can be made to work.)<p>4. Find something you want to do with the kernel or fix in it.<p>Kernel developers aren&#x27;t <i>that</i> common, so I imagine a lot of places are willing to train people. The first job I had doing kernel work was pretty open, and just threw minor stuff to begin with at me, e.g. &quot;things stopped working after kernel X.Y, figure out what happened&quot;. Bisecting, testing in VMs, printk&#x27;ing a <i>lot</i> to compare state, stuff like that. I later ended up being the owner of the kernel drivers of all our platforms, so I guess I did okay. :)')