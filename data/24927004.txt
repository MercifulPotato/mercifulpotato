Item(by='jlokier', descendants=None, kids=[24940972], score=None, time=1603943515, title=None, item_type='comment', url=None, parent=24926321, text='Thanks for the suggestions!<p>But I&#x27;ve found Coro highly reliable and effective, including under stressed and complex loads, for about 6 years.  Never found it segfaulty.  It also performed well, and the API design always impressed me with its cleanliness and good documentation.<p>Also I make extensive use of coroutine-local variables (like `thread_local` in C11) which operate at the same speed as normal `my` lexicals.  I.e. as fast as possible.  It&#x27;s just a good way that ordinary non-async modules can be trivially made async-safe, without performance loss, and without becoming tied to async or not-async (they become equally flexible for both uses, which is valuable).  (The module to make them run that fast isn&#x27;t public, but the API it relies on to work is part of Coro.  `Future::AsyncAwait` doesn&#x27;t provide the necessary API at the moment.)<p>&gt; Perl now has <a href="http:&#x2F;&#x2F;p3rl.org&#x2F;Future::AsyncAwait" rel="nofollow">http:&#x2F;&#x2F;p3rl.org&#x2F;Future::AsyncAwait</a> which is (like any async&#x2F;await system) a bit more restricted than a full coroutine but works beautifully<p>I&#x27;m not convinced.  Future::AsyncAwait is a different paradigm, and doesn&#x27;t do the things I find Coro useful for.<p>Async&#x2F;await has the &quot;function colour&quot; problem - every module that might logically &quot;block&quot; has to be re-engineered with a new, async version of the same module.  Same applies to any function which might call another to any depth in the call graph which then &quot;blocks&quot;.  People have argued that the &quot;function colour&quot; problem with async&#x2F;await isn&#x27;t really a problem.  I&#x27;d argue that it&#x27;s fine if you&#x27;ve designed around it from the start and you don&#x27;t intend to use code in both async and non-async environments.<p>That re-engineering can be done, but it&#x27;s a massive change to existing modules, and then you end up with something that can only be used in an async&#x2F;await program.<p>Whereas Coro is non-invasive.  I use the same modules in an async server <i>or</i> in a classic process-forking server (without loading Coro and no concerns about async issues), as well as standalone processes (scripts).  I choose appropriately depending on the service characteristics (e.g. async is poorly suited to some kinds of loads such as computationally heavy request processing).  Also for some things it&#x27;s good to have the confidence that comes from <i>not</i> loading any fancy stuff, e.g. in security code and standalone scripts.<p>For that dual-use functionality, as far as I can tell with Future::AsyncAwait I&#x27;d need to write two separate versions of most things.<p>It turns out a lot of things <i>might</i> call something that, via a deep and opaque call chain, might block somewhere.  E.g. any code that loads a config file when it&#x27;s first run.  Anything that uses a template, and calls out to a template compiler.  Anything that compiles and loads code lazily.  Anything that does something as trivial as stat() on a file.<p>In practice for my web stuff that means nearly everything (as you can imagine from my GP comment).  I also make heavy use of JSX-ish templates instead of custom Perl code.  It&#x27;s just cleaner, and they can be targeted to other languages, even compiled to C for speed.  Template components end up inheriting the same async properties as the server they are running in.  A page may refrence subresources, microservice calls, data fetches or file reads.  All fetched or calculated in parallel (calling other services or using multiple cores if necessary), which is good for latency.<p>There&#x27;s also a software engineering impact.  As soon as you get deep into complex logic like filesystems, and especially with memory allocation inside those, which triggers nested filesystem access, it&#x27;s just too much work to engineer everything in an async state machine way.  That&#x27;s why the Linux kernel was unable to do correct asynchronous I&#x2F;O through AIO functions for many years, and that&#x27;s why everything end up choosing threads instead of AIO in userspace too: <i>libuv</i> that you mentioned is a great example!<p>&gt; update it to more recent+reliable perl tech<p>I think &quot;reliable&quot; is misleading.  Coro is highly reliable (for me anyway), while Future::AsyncAwait has documented gotchas.<p>For &quot;more recent&quot;, the Perl community has picked its path.  In my view it&#x27;s a less useful path, and I&#x27;m disappointed Perl core didn&#x27;t choose to implement a coroutine mechanism.  But it didn&#x27;t.<p>With Coro all the modules just work without anything Coro-specific in them.  (Just a few coro-local-data annotations, which are ignored when Coro isn&#x27;t loaded.)  It&#x27;s neat!<p>As I use the same code in async and non-async contexts, I really don&#x27;t see me using Future::AsyncAwait and writing two versions of each module.<p>&gt; If you threw a github repo up somewhere I can think of a few people who might be interested<p>I never did get that framework to a point where I&#x27;m happy to publish, because it&#x27;s entangled with commercial and private code.  Cleaning up the separation seemed like a goal once, but I think I&#x27;d be wasting my time now.  It&#x27;s a great shame when you have a big personal library of Really Useful Modules, but sometimes you just have to start again.  The ideas live on!')