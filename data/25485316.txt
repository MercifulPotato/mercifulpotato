Item(by='KronisLV', descendants=None, kids=None, score=None, time=1608460983, title=None, item_type='comment', url=None, parent=25485193, text='Huh, the idea of manually downgrading the version number seems like a nice hack!<p>It does feel kind of unfortunate, however, that while containers themselves are immutable most of the time, the tags themselves will point to different images over time.<p>If you do want something like a rolling release model, where you always use &quot;:latest&quot; (or &quot;:master&quot; or &quot;:trunk&quot;, or &quot;:stable&quot; or whatever), then it feels like you&#x27;d need to constantly pull the latest versions of the image, with something like shepherd for Swarm ( <a href="https:&#x2F;&#x2F;github.com&#x2F;djmaze&#x2F;shepherd" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;djmaze&#x2F;shepherd</a> ), watchtower for regular Docker ( <a href="https:&#x2F;&#x2F;github.com&#x2F;containrrr&#x2F;watchtower" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;containrrr&#x2F;watchtower</a> ) or whatever the Kubernetes alternative is.<p>The whole DB user thing feels unfortunate, however! Especially on systems, where you have a single &quot;fat&quot; DB instance which is shared amongst different pieces of software (with separate schemas for each), as opposed to a more distributed approach, where each DB instance is separate and used by only one application.<p>Personally i&#x27;ve come to use the latter approach and run all of my DBs as containers, with bind-mounted &#x2F;var&#x2F;lib&#x2F;$DATA_DIRECTORY_FOR_DB_HERE directories, for easier data backups. Though i guess that&#x27;s also in part because i want to cap the resources available to each instance and also because i don&#x27;t trust any piece of software to let it impact others in a shared resource situation.')