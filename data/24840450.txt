Item(by='chubot', descendants=None, kids=[24842689], score=None, time=1603216773, title=None, item_type='comment', url=None, parent=24839697, text='<i>I think the reasonable take-away is that if you ever intend your language to be used for large programs, just take the hit and start off with static types. Your future self will thank you.</i><p>I think this is missing something: the creators of those languages wanted languages that were fun&#x2F;productive for writing <i>small</i> programs.  That is, extremely flexible languages (and yes maybe they were unaware back in the 90&#x27;s how this would limit their optimization potential)<p>And all big programs were once small programs.  Facebook is probably one of the easiest to see, since it was &quot;just&quot; a bunch of PHP scripts (although people tend to underestimate&#x2F;dismiss it for that reason).<p>Just like nobody ever says: &quot;Well I estimate that in 10 years Facebook will consist of 10M lines of PHP with 5,000 programers working on it -- I should probably write it in another language&quot;.<p>Nobody ever says: &quot;Well I think my language is going to be used by millions of people and will have billions of lines of code&quot;.<p>Well, there probably were people who thought that, but those were exactly the people who didn&#x27;t make languages as useful as Python and JS :)<p>----<p>That said I think the phrase &quot;irrational exuberance languages&quot; referring to Python&#x2F;JS is kinda funny, and in a way accurate ...<p><a href="https:&#x2F;&#x2F;blog.sigplan.org&#x2F;2020&#x2F;10&#x2F;12&#x2F;from-heavy-metal-to-irrational-exuberance&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.sigplan.org&#x2F;2020&#x2F;10&#x2F;12&#x2F;from-heavy-metal-to-irra...</a><p>Although again I would say the unexpected part was not that they thought single core scaling would continue forever and make their languages fast, it&#x27;s that those &quot;slow&quot; languages turned out to be the &quot;best&quot; ones for writing some of the most important systems of the last couple decades (not just commercial ones, but also Wikipedia, BitTorrent, etc.)<p>----<p>I&#x27;d make another analogy, to ISAs.  If you talk to anyone who knows about CPU design, they&#x27;ll say that x86 is shitty with a big pile of hacks.<p>&quot;It would be better&quot; if someone designed it from the beginning with current applications in mind.  But if anyone actually did that back in 1980, they wouldn&#x27;t have been successful.<p>And from my perspective, I mostly don&#x27;t care, because the C compiler makes it all work for me (although I know the people who make it work care very much).<p>So I guess the point is that technology adoption proceeds by evolution, and trying to plan 10 or 20 years ahead of time never works.<p>----<p>Also, there is a pretty hard tradeoff between static types and metaprogramming.  Recent languages have come closer to reconciling these features (Zig, Nim, D), but dynamic languages chose reflection&#x2F;metaprogramming, and that&#x27;s a primary reason why they became successful.<p>Ruby on Rails is a great example of that.  It uses Ruby metaprogramming&#x2F;reflection to a hilt, and lots of people who have no idea what that is love it, and they built tons of things with it (which now makes it an interesting optimization target)')