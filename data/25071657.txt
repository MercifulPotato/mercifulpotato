Item(by='chunkyfunky', descendants=None, kids=None, score=None, time=1605199557, title=None, item_type='comment', url=None, parent=25071365, text='Some fair points but I would disagree on the fundamental definition of the DIP. In my book it absolutely does not mean that low-level modules depend on high-level modules. That&#x27;s just high coupling turned upside down. You have to have shared abstractions as the &quot;loose coupling&quot; between modules and nothing more, to say you are adhering to the DIP.<p>Simply, this means that no implementation module, high or low, depends on any other implementation module, ever. It only ever depends on abstractions which are shared between modules.<p>I don&#x27;t see how using a DI container can change the program execution order, unless one is misusing it terribly - after all, its sole purpose is to provide the correct concrete implementation of a dependency to an object at the time of its construction, the execution order from the perspective of the program is 100% preserved. Sure, maybe the container itself creates my graph in a non-deterministic way, but why would I care? If my program depends on this that&#x27;s just bad design imo, no amount of libraries is going to save it :)<p>And the object graph is not obscured, in fact it is clarified, because you look at a class constructor and immediately can see what it&#x27;s invariants are! And I have yet to come across a DI library that wouldn&#x27;t immediately halt and catch fire if you introduced a circular dependency chain, so it&#x27;s literally not possible to have these amorphous blobs (great expression though!) in any proper DI container.')