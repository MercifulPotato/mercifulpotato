Item(by='dastbe', descendants=None, kids=[25599883, 25596060], score=None, time=1609441886, title=None, item_type='comment', url=None, parent=25595681, text='&gt; Re. size the main examples I&#x27;m looking at are SQS, Google&#x27;s Pub&#x2F;Sub etc which are pretty hard to fill up or overload.<p>It&#x27;s not the size of the queue supported by the queue service that&#x27;s the problem, it is the size of the queue in relation to the receivers capacity to process it. The infinite buffer can become a liability when your receivers are unable to handle it.<p>&gt; 1) if your messages are important, suck it up and add more subscriber processing capacity or\n&gt;\n&gt; 2) if they&#x27;re not important, purge the queue and restart your subscribers.<p>But what if things aren&#x27;t so binary? Say I have a queue of emails that have backed up because my email service (or one of its dependencies) had a multi hour outage on black friday. Some of these messages are time sensitive (&quot;We&#x27;re packing it!&quot; for a delivery that already happened) and some must be sent (&quot;Your account is being terminated, this is the last notification&quot;). You would like to discard messages like the former (which are certainly the overwhelming bulk of your messages) while making sure that you absolutely send the latter. Oh, and it turns out your email service has a fixed rate limit on your account and they won&#x27;t raise it. This stuff happens.<p>Another example I&#x27;ve seen is a queue used as a workflow system: I enqueue commands (add X to Y, ensure X is in state Z, remove W from Y) in a backing system because, right, sometimes the dependencies for doing these operations are down for a little bit. But then one day they are down for a long-time, and the automation that has been set up on top of the external API has enqueued A LOT of commands. And a lot of those commands are now useless, things like an unprocessed &quot;add X to Y&quot; when there&#x27;s a &quot;remove X from Y&quot; just a couple thousand messages later. My dependency is working to come back up to full capacity and isn&#x27;t going to give me a higher rate limit, so I need to figure out how to drain this queue faster to get back to my normal line rate.<p>Another way to put this is that queues introduce bimodal state. When the queue is empty or only experiences temporary periods of overfill, my service runs in one way and has predictable behavior. But when my queue becomes chronically overfilled, my service is in an entirely different state. This is certainly bad news for my system, but can also be bad news for adjacent parts of the greater system that expect certain behaviors out of my service.')