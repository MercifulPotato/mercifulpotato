Item(by='thu2111', descendants=None, kids=[25171505], score=None, time=1605979294, title=None, item_type='comment', url=None, parent=25170269, text='It&#x27;s gone too far though. Where I work everything is automated, even the setup of things where we only have one of them. It&#x27;s all a giant pile of Ansible scripts, some of which are sort of half maintained.<p>This kind of fanatically DevOps-y approach has a few problems:<p>1. It&#x27;s slow and expensive to develop all these scripts.<p>2. It encourages &quot;disposable infrastructure&quot; in which people think, gee, I need a test version of {very big complicated thing}, so I&#x27;ll just run these scripts and create an absurdly expensive duplicate that they then forget to shut down. You end up with a cloud filled with VMs that were used once, by one guy, for twenty minutes for a demo, and then never properly deleted.<p>3. There&#x27;s no real discoverability or way to iteratively figure out what you want with these things. If you aren&#x27;t entirely sure how to set something up, you can&#x27;t really do it by coding it because you&#x27;d end up being limited by the tools. Whereas shells and vim and such are designed for interactive work. But then once you&#x27;ve got it set up, for many tasks you hopefully don&#x27;t need to set it up again anytime soon, so at that point automation is just pointless overhead. It&#x27;d be quicker to just drop some notes in a wiki.<p>With respect to the article, it did very much remind me of the great wheel turning. I used to be an SRE at Google and I saw there two relevant trends.<p>One was that when I joined they still had some parts of the infrastructure managed by a giant Python script called the Babysitter. The Babysitter was in theory split into configuration and implementation aspects, but somehow not really. It&#x27;s dead for perhaps 12 or 13 years now so many Googlers would never have encountered it. The replacement system (Borg) used an intentionally limited configuration language, partly due to the experience of the Babysitter in which people had full programmability, and used it! But the borgcfg language rapidly started sprouting various kinds of programmability features too, and in fact one day someone demonstrated you could build Conway&#x27;s Game of Life in it. Seems like this new call to use full programming languages to create configuration is another turn of this wheel.<p>The other was hitting the limits of what was automatable. One of the tasks I had to do in my job was to set up some services in new clusters, and shut them down in old ones. This was a multi-step process that was very time consuming and annoying, so there were many attempts to automate it. Unfortunately most were unconvincing, partly because the speed at which new clusters needed to be set up was somehow sort of aligned with the speed at which the general set of tasks was itself changing. So you could attempt to automate the task, but by the time you&#x27;d finished the steps involved were already changing, so the next time you wanted to run your script it was wrong. Also: setting up clusters of hundreds of machines isn&#x27;t something that&#x27;s easy to test virtually (there were no &quot;mock datacenter&quot; libraries back then).<p>In the end, what I noticed was the big automation wins came from the infrastructure teams when they improved the underlying systems to be more robust. Us glorified sysadmins wrote a lot of scripts, but it was often hard to prove they really saved a lot of time when the cost of implementing and changing them was taken into account.')