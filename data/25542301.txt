Item(by='triska', descendants=None, kids=[25543434], score=None, time=1608974242, title=None, item_type='comment', url=None, parent=25538404, text='The key attraction of the representation I mentioned is that on the level of Prolog programs, the compactly represented lists appear like any other lists, no matter how they are internally represented. So, internally, it is a sequence of raw bytes, and to Prolog programmers, it appears as a Prolog list of characters.<p>In Haskell, as long as we are forced to use ByteString or similar data types to get this efficient representation, the situation is not as convenient: ByteString is not the same type as String, and we have to convert manually between them, i.e., within Haskell programs. So, this causes overhead for programmers: We have to learn a new type with new interfaces, call an unpack function etc. A conceptually simpler solution would be to reduce the number of different types in Haskell programs, and instead implement String (i.e., [Char]) more efficiently internally so that it can be directly used instead.<p>For comparison, in Trealla Prolog, when we write the string &quot;hello&quot;, then it is automatically <i>internally</i> represented in the efficient way as raw bytes. And on the Prolog level, it appears as a list of characters, corresponding to a String in Haskell:<p><pre><code>    ?- &quot;hello&quot; = [h,e,l,l,o].\n    true.\n</code></pre>\nTo read from files, there is a single predicate phrase_from_file&#x2F;2 that <i>internally</i> performs the mmap call. On the Prolog level, we again only see a list of characters, and we can use DCGs as usual to process them.<p>So, the key attraction is that this efficient representation is transparent to the programmer in the sense that lists that are represented in this way are semantically completely indistinguishable from lists that are represented in the naive way internally. To Prolog programs, they have the exact same type, shape, length etc., they are only represented differently internally in the virtual machine. This idea can be used in Erlang and Haskell too to represent strings.<p>Currently, SICStus Prolog is the only Prolog system that can be reliably used for linear programming with constraints and is fast enough, see its library(clpq). I hope that a free Prolog system with a similar feature set will eventually become available. Currently, Scryer Prolog is looking very promising, especially due to the mentioned efficient internal representation of characters and its strong commitment to the Prolog ISO standard. There is ongoing work on a simplex library for Scryer Prolog, please see this issue and the linked file:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog&#x2F;issues&#x2F;463" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog&#x2F;issues&#x2F;463</a><p>The library contains functionality for solving transportation and assignment problems via network flow algorithms. This sounds similar to your use case, and I hope it works for you.')