Item(by='berkes', descendants=None, kids=None, score=None, time=1608985681, title=None, item_type='comment', url=None, parent=25538466, text='There are legitimate cases for `nil`, but far less than most people allow.<p>What does &quot;user.last_login_at == nil&quot; mean? `NoMethodError `to_human_date` for `nil` in email.erb. &quot;Quick! lets fix that with a `try(:last_login_at, &quot;Never&quot;)`: if nil, it means the user never logged in.<p>You now, without proper thought, you introduced a business meaning to a missing value. Adding tight coupling, slowly painting yourself in a corner. How does this translate to &quot;Could you give me a CSV with all users that never logged in&quot;?<p>Maybe you did mean to assign such domain-meaning to &quot;last_login_at == nil&quot;, but then it is far better to explicitely do this. E.g. a `NeverLoggedInUser` subclass, a method on the model `never_logged_in?` an explicit flag in the database, or maybe even a special table &quot;inactive_users&quot; that holds these. All depending on domain-meanings, discussions, use-cases and thought. This is <i>always</i> a lot more work than just throwing another `try` at the bug. Rails &quot;rewards&quot; the bad choice, and somewhat opposes the proper solution.<p>Rails makes it easy to prototype and rapidly move forward: those are good features. But often you should, instead, be forced to halt for a second. To push you towards the whiteboard. Being able to throw in a quick `try` here, or a `sort(last_logged_in: :desc)` with another `where.not(last_logged_in: nil)` there, and so on, are a blessing when quickly moving forward. But they <i>will</i> haunt you in the future.<p>Balancing that is hard, regardless of framework, but Rails&#x27; features balance towards the &quot;moving fast&quot; a bit too often in my liking. Esp. because it rewards that team-member who &quot;Gets stuff done&quot; by abusing those &quot;quickfixes&quot;, while leaving the project with ever more technical debt etc.')