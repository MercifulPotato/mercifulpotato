Item(by='dragontamer', descendants=None, kids=[24841750, 24841780], score=None, time=1603223213, title=None, item_type='comment', url=None, parent=24841481, text='I don&#x27;t program in Go, so I can&#x27;t speak to that.<p>The fork-join model generally starts off with one-thread, often called &quot;The Single&quot; or &quot;The Master&quot;. Its where main() begins.<p>But somewhere along the line, you discover a portion of code that needs to be multithreaded. So you fork into many threads: maybe dozens of threads, or thousands in the case of SIMD or GPUs. This multithreaded portion is then &quot;joined&quot;, that is, the &quot;master&quot; thread refuses to continue until all children are done executing.<p>Lets say there&#x27;s a raytracer you are writing.<p><pre><code>    main() {\n      &#x2F;&#x2F; In the &quot;Single&quot; thread\n      Foo();\n      Bar(); \n\n      fork(doRayCastingInParallel(), 5-million); &#x2F;&#x2F; Spawns 5,000,000-threads, one for each ray\n      &#x2F;&#x2F; Implicitly wait for all 5-million threads to finish\n      \n      doSomethingElse(); \n    }\n</code></pre>\nNow, raycasting has a bunch of things to do, but you can break it up into the same steps for all 5-million threads.<p><pre><code>    doRayCastingInParallel(int myIdx){\n      doTrigonometry(ray[myIdx]);\n      findCollision(ray[myIdx]);\n      outputColor[myIdx] = calculateColors(ray[myIdx]);\n    }\n</code></pre>\nSo from both the &quot;single&quot; thread, as well as your &quot;child&quot; thread, it feels like you&#x27;re writing single-threaded code. But in actuality, your &quot;child&quot; thread is a 5-million spawned copy, executing in gross parallelism.<p>The &quot;Fork-Join&quot; model assigns a different &quot;myIdx&quot; number to each thread. So Ray#500 knows to do things differently than Ray#68121.<p>But otherwise, they run through the same code.<p>---------------<p>The important bit here is how general this mindset is. Its commonly used for GPU-programming (CPU issues a GPU command to spawn millions of threads often one-per-pixel, or even thousands per pixel). Then the CPU waits for the GPU threads to finish, and then just carries on.<p>But ISPC proved that you can use this fork-join model on SIMD units like AVX512 or SSE. Julia and Python are showing off how you can use it in higher level languages. Etc. etc.<p>OpenMP further proves that fork-join works on normal CPU threads. Maybe there&#x27;s some other CPU-threading languages (but OpenMP is the one I&#x27;m personally familiar with).')