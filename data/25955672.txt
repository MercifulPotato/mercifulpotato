Item(by='st_goliath', descendants=None, kids=[25956254, 25956951], score=None, time=1611913527, title=None, item_type='comment', url=None, parent=25953884, text='In 2017 at ELCE in Prague I saw an interesting talk by Alexander Graf (QEMU &amp; KVM developer at SuSE) which was about putting the Qemu tiny-code-generator into EDK2 (UEFI reference implementation) to run x86_64 option ROM blobs on ARM64 servers[1].<p>The main idea as I understood&#x2F;remember it was roughly this:<p>UEFI offers an abstract hardware interface to the OS, but to actually talk to the hardware it also needs drivers. To solve this issue, UEFI defines a driver interface and loads driver blobs directly from a ROM on the device itself. However, if you plug an off-the-shelf PCI card into an ARM server, this doesn&#x27;t work, because the driver blob is x86 code. For Linux this doesn&#x27;t matter, since it has its own drivers, but e.g. Grub doesn&#x27;t and if the PCI device in question is a graphics card, you are flying blind until the kernel is up.<p>So they patched their version of EDK2 to map the option ROM blobs as not-executable and when UEFI&#x2F;the bootloader tries to call into the option ROM blob, the page fault handler they installed traps that, extracts the call arguments and runs the blob through TCG. They use the same trick to catch calls from the ROM blob back into their ARM UEFI binary, extract the arguments again, do the call, convert the return values and jump back.<p>It sounds like a crazy hack, but apparently worked well enough that they could plug an Nvidia card into an ARM server and it would display the Grub boot splash screen and early printk messages.<p>[1] <a href="https:&#x2F;&#x2F;osseu17.sched.com&#x2F;event&#x2F;ByIv&#x2F;qemu-in-uefi-alexander-graf-suse" rel="nofollow">https:&#x2F;&#x2F;osseu17.sched.com&#x2F;event&#x2F;ByIv&#x2F;qemu-in-uefi-alexander-...</a>')