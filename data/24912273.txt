Item(by='brundolf', descendants=None, kids=[24913120, 24914391, 24917104, 24914257], score=None, time=1603834971, title=None, item_type='comment', url=None, parent=24910043, text='This is a good insight. So, clearly, higher-level languages have been an enormous success. But &quot;no-code&quot;, as we mean the term today, has still (mostly) been a failure.<p>So then what do we actually mean by &quot;no-code&quot; these days? I think &quot;no-code&quot;, today, has the unspoken implication of &quot;graphical&quot;. Okay, so why are &quot;graphical coding&quot; systems (languages?) mostly unsuccessful? There are some clear exceptions like Unreal Engine&#x27;s Blueprints and certain WYSIWYG web editors like Squarespace, but the great majority of programming is still done in what comes down to, at the end of the day, text files. There may be more and more elaborate editors built atop these text files, but the &quot;bones&quot; of the code is always available, and never <i>too</i> far out of reach.<p>My pet theory is that this last bit is the differentiator. In a totally graphical programming environment, the programmer never has to be exposed to the underlying format directly. This perhaps encourages proprietary stacks, where the GUI is all that&#x27;s known and the substance of the &quot;code&quot; itself may never even be made available to those who seek it out.<p>Maybe this arrangement keeps these &quot;languages&quot; siloed, and therefore keeps them from gaining real traction. It&#x27;s hard for a thriving ecosystem to evolve around a closed format. Competing tools, editors, compilers, open transfer via regular files, translation, etc are all stifled. You end up totally dependent on one company for all of your needs. For some projects the value-proposition still works out; for most it doesn&#x27;t.<p>If so, here&#x27;s my proposal: instead of focusing on all-in-one no-code environments, focus on creating graphical tooling for existing languages. Or even, creating new (text-based!) programming languages that are designed from the get-go with advanced (graphical?) tooling in mind, while still having that real, open, core source-of-truth underneath it.<p>We&#x27;ve seen echoes of this already: Rust&#x27;s features would make it nearly unusable without its (excellent) user-friendly tooling. Design apps like Sketch can output React source code. Pure-functional languages like Clojure really thrive with an editor that has inline-eval. I think if &quot;no-code&quot; is ever going to catch on for real, it needs to be less afraid of code.<p>On the other hand: is the value-add really the graphical interface, or is it the &quot;height&quot; of the language?<p>In the latter case, maybe it&#x27;s more important that we explore even-higher-level languages, and set aside the graphical part as a distraction. Or, maybe we combine the two goals: create higher-level-languages that also lend themselves to graphical UIs, but are still grounded in formalized text underneath.')