Item(by='btrask', descendants=None, kids=None, score=None, time=1602549720, title=None, item_type='comment', url=None, parent=24758462, text='Very interesting question!<p>I don&#x27;t think there is any language&#x2F;environment that does that natively.<p>What you seem to be asking for is an abstraction of processes. However the process itself is ultimately an abstraction that is made-up by operating systems.<p>For example, let&#x27;s say you call getpid(2) in your program. Then you do some &quot;async offline&quot; work, during which the process exits and is restarted. Now you have a new PID, which is not what you expected.<p>That means you need to introduce &quot;virtual PIDs&quot; that don&#x27;t change across async calls. Before long you&#x27;ve reimplemented all of libc (or equivalent).<p>Golang has had a lot of problems just making green (non-OS) threads work correctly. Any time you stray from the OS, you will have problems interfacing with it.<p>As an OS feature, I can imagine a kernel that aggressively pages out programs while they&#x27;re blocking, etc. Before long you get into philosophical questions like &quot;what does it mean for a process to be running?&quot; Usually it&#x27;s something that the OS defines, and we leave it at that. But you don&#x27;t have to, if you don&#x27;t want to.')