Item(by='dunham', descendants=None, kids=[25350094], score=None, time=1607449780, title=None, item_type='comment', url=None, parent=25340111, text='In the base definition are no numbers involved. Just S K and I, with these rewrite rules:<p><pre><code>    S x y z = x z (x z)\n    K x y = x\n    I x = x\n</code></pre>\nSo, you can think of the whole thing as a list of S K I and parenthesized sequences of S, K, and I.<p>If you see S up front, you take the next three things (call then x y and z) and put them back on in this order x y (x z).  x, y, and z are either a letter or a parenthesized sequence of letters and parentheses.<p>Note that S is the only combinator that makes the list longer.<p>If you want to think of them as functions they need to be _curried_. So they take one argument at a time and return a new function that takes the next argument.  In javascript, if &quot;(x, y) =&gt; x + y&quot; were your function, the curried version would be: &quot;x =&gt; y =&gt; x + y&quot;.<p>Expressed in javascript, our combinators are like: (but lazily evaluated)<p><pre><code>    let S = x =&gt; y =&gt; z =&gt; x(z)(y(z))\n    let K = x =&gt; y =&gt; x\n    let I = x =&gt; x\n</code></pre>\nNote for example that (K x) would be a new function that takes one more value, throws it away and returns x.  K is sometimes called the constant function.<p>True &#x2F; False are represented by building an expression that returns either the first thing that comes after it, or the second thing. So True&#x2F;False are in essence their own if statements:<p><pre><code>    T t e = t\n    F t e = e\n</code></pre>\n(I&#x27;ll call the variables t and e for &quot;then&quot; and &quot;else&quot;.)<p>So T = K, and SK will do what F is doing above, we apply it to t e and expand using the rules above to see:<p><pre><code>    S K t e = K e (t e) = e\n</code></pre>\nYou can think of this as just applying the rewrite rules above, but it sounds like you want to also think of it in terms of functions.  In which case, in the javascript notation you&#x27;re looking at:<p><pre><code>    S(K)(t)(e)\n</code></pre>\nS is applied to K to get a new function that takes two more arguments, above we wrote:<p><pre><code>    S = x =&gt; y =&gt; z =&gt; x(z)(y(z))\n</code></pre>\nso<p><pre><code>    S(K) is y =&gt; z =&gt; K(z)(K(y(z))\n</code></pre>\nApplying this to &#x27;t&#x27;, we get<p><pre><code>    S(K)(t) is z =&gt; K(z)(K(t(z))\n</code></pre>\nAnd then applying this to e:<p><pre><code>    S(K)(t)(e) is K(e)(K(t(e)))\n</code></pre>\nNow K(e) is (anything) =&gt; e, so the K(t(e)) is just thrown away.<p>This is where trying to express it in javascript gets a little wiggy.  The t(e) here might not make sense.  The K(e) function throws away the K(t(e)) but in javascript all of the arguments are evaluated before handing them to the function, so it would evaluate t(e) and then K(t(e)) before handing it K(e), where it is then ignored.<p>In the SKI calculus, recursion relies on this laziness (or you&#x27;d loop forever going down a path that would be thrown away).<p>Numbers can be expressed as functions using _Church encoding_.<p><pre><code>  Zero f x = x\n  Succ num f x = f (num f x)\n</code></pre>\nHere, Zero is 0, Succ Zero is 1, Succ (Succ Zero) is 2, etc. If you expand this out, it looks like:<p><pre><code>  Zero f x = x\n  One f x = f(x)\n  Two f x = f(f(x))\n  ...\n</code></pre>\nSo a number ends up being something that takes a function and a value and calls the function on the value that number of times.  There are ways to do addition, subtraction, multiplication, etc.<p>If you want to go deep down this rabbit hole, there was an IOCCC entry that was a simplified version of Haskell that compiled down to the SKI calculus - and it could compile itself. The process of developing it is written up here:<p><pre><code>   https:&#x2F;&#x2F;crypto.stanford.edu&#x2F;~blynn&#x2F;compiler&#x2F;\n</code></pre>\nIt&#x27;s pretty dense stuff, but fascinating.')