Item(by='martinhath', descendants=None, kids=None, score=None, time=1603276606, title=None, item_type='comment', url=None, parent=24837553, text='&gt; An extremely simple example is cross compiling. In Rust, usize is dependent on the architecture you&#x27;re compiling for. A very simple &quot;just compile and run the program, get the answer, and use it&quot; implementation of compile-time execution will produce a usize of the size of the host, not the target.<p>I get that there are non-obvious problems here, and as you say, this problem specifically has an easy fix, but I&#x27;d just like to note how Zig does this:<p><pre><code>  const std = @import(&quot;std&quot;);\n  pub fn main() anyerror!void {\n      std.debug.warn(&quot;{}\\n&quot;, .{.{\n          @sizeOf(*usize),\n          comptime @sizeOf(*usize)\n      }});\n  }\n</code></pre>\nModulo the `.{` weirdness, this probably looks familiar. By default, this prints out 8 and 8 on my system, but if I cross-compile to a 32-bit target, it prints 4 and 4.<p>&gt; It&#x27;s just that, when you start applying this super rigorously, you end up in weird places. How can you trust any behavior in a language without a specification?<p>I think this is a social issue for me; if rustc decides one day to change its behavior under my feet it feels like it&#x27;s my fault for not having written proper Rust in the first place (even if the behavior wasn&#x27;t properly defined in the first place), but if there&#x27;s crazy things going on in the compiler due to bugs (that we didn&#x27;t find, because proofs are hard), then that&#x27;s not really my fault, in a sense. And of course, if my CPU decides to run my program wrong, that can&#x27;t really be blamed on me. The end result in these three cases are all the same: the program didn&#x27;t run as expected, but the blame (I don&#x27;t want to point fingers, but this is the best word I could come up with) is different, and the probability of this happening is vastly different. I&#x27;ve never hit a CPU bug, but in the little unsafe Rust code I have written, I&#x27;ve had behavior change with a compiler update, which I&#x27;m sure is because I hit UB.<p>And for what it&#x27;s worth, I would greatly prefer Rust having a proper spec, even if that would increase turnaround time for the language evolution, just to ensure that everyone really is on the same page with respect to what the language really should and shouldn&#x27;t do. I realize that Rust would rather be careful and make sure that the decisions made are the right ones. I think it&#x27;s a fair trade-off, but I&#x27;m not sure I would have made it, if it were up to me.')