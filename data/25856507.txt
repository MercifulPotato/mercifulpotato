Item(by='KMag', descendants=None, kids=None, score=None, time=1611214995, title=None, item_type='comment', url=None, parent=25856212, text='Computed gotos are commonly used in main loops of bytecode interpreters to get a separate dispatch (indirect jump) at the end of handling each bytecode, so the CPU&#x27;s branch target buffer has a better chance of predicting the indirect jump target for the next bytecode based on the previous bytecode.  For instance, CPython&#x27;s dispatch loop uses computed goto on supported platforms, and Erlang&#x27;s BEAM VM (in non-JIT mode) uses computed branch labels to convert bytecodes into branch addresses at bytecode load time.<p>I suppose, for twice the latency, CPU designers could implement (a hash of) the previous branch address from the source instruction pointer as part of the BTB tag, similar to using the global branch history as part of the state in the branch predictor.  Presumably, the global branch history could also be used in the BTB tag to give some hint as to which bytecode we&#x27;ve just finished executing.<p>Though, where it really counts, interpreter writers are already often using computed gotos, reducing the reward to cost ratio for implementing such specialized BTB improvements.<p>On the other hand,<p><pre><code>   while (1) {\n       switch (...) {\n           ...\n       }\n  }\n</code></pre>\nis probably rare enough (and almost certainly in a hot loop) that a very specific optimization flag might be better than a syntactic extension.  Granted, an optimization flag doesn&#x27;t work for Erlang&#x27;s threaded code use case.')