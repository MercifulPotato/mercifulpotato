Item(by='raphlinus', descendants=None, kids=None, score=None, time=1607058329, title=None, item_type='comment', url=None, parent=25298521, text='This is a pretty deep topic. The best resource I&#x27;ve found is: <a href="https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2011&#x2F;07&#x2F;09&#x2F;a-trip-through-the-graphics-pipeline-2011-index&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2011&#x2F;07&#x2F;09&#x2F;a-trip-through-the-...</a><p>I&#x27;ll also do my best to answer your questions, though I won&#x27;t be able to do them justice in this space.<p>A pretty good model for GPUs is remote procedure calls. When you want to do something like draw some triangles, you call a function in the GL API on the client side, and what the driver actually does under the hood is serialize the parameters of that call into some binary sequence, then at some point that &quot;command buffer&quot; is uploaded to the GPU, and a combination of hardware and software on the GPU side decodes it and uses it to set up the hardware pipeline that actually draws a triangle.<p>There&#x27;s a lot more to it than that, obviously. A very big deal is that if you did an actual RPC for every triangle draw, it would be hopelessly inefficient. So a large part of what OpenGL drivers do is use heuristics for batching up a bunch of calls into one actual request. In OpenGL, the details of that batching, and the way the command buffer is encoded, are completely hidden from the application.<p>Shaders are basically small pieces of code that get run on the GPU hardware as part of the rendering pipeline. A vertex shader is a program that gets run every vertex in a mesh, and a fragment shader is another program that gets run for every fragment (pixel) that gets rasterized. There are other shaders that are run for other tasks, but those are the two biggies. In the early days of OpenGL, lighting calculations and so on were done by &quot;fixed function&quot; hardware, but these days it&#x27;s programmable.<p>In classic OpenGL, you call a function to compile a shader from a string containing GLSL source code, and the driver compiles it to machine language for the GPU hardware. You can use Radeon Shader Analyzer (available online at <a href="http:&#x2F;&#x2F;shader-playground.timjones.io&#x2F;" rel="nofollow">http:&#x2F;&#x2F;shader-playground.timjones.io&#x2F;</a>) to see what that assembly language looks like.<p>Even just to understand OpenGL better, it might make sense to learn about Vulkan. A good (though somewhat daunting) resource is &quot;API without Secrets: Introduction to Vulkan&quot;: <a href="https:&#x2F;&#x2F;software.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;develop&#x2F;articles&#x2F;api-without-secrets-introduction-to-vulkan-part-1.html" rel="nofollow">https:&#x2F;&#x2F;software.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;develop&#x2F;article...</a> . In Vulkan, the batching and other aspects of resource management are much more explicit and under control of the application, though other details are still abstracted by the driver. For example, there is no one standard binary format for encoding command lists. Also, instead of the driver compiling shaders all the way from source, the application is responsible for compiling the shader into an intermediate language (SPIR-V), then the driver compiles that to the actual GPU machine language.<p>There are some other low level GPU resources here: <a href="https:&#x2F;&#x2F;raphlinus.github.io&#x2F;gpu&#x2F;2020&#x2F;02&#x2F;12&#x2F;gpu-resources.html" rel="nofollow">https:&#x2F;&#x2F;raphlinus.github.io&#x2F;gpu&#x2F;2020&#x2F;02&#x2F;12&#x2F;gpu-resources.htm...</a><p>Best of luck, I find GPUs to be a fascinating journey!')