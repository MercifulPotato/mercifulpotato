Item(by='pron', descendants=None, kids=[25571872], score=None, time=1609258841, title=None, item_type='comment', url=None, parent=25570867, text='I&#x27;m saying that (1) has not been achieved even within a period of time that&#x27;s 3x Brooks&#x27;s prediction, and that (2) has been achieved as Brooks&#x27;s claimed it would. Again, don&#x27;t confuse 1986 with 1966. We had Smalltalk in 1980. In 1987 we had Perl. Everybody was using Visual Basic starting in 1991, and Python came out around the same time. The most popular &quot;fast and easy&quot; programming language we have <i>today</i> is 30 years old. We&#x27;ve been using virtually the same IDEs for over 25 years. Clojure would be immediately familiar to anyone who&#x27;s learned Scheme with SICP at school in 1980, and when I was in uni in the mid 90s, you know what the most hyped language was, the one that was thought to take over programming in a few short years? That&#x27;s right -- Haskell. Things have really changed very little <i>except</i> when it comes to the easy availability of free libraries and knowledge on the internet.<p>&gt; But again to be clear, today&#x27;s expectation of &quot;large, complex software&quot; -- has also changed<p>But most tasks cannot be achieved today 10x faster than in 1986 <i>except</i> by the one way Brooks said it might be.<p>In other words, Brooks&#x27;s prediction was incredibly prescient, and it is those who disagreed with him (and many, <i>many</i> did) who turned out to have been wrong.<p>&gt; I don&#x27;t know why we have to constantly refer to 1986<p>Because Brooks&#x27;s prediction is predicated on the thesis that improvements due to changes in programming languages and methodology mostly impact the ratio of accidental&#x2F;essential complexity, which means that we expect to see diminishing returns, i.e. a smaller improvement between 1990 and 2020 than we had between 1960 and 1990, which is exactly what we see.<p>&gt; Just that one example was 10x improvement within a decade<p>Brooks didn&#x27;t say there can&#x27;t be 10x improvements due to languages in <i>any</i> decade, only that there won&#x27;t be in the <i>following</i> decade(s), because when essential complexity is reduced, there&#x27;s less of it to reduce further. To grossly \n over-simplify his claim, yes, we did see a big difference between 1980 and 1990, but we won&#x27;t see as big a difference between 1990 and 2000. Or, in other words, he claimed that while you certainly can be 10x more productive than Assembly, you can&#x27;t be 10x more productive than Python.<p>&gt; As another example, the productivity improvement is the writing and deploying complex apps using Ruby on Rails or Javascript frameworks and deployed on AWS. That&#x27;s more than is more 10x faster than the 1990s CGI days of having C Language code writing to stdout to output HTML. Those early web apps were simpler and yet they were so utterly tedious and slow to code.<p>But that&#x27;s because the web took us <i>backward</i> at first. It was just as easy to develop and deploy a VB app connected to an Access DB in, say, 1993, as it is to develop and deploy a RoR one today. A lot of effort was spent reimplementing stuff on the web.')