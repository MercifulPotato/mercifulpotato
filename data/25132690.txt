Item(by='Ericson2314', descendants=None, kids=None, score=None, time=1605668106, title=None, item_type='comment', url=None, parent=25126531, text='The problem is type systems---be it Go, Java, Haskell[1], C++, or Rust[2]---don&#x27;t really mind if you ignore the values expressions turned into statements. All these `err` value business if having to remember to inspect and propagate.<p>The stuff Haskell and Rust do however make the type system far more aware of the issue. In Haskell, all the control flow is &quot;reified&quot; with Monads, which allows the type system (which is data-oriented) to be aware of everything and help much more. In particular, there is no way to &quot;do sequential things&quot; without also handling the errors or lots of extra work that is obvious readinng and wouldn&#x27;t happen by accident writing.<p>The situation in Rust isn&#x27;t quite as straightforward, because there are still genuine control flow operations being used. However, Sum types are still a huge help in that they properly model what is produced (<i>either</i> a success value or error value), and #[must_use] makes sure the Results aren&#x27;t ignored completely. Again, the path of least resistance is doing the right thing, and anything else is very obvious reading.<p>-------------------------<p>This is a long response, but if I could say just one thing, it&#x27;s wouldn&#x27;t programming language theory but economics. It&#x27;s important not just for Rob Pike or O&#x27;Rielly books to preach the right thing, but for the right thing to be<p>a) the easiest and shortest thing to write<p>b) the shortest and &quot;unmarked&quot; thing to read<p>Haskell and Rust succeed here, Go fails miserably.<p>-------------------------<p>[1] Thank goodness there is #[must_use], but to be fair that is linting post type checking.<p>[2] The moral equivalent of this problem in Haskell is the type of `seq`. But importantly the Monadic approach doesn&#x27;t need to use `seq`.')