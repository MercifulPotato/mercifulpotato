Item(by='neutronicus', descendants=None, kids=None, score=None, time=1601782833, title=None, item_type='comment', url=None, parent=24674826, text='If you have a hierarchy of types<p><pre><code>    struct A {vector&lt;B&gt; Children; int NChildren = 2, ...};\n    struct B {vector&lt;C&gt; Children; int NChildren = 2; ...};\n    struct C {vector&lt;D&gt; Children; int NChildren = 2; ...};\n    struct D {...)\n</code></pre>\nand a function template<p><pre><code>    template&lt;typename T&gt; T miniParser() { return T{}; }\n</code></pre>\nand you call it like<p><pre><code>    struct A;\n    recurseFillChildren&lt;A, B, C, D&gt;(A);\n</code></pre>\nIt expands into nested loops that fill the &quot;Children&quot; areas of each type with two default-constructed values of the next type down the hierarchy, until you get to D, at which point it does nothing.<p>The reason you can&#x27;t implement this in Rust is that Rust Generics (their &quot;template-y&quot; language feature) is missing a few capabilities relative to C++ templates. Namely,<p>1. They don&#x27;t operate on numbers<p>2. They have no notion of collections of types<p>Because of this, they<p>1. Can&#x27;t know that there <i>is</i> a collection of types<p>2. Can&#x27;t extract the size of the collection of types<p>This comes up in numerical code, where in C++ it is easy to write e.g. geometry code that is generic in the number of spatial dimensions, but in Rust it is a pain in the ass.')