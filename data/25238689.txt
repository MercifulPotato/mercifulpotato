Item(by='tzs', descendants=None, kids=[25239388], score=None, time=1606582707, title=None, item_type='comment', url=None, parent=25236712, text='&gt; Whatâ€™s the advantage of a formal standard when the language itself and the tools are all open source?<p>Let a, b, c be integers. Consider this statement in a language:<p><pre><code>  a = b % c\n</code></pre>\nIf b &lt; 0, c &gt; 0, is a &lt;= 0 or is a &gt;= 0? How about if b &gt; 0, c &lt; 0? How about if b &lt; 0, c &lt; 0?<p>There are three ways I might go about determining that.<p>1. I could write some test cases and run them. That will tell me what the deal is for that particular compiler on the particular OS and architecture I am compiling on&#x2F;for. It doesn&#x27;t tell me if I can count on that anywhere else. It could be that the compiler doesn&#x27;t care, and I&#x27;m simply seeing the way the underlying machine division or mod instruction works on my particular CPU.<p>If I care, then, I have to specifically write code myself to make it work the way I want, or make sure to only run my code on CPUs that work the way I want.<p>2. I could look at the source for the compiler. Suppose I see in there that it compiles it so that it will be consistent regardless of how the underlying CPU works, and it is even doing it the way I want.<p>Great, now I don&#x27;t need to write extra code. I can just use &quot;a = b % c&quot; and be done with it, right.<p>Nope. Maybe in the next release of the compiler they change this to just do whatever the underlying CPU does because that enables some optimization that they could not make when they forced one particular option for this. Then my code breaks.<p>3. I can read the language specification and see what it says about signs and modulus. If it says it will always work one specific way, I can code to that and be done with it.<p>Without a specification for language X, you cannot really write X code. You can just write code for the incompletely documented X-like language implemented by specific releases of specific X-like langauge compilers, possibly also limited to specific CPUs.')