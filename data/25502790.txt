Item(by='Geminidog', descendants=None, kids=[25504253, 25503338, 25502822, 25503149, 25503019], score=None, time=1608610680, title=None, item_type='comment', url=None, parent=25502459, text='It&#x27;s pretty simple.<p><pre><code>   x = 1\n   addSomething(y) = y + x\n</code></pre>\nThe above is not a combinator. addSomething relies on the line x = 1 and is forever tied to it. You cannot reuse addSoemthing without moving x = 1 with it. Therefore addSomething is not modular. This is the root of organizational technical debt. When logic depends on external factors it cannot be reorganized or moved.<p>This is also a big argument against OOP because OOP is basically the same exact thing with a bit of scope around it:<p><pre><code>  class B()\n     x = 1\n     addSomething(y) = y + x\n     divideSomething ...\n     b = 3\n</code></pre>\nNow addSomething can never be used without taking x=1 and everything inside B with it. It is less modular as a result.<p>A combinator is like this:<p><pre><code>  addSomething(x,y) = x + y\n</code></pre>\nfully modular and not tied to state.<p>The point free style is a bit long to explain. Another poster brought up readability and now I think I went too far with it as a recommendation, it&#x27;s like going vegan basically if you employ that style. Just stick to combinators and you get 99% of the same benefits.<p>Suffice to say the point free style eliminates the usage of all variables in your code. You are building just pipelines of pure logic without any state.<p>When you get rid of state as much as possible, your logic will not have any dependencies on state, and thus will generally be free of technical debt caused by logic being tied to dependencies.')