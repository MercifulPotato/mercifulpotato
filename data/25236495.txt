Item(by='pjmlp', descendants=None, kids=None, score=None, time=1606555603, title=None, item_type='comment', url=None, parent=25233554, text='&gt; 18&#x2F; Another &quot;magic&quot; trick is how their &quot;Swift&quot; programming language uses &quot;reference counting&quot; instead of the &quot;garbage collection&quot; in Android. They did something in their CPU to double the speed of reference counting.<p>&gt; 19&#x2F; ...even when translating x86 code, all that reference counting overhead (already more efficient than garbage collection) gets dropped in half. Yet another weird performance enhance to add to all the others.<p>Not at all, as proven by known benchmarks.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ixy-languages&#x2F;ixy-languages" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;ixy-languages&#x2F;ixy-languages</a><p>Putting refcounting in the CPU was the only way Apple managed to make it fast enough.<p>Objective-C only went with refcounting because Apple failed to make their tracing GC work flawless across frameworks with mixed compiler flags alongside C semantics, thus having the compiler automate retain&#x2F;release was a more sane option to do.<p>Likewise, Swift had a requirement to have flawless interoperability with Objective-C runtime and libraries, so the natural option was to adopt reference counting instead of a translation layer across both worlds.<p>.NET &#x2F; COM interoperability is a good example on how to integrate a tracing GC with reference counting can turn into an engineering feat.<p>Speaking of which UWP, which is 100% COM based, is somehow noticeable slower than pure Win32 applications, besides the sandboxing, the main reason is naturally AddRef&#x2F;Release everywhere.<p>Hence why C++&#x2F;WinRT as C++&#x2F;CX replacement is full of tricks, moving destruction to background threads, wrapping COM handles in stack allocations, taking advantage of constexpr.<p>So yeah, it is tricks and marketing how those tricks are sold, specially to crowds that care more about the next SPA framework release than how compilers work and CPUs work.')