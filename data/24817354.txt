Item(by='bsdubernerd', descendants=None, kids=[24821114, 24823880], score=None, time=1603024456, title=None, item_type='comment', url=None, parent=24817107, text='You don&#x27;t have direct control over caches, however if you have control over memory layout you can indirectly influence how the code performs by leveraging the proper cache sizes&#x2F;lanes. If that&#x27;s your goal, you cannot focus on program flow alone, and that&#x27;s the main point.<p>Low-level and high-performance code is not &quot;pretty&quot; by modern standards, as it often requires DMA and tight control over data placement in order to fully leverage instruction-level and hardware-level parallelism. The hardware influences how the data structure layout should be <i>first</i>, and we work on top of it. We abstract structs and containers that capture this layout, so that we can still have a readable program flow at the end.<p>In this sense, C++ can still be used as a glorified assembler, without the need to drop down to ASM for the simple stuff as your for loop: nobody wants to do that (me included). But contrarily to C, you can avoid a ton of preprocessor macros and get improved type checking, while still using ASM in selected spots if needed.<p>Your example about vector&lt;bool&gt; is not really surprising. Do you want the iterator to be efficient, or consistent? Tough choice, depending on the scenario. It&#x27;s annoying that it&#x27;s not standardized in one form or the other. I remember I was fretting over this detail over 10 years ago, but in actuality I used vector&lt;bool&gt; exactly 0 times in my career so far.<p>Again, please don&#x27;t consider this as if I was praising C++. There are _many_ areas, including lack of standardization in the stdlib area (vector&lt;bool&gt; being one of many), that I don&#x27;t like. I just want to say that it&#x27;s an incredibly versatile tool which is very hard to replace given the same constraints.')