Item(by='Jugurtha', descendants=None, kids=None, score=None, time=1612208076, title=None, item_type='comment', url=None, parent=25989720, text='This is where modular code and dependency injection are valuable. Example: one project I had interfaced with a Bluetooth Low Energy device. It didn&#x27;t follow the usual profiles and the communication protocol was sent by the manufacturer (send this sequence of bytes, this header, payload, and checksum, and you&#x27;ll get this response).<p>What I did was to turn the protocol specified in pages and pages of a PDF into a tiny YAML file containing a list of functions, their headers, request parameters, number of bytes, padding bytes. Then wrote a codec to encode a function function call with keyword arguments into a byte sequence corresponding to the function call, and vice versa: decode a byte sequence from the BLE device into a dictionary.<p>This allowed me to be able to test for several devices simply by feeding the <i>same</i> codec a different YAML file, and then feeding that instance of a codec to a device class. It also made the upgrade to newer models trivial, as in add entries to a YAML file for new functions like blood pressure, etc. I had a decorator that allowed me not to write code. The decorator used the codec in order either to transform a sequence of bytes into a dictionary, or a dictionary of keyword arguments into a sequence of bytes.<p>In addition to taking a codec instance, the device took another argument: bledevice. This device had an interface, which allowed me either to use a real BLE connection with the actual device, or a stub with the same interface as a BLE connection.<p>Which meant I could test without even having a real physical device. Which meant I could test all kinds of scenarios and transitions.<p>The gist of this is that the code was very modular. The bluetooth code handled all that was BLE related (connecting, disconnecting, scanning, reset, etc). It could be tested.<p>The codec to make parameters into byte sequences and byte sequences into parameters was isolated as well.<p>Given that, I was able to capture weird behavior that happened with a physical watch, and write a test for it.<p>The system used the actor model which was useful when facing weird exceptions and bringing new actors up again, as the devices were on customer premises and distributed geographically.<p><pre><code>  from silverwatch import BLEDevice, Codec, Watch\n  \n  conn = BLEDevice(&#x27;AA:BB:CC:DD:EE:FF&#x27;)\n  codec = Codec()\n  watch = Watch(conn, codec)\n  watch.start_ecg()\n\n\n</code></pre>\nWhat follows is part of the documentation for &quot;Testing&quot;. I spent a lot of time thinking about ways so colleagues did not have to get dirty with hardware problems. There was a binary file containing real data they could load, for exampe and a nice repr function to see the state of data collection:<p>&gt;<i>Toying with the watch is great, but what if you want to play with this code without necessarily having a BLE dongle or a physical watch? You can simply import a mock BLEDevice and inject it to Watch as you would do with a real connection.</i><p><pre><code>  &gt;&gt;&gt; from silverwatch import MockBLEDevice, Codec, Watch\n  &gt;&gt;&gt; codec = Codec()\n  &gt;&gt;&gt; conn = MockBLEDevice(&#x27;XX:XX:XX:XX:XX:XX&#x27;)\n  Started\n  Connect:  XX:XX:XX:XX:XX:XX\n  &gt;&gt;&gt; watch = Watch(conn, codec)\n  &gt;&gt;&gt; watch\n  -------------------------\n  Queues sizes:\n  -------------------------\n  Heart:            0\n  Activity:         0\n  Current Activity: 0\n  Total Activity:   0\n  Sleep:            0\n  Battery:          0\n  -------------------------\n  Raw Packets:      0\n\n</code></pre>\n&gt;<i>You can also mimick the behavior of the watch receiving packets. You can load the captured packets from packets.bin and feed them to the watch as if it had received them. Assuming you have a watch(real or mock):</i><p><pre><code>  &gt;&gt;&gt; from silverwatch import dispatch_packets, load_raw\n  &gt;&gt;&gt; packets = load_raw(&#x27;packets.bin&#x27;)\n  &gt;&gt;&gt; dispatch_packets(watch, packets)\n  &gt;&gt;&gt; watch\n  -------------------------\n  Queues sizes:\n  -------------------------\n  Heart:              1487\n  Activity:           26646\n  Current Activity:   99\n  Total Activity:     85\n  Sleep:              1688\n  Battery:            58\n  -------------------------\n  Raw Packets:        0</code></pre>')