Item(by='hajile', descendants=None, kids=[24840230], score=None, time=1603208134, title=None, item_type='comment', url=None, parent=24836188, text='`__proto__` doesn&#x27;t necessarily equal `.prototype`.<p><pre><code>    var foo = Object.create(null)\n    &#x2F;&#x2F;now foo.prototype and foo.__proto__ are both undefined\n    foo.prototype = {abc:123}\n    &#x2F;&#x2F;foo.__proto__ is still undefined. Need to use Object.setPrototypeOf()\n</code></pre>\nIn older JS code, I&#x27;ve seen people trying to abuse prototypes. One result in this kind of thing is often retaining references to those hidden `__proto__` leading to memory leaks.<p>Also, `__proto__` is deprecated. If you&#x27;re writing JS, you should be using `.getPrototypeOf()` instead.<p>&gt; Could you please expand this part? &quot;Primitive&quot; has specific meaning in JavaScript.<p><pre><code>    var fn = function () {}\n    fn.bar = &quot;abc&quot;\n\n    Object.keys(fn) &#x2F;&#x2F;=&gt; [&quot;bar&quot;]\n\n    &#x2F;&#x2F;likewise\n    (1).__proto__ === Number.prototype &#x2F;&#x2F;=&gt; true\n</code></pre>\nJS is torn on the idea of whether something is primitive or an object. You see this (for example) in Typescript with the primitive number being different from the Number type which represents a number object. To get at the primitive, you must actually call `.valueOf()` which returns the primitive in question. Meanwhile, you can attach your own properties to the function object -- a fact exploited by many, many libraries including modern ones like React. You can also add your own `.valueOf()` to allow your code to better interact with JS operators, but I believe that to pretty much always be a bad practice.')