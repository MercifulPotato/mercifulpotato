Item(by='ddragon', descendants=None, kids=None, score=None, time=1603760971, title=None, item_type='comment', url=None, parent=24901884, text='&quot;Ever&quot; could be a very long time, and lots of things can happen.<p>For example it might be possible to AoT compile parts of the code (as long as the types are fully defined) to export as a standalone library, and if that happens it would be beneficial to write the number crunching libraries for glue languages in Julia. I mean, there are already those (like DiffEq to Python and R), but if it&#x27;s a binary that could have just as easily come from C it would be even better. And there are already works along this path, including for wasm deployment.<p>The multithreading in Julia is very fast and easy to use, and I&#x27;m sure it will become robust and safer as well as the language gets older, which can very well allow for an Akka style framework that allow for large software with both high reliability (thanks to stuff like supervision trees) and structured code (since like Julia&#x27;s ecosystem design favors small libraries composing with each other, the future of large Julia codebases could become the composition of many small high level but fast actors).<p>There is also lots of interests in work-arounds on the garbage collector, like improved support to immutable structures (like 1.5 improvements on structs with references to mutable structures). It&#x27;s possible that you might be able to more reliably write parts of the code that do not allocate (or allocate in predictable ways), so you&#x27;ll be even handle those realtime code loops.<p>Sure this is very speculative, but look at Python today compared to when it had Julia&#x27;s age. It took 8 years since Julia became public to get to this point (2 years since it got the first stable release, 1 year since it got it&#x27;s multithreading model), it will surely be different when it has triple that age.')