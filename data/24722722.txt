Item(by='Const-me', descendants=None, kids=None, score=None, time=1602184616, title=None, item_type='comment', url=None, parent=24722370, text='&gt; iirc they all link against something that has a BLAS&#x2F;LAPACK API<p>Eigen can consume these I think, but they are optional. It has it’s own implementation of these, written in manually vectorized C++, with intrinsics, up to and including AVX512 (controlled with macros). For parallelization it uses OpenMP provided by the compiler (also controlled with a macro).<p>&gt; Has that changed?<p>It’s hard to directly compare Eigen to the rest of them. They don’t do the same thing.<p>One feature of Eigen is lazy evaluation. Expressions like a+b or a×b don’t return another matrix or vector; they return a placeholder object that only computes something on assignment. For complicated expressions this can be a huge win, e.g. r=a+b+c+d will read from a,b,c,d, compute sum of the 4 on the fly, and write into r without temporary copies in memory.<p>However, also makes Eigen’s source code outright scary, and hard to debug or optimize.<p>Anyway, based on the old pics there <a href="http:&#x2F;&#x2F;eigen.tuxfamily.org&#x2F;index.php?title=Benchmark" rel="nofollow">http:&#x2F;&#x2F;eigen.tuxfamily.org&#x2F;index.php?title=Benchmark</a> they are more or less comparable. Things like alpha·X+beta·Y were much faster in Eigen (probably due to that lazy evaluation thing), Hessenberg was much faster in MKL, in general they are close.')