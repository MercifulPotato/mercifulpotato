Item(by='tastyminerals2', descendants=None, kids=[24987840, 24987862, 24988285, 24988373], score=None, time=1604484436, title=None, item_type='comment', url=None, parent=24986774, text='Scala is weird. Sometimes it feels fluid and effortless but sometimes it simply cannot do things you would expect it to. For example, chaining custom methods. Why is it possible to do &quot;arr.map(_.nonEmpty).filter(a =&gt; a % 2)&quot; but not possible &quot;arr.map(_.nonEmpty).myCustomFilter(_)&quot;? In D thanks to UFCS and Properties you can chain all kinds of std and custom stuff together which looks more &quot;efforless&quot; and FP in my eyes.<p>Syntax aside I find Scala code hard to read due to how much implicitness it allows which stems from its &quot;do FP or die&quot; attitude which is again, weird for a language <i></i>designed<i></i> to incorporate both OOP and FP. Should I mention that in this regard D does a better job at serving the both worlds?<p>And finally, which threw me off completely is a real world case where we had to implement a word-entropy based algorithm to process tons of textual data and it appeared to be not much faster than a Python version despite all the optimization we tried to do. Scala is fast but there are many faster languages including Java itself. Considering the fact that its compiling times force you to leave your seat for a cup of coffee, you&#x27;d rather think of investing into another hard FP friendly language like Rust which simply has a wider applicability area. But yeah, this is all speculative but if you are thinking about what next language to pick up, these things start to matter.<p>Where Scala fits nicely is a small team which needs to build some business logic on top of the existing Java backend stack quickly and have a reliable working system. This is where it really shines. Scala provides a nice layer for JVM devs who have a soft spot for FP, safe and elegant solutions.')