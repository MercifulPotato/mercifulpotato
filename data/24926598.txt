Item(by='Ericson2314', descendants=None, kids=[24926736], score=None, time=1603939885, title=None, item_type='comment', url=None, parent=24926035, text='&gt; Nix and Bazel solve different problems.<p>I think both sides want to erase that difference, and I commend them for it.<p>&gt; I&#x27;m not sure exactly what you mean by synchronicity, but that&#x27;s basically how e.g. package-lock.json works... it&#x27;s the direction that everything is moving in, and Bazel is a target because it&#x27;s imposing this on new frontiers rather than just being a new language where &quot;things work that way&quot;.<p>package-lock.json stuff is fine, and Nix has long required that everything be locked.<p>That is the good synchronicity: it&#x27;s OK if upstream moves faster, downstream catches up and just pins whatever they are using. You can see how upgrade waves cascade downstream, this is because the sychronizing is <i>local</i>.<p>The internal good model is everything just lives in one repro and must update all at once. This is global synchronicity.<p>----<p>It&#x27;s a lot like 1 giant lock vs Multiversion concurrency control. The MVCC aspect is that there may be a few versions in flight as things cascade down, but old versions should be retired (like committed transactions) as new ones come.<p>The consistency is basically the pinning; nevermind what other transactions&#x2F;development is going one elsewhere, each package sees a consistent view as structured by the pins.<p>If you go listen to Google people talk about dependency&#x2F;version management. It&#x27;s like they think it&#x27;s global lock vs inconsistency. Monorepo or chaos. This false choice irks me.<p>I guess their dev tools people should talk to their DB people?')