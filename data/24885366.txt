Item(by='Twisol', descendants=None, kids=[24894292], score=None, time=1603623737, title=None, item_type='comment', url=None, parent=24885139, text='&gt; You still have to pass your logging code to every function that does logging right?<p>Yes, but no. Again, there are functional patterns you can apply.<p>First, functional programs tend to be more horizontally composed than vertically. Side effects usually happen at the same &quot;level&quot; of the application, rather than occuring at multiple depths. So the need to thread logging apparati is already reduced, simply because logging only happens higher up in the application.<p>Second, because side-effects only really occur at this thin layer, you can capture logging as a monadic action, avoiding the need to explicitly thread the logger state around. (This is the same situation as the &quot;thread the world&quot; problem we discussed earlier.)<p>Third, because so much more of your program is pure, it is much easier to perform unit tests and check assertions in other ways. At that level, logging is a bandaid over poor testing and assurance, not a goal in itself.<p>Finally, if you do find yourself deep down-stack with a need to perform some kind of side-effect, you can apply logical methods (a la LVars, CRDTs) to give a stateful interaction between separated parts of your program. The Haxl paper [0] is a good example of this: most of the design is pure functional, but for the part that involve an interaction not easily captured by the fundamental call-return &#x2F; request-response pattern, they utilize monotonic state to maintain a registry of fulfilled and unfulfilled requests.<p>[0] <a href="https:&#x2F;&#x2F;simonmar.github.io&#x2F;bib&#x2F;papers&#x2F;haxl-icfp14.pdf" rel="nofollow">https:&#x2F;&#x2F;simonmar.github.io&#x2F;bib&#x2F;papers&#x2F;haxl-icfp14.pdf</a><p>&gt; It&#x27;s rigorously correct, but I feel like it&#x27;s a step too far for most programs.<p>I feel you&#x27;re being too dismissive. There is an entire community of developers -- many of whom operate in industry -- who can and do effectively solve the problems you are raising.<p>&quot;Rigorously correct&quot; is one of those things non-FP folks think FP is about. You can write buggy code in any paradigm. What people like about FP is that it&#x27;s easier to reason about, and it&#x27;s generally easier to find precise abstractions that support that kind of reasoning. &quot;Rigorously correct&quot; is missing the point.')