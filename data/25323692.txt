Item(by='bertylicious', descendants=None, kids=None, score=None, time=1607265309, title=None, item_type='comment', url=None, parent=25323685, text='I&#x27;ve been anxious about posting this here for weeks now. I figured that it&#x27;s too niche or too trivial to be interesting. But today I saw a CSS file hitting the frontpage so I guess I just worried to much.<p>The idea is simple and functionally it doesn&#x27;t look like much. Yet I&#x27;m quite proud of it, because the implementation was much more difficult than expected for a couple of reasons.<p>Fighting the Visual Studio SDK: even though the VSSDK is super-powerful, some parts of it (especially CodeLenses) are very poorly documented.<p>UI styling: the VS team went out of their way to prevent extension developers from re-using the VS styles. They actually don&#x27;t want extensions to look like VS for CI reasons. It took days of trying random stuff and digging through the VS DLLs until I found what I needed. I&#x27;m not even sure this was entirely legal.<p>Finding the IL for the code-lensed method: this sounded so easy in my head at first. VS&#x2F;Roslyn gives you a <i>MethodSymbol</i> of the code-lensed method, I&#x27;ll just have to find it&#x27;s <i>MethodDefinition</i> in a Mono.Cecil <i>AssemblyDefinition</i> by name. But C# allows method overloading and suddenly I had to cook up a non-trivial matching logic that can resolve overloads without breaking my fingers or brain. Overloads can become arbitrarily complex (e.g. <i>Foo&lt;T&gt;(List&lt;T[]&gt;)</i>, <i>Foo&lt;T&gt;(List&lt;List&lt;T&gt;&gt;)</i>) and of top of that the types that have to be matched with one another (<i>MethodSymbol</i>s and <i>MethodDefinition</i>s) are structured differently in non-obvious ways.<p>Unit-testing the overload-resolution: in order not go insane, I had to have unit tests for the above. The idea for those was that each test gets the Roslyn <i>MethodSymbol</i> of a specific dummy C# method and then checks if the overload resolution can uniquely identify it in the Mono.Cecil <i>AssemblyDefinition</i> of the test data assembly where that dummy method is defined. Loading the test data assembly with Roslyn is easy enough, but how to get a specific <i>MethodSymbol</i>? If you only use the method&#x27;s name, you&#x27;d have to deal with overloads again, only this time on the Roslyn side. The solution was to have a special selector method which takes a lambda calling the dummy method. The selector method would then use Roslyn to analyze the test&#x27;s syntax tree, locate it&#x27;s own call in the test case, grab the lambda argument passed to it, and then return the <i>MethodSymbol</i> of the dummy method referenced by that lambda. Pretty nifty, I think, but I later found it would have been easier to write only a single test case that just iterates over all <i>MethodSymbol</i>s in the test data assembly and tries to resolve them using the matching logic. However, the disadvantage of that approach is that such a test case would lack focus and it would be harder to pinpoint what exactly went wrong when the test case fails.')