Item(by='ml_thoughts', descendants=None, kids=None, score=None, time=1609029641, title=None, item_type='comment', url=None, parent=25546787, text='This code seems to somewhat re-create effect, except noise is symmetric at both sides (also true of the xkcd-style plot in this article, actually). Plot: <a href="https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;dGZyylf" rel="nofollow">https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;dGZyylf</a><p>It seems a crucial piece of context is that there is some correlation between perceived and actual performance. There also is a global optimistic bias, apparently across experiments people perceive their rank is in the 66th percentile, so this universal effect leaves more room for error on the under-performing people while the highly-performing people are going to end up closer to that 66th percentile tautologically, and bounded above by smaller amount of space.<p><pre><code>  import random\n  import numpy as np\n\n  np.random.seed(seed=12345)\n\n  from scipy.linalg import eigh, cholesky\n  from scipy.stats import norm\n  from matplotlib import pyplot as plt\n\n  #Draw correlated random variables\n  #Ref here: https:&#x2F;&#x2F;scipy-cookbook.readthedocs.io&#x2F;items&#x2F;CorrelatedRandomSamples.html\n\n  num_samples = 125 * 4                 #\n  x = norm.rvs(size=(2, num_samples)) # uncorrelated random normal variables\n\n  expected_correlation = np.array([[1.0, 0.19], [0.19, 1.0]])\n  c = cholesky(expected_correlation, lower=True) #there&#x27;s a slight correlation of R = 0.19 between actual and perceived scores (according to Ackerman, 2002)\n\n  trans_x = np.dot(c, x)\n\n  #perceived &#x2F; actual readings with R=0.19\n  perceived = trans_x[0, :]\n  actual = trans_x[1, :]\n\n  #Sort both variables by actual scores.\n  sort_by_actual = sorted(range(num_samples), key = lambda idx: actual[idx])\n\n  perceived_by_actual = [perceived[i] for i in sort_by_actual]\n  actual_by_actual = [actual[i] for i in sort_by_actual]\n\n  quartile_indices = [i * (num_samples &#x2F;&#x2F; 4) for i in range(5)] #note: depends on divisiblity by four\n\n  x_coords = [xx &#x2F;&#x2F; 2 for xx in quartile_indices[1:]] #mid-points just for plotting\n  perceived_means = [np.mean(perceived_by_actual[start:end]) for (start, end) in zip(quartile_indices[:-1], quartile_indices[1:])]\n  actual_means = [np.mean(actual_by_actual[start:end]) for (start, end) in zip(quartile_indices[:-1], quartile_indices[1:])]\n\n  #Plot\n  fig = plt.figure()\n\n  ax1 = fig.add_subplot(111)\n  plt.title(&quot;Dunning-Kruger&quot;)\n\n  ax1.scatter(x_coords, perceived_means, marker=&quot;s&quot;, label=&quot;perceived&quot;)\n  ax1.scatter(x_coords, actual_means, marker=&quot;o&quot;, label=&quot;true&quot;)\n  ax1.legend()\n\n  plt.show()</code></pre>')