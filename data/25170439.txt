Item(by='dahart', descendants=None, kids=[25171071], score=None, time=1605975102, title=None, item_type='comment', url=None, parent=25169666, text='This is a great point, that APIs often abstract over things that some people need finer grained control over. I work on an API that was too high level, and was recently overhauled in a backward incompatible way due to the limits inherent in the abstractions, limits and abstractions that most of the time are a good idea, but were getting in the way of professionals. So I’m inclined to agree on one hand.<p>On the other hand, the OS filesystem APIs are detailed enough for most people (and even for most of the OS internals too). I’ve never wanted to know sector sizes or power loss characteristics for any reason other than curiosity. The needs of SQLite aren’t very common. Most developers writing code to use the filesystem don’t need (or even want) to know if a file was renamed or what happened to it before last reboot or whether it can be mmap()ed with other processes. I can barely manage to use rsync, and if I was burdened with these things whenever I need to open or write a file, I’d use SQLite as my API instead of fopen(), which puts me right back at using a high level API (<a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;whentouse.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;whentouse.html</a>).<p>All APIs present an interface over the resources they manage, so an abstraction is inherent, even if the API is low level. But usually part of the goal of API design is to make the interface easier to use than the resources it manages. If we expose an API that is too low level, then we compromise on usability and safety for everyone in favor of performance and detailed control for a very small minority of users.<p>So personally, I think I agree with your general concern in the sense that API designers should be aware of the needs of who they’re designing for, but I also think SQLite and the Linux filesystem aren’t a good example.')