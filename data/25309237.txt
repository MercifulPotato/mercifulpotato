Item(by='ryani', descendants=None, kids=None, score=None, time=1607121479, title=None, item_type='comment', url=None, parent=25294912, text='So the goal of futures is to deal with inversion of control.<p>The code you want to write is something like:<p><pre><code>  fn f( filename ) {\n    val someUrl = computeTheUrl();\n    val data = await http.get( someUrl );\n    val processedData = process(Data);\n    await filesystem.writeFile( filename, processedData );\n  }\n</code></pre>\n(I&#x27;m marking &quot;potentially blocking&quot; calls with &quot;await&quot; here)<p>But the code you want to <i>run</i> is an event loop:<p><pre><code>  while( program_is_running() ) {\n      poll_io()\n      poll_network()\n      run_ready_tasks()\n  }\n</code></pre>\nSo can you do to let you write f()?  You need to invert the control between run_ready_tasks() and f().  And you need to do so in a way that allows f() to both do network io, disk io, and other blocking tasks.<p>You&#x27;re right that you can use a green thread per task to solve this problem, and &quot;await&quot; is then just a function that switches context to the scheduler.  For various reasons, the Rust community decided that green threads were too heavy of an abstraction, and instead the compiler generates state machines (which are, in some ways, equivalent to green threads if you squint hard enough).<p>&gt; if a future is inert, how can it ever detect that it is ready to make progress and call wake?<p>The future doesn&#x27;t.  When the future makes a blocking call, it needs to push its waker into some data structure handled by the top level event loop &#x2F; scheduler.  And then the job of the waker is to understand how to push the task back into the ready queue when whatever was being waited on completes.<p>The complications in Rust&#x27;s design is due to their goal of making it so those compiler-generated-state-machines can be used by a library runtime -- to not require a particular standard library.')