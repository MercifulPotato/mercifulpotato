Item(by='mlthoughts2018', descendants=None, kids=None, score=None, time=1608426103, title=None, item_type='comment', url=None, parent=25477979, text='No, mocks should be used for any kind of external dependency, whether it is the external OS system calls, built in library functions that interface with sockets, databases, etc. It’s not about whether the resource you are patching is easy &#x2F; hard to deal with, for example the pytest built in fixture tmpdir abstracts this patching for temporary directories and filesystem ops even though that stuff is “easy” and behaves. Anytime you rely on something outside the runtime environment (even if through a stdlib) you should patch it.<p>You should have a completely different set of tests (integration tests &#x2F; end to end tests) that exercises important <i>unmocked</i> validation points. And your test runner should allow you to seamlessly switch between the two sets or combine them.<p>For example, use @pytest.mark.integration to distinguish all tests needed unmocked dependencies, and have some “integration-tests.ini” config for that.<p>Then “pytest” runs all the tests with mocks (runs fast, tests logical correctness with tight feedback) and “pytest -c integration-tests.ini” runs all tests or runs the subset requiring real third party resource access. It can run slower, sometimes fail for flaky reasons like network blip, etc.')