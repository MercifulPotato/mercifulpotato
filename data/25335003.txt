Item(by='PaulDavisThe1st', descendants=None, kids=[25336207], score=None, time=1607364652, title=None, item_type='comment', url=None, parent=25330609, text='&gt; A great example of this is the fact that we still use the metaphor of files and folders for organizing our source code.<p>I think there&#x27;s something akin to a category error here.<p>First, let&#x27;s agree that we do want to <i>organize</i> our source code to some degree. There are chunks of source code (on whatever scale you prefer: libraries, objects, concepts etc) thare are related to each other more than they are related to other chunks. The implementation of &quot;an object&quot; for example consists of a set of chunks that are more closely related to each other than they are to any chunk from the implementation of a different object.<p>So we have some notion of conceptual proximity for source code.<p>Now combine that with just one thing: scrolling. Sure, sometimes when I&#x27;m working on code I want to just jump to the definition of something, and when I want to do that, I really don&#x27;t care what the underlying organization of the bytes that make up the source code.<p>But scrolling is important too. Remove the ability to scroll through a groups of conceptually proximal code chunks and I think you seriously damage the ability of a programmer to interact in fundamentally useful ways with the code.<p>So, we want the bytes that represent a group of conceptually proximal code chunks to be scrollable, at least as one option in a set of options about how we might navigate the source code.<p>Certainly, one could take an AST and &quot;render&quot; some part of it as a scrollable display.<p>But what&#x27;s another name for &quot;scrollable bytes&quot;? Yes, you&#x27;ve guessed it: we call it a file.<p>Now, rendering some subset of the AST would make sense if there were many different ways of putting together a &quot;scroll&quot; (semantically, not implementation). But I would suggest that actually, there are not. I&#x27;d be delighted to hear that I&#x27;m wrong.<p>I think there&#x27;s a solid case for programming tools making it completely trivial to jump around from point to point in the code based, driven by multiple different questions. Doing that well would tend to decouple the programmer&#x27;s view of the source as &quot;a bunch of files&quot; from whatever the underlying reality is.<p>But ... I haven&#x27;t even mentioned build systems yet. Given how computers actually work, the end result of a build is ... a set of files. Any build system&#x27;s core function is to take some input and generate a set of <i>files</i> (possibly just one, possibly many more). There&#x27;s no requirement that the input also be a set of files, but for many reasons, it is hellishly convenient that the basic metaphor of &quot;file in &#x2F; file out&quot; used by some many steps in a build process tends to lead to the inputs to the build process also being files.')