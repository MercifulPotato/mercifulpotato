Item(by='Cthulhu_', descendants=None, kids=None, score=None, time=1604999753, title=None, item_type='comment', url=None, parent=25042395, text='Plus - at least so far - it hasn&#x27;t aged; they are reluctant to make backwards-incompatible changes, and right now they&#x27;re really humming and harring about whether or not to add generics. The biggest changes you&#x27;ll see in Go codebases from 10 years ago vs modern will be Go&#x27;s module system &#x2F; dependency management and the `context` package sprinkled as an argument to some of the API methods.<p>Compare that to other languages (from the top of my head, don&#x27;t pin me down on details or inaccuracies please):<p>- Java: Added generics, annotations, lambda expressions and streams, new date&#x2F;time libraries, modules, switch expressions and multiline strings.<p>- PHP: Added classes, types, null coalescing operator, etc<p>- Javascript: Classes, ES6 features (arrow functions), imports, and offshoots like Flow, Typescript.<p>- Obj-C &#x2F; Swift; ARC, Swift itself (4 versions), I haven&#x27;t been up to date with this much.<p>TL;DR, most languages really shift over time, often &#x27;borrowing&#x27; features from other languages, but Go resists these changes because it&#x27;s intended to still be read and compile in ten, twenty years&#x27; time.<p>Personally, I&#x27;m working on a management interface for a network application; the existing UI has been around since 2012, I&#x27;m trying to build this to last at least as long, probably longer, and I think Go is a great choice for it. The old application was built in PHP 5.2, which is vastly outdated now (and updating is challenging because on the one hand, the versions of RHEL used in production don&#x27;t supply newer packages, and on the other there&#x27;s 65K lines of badly written PHP that would likely need to be updated).<p>Conversely, the new Go back-end is standalone and self-contained, I try and maintain the habit of updating the Go version and all dependencies monthly; so far I&#x27;ve never had to make any code changes or had to rethink my architecture because of Go adding a new (architectural) feature. (I probably have the benefit that it started after `context` and the module system were in place though). I feel a lot more confident in its future proof-ness. And I feel confident that anyone looking at the code can maintain it, although that said I&#x27;m cautious about the more magic parts like GORM, which I should probably swap out with lower-level SQL at some point but I don&#x27;t really want to.')