Item(by='alquemist', descendants=None, kids=None, score=None, time=1606830118, title=None, item_type='comment', url=None, parent=25264102, text='Thanks. Then the &#x27;bad&#x27; code should look something like:<p><pre><code>    &#x2F;&#x2F; bad\n    NotifyIcon CreateNotifyIcon()\n    {\n      NotifyIcon icon = new NotifyIcon();\n      icon.Text = &quot;Blah blah blah&quot;;\n      system.Display(icon);\n      icon.Icon = new Icon(GetType(), &quot;cool.ico&quot;);\n      return icon;\n    }\n</code></pre>\nWhich would make noticing the coding error quite a bit easier, as we are passing an obviously incompletely initialized object to a third party. As presented, the code presumably is intended to be used like so:<p><pre><code>    NotifyIcon icon = CreateNotifyIcon();\n    system.Display(icon);\n</code></pre>\nwhich works in both versions. If &#x27;icon.Icon = new Icon(GetType(), &quot;cool.ico&quot;);&#x27; throws, then the NotifyIcon is never displayed.<p>As presented, this is hardly an argument that explicit error passing code is better at detecting bad code than exception based code. His other article, <a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20040422-00&#x2F;?p=39683" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20040422-00&#x2F;?p=39...</a>, is making the point a bit more clearly.<p>The point itself is half-sound. While it is true that with exception based code, it is hard to distinguish which statements may fail, the real issue is about correctly releasing resources. Assume that <i>every</i> statement can fail, and use some form RAII to manage resource cleanup. The exact content of RAII is hard to glean in both explicit error code and exception based code, as it depends on how the specific third party API acquires&#x2F;releases resources. Though APIs <i>can</i> be organized to essentially force the use of RAII, even if popular but ancient APIs like POSIX file system are not designed that way.<p>The real language design issue is that Java&#x2F;C# mechanism for running cleanup code &#x27;try {} finally {}&#x27; a. fails to pass through a handle to the resource that needs cleanup and b. is not scoping the lifetime of the resource that needs cleanup. Furthermore, the standard API makes no effort to provide RAII constructs for correctly managing resource lifetimes. Those language ecosystems actively steer people towards writing bad code. Exceptions may be fine, but the lack of language supported RAII is definitely poor language design. For better language design, exception based Python offers &#x27;with&#x27; mechanism and error code based Golang offers &#x27;defer&#x27;.<p><a href="https:&#x2F;&#x2F;www.python.org&#x2F;dev&#x2F;peps&#x2F;pep-0343" rel="nofollow">https:&#x2F;&#x2F;www.python.org&#x2F;dev&#x2F;peps&#x2F;pep-0343</a><p><a href="https:&#x2F;&#x2F;golang.org&#x2F;ref&#x2F;spec#Defer_statements" rel="nofollow">https:&#x2F;&#x2F;golang.org&#x2F;ref&#x2F;spec#Defer_statements</a>')