Item(by='jermd', descendants=None, kids=None, score=None, time=1610236283, title=None, item_type='comment', url=None, parent=25706117, text='You&#x27;re right there are other use cases besides microservices. For me, the other exciting application is to use Tuna in an analytics tool. The beauty would be that you don&#x27;t have to use any query language to analyze large datasets.<p>With regards to orchestration, I hope to add primitives for events, batch processing, and things like that.<p>Make sure I understand your question correctly: You&#x27;re asking how updates will work so:\n-old deployments don&#x27;t see the next version&#x27;s types coming out of global state \n-new deployments only see valid types.<p>I believe the compiler can do a lot of heavy lifting for updates while still remaining flexible. The compiler could take in two tuna files and type check across versions. For example, imagine two version of the same application. In v0 we store Foo. In v1 we store Bar.<p>A couple options open up:\n- We can deploy v1 but a transformation from Foo to Bar must be executed across all stored data. This would need to be performed while v0 is down.\n- We can deploy a type safe version of v0 and v1 that handle the union Foo or Bar. Then, we can teardown the type safe version of v0. v1 should be the only deployment that migrates foos to bars. The benefits of this approach is that you have non disruptive upgrades.')