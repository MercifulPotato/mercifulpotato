Item(by='dataflow', descendants=None, kids=[25892750, 25893020, 25892956], score=None, time=1611501360, title=None, item_type='comment', url=None, parent=25891971, text='&gt; It worked. The ecosystem is on py3.<p>Because they&#x27;re doing everything they can to force py2 to go away. It&#x27;s not it&#x27;s dying a natural death out of disuse. Exhibit A is everyone else in this post still wanting to use it.<p>If you think strings &quot;work&quot; under py3, my guess is you&#x27;ve never had to deal with all the edge cases, especially across all the 3 major desktop platforms. Possibly because your applications are limited in scope. (You&#x27;re <i>definitely</i> not writing general-purpose libraries that guarantee correctness for a wide variety of usage.) Most things Python treats as Unicode text by default (file contents, file paths, command-line arguments, stdio streams, etc.) are not guaranteed to be contain only Unicode. They can have invalid Unicode mixed into them, either accidentally or intentionally, breaking programs needlessly.<p>As a small example, try these and compare:<p><pre><code>  python2 -c &quot;import sys; print(&#x27;Your input was:&#x27;); print(sys.argv[1])&quot; $&#x27;\\x80&#x27; | xxd\n  python3 -c &quot;import sys; print(&#x27;Your input was:&#x27;); print(sys.argv[1])&quot; $&#x27;\\x80&#x27; | xxd\n</code></pre>\nThis program is content-agnostic (like `cat`, `printf`, etc.), and hence, with a decent standard library implementation, you would expect it to be able to pass arbitrary data through just fine. But it doesn&#x27;t, because Python insists on treating arguments as Unicode strings rather than as raw data, and it behaves worse on Python 3 than Python 2. You really have to go out of your way to make it work correctlyâ€”and the solution is often pretty much to just ditch strings in many places and deal with bytes as much as possible... i.e., you realize Unicode strings were the wrong data type. But since you&#x27;re still forced to deal with them in some ways, you get the worst of both worlds and that increases the complexity dramatically and it become increasingly painful to ensure your program still works correctly as it evolves.<p>I say all these because I&#x27;ve run into these and dealt with them, and it&#x27;s become clear to me that others who love Unicode strings just haven&#x27;t gone very far in trying to use them. Often this seems to be because they (a) are writing limited-scope programs rather than libraries, (b) confine themselves to nice, sanitized systems &amp; inputs, and&#x2F;or (c) take an &quot;out-of-sight -&gt; out-of-mind&quot; attitude towards issues that don&#x27;t immediately crop up on their systems &amp; inputs.')