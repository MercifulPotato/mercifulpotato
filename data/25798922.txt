Item(by='ricardobeat', descendants=None, kids=[25800107, 25800778], score=None, time=1610759769, title=None, item_type='comment', url=None, parent=25798771, text='&gt; you can even update a prop at the top of the component tree and it won&#x27;t re-render children that didn&#x27;t actually change<p>That&#x27;s true; the upside of immutability was supposed to be more efficiency when doing reconciliation. But in reality every large React app I&#x27;ve ever seen re-renders entire swaths of the component tree unnecessarily due to complexity -  especially now with Context, nullifying that.<p>It seems that a whole lot of people actually prefer mutability. See the popularity of MobX, and even libraries like seamless-immutable actually have the goal of offering a <i>mutation</i> interface that generates immutable objects underneath. If you can have mutations <i>and</i> correctness, sounds like a good deal. I&#x27;ve been using Svelte a lot recently, and it&#x27;s a breathe of fresh air to not worry about component lifecycle.<p>On top of that, React doesn&#x27;t do inequality checks unless you explicitly use PureComponent, or wrap function components in memo(), so you need a lot of manual work to actually get that benefit. It&#x27;s basically the inverse of having to call `rerender` everywhere.')