Item(by='dragontamer', descendants=None, kids=None, score=None, time=1603224168, title=None, item_type='comment', url=None, parent=24841750, text='&gt; Isn&#x27;t that how nearly all multi-threaded code is written<p>Producer-consumer queues say otherwise. As does Async. There&#x27;s also message-passing. There&#x27;s also thread-pools.<p>Task-based programming doesn&#x27;t wait for the tasks to finish. So without the &quot;join&quot;, you don&#x27;t have an easy synchronization point to rely upon, and have to use explicit locks for synchronization.<p>------<p>Producer - consumer can&#x27;t work with fork&#x2F;join, because there&#x27;s no &quot;join&quot; at all! The producer keeps producing, and the consumers just keep consuming.<p>Async is... a tangled mess. I&#x27;m pretty sure its just the modern &quot;unstructured goto&quot; style of spaghetti that has been rediscovered. Yeah, its super-efficient, but no, its not really easy to program.<p>Task-based parallelism is probably my next favorite style. Fork-join is super easy, but the join causes a significant waiting period and underutilization of the processor. Task-based provides more flexibility (at the cost of a little bit more complexity).<p>------<p>There&#x27;s a ton of other models of parallelism. But fork-join seems to be the methodology that more and more work is being focused on.')