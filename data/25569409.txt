Item(by='pron', descendants=None, kids=None, score=None, time=1609247414, title=None, item_type='comment', url=None, parent=25569148, text='I normally agree with Dan&#x27;s essays, but this time I very much disagree. As someone who first started programming around the time Brooks&#x27;s article was written, my conclusion is that not only was Brooks right, but, if anything, that he was too <i>optimistic</i>.<p>In the late 80s and early 90s, a lot of software development was done with various RAD languages (Magic, Business Basic -- my first programming job used that -- and later VB). We fully expected the then-nascent Smalltalk, or something like it, to become dominant soon; does anyone claim that JS or Python are a significant improvement over it? Our current state is a big disappointment compared to where most programmers in the 80s believed we would be by now, and very much in line with Brooks&#x27;s pouring of cold water (perhaps with the single exception of the internet).<p>My perception is that the total productivity boost over the past three decades is less than one order-of-magnitude (Brooks was overly careful to predict no 10x boost due to <i>one</i> improvement <i>in language design</i> within <i>one</i> decade), and almost all of it comes from improvements in hardware and the online availability of free libraries and information. The article also mixes hardware improvements and their relationship to languages, but we knew that was going to happen back then, and I think it&#x27;s been factored well into Brooks&#x27;s prediction. Moreover, my perception is that weâ€™re in a period of diminishing returns from languages, and that improvements to productivity Fortran and C had over Assembly are significantly greater than the gains since.<p>The best way to judge Brooks&#x27;s prediction, I think, is in comparison to opposite predictions made at the time -- like those that claimed Brooks&#x27;s predictions were pessimistic -- and those were even more wrong in retrospect.<p>&gt; Brooks states a bound on how much programmer productivity can improve. But, in practice, to state this bound correctly, one would have to be able to conceive of problems that no one would reasonably attempt to solve due to the amount of friction involved in solving the problem with current technologies.<p>I don&#x27;t think so. Although he stated it in practical terms, Brooks was careful to make a rather theoretical claim -- one that&#x27;s supported by computational complexity results obtained in the 80s, 90s and 00s, on the hardness of program analysis -- about the ability to express what it is that a program is supposed to do.')