Item(by='gwking', descendants=None, kids=[25206202], score=None, time=1606271345, title=None, item_type='comment', url=None, parent=25204427, text='These are interesting points. I&#x27;d like to hazard a guess that the leading contributor is cache-related. Just looking at the <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Reference_counting" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Reference_counting</a> suggests as much: &quot;Not only do the operations take time, but they damage cache performance and can lead to pipeline bubbles.&quot;<p>I roughly understand how refcounting causes extra damage to cache coherency: anywhere that a refcount increment is required, you mutate the count on an object before you use it, and then decrement it later. Often times, those counting operations are temporally distant from the time that you access the object contents.<p>I do not really understand the &quot;pipeline bubbles&quot; part, and am curious if someone can elaborate.<p>Reading on in the wiki page, they talk about weak references (completely different than weak memory ordering referenced above). This reminds me that Cocoa has been making ever more liberal use of weak references over the years, and a lot of iOS code I see overuses them, particularly in blocks. I last looked at the objc implementation years ago, but it was some thread safe LLVM hash map split 8 or 16 ways to reduce lock contention. My takeaway was roughly, &quot;wow that looks expensive&quot;. So while weak refs are supposed to be used judiciously, and might only represent 1% or less of all refs, they might each cost over 100x, and then I could imagine all of your points could be significant contributors.<p>In other words, weak references widen the scope of this guessing game from just &quot;what chip changes improve refcounting&quot; to &quot;what chip changes improve parallelized, thread safe hash maps.&quot;')