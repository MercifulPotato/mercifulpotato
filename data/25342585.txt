Item(by='mdasen', descendants=None, kids=None, score=None, time=1607409863, title=None, item_type='comment', url=None, parent=25341680, text='They touch on why they&#x27;re different a bit, but it&#x27;s kinda subtle.<p><pre><code>    foo(int? i) {\n      if (i != null) {\n        print(i + 1);\n      }\n    }\n</code></pre>\nIn that block, you can see that the compiler can understand that the null check on `i` means that it&#x27;s safe to use `i` as an int within.  Likewise, I can call `foo(int? i)` with `var something = 1`. `something` is an `int` and all `int`s are also `int?`s (but `int?`s aren&#x27;t `int`s without guarding against nulls).  By contrast, if a method takes `Optional&lt;Integer&gt;` then you have to wrap every `Integer` you have to call that method (with something like `Optional.of(something)`).<p>The author might be wrong about Swift being an example of Solution 1 (looking at Swift&#x27;s nullability syntax).<p>But the point is that nullable types provide a bit more power because they&#x27;re not just a data-structure, but a language feature. If you look at the source of `Option` in Rust, it&#x27;s an enum like `Result` or (kinda) anything you could write rather than a language feature.  Rust has built-in some things like the `?` &quot;try&quot; operator for special enums like `Option` and `Result` to unwrap them (or error), but it isn&#x27;t quite the same as the null-guards in Dart&#x2F;Kotlin and you still need to wrap them for functions like `Some(myVar)` rather than being able to pass `myVar` directly for an `Option&lt;T&gt;` parameter.<p>Again, they are almost the same, but they do talk about reasons for choosing Solution 2 over Solution 1.  In Rust, you pattern-match like `match myVar { Some =&gt; x(); None =&gt; y() }` which is very functional, but they wanted something that felt like traditional null checks with conditionals. They note that nullable types are basically erased at runtime - an `int?` at runtime is either something like `7` or `null`.  At compile time, you&#x27;ve checked that you&#x27;re never assigning a `null` to an `int`, but the runtime doesn&#x27;t need to know anything about it because the compiler has checked everything. Rust&#x27;s enums aren&#x27;t just a single special case, but something that you could make more complicated. Maybe you want a `SchrodingersResult` which could have `Success`, `Err`, or `Huh`. Ultimately, something like `Option` is an algebraic data type that you can compute off of - ex. pattern-match. The runtime needs to know that it&#x27;s an `Option` because you can write code for that.<p>It is almost the same. The question is whether you create a one-off language feature for nullability and get advantages like knowing that any `int` can be assigned to an `int?` without needing to wrap it or whether you decide to create a type that works like any other type in your system like Java&#x27;s `Optional`.  Both are reasonable ways to go, but they have subtle differences and the article outlines a lot of those differences.')