Item(by='acqq', descendants=None, kids=[25048571], score=None, time=1605025782, title=None, item_type='comment', url=None, parent=25047169, text='The approach presented introduces #pragmas which practically contain the code written in the language which extends the C language, as in the example:<p><pre><code>   double A[] = {\n   #pragma CMOD amend foreach ANIMAL:N = goose dog cat\n   [${ANIMAL }] = 2*${N},\n   #pragma CMOD done\n   };\n</code></pre>\nPersonally, I don&#x27;t like such an approach, as the convention through the decades was that #pragmas don&#x27;t contain the code but just the &quot;directives&quot;, that is, that it should be able to &quot;read&quot; the code without the #pragmas, which is here impossible (one would completely miss the &quot;foreach&quot; and &quot;goose&quot;, &quot;dog&quot; and &quot;cat&quot;).<p>As the idea is to have a preprocessing step before the result is fed to the compiler, a little better preprocessor could be written which would remove the requirement of having such pragmas.<p>Note that such kind of a bit stronger preprocessor was how the initial forms of C++ were implemented (1983) 37 years ago:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cfront" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cfront</a><p>&quot;The preprocessor did not understand all of the language and much of the code was written via translations.&quot;<p>Even older preprocessor (1974), 46 years ago, also implemented in Bell Labs, was Ratfor:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ratfor" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ratfor</a>')