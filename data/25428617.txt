Item(by='siraben', descendants=None, kids=None, score=None, time=1608025513, title=None, item_type='comment', url=None, parent=25427802, text='&gt; But that would make it fail the &quot;eval e = eval (opt e)&quot; rule in siraben&#x27;s proof. The same for picking a different order to execute the functions in &quot;f() + g()&quot;.<p>This is really a question of how the semantics are formulated. The eval function I gave doesn&#x27;t take into account an abstract machine so there is no notion of &quot;variable allocation&quot; or &quot;final state&quot; to check, the semantics doesn&#x27;t account for it.<p>To scale it to a more realistic model with nondeterminism, heaps and so on, the semantics needs to be changed to a relational one. For instance, eval would now be a relation that relates two states of the machine, and a proof of correctness would be something like[0], which takes into account all possible states of the heap.<p>Equality would no longer used to relate two &quot;equivalent&quot; programs but rather some other equivalence relation with the properties one cares about, for instance two programs would be heap-equivalent if they have exactly the same effect on the heap, or UB-equivalent if they have possible UB at the &quot;same&quot; (again under another relation) places.<p>[0] <a href="https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu&#x2F;plf-current&#x2F;Equiv.html#atrans_sound" rel="nofollow">https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu&#x2F;plf-current&#x2F;Equiv....</a>')