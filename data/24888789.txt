Item(by='nemo1618', descendants=None, kids=None, score=None, time=1603651744, title=None, item_type='comment', url=None, parent=24887521, text='I think Go is one of the most misunderstood languages. Many people want Go to be something that it isn&#x27;t, and often for the wrong reasons.<p>Generics are the most contentious issue, and people have been disparaging Go since day 1 for not supporting them. And yet, somehow we&#x27;ve spent the last 10 years writing all kinds of programs in Go, and the lack of generics has rarely been a showstopper. Go <i>does</i> have generics of course -- it just doesn&#x27;t have user-defined generics. My hot take is that this is actually an area of the programming space that deserves more exploration. It feels like a Pareto phenomenon, where adding a small number of generic types and functions covers 80% of the usecases. And indeed, it seems that generic arrays&#x2F;slices&#x2F;maps&#x2F;channels, plus a generic &#x27;append&#x27; function, a generic &#x27;range&#x27; keyword, etc. really are sufficient for the vast majority of programming tasks. These &quot;reified&quot; generics have significant advantages: for one, you can build deep compiler optimizations and tooling around them; and for two, perhaps more importantly, <i>every Go developer is familiar with them</i>. Reducing mental overhead when reading someone else&#x27;s code is a big part of the Go philosophy. (Having a really high-quality standard library contributes to this as well, for obvious reasons.)<p>People made similar arguments about operator overloading. It&#x27;s true, operator overloading allows for more &quot;expressive&quot; code. It also allows people to write code that is much harder to read, harder to debug, and whose performance is harder to analyze. I think it could be cool to have an &#x27;expressive {}&#x27; block, like Rust&#x27;s &#x27;unsafe {}&#x27;, where overloading is allowed; but when I&#x27;m reading normal code, I don&#x27;t want to have to worry about &#x27;x + y&#x27; jumping away to some other piece of code.<p>(As a side note, I see many people arguing for generics based on their desire to write map&#x2F;filter&#x2F;reduce functions in Go. My feeling is that map&#x2F;filter&#x2F;reduce (and other HOFs) are unlikely to become commonplace in Go code, even if generics are added. The reason is lambda syntax: even the simplest map or filter will require three lines of code (or one long one), including multiple type definitions and a return statement. It&#x27;s not enough of an improvement over a &#x27;for&#x27; loop to be worth it. If you could write &#x27;xs.map(x =&gt; x*x)&#x27;, it&#x27;d be another story, but that would require a much deeper language change.)<p>Anyway, Go wasn&#x27;t designed by idiots, which means you should apply Chesterton&#x27;s Fence. If some aspects of the design seems wrong, or violates your sensibilities, your first instinct should be &quot;perhaps this is optimizing for some usecase I haven&#x27;t considered,&quot; or &quot;perhaps this is targeting a particular niche that I&#x27;m not familiar with,&quot; rather than &quot;this is clearly a mistake.&quot; The steelman argument, then, should be usually be of the form &quot;It seems like Go is optimizing for X, but it falls short of X in significant ways,&quot; or &quot;Go is targeting X, but doing so comprises value Y that I consider more important.&quot;')