Item(by='arc776', descendants=None, kids=[24851797], score=None, time=1603311840, title=None, item_type='comment', url=None, parent=24850885, text='&gt; Can you give specific examples and prove that they cannot be overcome?<p>It&#x27;s hard to prove a theoretical negative, but perhaps by comparison with the run time performance of static AOT (SAOT) compiled languages I can show what I mean.<p>Dynamic typing:<p>- Python requires dynamic type checking before any program work is done. SAOT doesn&#x27;t need to do any run time work.<p>- Adding two numbers in Python requires handling run time overloads and a host of other complexities. SAOT is a single machine code instruction that requires no extra work.<p>Boxing values:<p>- Python value boxing requires jumping about in heap memory. SAOT language can not only remove this cost but reduce it to raw registers loaded from the stack and prefetched in chunks. This massively improves cache performance by orders of magnitude.<p>Determinism:<p>- In Python program operation can only be determined by running the code. In SAOT, since all the information is known at compile time programs can be further folded down, loops unrolled, and&#x2F;or SIMD applied.<p>Run time overheads<p>- Python requires an interpretive run time. SAOT does not.<p>In summary: Python necessarily requires extra work at run time due to dynamic behaviour. SAOT languages can eliminate this extra work.<p>I do understand though that with JIT a lot of these costs can be reduced massively if not eliminated once the JIT has run through the code once. For example here they go through the painful process of optimising Python code to find what is actually slowing things down, to the point of rewriting in C: <a href="http:&#x2F;&#x2F;blog.kevmod.com&#x2F;2020&#x2F;05&#x2F;python-performance-its-not-just-the-interpreter&#x2F;" rel="nofollow">http:&#x2F;&#x2F;blog.kevmod.com&#x2F;2020&#x2F;05&#x2F;python-performance-its-not-ju...</a><p>At the end they point out that PyPy gives a very impressive result that is actually faster than their C code. Of course, this benchmark is largely testing unicode string libraries rather than the language itself and I&#x27;d argue this is an outlier.<p>&gt; How much of the literature have you read?<p>Literature on speeding up Python or high performance computing? The former, very little, the latter, quite a lot. My background is in performance computing and embedded software.<p>I&#x27;m definitely interested in the subject though if you&#x27;ve got some good reading material?<p>&gt; people said monkey-patching in Python and Ruby was a hard overhead to peak temporal performance and fundamentally added a cost that could not be removed... turns out no that cost can be completely eliminated.<p>This really surprised me. Completely eliminated? I&#x27;m really curious how this is possible. Do you have any links explaining this?')