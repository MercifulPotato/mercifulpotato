Item(by='klodolph', descendants=None, kids=[25563503], score=None, time=1609189995, title=None, item_type='comment', url=None, parent=25563107, text='Haskell enforces function purity (side effect isolation) using the type system. This is relatively novel, neither Lisp nor Smalltalk did it or even tried to do it, as far as I can tell. You could put together lazy values in Lisp manually but Haskell made the entire language lazy by default, and as a result, you couldn’t reliably sequence I&#x2F;O operations if you tried to “cheat” the type system by giving pure type signatures to functions with side effects. The result was (eventually, in Haskell 1.3) the modern IO monad.<p>If you were using Lisp or ML, you could write pure code in the core of your program but fall back to impure code wherever you liked, because purity was not ever enforced. This explains why nobody really used stuff like monads in Lisp or ML—it wasn’t practically useful, because you could always just write impure code.<p>&gt; Besides, isn&#x27;t Haskell fundamentally about about lazy evaluation and rigorous type safety?<p>I’d say—no, absolutely not. It’s not about either of those things.<p>“Rigorous type safety” is kind of an ill-defined concept. I’d say Java has rigorous type safety, but it’s very different from Haskell. The lessons from Haskell is that function purity (side effect isolation) is incredibly useful, and laziness is the historical reason why functions in Haskell had to be annotated with the correct types—because a &quot;print :: String -&gt; ()&quot; would not work in Haskell.<p>In other words, the fact that Haskell uses lazy evaluation forced the development of type system capable of expressing side effects and sequential operations, and now that we’ve discovered how to do that, we could discard the lazy part and make an eager version of Haskell. Some people have done that, there are a couple eager variants of Haskell out there. They are <i>very</i> recognizably Haskell.<p>There are a couple other cool things that came out of Haskell’s purity, like software transactional memory. Haskell didn’t <i>invent</i> STM, just like it didn’t invent purity, but Haskell is still the one major success story for STM. The lesson from trying to port STM to other languages is that Haskell’s purity is what made it successful there. Lazy evaluation, in a sense, is just the thing that breaks your program if your functions are not pure, keeping you honest.')