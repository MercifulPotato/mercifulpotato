Item(by='astine', descendants=None, kids=None, score=None, time=1609271428, title=None, item_type='comment', url=None, parent=25569148, text='This essay badly misinterprets Brooks original essay. Brooks was talking specifically about the problem of building new systems from scratch.He was speaking about programming productivity. This essay is talking about operational tasks. Of course operational tasks can be speed up with improvements to software and hardware, that&#x27;s the whole point of writing new software and developing new hardware.<p>Furthermore, Brooks doesn&#x27;t actually argue that there is no way to tackle essential complexity when writing new software. What he says is that there is no single technique that will speed up the process of writing code across the board, that is, there is no <i>silver bullet</i>. However, he does make allowance for techniques that allow us to break up complex systems into smaller systems which can then be solved independently. He specifically mentions object oriented programming as a tool which makes it easier for programmers to write software as components but CPAN would have been a better example. He just doesn&#x27;t allow that OOP <i>by itself</i> would allow for an order of magnitute improvement (something which I think that experience has born out.)<p>The author of this essay, points out a couple of operational tasks which involve programming were easier for them than they would have been 34 years ago because faster hardware noow exists and because software that already takes care of a subset of the problem now exists when it didn&#x27;t before. Partially, this is confirmation of Brooks&#x27; idea that breaking down problems it the way to go long-term, but more critically, it&#x27;s a failure to realize on the part of the author that they&#x27;re speaking of productivity in their role as the user of a computer system whereas Brooks is speaking about productivity in designing new software products.<p>edit:<p>I think that the fundamental root of the essay&#x27;s problem is that the author seems to have misssed what Brooks was referring to which he discussed accidental vs essential complexity. Brooks specifically pointed out that he was referencing Aristotle when he used those terms, and in this case essential doesn&#x27;t mean unavoidable, but a part of the  essential character of the problem itself. A more modern terminology would be intrinsic vs extrinsic. Complexity is extrinsic to programming if it comes from something other than the nature of the problem itself. If my computer is too slow to allow me to write a program, then that&#x27;s probably not due the the nature of the program itself (except indirectly) and so represents a form of accidental complexity. Feature requirements however, represent essential complexity. You can manage essential complexity according to Brooks by dividing the problem up or avoiding altogether, but it&#x27;s not something that will go away simply with better tooling or a better methodology, (unless that better tooling <i>replaces</i> software that you otherwise would have written.')