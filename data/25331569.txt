Item(by='MaxBarraclough', descendants=None, kids=[25331662], score=None, time=1607344769, title=None, item_type='comment', url=None, parent=25331436, text='&gt; are you sure every programmer on Chromium is a genius? Google has a hard Interview process, but does it filter out every bad engineer?<p>I suspect that yes, it filters out all candidates who are outright <i>bad</i>. I don&#x27;t think this point really matters though. If even Google aren&#x27;t able to produce a large C++ codebase free of buffer-overflows, even when it really matters, it suggests that no-one can. <i>edit</i> This doesn&#x27;t need to be an argument drawn from a single sample, either. Buffer overflows happen to just about all major C&#x2F;C++ codebases. OpenSSL, the Linux kernel, Windows, the Apache Web Server, nginx, etc.<p>We could quibble about the way they don&#x27;t use the sort of methodology used in avionics software development, but I don&#x27;t think there&#x27;s much value in exploring that. If Google consider that to be too slow&#x2F;costly for Chromium, it highlights how rarely those methodologies can practically be used.<p>I don&#x27;t think there are any individual C++ programmers who are too smart to ever introduce undefined behaviour, but even if there were it wouldn&#x27;t matter. As you indicate, real large-scale software development happens with teams, not lone geniuses.<p>&gt; I think even current Rust would be much safer than MISRA C++.<p>I agree that the <i>language</i> might be a reasonable choice, but I don&#x27;t think the Sealed Rust project is anywhere near delivering a Rust compiler that can be trusted with your life. Even mature C compilers can have serious bugs, [0] and compiling Rust is far more challenging than compiling C.<p>[0] [PDF] <i>Finding and Understanding Bugs in C Compilers</i>, Regehr et al, 2011, <a href="https:&#x2F;&#x2F;www.cs.utah.edu&#x2F;~regehr&#x2F;papers&#x2F;pldi11-preprint.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.utah.edu&#x2F;~regehr&#x2F;papers&#x2F;pldi11-preprint.pdf</a>')