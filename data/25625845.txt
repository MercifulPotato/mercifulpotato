Item(by='mumblemumble', descendants=None, kids=None, score=None, time=1609713104, title=None, item_type='comment', url=None, parent=25625576, text='I&#x27;m hopeful that Rust will lead in a good direction.<p>A C-style ABI, by virtue of being the least common denominator, is probably the best bet for re-usability across paradigms. Higher level languages would want to write idiomatic fa√ßades, but they already habitually do that anyway, even on higher-level platforms like Java and .NET.<p>And I think that deterministic memory management is probably also a pretty important feature. You don&#x27;t want your libraries all bringing their own clever ideas about object lifetimes and such. But you also need it to be very reliable; a real danger with inviting libraries written in C and C++ into your process space is that they are liable to corrupt your memory. Rust&#x27;s affine type system seems like a big step in the right direction here.<p>Similar thoughts for the error model. I don&#x27;t have any particular complaints about exceptions, except that you don&#x27;t want to be bleeding them on an external API, because that ends up being another spot where languages can fail to mesh.<p>What&#x27;s missing, though, is that there is no good cross-platform standard for libraries that work with the C ABI (neither in source nor binary form) for other languages to plug into. So that&#x27;s where I get to thinking that Rust might be closer to (if not exactly at) the mark than C is.')