Item(by='momentoftop', descendants=None, kids=[25706010], score=None, time=1610224469, title=None, item_type='comment', url=None, parent=25701990, text='You can&#x27;t define the interface in either language.<p>Implementations of Functor consist, in part, of <i>type-level functions</i>. In Haskell terms, these are &quot;higher-kinded types&quot;. The standard example is the list type &quot;[]&quot; which, as a type-level function, takes an element type and gives back the type of lists whose elements are drawn from that element type.<p>In Java and F#, the only way to talk about the List type is in its fully applied context, where you&#x27;ve attached the element type. So maybe you&#x27;ve got &quot;List&lt;Int&gt;&quot;, or you&#x27;ve got &quot;List&lt;String&gt;&quot; or you may have a generic &quot;List&lt;A&gt;&quot;. What you don&#x27;t have is the type-level function that&#x27;s not been applied to anything. So there&#x27;s no equivalent to the Haskell Functor implementation:<p><pre><code>   instance Functor [] where\n      fmap _     [] = []\n      fmap f (x:xs) = f x : fmap f xs\n</code></pre>\nThis is barely half the story. What makes this useful in Haskell is the typeclass overloading, which makes it effortless to write functions that abstract over arbitrary Functors, and use &quot;fmap&quot; multiple times locally for different Functor instances, letting the type system figure out what implementation is needed to map over the particular type you&#x27;re working with. And in such abstract code, where you may know very little about the Functor instance you&#x27;re working with, it&#x27;s extremely important that they all be absolutely law-abiding: in many cases, the laws are all you have to work with.<p>These two features, higher-kinding and typeclass polymorphism, make it worth talking about Functors, and I don&#x27;t think you can appreciate Functors in Haskell  without seeing the interaction of these features and just how much it impacts the code style of the average Haskeller.')