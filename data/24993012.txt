Item(by='eska', descendants=None, kids=None, score=None, time=1604523634, title=None, item_type='comment', url=None, parent=24990829, text='You ask a lot of questions, but none of them are sincere.. Especially since you finish it off with a dogmatic &quot;Use them!&quot;. How about keeping an open mind, asking real questions, and give others the chance to prove you wrong (which would be beneficial to you if they succeed)?<p>IMO you&#x27;re so stuck in the OOP mindset, that you cannot see the very simple solutions to your questions. To just pick a single example out of the many, since you don&#x27;t seem to want to be proven wrong anyway..<p><i>Where do you store and how do you access all the hidden state, like keyboard focus, cursor position, editing modes, etc, that object oriented user interfaces simply expose as properties, getters or setters?</i><p>In OOP each single widget would store whether it is focused using some boolean member. In IM GUIs one just stores the ID of the widget that is focused once in some library-local data structure:<p><pre><code>    &#x2F;&#x2F; ui.h\n    bool has_keyboard_focus(uint64_t widget_id);\n\n\n    &#x2F;&#x2F; ui.cpp\n    struct UIData {\n        uint64_t focused_widget_id;\n        int16_t cursor_x, cursor_y;\n    } ui_data;\n\n    bool has_keyboard_focus(uint64_t widget_id) { return ui_data.focused_widget_id == widget_id; }\n\n    &#x2F;&#x2F; my_widget.h\n    EditMode my_widget_get_edit_mode(uint64_t widget_id);\n\n    &#x2F;&#x2F; my_widget.cpp\n    map&lt;uint64_t &#x2F;*widget_id*&#x2F;, EditMode&gt; widget_id_to_edit_mode;\n    option&lt;EditMode&gt; my_widget_get_edit_mode(uint64_t widget_id) {\n        auto itr = widget_id_to_edit_mode.find(widget_id);\n        return itr != widget_id_to_edit_mode.end() ? itr-&gt;second : std::nullopt;\n    }</code></pre>')