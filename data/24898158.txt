Item(by='ddragon', descendants=None, kids=[24898360], score=None, time=1603730729, title=None, item_type='comment', url=None, parent=24897724, text='Lisp macros (as opposed to macros in other languages besides C) are especially powerful not because you&#x27;re changing the syntax, as Lisp doesn&#x27;t have a syntax in the first place, you&#x27;re always working directly on it&#x27;s Abstract Syntax Tree. So stuff like conditional, loops and functions all have the same structure, which is why you could already write something that looks like a loop but it&#x27;s a function.<p>The difference is how it&#x27;s arguments are evaluated, for example if I wanted to make a function that implements a for loop of the form (myfor a from 1 to 10 do (print a)), if it&#x27;s a function then every argument will be evaluated immediately, so it will try to find a variable called a, from, to, do and it will also try to evaluate (print a) immediately before looping. Macros allows for delayed evaluation, as myfor will receive all arguments (at compile-time) as symbols instead of values, which you can then rearrange in a form that can evaluate properly at runtime. You can also go further if you actually want to create syntax and use reader macros, which allows you to write your own parser and therefore escape writing directly on the AST (then you can even write a C syntax within Lisp).<p>And if your question is: do I actually need them? The answer is obviously no as many languages do not support it (and there are even alternatives for many use cases, like lazy evaluation). The advantage is that your language can have a very simple core and features that were not implemented (say a pattern match structure) can be added entirely within userspace (which is also good for testing new functionality before adding to the core language). Macros are also very efficient since they run at compilation (so if you use the macro a lot of time you only have to evaluate them once, unlike functions that will usually have to run it&#x27;s logic every time it&#x27;s called). And all of that means that for DSL, it&#x27;s not just making a nice adaptation for your domain within the host language, but effectively writing an optimized language for your domain reusing the compiler of the host language without having to change it&#x27;s source code.')