Item(by='kazinator', descendants=None, kids=None, score=None, time=1611257596, title=None, item_type='comment', url=None, parent=25844626, text='Though it is a convention, it has demonstrable, objective benefits.<p>The use of 0 as the basis means that, in mathematical language, the indexing is <i>homogeneous</i> and that conversion between different units is a <i>linear map</i>.<p>Imagine if we have tape measure that measures both meters and centimeters. Imagine that the first tick on the tape measure, representing no displacement, is simultaneously labeled &quot;1 cm&quot; and &quot;1 m&quot; instead of 0.<p>Now, we no longer have a linear map to convert between <i>cm</i> and <i>m</i>. What we have is an <i>affine</i> map, like m = 1 + (cm - 1)&#x2F;100.<p>An affine map is a strictly inferior alternative when we have the freedom to establish a linear map.<p>Homogeneous&#x2F;linear is the superior default. One-based can be used in the special cases where it is nicer.<p>Here is one example: binary heaps. When we store a binary tree structure into a heap array, 1 based indexing makes the calculations nicer for navigating from parent to children or vice versa:<p><pre><code>        [1]\n    [2]     [3]\n  [4][5]   [6][7]\n</code></pre>\nThe children of every node [n] are [2n] and [2n + 1].  The parent of every node [n] is [n &#x2F; 2] (floor-truncating division).<p>Under 0 based, it&#x27;s not as nice:<p><pre><code>        [0]\n    [1]     [2]\n  [3][4]   [5][6]\n</code></pre>\nThe children are now [2n+1] and [2n+2]. One extra addition is required in the case of the left child. Finding the parent requires a subtraction: [(n-1)&#x2F;2].<p>Another way to see the advantage of 1 based here is that every row of the tree starts with a power of : [1] [2] [4] ...<p>Because we are dealing with exponentiation, avoiding 0 helps: 0 is not a power of two, so to &quot;boostrap&quot; the exponentiation, we have to displace it.<p>Note that even though it is nice for a binary heap to use 1 based indexing, we still want to store that in an zero-based array, and just sacrifice the storage for the zero element.<p>If we use a zero based array, then the nice heap arithmetic we wrote in the source code will look nice in the object code, due to the map from the source code array to the object code array being a linear map, rather than an affine map.<p>It is almost always better to simulate a 1 based array by sacrificing a storage element, than to have the compiler uglify the beautiful indexing calculations for the sake of which we switched to 1 based in the first place.<p>In summary:<p>1. we should choose the representation which offers the most succinct indexing calculations for the given situation, and not for some emotional reasons like &quot;children learn to count from 1 and non-programmers understand that best&quot;.<p>2. arrays should be zero-based to preserve the succinctness of the calculation through to the object code (linear map from source to object, not affine).')