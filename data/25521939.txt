Item(by='com2kid', descendants=None, kids=[25522888], score=None, time=1608755993, title=None, item_type='comment', url=None, parent=25515425, text='&gt;  let&#x27;s kick things off with jsx.<p>Of all the problems I have with React, and I do have a few, JSX is not one of them.<p>If you are going to be using a language to generate HTML, you are either going with a component approach that wraps HTML in some object library that then spits out HTML, or you are stuck with a templating language of some sort. (Or string concatenation, but I refuse to consider that a valid choice for non-trivial use cases.)<p>JSX is a minimal templating language on top of HTML. Do I think effects are weird and am I very annoyed at how they are declaration order dependent? Yup. But the lifecycle stuff is <i>not</i> that weird, or at least the latest revision of it isn&#x27;t (earlier editions... eh...). The idea of triggering an action when a page is done loading has been around for a very long time, and that maps rather well to JSX&#x27;s lifecycle events.<p>&gt; React alone provides little to nothing<p>Throw in a routing library, and you are pretty much done.<p>Now another issue I do have is that people think React optimizes things that it in fact does not, so components end up being re-rendered again and again. Throw Redux in there and it is easy to have 100ms latency per key press. Super easy to do, and <i>avoiding</i> that pitfall involves understanding quite a few topics, which is unfortunate. The default path shouldn&#x27;t lead to bad performance.<p>&gt; The concept of components and the idiotic life cycles<p>Page loads, network request is made. Before React people had listeners on DOM and Window events instead, no different.<p>Components are nice if kept short and sweet. &quot;This bit of HTML shows an image and its description&quot; is useful.<p>&gt; Do I need to explain how much stuff can be packed in 400kb?<p>No, I&#x27;ve worked on embedded systems, I realize how much of a gigantic waste everything web is. But making tight and small React apps is perfectly possible.<p>And yes, if you pull in a giant UI component library things will balloon in size. It is a common beginner mistake, I made it myself when I first started out. Then I realized it is easier for me to just write whatever small set of components I need myself, and I dropped 60% of my bundle app size.<p>In comparison, doing shit on the backend involves:<p>1. Writing logic in one language that will generate HTML and Javascript\n2. Debugging the HTML and Javascript generated in #1.<p>And then someone goes &quot;hey you know what&#x27;s a great idea? Let&#x27;s put state on the back end again! And we&#x27;ll wrap it up behind a bunch of abstractions so engineers can pretend it actually isn&#x27;t on the back end!&quot;<p>History repeats itself and all that.<p>SPAs exist for a reason. They are easier to develop and easier to think about. And like it or not, even trivial client side functionality, such as a date picker, requires Javascript (see: <a href="https:&#x2F;&#x2F;caniuse.com&#x2F;input-datetime" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;input-datetime</a>).<p>SPAs, once loaded, can be very fast and scaling the backend for an SPA is a much easier engineering task (not trivial, but easier than per user state).<p>Is all of web dev a dumpster fire? Of course it is. A 16 year old with VB6 back in 1999 was 10x more productive than the world&#x27;s most amazing web front end developer now days. Give said 16yr old a copy of Access and they could replace 90% of modern day internally developed CRUD apps at a fraction of the cost. (Except mobile support and all that...)<p>But React isn&#x27;t the source of the problem, or even a particularly bad bit of code.')