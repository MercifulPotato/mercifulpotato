Item(by='pgt', descendants=None, kids=[24898945], score=None, time=1603711993, title=None, item_type='comment', url=None, parent=24893416, text='Lisp has only one rule called the Operational Form:<p><pre><code>   (operator arg1 arg2 arg3 ...)\n</code></pre>\nThe Operational Form is just a list denoted by parentheses. The operation or &#x27;function&#x27; comes first, followed by its arguments or operands, e.g.<p><pre><code>   (+ 1 2 3)\n   =&gt; 6\n</code></pre>\nThe + symbol resolves to the plus function and is passed in the arguments 1, 2 and 3. Nested forms are evaluated inside-out:<p><pre><code>   (+ 5 (- 10 6))\n   =&gt; 9\n</code></pre>\nTraditionally, Lisp only has one data literal: `(linked lists)`, but Clojure adds `[square brackets for vectors]` and `{:curly brackets}` for hash maps. The colon denotes a keyword, which is a symbol which only ever resolves to itself and is commonly used for labeling things, e.g. keys in a map.<p>Notice how the operational form is just a list with some symbols and data literals. In Lisp, the syntax for writing data structures and the syntax for writing code is the <i>same syntax</i>. And since a function operates on data and produces new data, what if a function could operate on code and produce <i>new code</i>, since code is just data?<p>We call such a function a macro (and I don&#x27;t mean Excel macros). Macros run at &quot;compile-time&quot; (technically &#x27;read time&#x27;) and the code output is executed at &quot;run-time&quot; (or during &#x27;evaluation&#x27;). The benefit of macros is that if your language is missing a feature, you can add it.<p>You can see this in practice by looking at the source code for the `and` and `or` logic functions in Clojure, which are typically built-ins, but in Clojure they are just macros bootstrapped on top of the special forms `if` and `let`: <a href="https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;clojure&#x2F;blob&#x2F;38bafca9e76cd6625d8dce5fb6d16b87845c8b9d&#x2F;src&#x2F;clj&#x2F;clojure&#x2F;core.clj#L842-L852" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;clojure&#x2F;blob&#x2F;38bafca9e76cd6625d8d...</a><p>Clojure only has 13 special forms:<p><pre><code>    [fn let let loop do while . if def recur\n     try catch throw quote var\n     monitor-enter monitor-exit]\n</code></pre>\nEverything else is built on top of that.<p>When I started learning Clojure, I found the ClojureScript Koans to be very helpful in getting a feel for the semantics and to become familiar with the argument placement: <a href="http:&#x2F;&#x2F;clojurescriptkoans.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;clojurescriptkoans.com&#x2F;</a><p>If you come from a traditional OO-background, my condolensces and I recommend starting with Rich Hickey&#x27;s 2-hour talk, &quot;Clojure for Java Programmers&quot;: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=P76Vbsk_3J0" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=P76Vbsk_3J0</a>')