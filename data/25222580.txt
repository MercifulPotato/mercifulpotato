Item(by='kazinator', descendants=None, kids=[25222853], score=None, time=1606416442, title=None, item_type='comment', url=None, parent=25220892, text='This is a really poor article. Only in very rare circumstances can developers change the API&#x27;s. API&#x27;s are not &quot;bad&quot;; they are built to various important requirements. Only some of those requirements have to do with performance.<p>&gt; <i>“Well, it is fine to copy memory here and perform this expensive computation because it saves us one I&#x2F;O operation, which is even more expensive”.</i><p>&quot;I&#x2F;O operation&quot; in fact refers to the API call, not to the raw hardware operation. If the developer measured this and found it true, how can it be a misconception? \nIt may be caused by a &quot;bad&quot; I&#x2F;O API, but so what? The API is what it is.<p>API&#x27;s provide one requirement which is stability: keeping applications working. That is king. You can&#x27;t throw out API&#x27;s every two years due to hardware advancements.<p>&gt; <i>“If we split this into multiple files it will be slow because it will generate random I&#x2F;O patterns. We need to optimize this for sequential access and read from a single file”</i><p>Though solid state storage doesn&#x27;t have track-to-track seek times, the sequential-access-fast rule of thumb has not become false.<p>Random access may have to wastefully read larger blocks of the data than are actually requested by the application. The unused data gets cached, but if it&#x27;s not going to be accessed any time soon, it means that something else got wastefully bumped out of the cache. Sequential access is likely to make use of an entire block.<p>Secondly, there is that API again. The underlying operating system may provide a read-ahead mechanism which reduces its own overheads, benefiting the application which structures its data for sequential access, even if there is no inherent hardware-level benefit.<p>If there is any latency at all between the application and the hardware, and if you can guess what the application is going to read next, that&#x27;s an opportunity to improve performance. You can correctly guess what the application will read if you guess that it is doing a sequential read, and the application makes that come true.')