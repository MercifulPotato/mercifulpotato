Item(by='JHonaker', descendants=None, kids=[24735269, 24733746], score=None, time=1602271061, title=None, item_type='comment', url=None, parent=24731833, text='&gt; Editors (Juno) do not check types at runtime when the information is readily available<p>This complaint is really common with people that see types and expect them to do something like TypeScript. Julia is not a statically typed language. The types are not there for a type checker to check your code for correctness.<p>Instead the types allow Julia to dispatch your method call to the correct implementation for the type of your variable <i>at runtime</i>. This is Julia&#x27;s secret sauce, and it&#x27;s the main reason you&#x27;ll hear about Julia programmers declaring about how composable Julia packages are. I can &quot;reach into your package&quot;, and define the behaviour of your functions on my own custom types and then whenever anyone tries to call the function&#x2F;method with one of my types, it&#x27;ll <i>just work</i>. I don&#x27;t need to author a pull request to your package or futz around with anything that you&#x27;ve wrote.<p>Novice Julia programmers often come in thinking that the type annotations are there for ensuring correctness, but that&#x27;s not it at all. In actuality, you want to be as general with your types as you can, and by default most parameters will probably be untyped. If you need certain behaviour for the function, then you should probably annotate it, but it&#x27;s definitely not required.<p>I&#x27;m guilty of this misstep as well, one of the biggest things I struggled with when I was new was using ::Array everywhere, when what I wanted was ::AbstractArray.<p>&gt; Include() includes (is this PHP all over again?) a file into the script!<p>Use Modules. Don&#x27;t fault Julia for you being a beginner and not reading the necessary parts of the documentation.')