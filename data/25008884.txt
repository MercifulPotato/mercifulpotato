Item(by='cjg', descendants=None, kids=[25009236, 25009562, 25009056, 25009199], score=None, time=1604680574, title=None, item_type='comment', url=None, parent=25006619, text='We give up on automated program analysis far too easily - even for &quot;Turing complete&quot; languages.<p>To be truly Turing complete requires infinite memory. That clearly doesn&#x27;t hold for any current programming language.<p>Mathematical proofs are only applicable where their assumptions are valid. So why would we believe that the where memory isn&#x27;t infinite (everywhere in practice) that Turing&#x27;s halting analysis is applicable?<p>Sure, automated program analysis might not be easy, but that doesn&#x27;t mean we should just give up. Indeed I have a simple algorithm (although relatively inefficient) to solve the halting problem where memory size is fixed and finite: enumerate every state until either a state is repeated or the program halts. This completes in O(2^N) time where N is the size of the memory.<p>But I&#x27;m sure someone clever will come up with a more efficient algorithm than that. I already have several ideas that this margin is too small to contain.<p>For me the tricky bits are where a loop terminates if and only if Goldbach&#x27;s conjecture is true (or similar) - but perhaps a compiler could require an &quot;unsafe&quot; block for such code (in the vein of Rust).')