Item(by='emn13', descendants=None, kids=None, score=None, time=1607857881, title=None, item_type='comment', url=None, parent=25384102, text='You can wait in a threaded model too, right?  The only difference is that if you do so, you&#x27;re blocking that thread.  The pain comes when you mix the two models, because async often deals really poorly with blocking.  In general, the differences between the two models when used cleanly are quite small.  When most waits are no-ops, threads have significantly lower overhead; but when waits are common, especially if long-lived, async overhead is much lower.<p>In fact, if you want to minimize the chance of deadlocks, using threads or processes for <i>every</i> action is safest; although of course that means you may get issues with concurrent modification.  But though that risk is serious, it&#x27;s worth noting that async code doesn&#x27;t actually solve it; after all, every await may mean a context switch, and thus if you have shared mutable state living across an await, all bets are still off. async-only code with exactly 1 thread only provides safety to the extent that modification is encapsulated and that the module within which the internal datastructures are updated does not use async.  And that&#x27;s not nothing; it&#x27;s kind of as if a java object was synchronized on all methods.  But it&#x27;s also not reliable enough that you can just forget about concurrent modification, either.<p>But if all you want to do is automate a browser, those overheads are completely irrelevant, and this story about concurrent modification likely is too.  You could use either model equally well.  To be explicit: there&#x27;s nothing about promises that means you need to use async.  It&#x27;s only once you start chaining a bunch of them that you enter async territory, but why would you <i>ever</i> do that in a threaded model when automating a browser?   The browser is so heavy weight, just fork a bunch of processes already, and KISS: no need to worry about any of this, <i>at all</i>.')