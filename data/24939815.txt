Item(by='AaronFriel', descendants=None, kids=[24958887, 24940404, 24941567, 24941016, 24945153, 24940432, 24941069, 24942530], score=None, time=1604041063, title=None, item_type='comment', url=None, parent=24921657, text='Now what happens when you add STM to these languages? You&#x27;ve just created an enormous footgun by creating another color of function (<a href="https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2015&#x2F;02&#x2F;01&#x2F;what-color-is-your-function&#x2F;" rel="nofollow">https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2015&#x2F;02&#x2F;01&#x2F;what-color-is-...</a>, see also: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8984648" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8984648</a>).<p>What this proposal misses is that reasoning about software transactional memory in functions all but demands being able to abort and retry code to make progress, and that therefore means having a high level separation between transactional code and IO code.<p>Suppose you had a banking application, you would like to use STM (as in the &quot;ractor&quot; example in this article) to move balances from one to another. In Haskell, you&#x27;d perform STM actions on those TVars (transactional vars) and use the default retry policy of STM to automatically construct an order of operations such that each operation appears to occur atomically. (STM doesn&#x27;t impose a clock based ordering but I don&#x27;t think it would be tremendously difficult to do so.)<p>If you don&#x27;t use Haskell&#x27;s &quot;check&quot; or &quot;retry&quot;, you find that your code will abort and fail with near certainty. You can&#x27;t perform lots of transactions on tvars and not, occasionally, read from a var another transaction is writing.<p>So you add &quot;check&quot; calls to verify your preconditions and postconditions such as balances cannot go negative, and you add &quot;retry&quot; calls to automatically retry transactions that fail because of concurrency.<p>Now imagine doing that in a modern Ruby codebase, or a modern JavaScript codebase. There&#x27;s so much mutation that happens in these environments, can you guarantee within a Ruby function that it hasn&#x27;t mutated another variable with ease? That it hasn&#x27;t written to disk, made an API call, or changed some global state?<p>Haskell pioneered the use of STM. It&#x27;s easier to reason about in Haskell because the world of the STM can be isolated from the world of effects due to the IO monad. It&#x27;s easy to declare &quot;this function is blue&quot; and &quot;this function is red&quot; and the never the twain shall meet.<p>In any other language, all bets are off.')