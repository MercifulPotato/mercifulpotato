Item(by='judofyr', descendants=None, kids=[24801869, 24801989], score=None, time=1602862312, title=None, item_type='comment', url=None, parent=24801670, text='&gt; Obviously, just from Java occupying the top 2 or 3 spots for popularity over the last 15 years -- Java&#x27;s approach must be doing something right.<p>I&#x27;m not sure if this argument holds. Java&#x27;s high memory usage is frequently cited as a <i>downside</i> of Java. GUI applications written in Java have a reputation of being memory-hungry, and I know plenty of people struggling with memory usage of server application (e.g. ElasticSearch). You will also find C&#x2F;C++ on the same popularity listsâ€¦<p>That said, I do agree that a tracing GC is a better solution (for <i>most</i> programs) than reference counting these days. The improvements in the pause times by the Java GCs are really impressive, and the throughput is great. One example would be ESBuild: The author created a prototype in both Rust and Go, and found that the Go version was faster allegedly because Rust ended up spending a lot of time deallocating [source: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22336284" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22336284</a>].')