Item(by='knorker', descendants=None, kids=None, score=None, time=1611059052, title=None, item_type='comment', url=None, parent=25832639, text='Yeah, in the longer comment I said that it &quot;complicates&quot; contexts, because you can put the context in the work unit. But it&#x27;s very easy to get it wrong.<p>E.g. the godoc for the context package itself says &quot;Do not store Contexts inside a struct type&quot;. I understand the reason to be that it&#x27;s easy to make the lifetime nonobvious, and make it &quot;strange&quot; (hard to read and reason about) if it&#x27;s not very strictly kept under control. In other words it becomes a foot-gun as the code base grows.<p>And even then the stack is still unhelpful.<p>Benchmarking for your own workload beats anything else no matter what the language, of course. But it may change in the future, too. Maybe the next version of Go actually makes it faster? In other words it&#x27;s not wrong, but great care should be used.<p>One reason it can be faster to spawn goroutines is that IIRC spawning a goroutine actually makes the current OS thread start running that. And if it completes then it can jump back to the spawner. In other words spawning goroutine can save thread creations and context switches, while a goroutine pool will likely incur an OS context switch, with cache implications and other complex interactions.<p>But yes, measure with your actual workload is king.')