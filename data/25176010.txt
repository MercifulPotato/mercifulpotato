Item(by='inopinatus', descendants=None, kids=None, score=None, time=1606035199, title=None, item_type='comment', url=None, parent=25175932, text='It&#x27;s dangerous to assume that definition by keyword is syntactic sugar, because there are crucial lexical differences that will bite the novice metaprogrammer on the backside. For example, writing<p><pre><code>    class Foo; end\n</code></pre>\ndiffers from<p><pre><code>    Foo = Class.new\n</code></pre>\nsince the former will open an existing class, whilst the latter will overwrite the constant with a new class, and then the <i>cref</i> (roughly speaking, constant search path) is different due to the module nesting structure; hence:<p><pre><code>    class Foo\n      MAGIC_NUMBER=42\n\n      def self.hello1\n        MAGIC_NUMBER\n      end\n    end\n\n    def Foo.hello2\n      MAGIC_NUMBER\n    end\n\n    Foo.hello1 #=&gt; 42\n    Foo.hello2 #=&gt; NameError: uninitialized constant MAGIC_NUMBER\n</code></pre>\nand worse:<p><pre><code>    Bar = Class.new do\n      MAGIC_NUMBER = 99\n    end\n</code></pre>\ndefines MAGIC_NUMBER as a top-level constant, not as Bar::MAGIC_NUMBER, which is bad enough in itself, but now<p><pre><code>    Foo.hello2 #=&gt; 99\n</code></pre>\nwhich is the kind of subtle misbehaviour that drives people nuts trying to resolve.<p>Without going into the arcane detail, there are similarly subtle variations that&#x27;ll show up, involving the default definee (aka the <i>third implicit context</i>), and closures contained in the class definitions.<p>So I&#x27;m very sparing in my use of Class.new and even Module.new, I&#x27;ll restrict them to carefully written framework methods.<p>&gt; Class method is just a method of objects class<p>You&#x27;d hope. But look at the mechanics of Kernel#class. Objects don&#x27;t work from a reference to their (apparent) class, the obj-&gt;klass pointer doesn&#x27;t necessarily go there; it references the head of the <i>linked list of all ancestors</i>, and if you&#x27;ve referred to the singleton in any fashion it&#x27;ll point to that (absent funny business like prepending the singleton). Then rb_class_real has to iterate along the list skipping the singleton and any ICLASS entries, and assumes the first thing it sees otherwise is the class you meant.<p>The point being that an object&#x27;s apparent class is defined by the first object in its ancestors list that isn&#x27;t its singleton class or a included&#x2F;prepended module.  In theory, this should be invariant across the object&#x27;s lifetime.  In practice, Ruby recomputes it each time. The reason for this is that as soon as you reference the singleton of an object, Ruby a) allocates it, and b) updates the obj-&gt;klass pointer to be the singleton, not the class it was made from.<p>Also, you can screw with people&#x27;s assumptions via def foo.class; Object; end, which just demonstrates how wilfully ignoring the Law of Demeter gets you into trouble.')