Item(by='ImprobableTruth', descendants=None, kids=[24966225], score=None, time=1604275770, title=None, item_type='comment', url=None, parent=24963087, text='I&#x27;d agree that people are generally going to be less familiar with type theory (though I think it&#x27;s not uncommon to touch on the simply typed lambda calculus in undergrad courses), but I really think anybody who has all those prerequisites could also learn enough type theory to write specifications in a couple hours because you don&#x27;t actually need a deep understanding of type theory to use it (though maybe you meant that you immediately started writing specifications of large, real-world systems in TLA+, but I&#x27;d presume you&#x27;d then be the outlier on that). In my experience people pick up Isabelle (&#x2F;HOL) really quickly and writing specifications in a type theory based proof assistant isn&#x27;t a huge jump from that.<p>Now, writing actual proofs is a completely different matter, but I didn&#x27;t disagree with you on how economical&#x2F;ergonomic the over all approach actually is, just the basic complexity of the theory&#x2F;specifications ;)<p>&gt;What is the type of its first argument?<p>Some universe U, which is an implicit argument. \nYou could alternatively write your Lean example as<p>def id {u} {α : Sort u} (a : α) : α := a<p>Not being able to specify the type of u in Lean might seem kinda cheaty, but I&#x27;d say that&#x27;s similar to how one declares generic type parameters in e.g. Java. You wouldn&#x27;t say that those languages&#x27; generic functions aren&#x27;t actually functions, would you?<p>Similar to how one could make those generics explicit, it is actually possible to define a special type of all universes (not including itself). Agda does this by having a special primitive type of universe levels. As an example<p>id : forall {u : Level} -&gt; forall {A : Set u} -&gt; A<p>is the signature of the universe polymorphic identity function. The Level type doesn&#x27;t you any issues because it is essentially a &#x27;top&#x27; type that doesn&#x27;t have a type itself.')