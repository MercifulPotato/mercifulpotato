Item(by='dkarl', descendants=None, kids=None, score=None, time=1608151376, title=None, item_type='comment', url=None, parent=25447467, text='Maybe it&#x27;s easy to overlook these things when you have a really deep computer science background, but coming to software engineering from a non-CS background (math degree) I found lots of valuable knowledge in CS.  The most important parts for me would be:<p>- State machines.  I run into a lot of state machines, especially incompletely specified ones.  Not that everybody gets these wrong if they haven&#x27;t studied state machines in a textbook and worked the exercises at the end of the chapter, but recognizing &quot;oh, this is a state machine&quot; gives me a mental framework, a notation, a vocabulary that other developers understand, and a better ability to understand when a problem is underspecified or inconsistent.<p>- Queueing theory and algorithmic complexity.  These two usually come in handy from the perspective of spotting and avoiding stupid mistakes.  It&#x27;s true that people can do a pretty decent job from a handful of rules of thumb, but not everybody has that minimum knowledge, and sometimes a problem has a twist that an imprecise rule of thumb doesn&#x27;t account for.<p>- Distributed systems.  Just understanding the solution of a few problems in depth, and knowing from that how hard simple things really are, is incredibly valuable.  Without that background, people can naively tackle extremely complex problems, bash their heads against them for years, and still underestimate the difficulty of the problems they&#x27;ve created for themselves by orders of magnitude.<p>In general, the rigor of doing theoretical problems, the discipline of actually proving things, creates habits that uncover lots of non-happy path possibilities.')