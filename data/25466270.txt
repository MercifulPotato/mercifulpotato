Item(by='jgraham', descendants=None, kids=None, score=None, time=1608292820, title=None, item_type='comment', url=None, parent=25465424, text='I recently converted a medium size project from Python 2 to 3 by first adding type annotations to everything, then getting mypy to pass with both versions of Python and then fixing up the remaining issues on the unittests. The functionality of the code depends a lot on external services that are accessed via HTTP&#x2F;subprocesses. This makes it pretty hard to test well; at best your tests end up exercising an inaccurate partial facsilmile of the external service.<p>Overall I didn&#x27;t really love mypy; the type system it implements seems relatively simplistic and it was frequently easier to change the code rather than work out how to write working annotations for the existing code. The lack of support for decorated property setters in particular was a big problem; this particular codebase makes extensive use of those to annotate methods that require mutable access to the underlying data. Nevertheless I&#x27;m convinced that this approach to the migration was much faster and less painful than it would have been to try and figure out all the string&#x2F;bytes differences without any tooling support except for the tests. And post migration the code seems overall somewhat higher quality than at the start.<p>On balance, I think the lesson was actually that Python isn&#x27;t a great choice for this kind of project. When you are depending on external services the ability to unit test everything is greatly diminished, but the ability to make type assertions is not. So for correctness you want the latter to do as much lifting as possible. That suggests that other langauges such as typescript (if you still want a language in vaugely the same category as Python), or Rust (if you don&#x27;t), which come with more expressive, better integrated, type systems, might be superior options.')