Item(by='chriswarbo', descendants=None, kids=None, score=None, time=1604319663, title=None, item_type='comment', url=None, parent=24963821, text='Thinking about safety and security can benefit from a threat model: what sort of things do we expect to happen, and are we trying to prevent?<p>I think of safe handling of user input as &quot;first order safety&quot;. Server-side code handling arbitrary input from the network should use an adversarial model: assume that users will exploit any weakness we expose, no matter how convoluted.<p>Program&#x2F;library architecture and design is more like &quot;higher order safety&quot;: we&#x27;re not directly preventing attacks, we&#x27;re preventing code-which-allows-attacks. I don&#x27;t follow an adversarial approach here: I&#x27;m not trying to stop a rogue developer from inserting backdoors into a project, I&#x27;m trying to catch and prevent mistakes from being made.<p>If there&#x27;s a correct-by-construction way to approach certain problems then I&#x27;ll gladly use it (e.g. one of my current projects uses NonEmptyString, NonEmptySet and NonEmptyList, which use a (head, tail) pair to guarantee non-emptiness). If that&#x27;s not practical, but there is a way to encapsulate problematic code using newtypes and modularity, then I&#x27;ll take that (e.g. this project has a NoSpace newtype for strings without whitespace). If it&#x27;s not practical to encapsulate problematic code, then I&#x27;d still rather make it obvious when something dodgy is happening, e.g. even if a &#x27;StatusCode&#x27; is isomorphic to a String, the minor cost of wrapping it up in a newtype is worth it to prevent obvious mistakes like appending semantically distinct values. It&#x27;s all about bang-for-buck.<p>I also agree that type synonyms usually aren&#x27;t worth it. The extra cost of introducing a newtype isn&#x27;t much, and it buys us a lot more in terms of ruling out problems, making conversions more explicit, better error messages, etc.')