Item(by='cb321', descendants=None, kids=[24821232], score=None, time=1603048379, title=None, item_type='comment', url=None, parent=24817594, text='FWIW, the Nim version is (no deps besides stdlib):<p><pre><code>  import os, strutils, tables, heapqueue\n\n  iterator topByVal*[K, V](c: Table[K, V], n = 10, min = V.low): (K, V) =\n    var q = initHeapQueue[(V, K)]()\n    for key, val in c:\n      if val &gt;= min:\n        let elem = (val, key)\n        if q.len &lt; n: q.push(elem)\n        elif elem &gt; q[0]: discard q.replace(elem)\n    var y: (K, V)         # yielded tuple\n    while q.len &gt; 0:      # q now has top n entries\n      let r = q.pop\n      y[0] = r[1]\n      y[1] = r[0]\n      yield y             # yield in ASCENDING order\n\n  template maybeCount(count, word: untyped) =\n    if word.len &gt; 1: count.mgetOrPut(word, 0).inc\n\n  proc main() =\n    var count = initTable[string, uint]()\n    for path in &quot;.&quot;.walkDirRec:\n      if not path.endsWith(&quot;.txt&quot;):\n        continue\n      for line in path.lines:\n        var word = &quot;&quot;\n        for c in line.toLower:\n          if c in {&#x27;a&#x27;..&#x27;z&#x27;}:\n            word.add c\n          else:\n            count.maybeCount word\n            if word.len &gt; 0: word.setLen 0\n        count.maybeCount word # line ends in a word\n    for word, cnt in count.topByVal:\n      echo cnt, &quot; &quot;, word\n\n  main()\n</code></pre>\nDoing a gcc-10 profile-guided-optimization build on this, I get the min time of 5 trials running on Charles Dickens&#x27; Tale Of Two Cities { opening paragraph is very optimization claims relevant! :-) } available here: <a href="http:&#x2F;&#x2F;www.textfiles.com&#x2F;etext&#x2F;AUTHORS&#x2F;DICKENS&#x2F;dickens-tale-126.txt" rel="nofollow">http:&#x2F;&#x2F;www.textfiles.com&#x2F;etext&#x2F;AUTHORS&#x2F;DICKENS&#x2F;dickens-tale-...</a><p><pre><code>   7.3 ms  EDIT- tptacek&#x27;s C version (w&#x2F;bug-fix &amp; new tokenization)\n  15.8 ms  Above Nim 1.4 PGO --gc:arc\n  24.8 ms  Above Nim 1.4 --gc:arc\n  27.3 ms  Original C++ PGO\n  30.2 ms  Original C++ -O3 only\n  42.6 ms  dga&#x27;s Rust with rustc-1.47.0 build --release\n</code></pre>\nThis is on a i7-6700k.  So, Skylake core and probably more importantly 8 MiB L3.  So, also FWIW, I could not reproduce the Rust&#x2F;C++ timing ratios with the above mentioned input file.  I would also point out that not only is globwalk unnecessary as @burntsushi points out, neither are regexes nor even sorting.  A heap is a better way to do &quot;top N&quot;, but you may need to reverse the answer if you care.  I mean, maybe the point of the original C++ is to also bench&#x2F;exhibit use of regex engines and part of the Rust point is utf8 or some such, but to me that seems more like a distraction.<p>Anyway, maybe my rust build environment is screwy.  Hence, my inclusion of an exact input .txt file for others to try out if they care.  I had to add some extern crates and [dependencies] of anyhow, lazysort, regex, globwalk.  I&#x27;ve never done a PGO build with rust, either.  So, that may help.')