Item(by='dvt', descendants=None, kids=[25425435, 25423121, 25423098, 25424248, 25423703], score=None, time=1607973764, title=None, item_type='comment', url=None, parent=25419740, text='First of all: <i>fantastic article</i>. In-depth, insightful, and the examples are absolutely top-notch. On the razor&#x27;s edge between accessible and profound. Hats off to the author.<p>I will say that the problems seem to lie in a few interesting interlanguage quirks, and not so much on language <i>specs</i>. For example, LLVM and C have different definitions of &quot;undefined behavior&quot;[1] -- this is pointed out when looking at the `poison` identifier. In LLVM this might just be a weird side-effect we don&#x27;t care about, but actually having an integer overflow is a <i>big deal</i> in C that introduces UB. Given the introduction, LLVM (incorrectly) introduces (C) UB at times.<p>The second section, on pointer provenance, is much trickier, as there&#x27;s no &quot;obvious&quot; UB introduced there. Further, I would argue that pointer provenance is a meta-language (or meta-computational) concept (which the Rust docs hint at), and logically speaking, might be intractable in the general case (I&#x27;d have to think about this more). Pointer arithmetic can fiddle with meta-state, whereas IRs like LLVM tend to focus purely on symbol manipulation.<p>As a side note, I&#x27;d be curious what happens when LLVM sees something like: `void *p = &amp;p` which is a self-referential pointer. What does it deduce about it? Does it optimize it away?<p>Cool thought-provoking article.<p>[1] <a href="https:&#x2F;&#x2F;www.cs.utah.edu&#x2F;~regehr&#x2F;llvm-ub.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.utah.edu&#x2F;~regehr&#x2F;llvm-ub.pdf</a>')