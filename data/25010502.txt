Item(by='gregmac', descendants=None, kids=None, score=None, time=1604691962, title=None, item_type='comment', url=None, parent=25009411, text='&gt; although the phrase technical debt caries a lot of emotional weight, it also brings a lot of baggage from all the times management has heard the phrase from someone that didn&#x27;t understand the bigger picture.<p>I think this is an excellent point, but we still need a shorthand way to talk about it.<p>&gt; They&#x27;d say instead something like &quot;I was thinking that if we changed X we would get value Y.&quot;<p>The problem I have with this is it&#x27;s very hard to make a compelling argument, and without one, nothing gets done. A lot of the time technical debt is tantamount to a slow death by a thousand cuts, and &quot;value Y&quot; is more like &quot;save some unknown but non-zero amount of time in the future&quot;.<p>One example is when you have (tens of) thousands of lines of code that don&#x27;t have unit tests, have high coupling, and no or outdated documentation. Maybe there&#x27;s some known bugs, but they&#x27;re of low importance (in other words: fixing them is low value to the business). That code works today, and if not modified it&#x27;ll continue to work. If it <i>does</i> eventually get modified, then there are no guarantees: maybe the modifications won&#x27;t break anything, or maybe they&#x27;ll cause dozens of new bugs.<p>If we refactor today and add lots of tests, it&#x27;ll <i>probably</i> mean that future modification causes fewer bugs (saving time&#x2F;money), but we actually can&#x27;t guarantee anything -- aside from the refactor will cost a bunch of time, now.<p>&gt; a huge amount of technical debt is just code that a more senior engineer would refactor as they went<p>In a case like I described above you can sometimes refactor as you go but it&#x27;s been my experience this is often a deep rabbit hole. Sometimes your refactor requires touching a dozen layers and related bits and before you know it it can easily be several orders of magnitude more work and more risk vs the &quot;quick fix&quot;.<p>Another thing I often run into that we describe as &quot;technical debt&quot; is about foundational designs that are (currently) wrong. This includes things like database schema and core structure of the application. I say &quot;currently&quot; because some where not clearly wrong at the time they were made, but it had become clear since then and yet more stuff was still built on top.<p>As an example, I&#x27;m working on an application that was built to run on a single instance but we&#x27;d like to be able to scale horizontally. One of the problems is the application uses what is effectively an in-process cache for a lot of the database objects. The objects are not pure DTO-style objects and so the cache can&#x27;t just be moved to external (Redis or something). The schema is not that well designed, so entirely removing the cache would almost certainly kill performance, and might mean refactoring half the code anyway. A layer up, several parts of the app (including UI forms and some background processing) are built assuming they have a consistent view of things, and ignoring these issues causes all kinds of strange consistency problems as data is silently overwritten&#x2F;changed.<p>That type of problem is not at all fixable by &quot;refactoring as we go&quot;.  In some sense I&#x27;d <i>love</i> to do a totally clean rewrite, but that just isn&#x27;t going to happen largely because the business has no appetite for that. In the past I&#x27;ve done the massive rewrite thing before, and going a couple years without delivering anything from it is crazy stressful and no one is happy.<p>Instead, we&#x27;re working on rewriting major (but approachable) chunks of this one at a time, while retaining compatibility with other parts of the system and still trying to find things that provide customer&#x2F;business value as part of it (either fixing long-standing bugs or introducing new features). It&#x27;s <i>hard</i>, and overall is more work than just rewriting from scratch, but means we can deliver value as we go. Maybe this is what you mean by &quot;refactor as we go&quot; (or maybe that&#x27;s just how I should describe what we&#x27;re doing to higher-up), but to me we&#x27;re basically starting from zero and at best, pulling small chunks of the old code in, so it definitely doesn&#x27;t feel like &quot;refactor&quot;.<p>(I know this post is explicitly about not calling this &quot;technical debt&quot; but I can&#x27;t help but think this approach is analogous to a payment plan. :) )')