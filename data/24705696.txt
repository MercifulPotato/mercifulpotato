Item(by='msla', descendants=None, kids=[24706429, 24706258], score=None, time=1602050788, title=None, item_type='comment', url=None, parent=24705560, text='From the paper:<p>&gt; A key concept of the CP&#x2F;CMS  design was the bifurcation of computer resource management and user support. In effect, the integrated  design  was split into CP  and  CMS. CP solved the problem of multiple use by providing separate computing environments at the machine instruction level for each user. CMS then provided  single user service unencumbered by the problems of sharing, allocation, and protection.<p>I think we&#x27;ve lost this concept: We run Multics-like OSes as guests under Xen, not CMS-like.<p>&gt; As an aside, the MULTICS system [13] of M.I.T.â€™s Project MAC and CP&#x2F;CMS were both second-generation systems drawing heavily on the CTSS experience with very different architectural results.<p>And Unix is fundamentally of the Multics mold.<p>Another thing I want to comment on:<p>&gt; The design of System&#x2F;360, in order to facilitate the multiplexed execution of several jobs in a scheduled job environment, provided two instruction execution states: privileged and problem. The instructions available in problem state  are those commonly used by application programs. They are innocuous to other programs within the same  machine  and can be  safely executed. However, privileged instructions affect the entire machine as well as report its status. As they are encountered in problem state, the machine blocks their execution and transfers control to a designated program. When using CP, each virtual machine  program is actually executed in  problem state. The effects of privileged instructions are reproduced by CP  within the virtual machines.<p>All privileged instructions faulting to the hypervisor is a basic requirement for efficient virtualization in the Popek &amp; Goldberg virtualization requirements.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Popek_and_Goldberg_virtualization_requirements" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Popek_and_Goldberg_virtualizat...</a><p>(It&#x27;s nice to know what things are called if you want to do further research.)<p>Another interesting little note:<p>&gt; For example, a piece of CP might be implemented within hardware to extend machine capability. Users of virtual machines and their operating systems would see no change  in this function except possibly in cost or speed. Conversely, CP might simulate a new hardware feature to be tested. Performance might be poor, but programs using this feature could  be run. This  was done within IBM to prepare System&#x2F;370  programs using a System&#x2F;360.<p>Moving features from the hypervisor to the hardware is an interesting concept.<p>&gt; The System&#x2F;370 virtual machine can be in basic or extended control mode. Basic control does not include the virtual  memory hardware. This type of machine is used by  CMS and other operating systems that do not themselves utilize the address translation hardware. Extended control  mode  is selected when an operating system that controls virtual memory, such as CP or OS&#x2F;VS, is executed in a virtual machine. This  might be the case when a new version of CP is to be tested.<p>That&#x27;s right: Running a hypervisor as a guest of another hypervisor, possibly to debug a newer hypervisor in a safe (and potentially gimmicked?) environment which is nevertheless exactly like running on bare hardware. Is that possible with non-VM hypervisors on commodity hardware? Or is it another idea we&#x27;ve lost?')