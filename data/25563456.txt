Item(by='rav', descendants=None, kids=[25564414], score=None, time=1609191069, title=None, item_type='comment', url=None, parent=25560750, text='I work at a small company on a single page webapp. Since we&#x27;re working on a subscription-based product, we need to focus on fixing bugs and improving usability to make our users more productive and more happy. This should place us in firmly the third camp of pragmatic professional software engineers. But I don&#x27;t agree with the trichotomy outlined in the article.<p>We spend plenty of time and effort doing &quot;programming as hardware hacking&quot; to implement a backend that can process our customers&#x27; data orders of magnitude faster than our closest competitors: This allows our customers to obtain analysis results in minutes&#x2F;hours instead of days&#x2F;weeks. We didn&#x27;t get there with the third-camp sentiment that &quot;The program only has to be fast enough for the users&quot; - if we did, we wouldn&#x27;t be leaders of the (niche) industry that our customers operate within.<p>Then again, we spend plenty of time doing &quot;programming as applied mathematics&quot;. Our software inherently consists of a lot of geometric algorithms. To give a recent example, a couple colleagues and I spent a couple days last month to fix a buggy geometric primitive: Given an almost-simple polygon, which is made by joining the endpoints of a polyline without self-intersections with a straight edge, compute its area. We had a seemingly-correct, but complicated and evidently buggy, implementation that needed to be used in a new user-facing feature (contour-line simplification). After several whiteboard sessions and do-overs, we found a simple formulation of the problem that admitted a simple and obviously correct implementation. The buggy area computation didn&#x27;t cause any crashes or other obstructions to the user, but it created results that looked aesthetically unpleasing (because the lines were poorly simplified).')