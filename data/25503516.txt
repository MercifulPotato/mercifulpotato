Item(by='Geminidog', descendants=None, kids=None, score=None, time=1608618066, title=None, item_type='comment', url=None, parent=25503338, text='&gt;The downside to taking that combinator approach too dogmatically is that passing all state as parameters can get extra unwieldy, because now a simple change in data schema can result in you refactoring every single function call.<p>This should happen with methods too. Whether a variable is free or a parameter doesn&#x27;t change anything.<p><pre><code>   x = {b = 1, c = 2}\n   f(x) {return x.b}\n   g() return x.b\n</code></pre>\nA change in x, say deleting b, will require a refactor for both the combinator and the method.<p>I&#x27;m not saying combinators are the solution to everything. Of course not. I&#x27;m saying combinators are the solution to technical debt caused by organizational issues. Of course there are trade offs, I never said otherwise.<p>Both of the issues above are separate from the expression problem though. Personally I don&#x27;t think the expression problem is much of a problem. Whether you add a new function or a new shape to either paradigm in the example link you gave, the amount of logical operations you have to add is equal for both cases. The difference is the location of where you put those logical operations. In one case they can be placed closed together, in another case they have to be placed in separate scopes, but the total amount of logical operations written to achieve a certain goal is equal.<p>For example adding perimeter to either paradigm necessitates the need for you to define the perimeter of every shape no matter what. Neither paradigm actually offers a shortcut when new information is introduced into the system.')