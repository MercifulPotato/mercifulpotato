Item(by='lambda', descendants=None, kids=[25839209, 25839547], score=None, time=1611090447, title=None, item_type='comment', url=None, parent=25836448, text='RISC vs CISC isn&#x27;t really about instructions doing &quot;one simple thing period.&quot;<p>It&#x27;s about increased orthogonality between ALU and memory operations, making it simpler and more predictable in an out-of-order superscalar design to decode instructions, properly track data dependencies, issue them to independent execution units, and to stitch the results back into something that complies with the memory model before committing to memory.<p>Having a few crazy-ass instructions which either offload to a specialized co-processor or get implemented as specialized microcode for compatibility once you realize that the co-processor is more trouble than it&#x27;s worth doesn&#x27;t affect this very much.<p>What ARM lacks are the huge variety of different instruction formats and addressing mode that Intel has; which substantially affect the size and complexity of the instruction decoder, and I&#x27;m willing to bet that creates a significant bottleneck on how large of a dispatch and reorder system they can have.<p>For a long time, Intel was able to make up this difference with process dominance, clever speculative execution tricks, and throwing a lot of silicon and energy at it which you can do on the server side where power and space are abundant.<p>But Intel is clearly losing the process dominance edge. Intel ceded the mobile race a long time ago. Power is becoming more important in the data center, which are struggling to keep up with providing reliable power and cooling to increasingly power-hungry machines. And Intel&#x27;s speculative execution smarts came back to bite them in the big market they were winning in, the cloud, when it turned out that they could cause information leaks between multiple tenants, leading to them needing to disable a lot of them and lose some of their architectural performance edge.<p>And meanwhile, software has been catching up with the newer multi-threaded world. 10-15 years ago, dominance on single threaded workloads still paid off considerably, because workloads that could take advantage of multiple cores with fine-grained parallelism were fairly rare. But systems and applications have been catching up; the C11&#x2F;C++11 memory model make it significantly more feasible to write portable lock-free concurrent code. Go, Rust, and Swift bring safer and easier parallelism for application authors, and I&#x27;m sure the .net and Java runtimes have seen improvements as well.<p>These increasingly parallel workloads are likely another reason that the more complex front-ends needed for Intel&#x27;s instruction set, as well as their stricter memory ordering, are becoming increasingly problematic; it&#x27;s becoming increasingly hard to fit more cores and threads into the same area, thermal, and power envelopes. Sure, they can do it on big power hungry server processors, but they&#x27;ve been missing out on all of the growth in mobile and embedded processors, which are now starting to scale up into laptops, desktops, and server workloads.<p>I should also say that I don&#x27;t think this is the end of the road for Intel and x86. They have clearly had a number of setbacks of the last few years, but they&#x27;ve managed to survive and thrive through a number of issues before, and they have a lot of capital and market share. They have squeezed more life out of the x86 instruction set than I thought possible, and I wouldn&#x27;t be shocked if they managed to keep doing that; they realized that their Itanium investment was a bust and were able to pivot to x86-64 and dominate there. They are facing a lot of challenges right now, and there&#x27;s more opportunity than ever for other entrants to upset them, but they also have enough resources and talent that if they focus, they can probably come back and dominate for another few decades. It may be rough for a few years as they try to turn a very large boat, but I think it&#x27;s possible.')