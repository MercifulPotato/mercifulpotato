Item(by='adwn', descendants=None, kids=[24885102], score=None, time=1603601849, title=None, item_type='comment', url=None, parent=24881543, text='&gt; <i>My point is that turing-completeness is not necessarily a desirable aspect of a language.</i><p>Ah, okay, I see.<p>&gt; <i>For some use-cases, like seting up a mainloop, you need an escape hatch because that mainloop is not going to be total. But not every program needs that.</i><p>Hmm, I would argue that in practice, nearly all programs <i>will</i> need that, because they&#x27;re either potentially non-terminating (let&#x27;s call this &quot;type 1&quot;) or have a runtime with a bound which is not determined by any of its inputs (&quot;type 2&quot;). Examples for type 1 include firmware, kernels, drivers, database engines, any kind of server, all programs with a GUI, all REPLs, and many Unix-style utilities that process or generate streams (thing grep, cat, sed, dd). Examples for type 2 include all programs with non-blocking IO (because even if the input and output are known to be bounded, the number of read&#x2F;write calls is potentially unbounded) and most programs which take a file name as input (because the file <i>size</i> is not part of the program&#x27;s input).<p>That doesn&#x27;t leave many exceptions. I admit, however, that in most cases you could structure your program so that it has a non-total mainloop which exclusively calls proven total functions. But I don&#x27;t think this is very useful, because even in safety-relevant, hard real-time contexts, termination is not sufficient, but termination within a certain timespan.')