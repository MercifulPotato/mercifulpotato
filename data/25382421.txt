Item(by='lmm', descendants=None, kids=[25382886], score=None, time=1607662044, title=None, item_type='comment', url=None, parent=25381903, text='&gt; Ideological answer: For the same reason HTTP&#x2F;2.0’s binary protocol didn’t instantly obviate&#x2F;deprecate HTTP&#x2F;1.0’s text protocol. Text has advantages: text is debuggable, and prototypable. If the interface between two programs is a text based declarative language, you can audit that text, diff that text, edit that text to see how changes affect the result, mock one side or the other by producing or consuming that text, etc.<p>I can see the argument for using a textual format (although I think it&#x27;s weaker than you say; if we&#x27;re generating this config with code then we don&#x27;t want to diff or edit the generated config), but YAML seems like a singularly poor choice if you want reliable diffs and editing; it&#x27;s like picking tag-soup HTML. Straight JSON (ideally with a schema), TOML or even XML seems like a better bet if you&#x27;re generating it programmatically.<p>&gt; And, obviously, if you don’t control the other end, you don’t decide how the other end does its config.<p>Right, in that case it&#x27;s all moot. I took GP to be talking about what formats these tools should use. IMO if the tool is intended to consume a machine-generated config then it would be better to use a machine-oriented config format. I think the option of something like protobuf (which is language-independent) is underappreciated, but even restricting ourselves to textual options, something stricter than YAML seems like a better bet.')