Item(by='mywittyname', descendants=None, kids=None, score=None, time=1609867470, title=None, item_type='comment', url=None, parent=25647143, text='You certainly could write a procedural-generated test harness, where you generate a graph of user actions, then send them to the system.  I&#x27;ve done that before for integration testing of user-generated event pathways.  But my main concern was for accuracy and load testing, so at the end of the test, I would query the database and check the report against what the test case sent.<p>The problem with this approach is that it results in &quot;wobbly&quot; tests, that is, tests that fail non-deterministically.  These are really annoying and will quickly cause developers to ignore test failures.  So I don&#x27;t like them as part of a standard testing suite.<p>It sounds like you may want to put more boundaries in your application.  Rather than testing out all possible combinations, reduce the available combinations and test their enforcement.  I think you&#x27;re best starting point is to place hard limits on input and test up to those limits.  For example, define the maximum length of inputs, allowable character sets, numeric ranges,  etc, then write test cases to ensure those limitations are enforced.<p>It&#x27;s difficult to know what the next step would be without knowing your tech stack or your goal.  Why do you want test various permutations of user input?  Is there some cause for concern if a user performs Action B, then Action A instead of the predefined Action A, then Action B?  If that&#x27;s the case, you should encode these paths into your software and have test cases to check them.<p>It sounds to me like you&#x27;re looking for a magic bullet to get comprehensive testing without writing comprehensive tests.  That&#x27;s not really possible.  You have to test what&#x27;s important, then rely on logical implication for the rest.  Sprinkle in good logging and error handling for the inevitable hiccup, and monitor the logs for improvements.')