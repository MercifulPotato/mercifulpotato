Item(by='AnthonBerg', descendants=None, kids=None, score=None, time=1603905802, title=None, item_type='comment', url=None, parent=24917393, text='As this has been downvoted, perhaps it wasn&#x27;t clear that I am being serious and earnest :)<p>I&#x27;m keenly interested in composing and talking to a loosely hierarchical structure of functions that do text layout through profunctor optics. Profunctor optics are an approach to define composable, hierarchical, and <i>&quot;simpler ways of writing programs that access the components of compound data structures&quot;.</i> It&#x27;s especially interesting when the problem context is this complex. To build that complex program, we would want to use the ways that are as simple as possible, right?<p>Can we use profunctor optics to build a functional (working) description of a text layout pipeline? Can we use profunctor optics to swap out components? (Probably!) Can we design a profunctor optic-based program structure that allows meaningful transformations of input and output as needed?<p>Abstract: Profunctor Optics Modular Data Accessors<p><i>Matthew Pickering, Jeremy Gibbons, and Nicolas Wu</i><p><a href="http:&#x2F;&#x2F;www.cs.ox.ac.uk&#x2F;people&#x2F;jeremy.gibbons&#x2F;publications&#x2F;poptics.pdf" rel="nofollow">http:&#x2F;&#x2F;www.cs.ox.ac.uk&#x2F;people&#x2F;jeremy.gibbons&#x2F;publications&#x2F;po...</a><p><i>Abstract Data accessors allow one to read and write components of a data structure, such as the fields of a record, the variants of a union, or the elements of a container. These data accessors are collectively known as optics; they are fundamental to programs that manipulate complex data. Individual data accessors for simple data structures are easy to write, for example as pairs of ‘getter’ and ‘setter’ methods. However, it is not obvious how to combine data accessors, in such a way that data accessors for a compound data structure are composed out of smaller data accessors for the parts of that structure. Generally, one has to write a sequence of statements or declarations that navigate step by step through the data structure, accessing one level at a time—which is to say, data accessors are traditionally not first-class citizens, combinable in their own right.</i><p><i>We present a framework for modular data access, in which individual data accessors for simple data structures may be freely combined to obtain more complex data accessors for compound data structures. Data accessors become first-class citizens. The framework is based around the notion of profunctors, a flexible gen- eralization of functions. The language features required are higher-order functions (‘lambdas’ or ‘closures’), parametrized types (‘generics’ or ‘abstract types’) of higher kind, and some mechanism for separating inter- faces from implementations (‘abstract classes’ or ‘modules’). We use Haskell as a vehicle in which to present our constructions, but other languages such as Scala that provide the necessary features should work just as well. We provide implementations of all our constructions, in the form of a literate program: the manuscript file for the paper is also the source code for the program, and the extracted code is available separately for evaluation. We also prove the essential properties, demonstrating that our profunctor-based representations are precisely equivalent to the more familiar concrete representations. Our results should pave the way to simpler ways of writing programs that access the components of compound data structures.</i>')