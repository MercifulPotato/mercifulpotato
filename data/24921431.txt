Item(by='nendroid', descendants=None, kids=None, score=None, time=1603905408, title=None, item_type='comment', url=None, parent=24915643, text='It&#x27;s not just pure functions. Two things break modularity: Free variables and mutation.<p>The problem with OOP is that no method is truly pure, no method is a combinator.<p><pre><code>   class Thing\n      var memberVar\n      def addOne():\n          return memberVar+1;\n\n</code></pre>\nThe above is an example of your typical class. AddOne is not modular because it cannot be used outside of the context of Thing.<p>You can use static functions but the static keyword defeats the purpose of a class and makes the class equivalent to a namespace containing functions.<p><pre><code>   class Thing\n      static def add(x):\n           return x + 1;\n</code></pre>\nthe above is pointless. Just do the below:<p><pre><code>   namespace Thing:\n       def add(x):\n           return x + 1; \n</code></pre>\nThe point of OOP is for methods to operate on internal state. If you remove this feature from OOP you&#x27;re left with something that is identical to namespaces and functions.<p>Use namespaces and functions when all you have are pure functions and use classes when you need internal state... there is literally no point for OOP if you aren&#x27;t using internal state with your classes.')