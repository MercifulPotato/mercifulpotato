Item(by='robocat', descendants=None, kids=None, score=None, time=1610399943, title=None, item_type='comment', url=None, parent=25735957, text='<p><pre><code>    int rdrand(unsigned long *ret) {\n    &#x2F;* So, you are a &quot;security researcher&quot;, and you wonder why we bother with using raw RDRAND here,\n         * instead of sticking to &#x2F;dev&#x2F;urandom or getrandom()?\n         *\n         * Here&#x27;s why: early boot. On Linux, during early boot the random pool that backs &#x2F;dev&#x2F;urandom and\n         * getrandom() is generally not initialized yet. It is very common that initialization of the random\n         * pool takes a longer time (up to many minutes), in particular on embedded devices that have no\n         * explicit hardware random generator, as well as in virtualized environments such as major cloud\n         * installations that do not provide virtio-rng or a similar mechanism.\n         *\n         * In such an environment using getrandom() synchronously means we&#x27;d block the entire system boot-up\n         * until the pool is initialized, i.e. *very* long. Using getrandom() asynchronously (GRND_NONBLOCK)\n         * would mean acquiring randomness during early boot would simply fail. Using &#x2F;dev&#x2F;urandom would mean\n         * generating many kmsg log messages about our use of it before the random pool is properly\n         * initialized. Neither of these outcomes is desirable.\n         *\n         * Thus, for very specific purposes we use RDRAND instead of either of these three options. RDRAND\n         * provides us quickly and relatively reliably with random values, without having to delay boot,\n         * without triggering warning messages in kmsg.\n         *\n         * Note that we use RDRAND only under very specific circumstances, when the requirements on the\n         * quality of the returned entropy permit it. Specifically, here are some cases where we *do* use\n         * RDRAND:\n         *\n         *         • UUID generation: UUIDs are supposed to be universally unique but are not cryptographic\n         *           key material. The quality and trust level of RDRAND should hence be OK: UUIDs should be\n         *           generated in a way that is reliably unique, but they do not require ultimate trust into\n         *           the entropy generator. systemd generates a number of UUIDs during early boot, including\n         *           &#x27;invocation IDs&#x27; for every unit spawned that identify the specific invocation of the\n         *           service globally, and a number of others. Other alternatives for generating these UUIDs\n         *           have been considered, but don&#x27;t really work: for example, hashing uuids from a local\n         *           system identifier combined with a counter falls flat because during early boot disk\n         *           storage is not yet available (think: initrd) and thus a system-specific ID cannot be\n         *           stored or retrieved yet.\n         *\n         *         • Hash table seed generation: systemd uses many hash tables internally. Hash tables are\n         *           generally assumed to have O(1) access complexity, but can deteriorate to prohibitive\n         *           O(n) access complexity if an attacker manages to trigger a large number of hash\n         *           collisions. Thus, systemd (as any software employing hash tables should) uses seeded\n         *           hash functions for its hash tables, with a seed generated randomly. The hash tables\n         *           systemd employs watch the fill level closely and reseed if necessary. This allows use of\n         *           a low quality RNG initially, as long as it improves should a hash table be under attack:\n         *           the attacker after all needs to trigger many collisions to exploit it for the purpose\n         *           of DoS, but if doing so improves the seed the attack surface is reduced as the attack\n         *           takes place.\n         *\n         * Some cases where we do NOT use RDRAND are:\n         *\n         *         • Generation of cryptographic key material \n         *\n         *         • Generation of cryptographic salt values \n         *\n         * This function returns:\n         *\n         *         -EOPNOTSUPP → RDRAND is not available on this system \n         *         -EAGAIN     → The operation failed this time, but is likely to work if you try again a few\n         *                       times \n         *         -EUCLEAN    → We got some random value, but it looked strange, so we refused using it.\n         *                       This failure might or might not be temporary. \n         *&#x2F;</code></pre>')