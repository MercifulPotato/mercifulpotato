Item(by='Jtsummers', descendants=None, kids=[25201904], score=None, time=1606244545, title=None, item_type='comment', url=None, parent=25201193, text='It has C and C++&#x27;s performance without a lot of the footguns. A better type system. The trait system is a nicer way to extend types than C++&#x27;s class system (IMO). Generics from the start, instead of absent (C) or added on and still not fully utilized by practitioners (C++, some practitioners get the value, other offices bar using them). The ownership model means that using the lower level concurrency primitives is less likely to have the subtle issues of C and C++. It also means they could avoid encoding a specific concurrency model into the language (like Go or Erlang) and let those be libraries.<p>Cargo as a standard build system, package manager, and test runner. This makes for a much more coherent development environment than the tire fire that is C and C++&#x27;s build, test, and package management story.<p>Developing tests is much easier than in C and C++, which means many of the packages are actually reasonably well tested (maybe not perfect, but better than the average C or C++ package you might want to incorporate into a project).<p>Rust has a pretty good module system. C has nothing of the sort, and C++ has a mix of things that can be used similarly (classes, namespaces) and only recently got modules proper in C++20. This helps a lot with organizing your code into a modular structure and then sharing that code with other projects.<p>Rust can call and be called from C, so there is no tossing anything out. You can integrate Rust into an existing project one file at a time. Move your more critical code into it, and let other code call it. Going back to concurrency, put the part that generates and manages workers (as an example of one model) in Rust and leave the rest of the logic in C or C++. Gradually migrate the worker logic into Rust, or not. Perhaps it&#x27;s a library that you don&#x27;t control or don&#x27;t want to change.<p>Some things aren&#x27;t pretty or aren&#x27;t clear. For instance, str and String are pretty confusing for new users. But the compiler will catch these for you. Speaking of, actually decent compiler warnings and errors. Often with potential fixes included, which usually do what you want.<p>In summary: Fewer footguns, better quality of life components, better language features in some areas (type system, modules, in particular), no performance hit (or no major performance hit) compared to other options for languages attempting to offer improved safety (where safety could be along many dimensions).')