Item(by='flohofwoe', descendants=None, kids=None, score=None, time=1603708606, title=None, item_type='comment', url=None, parent=24894608, text='Yeah I just added that while you wrote your comment, sorry.<p>You can still put multiple implementations into the same source file and compile that into a library, for example:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;floooh&#x2F;sokol-samples&#x2F;blob&#x2F;master&#x2F;libs&#x2F;sokol&#x2F;sokol.c" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;floooh&#x2F;sokol-samples&#x2F;blob&#x2F;master&#x2F;libs&#x2F;sok...</a><p>That&#x27;s what I usually do for projects that don&#x27;t just consist of a single source file (e.g. simple command line tools).<p>An actual advantage of this approach is that you can add any configuration defines in that same source file, instead of passing them in from the build system via compiler command line args.<p>Also for bigger projects you can have dozens or hundreds of header files but only a small number of source files (e.g. one source file per &quot;system&quot; or split by change frequency, or by any other criteria (like whether the implementations include Windows.h or other system headers). A small number of compilation units means fast compile times (since it&#x27;s essentially a unity build), but at the same time you have enough control over the project&#x27;s file structure to balance compile times vs &quot;namespace pollution&quot; vs what changes trigger a rebuild.')