Item(by='Raidion', descendants=None, kids=[25296498, 25296270, 25299075, 25296878, 25298579, 25297083, 25303612, 25297858, 25296234, 25299708, 25297349], score=None, time=1607030564, title=None, item_type='comment', url=None, parent=25290339, text='If I make the change in code, I can roll it out, test it in prod, and then slowly migrate traffic over in very standard and well defined ways.<p>If I deploy to the database and something goes wrong, I need to really trust my rollback scripts. If the rollback scripts go haywire, you&#x27;re in a tough spot. If that happens to code, you can literally just move all the traffic to the same thing that was working before, you don&#x27;t quite have that luxury with the database.<p>You can have a bunch of servers, you really only can have one database. This means the database should be very sensitive to changes because it&#x27;s a single point of failure. I don&#x27;t like modifying or changing single points of failure without very good and well tested reasons.<p>Could you version your procs and have the new version of the code call the new procs? Sure, but now you have to manage deployment of both a service, and the database, and have to handle rollover and&#x2F;or A&#x2F;B for both. If my logic is in there service, I only have to worry about rolling back the service.<p>Database logic saves you a little bit of pain in development for a ton of resilience and maintenance costs, and it&#x27;s not worth it in the long run IMO. Maybe it&#x27;s because the tooling isn&#x27;t that mature, but until I can A&#x2F;B test an atomic database, this doesn&#x27;t work for a lot of applications.')