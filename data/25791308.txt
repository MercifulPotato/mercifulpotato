Item(by='userbinator', descendants=None, kids=[25792721], score=None, time=1610721019, title=None, item_type='comment', url=None, parent=25788819, text='My experience is pretty much the exact opposite, and I&#x27;ve been writing x86 Asm since the DOS days, only looking at ARM and other RISC stuff later.<p><i>Most RISC ISA&#x27;s are relatively orthogonal, in the sense that you have to memorize only a small list of things, e.g. of kinds of instructions, kinds of registers, kinds of addressing modes, and then you can express any program as a combination of those few elements.</i><p>x86 is very orthogonal and has been since the 386. There&#x27;s something called a ModRM, and the majority of the instructions use that form. The encoding is based on octal: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;seanjensengrey&#x2F;f971c20d05d4d0efc0781f2f3c0353da" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;seanjensengrey&#x2F;f971c20d05d4d0efc0781...</a><p><i>The original x86 registers are all different having different features, there are not even 2 identical registers, so to find the optimal register allocation is difficult.</i><p>On the contrary, that guides register allocation. Too bad most compilers don&#x27;t seem to know, which is why they are often very easy to beat (and why compiler output looks so distinctively different from good handwritten Asm.)<p><i>Even the extra 8 registers added by the AMD 64-bit extension are not identical, but they are divided in 3 or 4 groups with different properties regarding the encoding of the instructions, which result in different program izes.</i><p>I have no idea what you mean by  &quot;divided in 3 or 4 groups&quot;. The &quot;high registers&quot; are all accessed with an extra prefix byte.<p><i>It is difficult to determine the total number of different instructions in the x86 ISA, but they are much more than a thousand, many of which are obsolete and which should be avoided.</i><p>FUD, no one really cares about &quot;total number of different instructions&quot;. If you think of the typical RISC with fixed 32-bit instructions, that&#x27;s over 4 billion values...<p>RISC is so bland and boring that it&#x27;s hard to do a better job than a stupid compiler. An &quot;op mem, reg&quot; which is usually 2 or 3 bytes on x86 turns into at least 3 instructions (=12 bytes) and an explicit register allocation on a RISC. It&#x27;s like writing microcode. No wonder they have so many  registers --- they&#x27;re really what a more intelligent CISC would use dynamically allocate internally in its uop execution engine&#x2F;register renamer, saving cache occupancy and fetch bandwidth.')