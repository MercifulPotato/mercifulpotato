Item(by='nicoburns', descendants=None, kids=[25913607], score=None, time=1611499234, title=None, item_type='comment', url=None, parent=25891794, text='&gt; You’re trading “py2 vs py3” with “py2 mode vs py3 mode”.<p>Yes, that&#x27;s the whole point. Because compatible modes allow for a gradual transition. Which in practice allows for a much <i>faster</i> transition, because you don&#x27;t have to transition everything at once (which puts some people off transitioning entirely - making things infinitely harder for everyone else).<p>Languages like Rust (editions) and JavaScript (strict mode) have done this successfully and relatively painlessly.<p>&gt; So you’d have some magic code that switches py2str to bytes. Which means every py3 caller has to cast bytes into a string to do anything useful with it, because returning strings is the most common case. Then that code has to be removed when the code it’s calling is updated to py3 mode. Which is basically the blue&#x2F;green issue you see with async functions but way, way worse.<p>Well yes, you&#x27;d still have to upgrade your code. That goes with a major version bump. But it would allow you to do it on a library-by-library basis rather than forcing you to wait until every dependency has a v3 version. Have that one dependency that keeping you stuck on v2: no problem, upgrade everything else and wrap that one lib in conversion code.<p>&gt; Then you’d need to handle subclasses, wrappers of bytes&#x2F;str, returning collections of strings across py2&#x2F;py3 boundaries (would these be copies? Different types? How would type(value[0]) work?), ending up with mixed lists&#x2F;dicts of bytes and strings depending on the function context, etc etc.<p>I&#x27;m not sure I understand the problem here. The types themselves are the same between python 2 and 3 (or could have been). It&#x27;s just the labels that refer to them that are different. A subclass of string in python 2 code would just be a subclass of bytes in python 3 code.')