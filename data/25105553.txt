Item(by='piotrkaminski', descendants=None, kids=[25107245], score=None, time=1605479282, title=None, item_type='comment', url=None, parent=25101820, text='I&#x27;m seeing a lot of criticism along the lines of &quot;the trade-offs are not worth it in &lt;context&gt;&quot; or &quot;the article didn&#x27;t address every detail&quot;.  Well, yeah -- no advice is universal, and this blog post isn&#x27;t a 500 page reference book.  I think it would be more productive to help the author articulate the trade-offs and forces pushing for and against this architecture.<p>FWIW, Reviewable (<a href="https:&#x2F;&#x2F;reviewable.io" rel="nofollow">https:&#x2F;&#x2F;reviewable.io</a>) follows roughly this design and, after 6 years, it&#x27;s still a fine system to develop in.  It runs on top of Firebase RTDB which takes care of the security rules; if anything, I feel better having all the security rules articulated in one central location (the schema) rather than spread throughout the backend.  Communication between client and backend also flows through the database (with very few exceptions), which lets the backend get away with an easy to scale queue-based design.<p>There are downsides, of course.  As many posters alluded to, changing the schema gets tricky.  It basically must remain backwards compatible for at least a few releases so as not to inconvenience the users, and some kinds of changes are just not feasible.  And yeah, how the client wants to fetch data does affect the schema as well, though in practice I haven&#x27;t found the impact to be too bad.  Also, Reviewable has only one (browser) client, so I don&#x27;t need to worry about duplicating logic -- I probably wouldn&#x27;t pick this architecture if multiple clients were a requirement.  Putting much of the business logic in a client-side model layer integrated with the database structure actually works out really nicely, though I still struggle with how to efficiently share some of the logic with server-side code.<p>Overall, I&#x27;m satisfied with how things worked out and would definitely consider using a similar architecture again in the right circumstances.  The article is right on the money that if you&#x27;re just getting started on your MVP it&#x27;s worth thinking about a thin- or no-backend approach.')