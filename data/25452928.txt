Item(by='josephg', descendants=None, kids=None, score=None, time=1608183886, title=None, item_type='comment', url=None, parent=25452548, text='&gt; you need to continue to learn outside of a school setting and cultivate that curiosity<p>This is true of just about everyone in computing. This isn&#x27;t an industry for people who expect to cruise on the knowledge they were given a decade ago. (Plenty of people do, but thats another rant.)<p>Regarding big-O, one habit &#x2F; intuition I think its really important to develop is an intuition about how well something will actually perform in practice. Like, you should be able to guess within an order of magnitude or two:<p>- How many simple reads per second and writes per second your database can perform<p>- How many lookups &#x2F; inserts per second to expect out of some standard data structures. (And how those numbers change as the collection grows)<p>- How many allocations your program does, and how much time is spent in the allocator<p>- About how large the steady state working memory size should be for your program<p>I&#x27;m not talking about theoretical O(n) numbers. I mean, right now, if I write a tight loop in nodejs on my laptop writing random numbers to a JS Map(), how fast will it go? How does that compare to C&#x2F;Rust? How many SET calls per second can a redis instance on my laptop handle? How about SELECT queries to postgres, or find({id:...}) calls to mongodb? Will the database be faster or slower than the nodejs program on my laptop thats issuing those queries? How many HTTP requests per second should I expect out of my express server? How many milliseconds should it take to statically render my web app to HTML? Etc.<p>And arguably <i>more</i> importantly, it shouldn&#x27;t take you more than ~20 minutes to go and find out the answer to any of those questions. Benchmarking is a delicate art, but if you can&#x27;t measure, you programming blind.<p>I wrote a fuzzer the other day which did about 100 iterations &#x2F; second. And I know something was wrong because the number was orders of magnitude lower than I intuitively expected. Some tweaking later its now running about 1000 iterations&#x2F;second - still too slow. Profiling shows its now spending 99% of the time in a single function. I&#x27;m hoping for another 10x when I rewrite that function. Without my intuition whispering in my ear, my program could have ended up 100x slower than it should be for no good reason.<p>Aside: This might make a great interview question for a mid. &quot;I have this simple piece of code. How fast do you think it will run on your laptop? Ok, share your screen and write a program to measure it. Talk to me about your answer!&quot;')