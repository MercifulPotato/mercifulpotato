Item(by='bitwize', descendants=None, kids=None, score=None, time=1608133215, title=None, item_type='comment', url=None, parent=25441664, text='Probably the best way to get started just to install SBCL and start typing stuff in at the REPL. Lisp is a very immediate language; you can type an expression in and the REPL will instantly evaluate it and show you the results. Many other languages, such as Python, Ruby, and JavaScript, actually borrowed this feature from Lisp.<p>You&#x27;re going to need an editor to write long-form programs. Vim and Visual Studio Code are fine, but the ne plus ultra of Lisp editors is Emacs ( <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;emacs</a> ). Emacs comes with an excellent Vim-emulation mode, so if you cannot leave behind your vi muscle memory, that&#x27;s always available to you. Another feature of Emacs is, it contains, and much of it is written in, its own dialect of Lisp! The upshot of this is you can usefully extend and customize your editor by evaluating a few Lisp expressions. Playing with Emacs Lisp is a great way to learn how to use the language to do &quot;real work&quot; during your experimentation. Emacs has a package available called SLIME, which allows it to talk to a standalone Lisp environment such as SBCL, send it expressions to evaluate, and get results. SLIME also has LSP-like features to show documentation on the Lisp functions you&#x27;ve defined. Vim and Visual Studio Code can speak SLIME&#x27;s protocol with the proper add-ons, but the integration is not as tight as with Emacs.<p>If Lisp seems overwhelming, it&#x27;s because it&#x27;s more of an idea than a specific language. There are three varieties of Lisp you should be aware of. Well, four if you count Emacs Lisp, but the standalone ones are:<p>* Common Lisp<p>* Scheme<p>* Clojure<p>Of these, the best place to start is probably Common Lisp. It is a comprehensive language which has been used in real-world software engineering projects since the 1980s, and it has a very strong community surrounding it. There are a few implementations, both open source and proprietary. The most favored one today is SBCL: <a href="https:&#x2F;&#x2F;www.sbcl.org" rel="nofollow">https:&#x2F;&#x2F;www.sbcl.org</a><p>Scheme is much simpler. It is more of a language <i>core</i> used for teaching, and for providing a basis for a more feature-rich programming language. There are many implementations, most of which provide their own extensions to the core language; my favorite for getting work done in a Unix-like environment is GNU Guile: <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile</a><p>Clojure is a language that is designed to interoperate well with the JVM, and to promote Rich Hickey&#x27;s ideas on functional programming. It is a very opinionated language, more so than the other two, and you may find yourself struggling more if you don&#x27;t do things the Clojure way. Personally, I like it less than the other two, but that&#x27;s a matter of taste and you may find it more useful.<p>Over time I hope you will have the opportunity to try all three. Each has something different to offer and each can be learned from.')