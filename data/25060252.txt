Item(by='bamazizi', descendants=None, kids=[25062170, 25062171, 25061542], score=None, time=1605114706, title=None, item_type='comment', url=None, parent=25057864, text='I&#x27;ve been using CQRS pattern since 2017. Let me tell you it&#x27;s not a complete system pattern, only a starting point. You need to design your system as LEGO pieces.<p>What do you need to add?<p>1) Internal design guide&#x2F;rule&#x2F;law system so everyone understands and abides by. i.e. &quot;C&quot; command services should NOT talk to other command services, only to query services. But query services can only talk to other query services. You need service mesh and discovery. A bit complex.<p>2) Sink or aggregator. It&#x27;s not efficient to have a query service listen to both events from message bus to store in DB and serve requests. It&#x27;s best to have dedicated sink service(s) where data is streamed to database(s) with certain level of guarantees.<p>3) Rules engines or workflow system. Since command services cannot talk to one another, you&#x27;d need to orchestrate actions among them, that&#x27;s what workflow systems are designed for. They connect to both query and command services and make sure long or complex tasks get done without the need to do hacky stuff!<p>4) Sanity! The moment you go with CQRS + Sink + Workflows, it&#x27;ll become easy to feel overwhelmed and loose control. Start with a small set of MACRO based micro-services. Jam pack all commands into one service, same for query and sink and slowly dissect into multiple smaller services over time as workload grows and you need scalability (chaos monkey). This way you have only ~4 microservices to manage, well 5 if you need an API gateway.<p>5) With all the services and probably technologies, you need a contractual way to communicate. You need a system where CODE is the DOC! You need Protobuf or similar to design your schemas and api. You need GRPC because of protobuf...')