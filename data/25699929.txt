Item(by='kdkeyser', descendants=None, kids=None, score=None, time=1610196446, title=None, item_type='comment', url=None, parent=25699736, text='This indeed seems to be the main&#x2F;only point of criticism in this post that is valid: however, it is not that Haskell has no &quot;pragmatic&quot; libraries to get stuff done (e.g. WAI&#x2F;Warp, Yesod, Servant, ... are top notch, practical libraries if you are writing network&#x2F;HTTP services). They do seem to drown in the sea of libraries&#x2F;blog posts that are focused on the academic&#x2F;abstract stuff. The end result does not feel consistent, and reminds me of the horrors we had with the early C++ metaprogramming efforts: it looks cool, but you end up fighting the language and produce unreadable code.<p>For Haskell to become a successful &quot;industrial&quot; language, I think most of the dependent-typing stuff should probably go (to Idris&#x2F;Agda etc.), so that a clear and consistent Haskell subset can be defined.<p>The other arguments in the article are just weak. The rant about data not having a type, is missing the point. Sure, often you receive data that you need to inspect to know what it is. You can easily do this in Haskell (just label it with the UnknownData type), and have a function that inspects it and returns, depending on the contents, the right type). The big advantage is that you don&#x27;t have to keep on doing this same check.<p>Types being the cause of difficulty in refactoring when business requirements change, is the opposite of my experience. In large dynamically typed codebases, being sure that a large refactor caught everything, is very hard &#x2F; costly in test coverage. I have seen this go wrong many times. Having the compiler point out what you have missed, based on the types, is very helpful.<p>While I think the arguments are a bit weak, I do agree that it is at least unclear if Haskell is a sound choice as a production language at this time. Fighting against an ecosystem is not something you want to be doing while building your product. But in contrast to the author, I do think this is fixable, and see steps happening in the right direction (e.g. with IHP, but also with the efforts around the Haskell Foundation and the Haskell Language Server)')