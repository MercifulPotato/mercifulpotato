Item(by='jcranmer', descendants=None, kids=None, score=None, time=1603480092, title=None, item_type='comment', url=None, parent=24870968, text='There&#x27;s no theoretical difference between phis and basic block parameters.<p>When you do SSA conversion, you need a notion that allows you to bind a value to a variable along an edge in the control-flow graph. You can choose to actually have some edge data that indicates these bindings, but this tends to be a poor engineering solution. If it has to go into a basic block, you need to either bind it to the source basic block or the target basic block. Bind it to the target, and you get phi nodes. Bind it to the source, and you get basic block parameters.<p>The choice of which to use is an engineering tradeoff. Phis have the issue that they are pseudo-instructions existing as the leading instructions in a basic block, and you may well need to special-case them in transformation or analysis passes. Using basic block arguments also provides a more direct analogy to interprocedural optimization, and you could potentially use the exact same code with a touch of specialization to handle that domain.<p>Since the two forms are moving the edge instructions to different places, they make different questions easier. With a phi node, it&#x27;s quick to see if all predecessors are providing the same value. With a basic block argument, it&#x27;s quick to see which variables are live out (assuming you&#x27;re restricted to using only basic block-local variables [1]). In general, if you need to query all-predecessor analyses, it&#x27;s easier with phis; if you need all-successor analyses, it&#x27;s easier with basic block arguments.<p>[1] The choice of where variables can be used is <i>also</i> orthogonal to phis versus basic block arguments. Loop-closed SSA already exists, which prevents you from using a variable outside of its loop.')