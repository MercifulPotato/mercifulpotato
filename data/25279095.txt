Item(by='derefr', descendants=None, kids=[25279860, 25283334, 25280117], score=None, time=1606931586, title=None, item_type='comment', url=None, parent=25278679, text='Let&#x27;s start with views. A database view is a &quot;stored query&quot; that presents itself as a table, that you can further query against.<p>If you have a view &quot;bar&quot;:<p><pre><code>    CREATE VIEW bar AS $$\n    SELECT x * 2 AS a, y + 1 AS b FROM foo\n    $$\n</code></pre>\nand then you `SELECT a FROM bar`, then the &quot;question&quot; you&#x27;re really asking is just:<p><pre><code>    SELECT a FROM (SELECT x * 2 AS a, y + 1 AS b FROM foo)\n</code></pre>\n— which, with efficient query planning, boils down to<p><pre><code>    SELECT x * 2 AS a FROM foo\n</code></pre>\nIt&#x27;s especially important to note that the `y + 1` expression from the view definition isn&#x27;t computed in this query. The inner query from the view isn&#x27;t &quot;compiled&quot; — forced to be in some shape — but rather sits there in symbolic form, &quot;pasted&quot; into your query, where the query planner can then manipulate and optimize&#x2F;streamline it further, to suit the needs of the outer query.<p>-----<p>To <i>materialize</i> something is to turn it from symbolic-expression form, into &quot;hard&quot; data — a result-set of in-memory row-tuples. Materialization is the &quot;enumeration&quot; in a Streams abstraction, or the &quot;thunk&quot; in a lazy-evaluation language. It&#x27;s the master screw that forces all the activity dependent on it — that would otherwise stay abstract — to &quot;really happen.&quot;<p>Databases <i>don&#x27;t</i> materialize anything unless they&#x27;re forced to. If you do a query like<p><pre><code>    SELECT false FROM (SELECT * FROM foo WHERE x = 1)\n</code></pre>\n...no work (especially no IO) actually happens, because no data from the inner query needs to be <i>materialized</i> to resolve the outer query.<p>Streaming data out of the DB to the user requires serialization [= putting the data in a certain wire format], and serialization requires materialization [= having the data available in memory in order to read and re-format it.] So whatever final shape the data returned from your outermost query has when it &quot;leaves&quot; the DB, <i>that</i> data will always get materialized. But other processes internal to the DB may sometimes require data to be materialized as well.<p>Materialization is costly — it&#x27;s usually the only thing forcing the DB to actually read the data on disk, for any columns it wasn&#x27;t filtering by. Many of the optimizations in RDBMSes — like the elimination of that `y + 1` above — have the goal of avoiding materialization, and the disk-reads &#x2F; memory allocations &#x2F; etc. that materialization requires.<p>-----<p>Those definitions out of the way, a &quot;materialized view&quot; is something that acts similar to a view (i.e. is constructed in terms of a stored query, and presents itself as a queriable table) but which — unlike a regular view — has been pre-materialized. The query for a matview is still stored, but at some point in advance of querying, the RDBMS actually <i>runs</i> that query, fully materializes the result-set from it, and then caches it.<p>So, basically, a materialized view is a view with a cached result-set.<p>Like any cache, this result-set cache increases read-time efficiency in the case where the original computation was costly. (There&#x27;s no point in &quot;upgrading&quot; a view into a matview if your queries against the plain view were already cheap enough for your needs.)<p>But like any cache, it needs to be maintained, and can become out-of-sync with its source.<p>Although materialized views are part of the SQL standard, not all SQL RDBMSes implement them. MySQL&#x2F;MariaDB does not, for example. (Which is why you&#x27;ll find that much of the software world just pretends matviews don&#x27;t exist when designing their DB architectures. If it ever needs to run on MySQL, it can&#x27;t use matviews.)<p>The naive approach that some other RDBMSes (e.g. Postgres) take to materialized views, is to only offer manual, full-pass recalculation of the cached result-set, via some explicit command (`REFRESH MATERIALIZED VIEW foo`). This works with &quot;small data&quot;; but at scale, this approach can be so time-consuming for large and complex backing queries, that by the time cache is rebuilt, it&#x27;s already out-of-date again!<p>Because there are RDBMSes that either don&#x27;t have matviews, or don&#x27;t have <i>scalable</i> matviews, many application developers just avoid the RDBMS&#x27;s built in matview abstraction, and build their own. Thus, another large swathe of the world&#x27;s database architecture either will use cron-jobs to regular run+materialize a query, and then dump its results back into a table in the same DB; or it will define on-INSERT&#x2F;UPDATE&#x2F;DELETE triggers on &quot;primary&quot; tables, that transform and upsert data into &quot;secondary&quot; denormalized tables. These are both approaches to &quot;simulating&quot; matviews, portably, on an RDBMS substrate that isn&#x27;t guaranteed to have them.<p>Other RDBMSes (e.g. Oracle, SQL Server, etc.) <i>do</i> have scalable materialized views, a.k.a. &quot;incrementally materialized&quot; views. These work less like a view with a cache, and more like a secondary table with write-triggers on primary tables to populate it — but all handled under-the-covers by the RDBMS itself. You just define the matview, and the RDBMS sees the data-dependencies and sets up the write-through data flow.<p>Incrementally-materialized views are great for what they&#x27;re designed for (reporting, mostly); but they aren&#x27;t intended to be the bedrock for an entire architecture. Building matviews on top of matviews on top of matviews gets expensive fast, because even fancy enterprise RDBMSes like Oracle don&#x27;t <i>realize</i>, when populating table X, that writing to X will in turn write to matview Y, which will in turn &quot;fan out&quot; to matviews {A,B,C,D}, etc. These RDBMS&#x27;s matviews were never intended to support complex &quot;dataflow graphs&quot; of updates like this, and so there&#x27;s too much overhead (e.g. read-write contention on index locks) to actually make these setups practical. And it&#x27;s very hard for these DBMSes to change this, as their matviews&#x27; caches are fundamentally reliant on <i>database table</i> storage engines, which just aren&#x27;t the right ADT to hold data with this sort of lifecycle.<p>-----<p>Materialize is an &quot;RDBMS&quot; (though it&#x27;s not, really) engineered from the ground up to make these sorts of dataflow graphs of matviews-on-matviews-on-matviews practical, by doing its caching completely differently.<p>Materialize looks like a SQL RDBMS from the outside, but Materialize <i>is not</i> a database — not really. (Materialize has no tables. You can&#x27;t &quot;put&quot; data in it!) Instead, Materialize is a data <i>streaming</i> platform, that caches any intermediate materialized data it&#x27;s forced to construct during the streaming process, so that other consumers can work off those same intermediate representations, without recomputing the data.<p>If you&#x27;ve ever worked with Akka&#x27;s Streams, or Elixir&#x27;s Flows, or for that matter with Apache Beam (nee Google Dataflow), Materalize is that same kind of pipeline. But where all the plumbing work of creating intermediate representations — normally a procedural map&#x2F;reduce&#x2F;partition kind of thing — is done by defining SQL matviews; and where the final output isn&#x27;t a fixed output of the pipeline, but rather comes from running an arbitrary SQL query against any arbitrary matview defined in the system.')