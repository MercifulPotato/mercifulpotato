Item(by='josephg', descendants=None, kids=None, score=None, time=1609742848, title=None, item_type='comment', url=None, parent=25626827, text='&gt; In my experience most of the time you need arenas youâ€™re using your own data structure anyway, but YMMV.<p>That makes sense for video games. Recently I was goofing with cyrus-imap. I wanted to parse the emails out of an mbox file into JSON (JMAP). Parsing an email with cyrus currently does about 5-10k calls to malloc, but the objects are all extremely short lived - they just have to live long enough to parse and then convert to JSON. This is a perfect case for a bump allocator - I&#x27;d love to allocate all the parsed email fields into an arena and then clear the whole thing when we move on to the next message.<p>Yes, Cyrus uses a ton of its own internal structs for emails, and they&#x27;re littered with strings and vectors. (Eg for email headers, lists of email recipients, plain text &#x2F; HTML message content, etc).<p>Looks like bumpalo will do the job, since it implements its own Box, Vector and String. I understand why, but it seems jarring that I&#x27;d need to replace the data types in order to change out the allocator like this. I&#x27;m definitely keen for GAT landing if it means bumpalo and friends don&#x27;t need to reinvent the world to be able to change the allocation strategy.<p>Edit: Oooh Vec::new_in is in nightly! Exciting! <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;beta&#x2F;std&#x2F;vec&#x2F;struct.Vec.html#method.new_in" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;beta&#x2F;std&#x2F;vec&#x2F;struct.Vec.html#metho...</a>')