Item(by='svat', descendants=None, kids=[25597854], score=None, time=1609453235, title=None, item_type='comment', url=None, parent=25591205, text='You are right that literate programming first occurred to Knuth as a way to overcome the deficiencies of Pascal. Specifically, it was the product of a few things:<p>1. The first version of TeX was written in 1978 and spread like wildfire in a couple of years: ported by others to 200 programming environments i.e. (OS, language) pairs! So when he started writing his new version in 1980 trying to be portable to all those OSes, he was basically forced to use Pascal, which was at the time in widest use at universities for teaching, and thus most widely available on computer installations. (C was still confined to Bell Labs and maybe a few other places.)<p>2. Tony Hoare had suggested that the source code should be published as a book. This raises questions of how best to present messy real-world code written with real-world constraints (rather than &quot;clean&quot; toy examples).<p>3. Pascal, especially the subset of Pascal he was targeting (the common denominator across Pascal runtimes&#x2F;compilers in use at the time) was extremely limited and had poor support for strings, array parameters, even control-flow (no &quot;break&quot; and &quot;continue&quot; in loops, and goto &quot;labels&quot; had to be numeric); moreover doing anything nontrivial practically necessitated many global variables that had to be initialized at the start of the program. I&#x27;ve written a bit more about this at <a href="https:&#x2F;&#x2F;shreevatsa.github.io&#x2F;tex&#x2F;program&#x2F;pooltype" rel="nofollow">https:&#x2F;&#x2F;shreevatsa.github.io&#x2F;tex&#x2F;program&#x2F;pooltype</a><p>4. This is a joke, but he was&#x2F;is also annoyed by the anti-goto moralists championing their vision &quot;structured programming&quot; (pejoratively implying anything else is unstructured), so he called his vision &quot;literate programming&quot; (as no one wants to be accused of writing illiterate programs).<p>So after some experiments he was led to the idea of a macro preprocessor, with sections that would be reordered in the way needed by the compiler, but could be written in the order the programmer wanted to write or present them.<p>As for monoliths, partly that&#x27;s how Knuth seems to think. And he seems to have no trouble keeping a lot of program detail in his head that would overwhelm most of us, and he has always been a machine-level programmer at heart and is acutely conscious of wasteful stuff like—a real concern at the time—subroutine overheads. Even in this interview he mentions things like APL versus his preference of languages closer to what a computer actually does. And partly the Pascal subset he was targeting dictated the program structure: the compiler should get all its code in a single file the way toy programs are written, like<p><pre><code>    var &lt;declare lots of globals here&gt;;\n    &lt;declare lots of functions&#x2F;procedures here&gt;;\n    begin\n      &lt;initialization code&gt;\n      &lt;rest of &quot;main&quot;&gt;\n    end.\n</code></pre>\n(In fact his earlier non-literate TeX78 in the SAIL language was written as a bunch of separate files&#x2F;modules, rather than a single 25000-line file like the literate&#x2F;&quot;better&quot; tex.web.)<p>So that&#x27;s a bit about the genesis of literate programming. Now about some of your other comments:<p>- Your quote about top-down programming from literateprogramming.com is from the author of fweb, but actually Knuth himself <i>doesn&#x27;t</i> advocate (or practise) top-down programming. One of the things he likes about literate programming is that the program can be written in a mixture of bottom-up and top-down programming without being forced to commit to either; from studying many of his programs it&#x27;s clear that his preference is to build things mostly bottom-up, though each small &quot;layer&quot; he may write top-down and sometimes he may switch it up. (For example, in his TeX program he starts with &quot;chapters&quot; on string handling, arithmetic, memory allocation, data structures etc, building up to the main program as the climax of the book. Each &quot;chapter&quot;, which is sometimes just a single function, is written top-down, more or less.)<p>- You linked to how the PBRT book introduces literate programming, and said it shows noweb&#x2F;LP is &quot;still too mired by constraints of C&quot;, but to be clear, it&#x27;s just that the <i>example</i> they used for the idea of rearranging sections is one of overcoming some constraints of C using LP. (It&#x27;s not really specific to C though; the same thing would apply whenever one had a lot of initialization to do in different places, like the giant object constructors one can see in many C++ codebases.)<p>- Tastes are subjective, but IMO the program he wrote for Bentley&#x27;s question of &quot;top k most common words&quot; (not his choice of problem!) is actually very interesting: it&#x27;s an exposition of an ingenious data structure called a (packed) hash trie that has, to the best of my knowledge, never been described anywhere else, and which he probably made up on the spot for this problem. (Packed tries are described in an exercise in TAOCP and the TeX program uses them to store hyphenation patterns—his student Liang&#x27;s thesis was about this—but packing them randomly using an open-addressing hash table seems to be a twist particular to this program.) I was planning to write a blog post last year illustrating this with pictures and all that, but never got around to it. I did write a translation into (non-literate) C++ here: <a href="https:&#x2F;&#x2F;codegolf.stackexchange.com&#x2F;a&#x2F;197870" rel="nofollow">https:&#x2F;&#x2F;codegolf.stackexchange.com&#x2F;a&#x2F;197870</a><p>- Returning to a couple of your other comments and the phrase &quot;top-down style associated with literate programming&quot;: I think another way of looking at this is historical. When Knuth learned to program, in machine code on an IBM 650 (I say this was the first and last generation of <i>truly</i> self-taught programmers) and later writing compilers in machine code (or with his own assemblers) for other machines, even the idea of subroutines (with standard calling conventions and all that) was hardly well-established, which is why TAOCP Chapter 1 has, under 1.4 &quot;Some Fundamental Programming Techniques&quot; an explanation of what subroutines are, followed by coroutines and interpretive routines. When &quot;Structured Programming&quot; took over in the 1970s (just the idea of using if&#x2F;while&#x2F;for and subroutines instead of arbitrary control-flow jumps), it was a revolution, and even that Knuth is not still fully on board with. (If anyone is interested I&#x27;ll try to string together a blog post on all mentions I&#x27;ve seen of Knuth&#x27;s opinion on &quot;goto&quot;. Some juicy bits, e.g. <a href="https:&#x2F;&#x2F;twitter.com&#x2F;svat&#x2F;status&#x2F;885344334735745024" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;svat&#x2F;status&#x2F;885344334735745024</a> <a href="https:&#x2F;&#x2F;twitter.com&#x2F;svat&#x2F;status&#x2F;913114286951505920" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;svat&#x2F;status&#x2F;913114286951505920</a> <a href="https:&#x2F;&#x2F;twitter.com&#x2F;svat&#x2F;status&#x2F;1336935057877991424" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;svat&#x2F;status&#x2F;1336935057877991424</a>.) Since then, the programming &#x2F; software-engineering world at large has settled on certain ideas of structuring programs, in order to keep complexity manageable: the use of abstraction, encapsulation, modules, information-hiding, objects, avoiding global variables, etc. In some sense what Knuth came up with for himself with WEB&#x2F;CWEB is a wholesale <i>alternative</i> to all these ways of structuring programs, bypassing the mainstream. This seems to suffice for him, but for the rest of us it&#x27;s a highly unfamiliar&#x2F;unpalatable way of writing programs. This doesn&#x27;t mean &quot;Knuth is doing it wrong&quot; in the sense of Kartik&#x27;s post, because what you should take away as &quot;Literate Programming&quot; from reading his programs is not the diff w.r.t. how a modern programmer would write it, but the diff w.r.t. how <i>he</i> would write it without LP. That is, if you take for granted that the program is going to have very few functions, lots of global variables, etc., the question is whether LP is a better way of writing or presenting <i>that</i> program than non-LP. (It seems the answer is yes, though even this is debatable. Besides, Knuth does say that without LP he&#x27;d probably write more levels of functions but with LP he doesn&#x27;t &quot;have to&quot;, so you may disagree with the question too.) You should instead look at examples of programs that a modern programmer familiar with modern idioms wrote with and without LP. I imagine these days one might have better results searching for people using org-babel (rather than cweb&#x2F;noweb), say. I see also there&#x27;s  <a href="https:&#x2F;&#x2F;github.com&#x2F;AndrewOwenMartin&#x2F;nestor" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;AndrewOwenMartin&#x2F;nestor</a> mentioned in another thread above, or &quot;nbdev&quot; that came up recently (<a href="https:&#x2F;&#x2F;www.fast.ai&#x2F;2019&#x2F;12&#x2F;02&#x2F;nbdev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.fast.ai&#x2F;2019&#x2F;12&#x2F;02&#x2F;nbdev&#x2F;</a> , <a href="https:&#x2F;&#x2F;github.blog&#x2F;2020-11-20-nbdev-a-literate-programming-environment-that-democratizes-software-engineering-best-practices&#x2F;" rel="nofollow">https:&#x2F;&#x2F;github.blog&#x2F;2020-11-20-nbdev-a-literate-programming-...</a>).<p>- But that apart, returning once again to Knuth&#x27;s own literate programs. I have struggled a lot with them. Many people have easily understood much more than me, but I suspect I have <i>struggled</i> more than anyone :D I had some grand plans to make it more readable etc (<a href="https:&#x2F;&#x2F;shreevatsa.net&#x2F;tex&#x2F;program" rel="nofollow">https:&#x2F;&#x2F;shreevatsa.net&#x2F;tex&#x2F;program</a>), but eventually they started making sense. (I should update those pages…) The point is, literate programming still does not mean writing code in a vacuum for readers who know nothing. Knuth does not consider explaining basic language features (as you pointed out with the INFORM example in another comment here), and moreover he also assumes familiarity with his LP conventions (the overall structure of the program, how to use the index and flip back-and-forth) and even I think his usual programming conventions. So the fact that the ADVENTURE program has the source file&#x27;s outline (with #includes and everything at the top) on the second page, with a typedef of the &quot;boolean&quot; type and a couple of general-purpose variables declared at the top of &quot;main&quot; (which will probably be (ab)used for lots of different purposes, I expect)—all of these are not a serious problem, for the &quot;literate&quot; reader. To Knuth, literate programming does not mean belabouring and explaining <i>everything</i>; it&#x27;s just a way of structuring your program. And though he mentions reading the program like a book, he doesn&#x27;t think of books as things to be read strictly word-for-word in the sequence they appear; I expect he imagines reading <i>any</i> book non-linearly (looking up the index, flipping back-and-forth, skimming, etc) and that&#x27;s how the programs are to be read too. The order of sections in the literate program is only <i>more or less</i> the &quot;right&quot; one, not strictly.<p>About the ADVENTURE program in particular, which is a useful case study, let me post a separate comment (as reply to this one), as this is already very long.')