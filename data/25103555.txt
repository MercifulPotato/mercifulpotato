Item(by='dasil003', descendants=None, kids=[25103984, 25109088], score=None, time=1605465785, title=None, item_type='comment', url=None, parent=25102009, text='This very much depends on the use case.  If you are truly CPU-bound than yes, ruby is a bad choice.  Similarly, if you are IO-bound or otherwise need a lot of concurrency ruby is not great.  I also think it&#x27;s problematic for large code bases with hundreds of developers.   However, there is a huge swath of web apps and APIs that just need to pull a bit of data from a DB or two, munge it together and send it to the client.  Rails is perfectly horizontally scalable and plenty fast for this even at scale given Amdahl&#x27;s law.<p>That said, there are definitely some self-inflicted wounds people run into here.  Of course there are the oft-cited expert beginner problems like n+1 queries and missing indices, but there&#x27;s a more subtle issue as well: ActiveRecord itself is so convenient that it discourages writing baseline efficient code even when you need it.  Basically any time you need to process a medium to large amount of data, ActiveRecord acts like a sort of super boxed type (to use Java terminology) adding a huge amount of overhead.  Yes it&#x27;s true that ruby doesn&#x27;t even have true primitive types that can achieve the performance of Go or Java, but often times ruby primitives are plenty fast, you just have to be willing to write a bit of extra code, and ActiveRecord as an ORM has plenty of escape hatches at various levels of granularity to facilitate this (eg. pluck, find_by_sql, update_all, execute, etc).')