Item(by='dmitriid', descendants=None, kids=None, score=None, time=1610376264, title=None, item_type='comment', url=None, parent=25728382, text='&gt; You don&#x27;t get any information from `IO _` functions, but that&#x27;s the case with every mainstream language, where you have an implicit `IO` on every single function.<p>Indeed. And that&#x27;s why I picked up on that particular point in the article that I&#x27;m criticising. The article chose to use those examples and those words and they <i>don&#x27;t</i> show anything beyond what other mainstream languages have.<p>&gt; If you want to go the other way, you can concretely model the kinds of effects you need parts of your programs to do, and use that model instead<p>Yes, you can. No, the article doesn&#x27;t show that in any way. Just to remind you how I started my comment:<p>--- start quote ---<p>But this article goes out of its way to make the worst possible case for Haskell imaginable.<p>--- end quote ---<p>Does the article show &quot;other models&quot;? No. Does it even try and show how to reason about a function by looking at its type signature alone? Also, no. Would this article be laughed into oblivion had it been about any other language but Haskell? Yes, most likely.<p>&gt; Effect modeling is a real shift in perspective.<p>Ah yes. Does the article talk about this? Does it show a single example of this? No.')