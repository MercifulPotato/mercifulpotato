Item(by='megameter', descendants=None, kids=None, score=None, time=1604959817, title=None, item_type='comment', url=None, parent=25038273, text='Most of the remarks here emphasized performance, but I believe the actual thing that is &quot;lost&quot; in Rust&#x27;s model is the ability to quickly rearrange the data dependencies.<p>A lot of the time, a game&#x27;s bug surfaces in a way that will never cause a crash: it&#x27;s just undesired behavior. At some level, the behavior can be defined in terms of &quot;must&quot; and &quot;cannot&quot; constraints, RFC-style.<p>And in theory you could do some kind of automatic verification of each behavior. But...the majority of the plumbing of the game isn&#x27;t in the rule logic itself - almost all of the rules are simple. It&#x27;s in making sure that the mutations produced by one rule will flow neatly into the next, without introducing some form of synchronization bug. This is a real minefield because you&#x27;re often iterating over lots of similar elements, and it can look like you can bundle their update code to look &quot;clean&quot; or present an opaque interface, but then in practice, you need to split out the iteration differently to resolve a dependency issue.<p>Developers responded to this by introducing an event-bus abstraction, with bubbling and priorities and all the bells and whistles. But that doesn&#x27;t really solve <i>having dependencies</i>, it just presents another way to surface a scripting layer.<p>Repeat this class of problem enough times and you will start inlining the bulk of the update into a single main loop, because that makes manual review of the dependencies more of a spatially engaging process, one where you don&#x27;t have to provide new boilerplate so that the build process can tell you that you screwed up: instead you just look carefully, see that the ordering is wrong, and shovel around the block of code. Done.<p>And while you can do this in Rust, it renders a great deal of the language irrelevant, because the features it helps most with are those parts where you want tighter access control across function boundaries. When you start leveraging that access model, behavioral changes can start to take hours instead of seconds, which makes it appropriate for inner-layer backends that need deep optimization, but ergonomically  terrible for the greenfield case, which is what games need to bend towards early in production when major features might be changing.')