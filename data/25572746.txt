Item(by='ufo', descendants=None, kids=None, score=None, time=1609265233, title=None, item_type='comment', url=None, parent=25571773, text='Yes, the main difference is the instruction set.<p>One common way to design a stack-based instruction set is to refer to the local variables using stack offsets, just as in a register-based instruction set. The operation for reading a local variable makes a copy of the stack slot at the given offset and pushes it into the top of the stack, where it may be used as the input for subsequent operations. For example, to implement &quot;X = X + Y&quot; it might use the following code:<p><pre><code>   LOAD 0 (pushes the contents of X to the stack)\n   LOAD 1 (pushes the contents of Y to the stack)\n   ADD    (pops two values and pushes the result)\n   STORE 0 (pops one value, and stores it into X)\n</code></pre>\nMeanwhile, in a register-based VM the ADD operation manipulates the relevant stack slots directly:<p><pre><code>  ADD R0 R0 R1 (compute R0 + R1 and store in R0)\n</code></pre>\n&gt;  Instruction set is simpler but at the cost of requiring additional operations.<p>Well put. This is one of the key differences between a stack VM and a register VM. In register VM the instructions are larger, because they need to specify all their arguments. However, a stack VM may need to generate more instructions to fiddle with the top of the stack.<p>If you want to read more, one good example of a stack-based VM is the one in the Crafting Interpreters book. For a good example of a register based VM my suggestion would be the paper about the implementation of Lua (section 7 in particular).<p><a href="https:&#x2F;&#x2F;craftinginterpreters.com&#x2F;local-variables.html" rel="nofollow">https:&#x2F;&#x2F;craftinginterpreters.com&#x2F;local-variables.html</a><p><a href="http:&#x2F;&#x2F;www.jucs.org&#x2F;jucs_11_7&#x2F;the_implementation_of_lua" rel="nofollow">http:&#x2F;&#x2F;www.jucs.org&#x2F;jucs_11_7&#x2F;the_implementation_of_lua</a>')