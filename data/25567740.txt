Item(by='Twisol', descendants=None, kids=None, score=None, time=1609229097, title=None, item_type='comment', url=None, parent=25563825, text='I&#x27;m not especially familiar with either MVars or STM, so you&#x27;ll have to make do with my first impressions...<p>MVars seem most useful for a token-passing &#x2F; half-duplex form of communication between modules. I&#x27;ve implemented something very similar, in Java, when using threads for coroutines. (Alas, but Project Loom has not landed yet.) They don&#x27;t seem to add a whole lot over a mutable cell paired with a binary semaphore. Probably the most valuable aspect is that you&#x27;re forced to think about how you want your modules to coordinate, rather than starting with uncontrolled state and adding concurrency control after the fact.<p>STM seems very ambitious, but I struggle to imagine how to build systems using STM as a primary tool. Despite its advantages, it still <i>feels</i> like a low-level primitive. Once I leave a transaction, if I read from the database, there&#x27;s no guarantee that what I knew before is true anymore. I still have to think about what the scope of a transaction ought to be.<p>Moreover, I get the impression that STM transactions are meant to be <i>linearizable</i> [1], which is a very strong consistency requirement. In particular, there are questions about determinism: if I have two simultaneous transactions, one of them must commit &quot;first&quot;, before the other, and that choice is not only arbitrary, the program can evolve totally differently depending on that choice.<p>There are some situations where this &quot;competitive concurrency&quot; is desirable, but I think most of the time, we want concurrency for the sake of modularity and efficiency, not as a source of nondeterminism. When using any concurrency primitive that allows nondeterminism, if you don&#x27;t want that behavior, you have to very carefully avoid it. As such, I&#x27;m most (and mostly) interested in models of concurrency that guarantee deterministic behavior.<p>Both LVars and logic programming are founded on monotonic updates to a database. Monotonicity guarantees that if you &quot;knew&quot; something before, you &quot;know&quot; it forever -- there&#x27;s nothing that can be done to invalidate knowledge you&#x27;ve obtained. This aspect isn&#x27;t present in most other approaches to concurrency, be it STM or locks.<p>The CALM theorem [2] is a beautiful, relatively recent result identifying consistency of distributed systems with logical monotonicity, and I think the most significant fruits of CALM are yet to come. Here&#x27;s hoping for a resurgence in logic programming research!<p>&gt; There&#x27;s one exception in particular that I&#x27;ve seen begin to gain steam in the industry which I think is interesting, and that&#x27;s Elixir.<p>I&#x27;ve not used Elixir, but I very badly want to. It (and Erlang) has a very pleasant &quot;functional core, imperative shell&quot; flavor to it, and its &quot;imperative shell&quot; is like none other I&#x27;ve seen before.<p>[1] <a href="https:&#x2F;&#x2F;jepsen.io&#x2F;consistency&#x2F;models&#x2F;linearizable" rel="nofollow">https:&#x2F;&#x2F;jepsen.io&#x2F;consistency&#x2F;models&#x2F;linearizable</a><p>[2] <a href="https:&#x2F;&#x2F;rise.cs.berkeley.edu&#x2F;blog&#x2F;an-overview-of-the-calm-theorem&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rise.cs.berkeley.edu&#x2F;blog&#x2F;an-overview-of-the-calm-th...</a>')