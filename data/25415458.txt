Item(by='patrec', descendants=None, kids=None, score=None, time=1607941963, title=None, item_type='comment', url=None, parent=25414386, text='The most convenient way is to probably to use a compiler builtin <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Integer-Overflow-Builtins.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Integer-Overflow-Builtins...</a>, if you want to be portable the next easiest way is to use a wide enough type (e.g. add or multiply two 32 bit numbers to a 64 bit one and verify it is inside [INT_MIN, INT_MAX]). Otherwise, you can either do a pre-condition check (for addition overflow occurs if a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; a &gt; INT_MAX-b || a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; a &lt; INT_MIN-b) or work with unsigned integers and check for wraparound after the operation. Finally, both clang and gcc have options to check for signed integer overflow at runtime (-fsanitize=signed-integer-overflow for gcc).<p>Of course, in practice this is too much effort for most people most of the time, so actual deployed C and C++ code is full of undefined behavior due to integer overflow. This paper has a great overview:<p><a href="https:&#x2F;&#x2F;wdtz.org&#x2F;files&#x2F;tosem15.pdf" rel="nofollow">https:&#x2F;&#x2F;wdtz.org&#x2F;files&#x2F;tosem15.pdf</a>')