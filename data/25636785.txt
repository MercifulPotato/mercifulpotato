Item(by='KronisLV', descendants=None, kids=[25641658], score=None, time=1609789251, title=None, item_type='comment', url=None, parent=25629341, text='This makes me think about how other people here feel about the arguments presented in this post. Personally, i actually agree with some of these points!<p>&gt; difficulty deploying schema changes<p>Definitely agreed, even with tools like Flyway, Liquibase, dbmate or most of the framework provided options (such as Active Record Migrations for Rails and Doctrine for Symfony), most migrations still end up feeling brittle, because you oftentimes do things like renaming a column, or processing some data into a new format, or cleaning up old data etc. Well, you want to do that anyways, but then you realize that instead of simply renaming a column, you&#x27;ll probably do a rolling migration for the apps that use the DB, therefore you need to create a new column that the app will write data into, then migrate all of the app instances to the new version and then clean up the old column, god forbid validations use the wrong column while this is going on. I don&#x27;t think it&#x27;s possible to work around problems like this with technologies like MongoDB either, since then dealing with missing data in an &quot;old&quot; version of a document would still be annoying. I don&#x27;t know of any good solutions to address how data evolves over time, regardless of technology.<p>&gt; difficulty sharding<p>Definitely agreed, in general it seems like most DBMS mostly scale vertically better than they do horizontally. For example, master-slave replication seems doable, but once you want to do master-master replication, you run into problems with latency and data consistency. There are some solutions like TiDB which attempt to give you a distributed database in a transparent way, without making you worry about its inner workings, but that only works until suddenly it doesn&#x27;t. It seems like this problem affects most distributed systems and i&#x27;m not sure how to address it, short of making each new data entry reference the previous state, like CouchDB does with revisions ( <a href="https:&#x2F;&#x2F;docs.couchdb.org&#x2F;en&#x2F;stable&#x2F;intro&#x2F;api.html#revisions" rel="nofollow">https:&#x2F;&#x2F;docs.couchdb.org&#x2F;en&#x2F;stable&#x2F;intro&#x2F;api.html#revisions</a> ) and even that won&#x27;t always help.<p>&gt; an awkward square-table model and a terrible query language<p>Partially agreed, SQL is pretty reasonable for what it does, despite its dialects being somewhat inconsistent, many of the procedural extensions being clunky and most of the in-database processing heavy systems that i&#x27;ve encountered being a nightmare from a debugging and logging perspective, though i guess that&#x27;s mostly the fault of the tooling surrounding them. Discoverability can be a big problem if OTLT and EAV are heavily used ( <a href="https:&#x2F;&#x2F;tonyandrews.blogspot.com&#x2F;2004&#x2F;10&#x2F;otlt-and-eav-two-big-design-mistakes.html" rel="nofollow">https:&#x2F;&#x2F;tonyandrews.blogspot.com&#x2F;2004&#x2F;10&#x2F;otlt-and-eav-two-bi...</a> ) and foreign keys are not used. Window functions, analytical functions, partitioning and other functionality feels like it&#x27;s implemented in unintuitive ways in some systems, but that could also be a question of familiarity and a steep learning curve.<p>&gt; if you make the mistake of trying to use the transactional functionality that&#x27;s the one actual selling point of those datastores then you&#x27;re practically guaranteed to deadlock yourself in production at some point during your growth process<p>Partially agreed, it can definitely happen, but being able to revert bad changes to the data and even test them in the first place sometimes feels like a godsend. Well, there should always be a local instance that&#x27;s safe to break, but in practice that doesn&#x27;t really come true often.')