Item(by='steveklabnik', descendants=None, kids=None, score=None, time=1610382716, title=None, item_type='comment', url=None, parent=25729012, text='&gt;  why doesn&#x27;t it just do the cross-function inference<p>It could! This is an explicit design choice. There are a few different reasons. They&#x27;re all sort of connected...<p>In general, Rust takes the position that the type signature is the contract. If you inferred the types on function signatures, changing the body of your function could change the signature, which means that breaking changes are harder to detect. It also leads to &quot;spooky action at a distance&quot; errors; I could change a line of code in function A, but then the compiler complains about the body of some unrelated code in a totally different part of the codebase, because that changed the signature of function A, which changed the signature of function B, which is called in function C. My error shows C is wrong, but I made a mistake in the body of A. That&#x27;s confusing. Much nicer to say &quot;Hey you said the signature of A is X but the body is Y, something is wrong here.&quot;<p>I am gonna handwave this one slightly because I don&#x27;t fully remember all of the details, but full program inference and subtyping is undecidable. Rust doesn&#x27;t have subtyping in general for this and other reasons, but lifetimes <i>do</i> have subtyping. I am sure this would get ugly.<p>Speaking of getting ugly, Rust is already criticized often for compile times. Full program inference would make this much, much worse. Again with that changing signatures issue, cascading signature change would cause even more of your program to need to be recompiled, which means that bad error message is gonna take even longer to appear in the first place.<p>I think there might be more but those are the biggest ones off the top of my head.')