Item(by='throwaway894345', descendants=None, kids=None, score=None, time=1609725680, title=None, item_type='comment', url=None, parent=25626889, text='&gt; You pay for those breaks out of the devops budget.<p>Only for organizations where &quot;devops&quot; means &quot;ops&quot;. If your organization practices continuous deployment, then getting a bug fix out is no big deal (merge your PR to master and make sure the deployment doesn&#x27;t fail); certainly no devops time is required.<p>&gt; Moving breakage to earlier in the developer cycle typically reduces the cost of fixing it.<p>This axiom originates in the days of waterfall development and annual software deployments shipped to customers on shrink-wrapped physical media. It&#x27;s not nearly as costly as our dated CompSci or SoftEng educations make it out to be.<p>Your average web service isn&#x27;t going to benefit on balance from moving from Go to Rust because any gains in finding&#x2F;preventing bugs sooner are going to be dwarfed by the slowed pace of development.<p>Of course, someone will point out that data races of the sort that Rust precludes are really hard to debug, which is true, but they&#x27;re also very rare because request handling rarely requires parallel access to local resources (mostly things like database connections, where the locking is handled by the database library). The total cost of dealing with these for your average web application is still going to be dwarfed by the smaller tax Rust imposes on every change you make.<p>Note that Rust has improved significantly, both by accepting more correct programs (laxer rules such as non-lexical lifetimes) and by improving tooling (rust analyzer). I&#x27;m not sure if they&#x27;ll ever close the gap completely such that using Go&#x2F;C#&#x2F;etc are relegated to certain niche use cases, but I think it will continue to steal more and more of the application space that leans toward performance- or correctness-sensitive.')