Item(by='jiggawatts', descendants=None, kids=[25091964, 25091800, 25092066], score=None, time=1605354227, title=None, item_type='comment', url=None, parent=25090816, text='For over a decade now, I&#x27;ve been pondering a &quot;perfect&quot; language.<p>Of course, such a thing is impossible, because we&#x27;re always learning, and we can always do <i>better</i>, but it leads to some interesting avenues of thought. We can claim that certain concepts are <i>mandatory</i>, which can be used to reject languages that can never meet our ultimate requirements.<p>For example, a common complaint is the &quot;impedance mismatch&quot; between, say, query languages such as SQL or MDX, and object oriented languages such as Java and C#. Similarly, JSON has become popular precisely because it has zero &quot;mismatch&quot; with JavaScript -- it is a nearly perfect <i>subset</i>.<p>This leads one to the obvious conclusion: An ideal language must have subsets, and probably quite a few. If it doesn&#x27;t, some other special-purpose language would be forced on the developers, and then our ideal language isn&#x27;t perfect any more!<p>The way I envision this is that the perfect language would have a pure &quot;data&quot; subset similar to JSON or SQL tables, with absolutely no special features of any type.<p>The next step up is data with references.<p>Then data with references and &quot;expression&quot; code that is guaranteed to terminate.<p>Then data with expressions and pure functions that may loop forever, but have no side-effects of any kind.<p>At some point, you&#x27;d want fully procedural code, but not unsafe code, and no user-controlled threads.<p>At the full procedural programming language level, I&#x27;d like to see a Rust-like ownership model that&#x27;s <i>optional</i>, so that business glue code can have easy-to-use reference types as seen in C# and Java, but if a library function is called that uses ownership, the compiler takes care of things. You get the performance benefit where it matters, but you can be lazy when it doesn&#x27;t matter.<p>Interestingly, C# is half-way there now with their Span and Memory types, except that this was tacked on to an existing language and virtual machine, so the abstractions are more than a bit leaky. Unlike Rust, where the compiler provides safety guarantees, there are a lot of warnings-to-be-heeded in the dotnet core doco.<p>TL;DR: We don&#x27;t need separate simplified languages, we need powerful languages with many simpler subsets for specialist purposes.')