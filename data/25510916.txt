Item(by='combatentropy', descendants=None, kids=None, score=None, time=1608669331, title=None, item_type='comment', url=None, parent=25509970, text='In a few tests I ran, I found rendering to be fast and lightweight. If you already have prepared the associative array of values, then the final stage of combining it with a template and producing HTML doesn&#x27;t strain the server, and so it doesn&#x27;t help your server much to move that part to the client.<p>The server&#x27;s hardest work is usually in the database: scanning through thousands of rows to find the few that you need, joining them with rows from other tables, perhaps some calculations to aggregate some values (sum, average, count, etc.). The database is often the bottleneck. That isn&#x27;t to say I advocate NoSQL or some exotic architecture. For many apps, the solution is spending more time on your database (indexes, trying different ways to join things, making sure you&#x27;re filtering things thoroughly with where-clauses, mundane stuff like that). A lot of seasoned programmers are still noobs with SQL.<p>Anyway, if rendering is lightweight, then why does it bog down web browsers when you move it there? I don&#x27;t think it does. If all you did was ship the JSON and render it with something like Handlebars, I think the browser would be fine, and it would be hard to tell the difference between it and server-side rendering.<p>I think what causes apps to get slow is when you not only render on the client but implement a single-page application. (It&#x27;s possible to have client-side rendering in a multipage application, where each new page requires a server roundtrip. I just don&#x27;t hear about it very much.) Even client-side routing need not bog down the browser. I&#x27;ve tested it with native JavaScript, using the History API, and it is still snappy.<p>I guess what it is, is that the developers keep wanting to bring in more bells and whistles (which is understandable) especially when they find some spiffy library that makes it easier (which is also understandable). But after you have included a few libraries, things start to get heavy. Things also start to interact in complex ways, causing flakiness. If done well, client-side code can be snappy. But a highly interactive application gets complicated quickly, faster than I think most programmers anticipate. Through careful thought and lots of revision, the chaos can be tamed. But often programmers don&#x27;t spend the time needed, either because they find it tedious or because their bosses don&#x27;t allot the time --- instead always prodding them on to the next feature.')