Item(by='simias', descendants=None, kids=[25822913, 25822559, 25826276, 25822488, 25828717, 25824691, 25824856, 25823892, 25826611, 25822868, 25822444, 25825907, 25825339, 25828935, 25822837], score=None, time=1610981842, title=None, item_type='comment', url=None, parent=25821718, text='Careful abusing these tricks. Over 10 years ago I decided to implement an RC4 (arcfour) cypher to generate pseudorandom noise for a test program.<p>The algorithm looks like (from wikipedia):<p><pre><code>  i := 0\n  j := 0\n  while GeneratingOutput:\n    i := (i + 1) mod 256\n    j := (j + S[i]) mod 256\n    swap values of S[i] and S[j]\n    K := S[(S[i] + S[j]) mod 256]\n    output K\n  endwhile\n</code></pre>\nBeing a smartass 1337 coder (and declaring intermediate variables always being a bit of a bother in C89) in my implementation I decided to implement the swap using the xor trick:<p><pre><code>   s[i] ^= s[j];\n   s[j] ^= s[i];\n   s[i] ^= s[j];\n</code></pre>\nI then ran a few basic test vectors, everything seems to work fine.<p>A little while later I noticed that the output of the cypher was weird, the longer it ran the more zeroes I would get, eventually getting only zeroes.<p>The keen reader will already have spotted the problem: whenever i and j happen to be equal instead of doing nothing the code sets the entry to 0 (since x ^ x == 0 for any x).<p>And that&#x27;s the story of how I never used this trick ever again.<p>In general it&#x27;s always better to write clear, concise code and let the compiler optimize it. If it turns that the code is performance critical and the compiler doesn&#x27;t do a good enough job then you can see if the smart solution is worth it.<p>And if you fail an interview because the interviewer expected you to know how to find a duplicate in an integer list by using xor then you probably dodged a bullet anyway. What a silly trivia question.')