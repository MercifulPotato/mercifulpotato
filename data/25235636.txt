Item(by='inkyoto', descendants=None, kids=None, score=None, time=1606543253, title=None, item_type='comment', url=None, parent=25232855, text='Static translation is, in fact, the simplest to accomplish, and it is time proven as well. This is what IBM have been doing with AS&#x2F;400 for more than three decades. AS&#x2F;400 runs on a virtual ISA, and applications are alwyas compiled into the virtual instruction set. Pointers, for instance, have been 128-bit since day 1 (1989 circa). Upon the first startup, virtual instructions are compiled into real CPU instructions, and the recompiled application image is stashed away in a cache. Consequent application restarts use the cached application image. IBM have been using POWER CPU&#x27;s for the last few generations of AS&#x2F;400, but they have also used drastically different CPU designs in the past as well. This allows to run applications that had been written in 1991 today, for example.<p>Dynamic binary translation (a predecessor of modern JIT) is a completely different story, though.<p>Now, a few years back, Apple introduced iOS app uploads in Bitcode. Bitcode is the LLVM&#x27;s own intermediate representation of the abstracted LLVM ISA. Apps available in Bitcode, when downloaded, are statically compiled into the ISA of the actual CPU one&#x27;s iPhone has. Again, apps uploaded in Bitcode in 2018, will run fast and effeciently on iPhone 18 as well. I could immediately draw parallels with AS&#x2F;400 a few years back when Apple announced the Bitcode availability.<p>I could not quickly check whether Bitcode was available for OS X apps today as well, but it would be hard to imagine why Apple would not want to extend the approach to the OS X apps as well. This is where it can get really interesting as apps available through the OS X app store in Bitcode, could be developed and compiled on a device running on the Intel ISA, but they could also be statically translated into M1 (M2, M3 etc) ISA at the download time and, at least theoretically, they would not require a separate ARM &#x2F; M1 app image (or a universal binary for that matter). Unless, of course, the app leans on something x86 specific.<p>I am on the hunch that the real disruption that Apple has inflicted upon the industry is not just a stupendously fast and power efficient chip (it is very nice but secondary), but the concept of the demise of the importance of hardware ISA&#x27;s in general â€“ use the intermediate code representation for app binary images and use whatever CPU &#x2F; hardware ISA that allows to realise the product vision. It is ARM today but it can be anything else 10 years down the road. I wonder who can push the mainstream PC industry in a similar direction and successfully execute it, though.')