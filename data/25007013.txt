Item(by='Athas', descendants=None, kids=None, score=None, time=1604664218, title=None, item_type='comment', url=None, parent=25006619, text='While I&#x27;m always down with research into applied restricted languages, I&#x27;m not sure this is the path to mainstream parallel programming.  It&#x27;s one thing to identify that parallel execution is safe, and it&#x27;s quite another to exploit that parallelism efficiently. E.g. in a pure functional language, you can automatically extract an enormous amount of parallelism, but doing so eagerly and naively will lead to a very slow program, as the communication and synchronisation overheads will dwarf any performance benefits of parallel execution.<p>In practice, it appears that programmers don&#x27;t find it problematic to explicitly indicate when things should run in parallel, and the main task of the language is to impose restrictions to avoid accidental sharing and race conditions. Rust is probably the most hyped example of such a language, but it&#x27;s by no means the first or only one.<p>Also, the elephant in the room is that in many common cases, the programming model is such that you get massive parallelism almost for free - e.g. when writing server-side web programs, where parallelism inside of one request may not matter (and often the database will take care of it when it does), because you have thousands of concurrent requests anyway.')