Item(by='breck', descendants=None, kids=None, score=None, time=1608319250, title=None, item_type='comment', url=None, parent=25470154, text='Here is the paper: <a href="https:&#x2F;&#x2F;github.com&#x2F;treenotation&#x2F;research&#x2F;blob&#x2F;master&#x2F;papers&#x2F;paper&#x2F;treenotation.pdf" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;treenotation&#x2F;research&#x2F;blob&#x2F;master&#x2F;papers&#x2F;...</a><p>It&#x27;s not that traditional a style as I had no experience in academia until after I published it on arxiv, but I still stand by basically all of it.<p>For the encoding all you need is 3 things: a node delimiter (generally newlines), a cell delimiter (generally tab or space), and an edge delimiter for parent&#x2F;child relationships (generally reuse the tab or space from above).<p>Think of a spreadsheet as a program, and that&#x27;s the base encoding.<p>From there you just need to define Grammars to get higher level constructs. This page (<a href="https:&#x2F;&#x2F;jtree.treenotation.org&#x2F;designer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jtree.treenotation.org&#x2F;designer&#x2F;</a>) contains ~15 example grammars, including a grammar for grammars (similar to YACC or ANTLR). This is just the tip of the iceberg though, you can do really novel things with these languages that you don&#x27;t see with all our traditional languages (like having N parse heads that start all over the place and move in all sorts of directions).<p>So if you take these ideas and combine them with this &quot;Statecharts&quot; paper of 1987, what you would do is create a &quot;Statecharts&quot; Tree Language defining all the elements they have in that paper, and then people could write &quot;programs&quot; in this Tree Language, and then you could use the Compiler Compiler I linked to above to generate a compiler that reads those programs and either 1) compiles them to SVGs like they have in their paper or 2) generates 3-D visualizations where the program shape in the focus is unchanged.')