Item(by='aboodman', descendants=None, kids=None, score=None, time=1605591801, title=None, item_type='comment', url=None, parent=25120243, text='Really the opposite is true.<p>If you want to know that you have handled every error path, Go is awful because there is no language or compiler support for it at all. Completeness has to be ensured manually, by inspection.<p>Check out Rust&#x27;s error handling approach sometime for an example of a language that truly values complete and correct error handling. It is a joy.<p>===<p>The reality is that Go doesn&#x27;t have better error handling because the language designers value the simplicity of Go&#x27;s implementation more than the simplicity of its interface - a trait that directly flows from its unix roots [1].<p>This is a fine tradeoff, and the right one for many problems. Go has been extremely successful in large part because of this philosophy. But you should not kid yourself that this is somehow the Right Way to handle errors, just because it&#x27;s what Go does. Because even Go&#x27;s designers are actively trying to fix it [2].<p>[1] <a href="https:&#x2F;&#x2F;www.jwz.org&#x2F;doc&#x2F;worse-is-better.html" rel="nofollow">https:&#x2F;&#x2F;www.jwz.org&#x2F;doc&#x2F;worse-is-better.html</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;32437" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;32437</a>')