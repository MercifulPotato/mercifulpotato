Item(by='onelivesleft', descendants=None, kids=None, score=None, time=1605479779, title=None, item_type='comment', url=None, parent=25099152, text='JS is so meh to write in, why learn it here.  Instead, learn DRUL, the assembler made for solving Rudy The Red Dot:<p>code = compile(&quot;.:dddddrruuuul@.&quot;);<p>var colors = [];<p>var acc = 0;<p>function run(instructions) {  \n   var pc = 0;<p><pre><code>   while (pc &lt; instructions.length) {\n     var line = instructions[pc];\n   var op = line[0];\n     var args = line[1];\n     switch (op) {\n       case &quot;a&quot;: &#x2F;&#x2F; set accumulator (set to remainingDots() if no arg)\n  a(args[0]);\n  break;\n       case &quot;+&quot;: &#x2F;&#x2F; add to accumulator (+1 if no arg)\n  add(args[0]);\n  break;\n       case &quot;-&quot;: &#x2F;&#x2F; subtract from accumulator (-1 if no arg)\n  sub(args[0]);\n  break;\n       case &quot;u&quot;: &#x2F;&#x2F; up n squares (1 if no arg)\n  u(args[0]);\n  break;\n       case &quot;d&quot;: &#x2F;&#x2F; down n squares (1 if no arg)\n  d(args[0]);\n  break;\n       case &quot;l&quot;: &#x2F;&#x2F; left n squares (1 if no arg)\n  l(args[0]);\n  break;\n       case &quot;r&quot;: &#x2F;&#x2F; right n squares (1 if no arg)\n  r(args[0]);\n  break;\n       case &quot;g&quot;: &#x2F;&#x2F; get current square color: color index n, unshift if -1, or push if no arg\n  g(args[0]);\n  break;\n       case &quot;s&quot;: &#x2F;&#x2F; set current square color: color index n, pop if -1, or shift if no arg\n  s(args[0]);\n  break;\n       case &quot;=&quot;: &#x2F;&#x2F; if current square color is literal (b &#x2F; r &#x2F; g &#x2F; y &#x2F; w) or color index n then jump to label\n  if (eq(args[0])) {\n   pc = args[1];\n   continue;\n  }\n  break;\n       case &quot;!&quot;: &#x2F;&#x2F; if current square color is not literal (b &#x2F; r &#x2F; g &#x2F; y &#x2F; w) or color index n then jump to label\n  if (!eq(args[0])) {\n   pc = args[1];\n   continue;\n  }\n  break;\n       case &quot;@&quot;: &#x2F;&#x2F; jump to label\n  pc = args[0];\n  continue;\n       case &quot;0&quot;: &#x2F;&#x2F; if accumulator is 0 then jump to label\n  if (acc == 0) {\n    pc = args[0]\n    continue;\n  }\n  break;\n       case &quot;~&quot;: &#x2F;&#x2F; if accumulator is not 0 then jump to label\n  if (acc != 0) {\n    pc = args[0]\n    continue;\n  }\n  break;\n        }\n  pc++;\n   }\n }\n\n\n run(code);\n\n\n function compile(code) {\n  var instructions = [];\n   var waiting_for_op = true;\n   var max_args = 0;\n   var skip_if_non_number = false;\n   var op = &quot;&quot;;\n   var label = &quot;&quot;;\n   code += &quot;     &quot;;\n\n   var i = 0;\n   var line = [];\n   var args = [];\n\n   while (i &lt; code.length) {\n     var c = code[i];\n     if (!waiting_for_op &amp;&amp; skip_if_non_number &amp;&amp; c != &quot;-&quot; &amp;&amp; isNaN(parseInt(c))) {\n  line.push(args);\n  instructions.push(line);\n  line = [];\n  waiting_for_op = true;        \n     }     \n     if (waiting_for_op) {\n       if (c == &quot; &quot;) {\n  i++\n  continue;\n       }\n       if (code[i+1] == &quot;:&quot;) {\n  label = c;\n  i += 2;        \n  op = code[i];\n       }\n       else {\n  label = &quot;&quot;;\n     op = c;\n       }\n       waiting_for_op = false;\n       line = [label, op];\n       args = [];\n       skip_if_non_number = (op == &quot;u&quot; || op == &quot;d&quot; || op == &quot;l&quot; || op == &quot;r&quot;);\n       if (op == &quot;=&quot; || op == &quot;!&quot;)\n  max_args = 2;\n       else\n  max_args = 1;      \n     }\n     else {\n       if (c == &quot; &quot;) {\n  line.push(args);\n  instructions.push(line);\n  line = [];\n  waiting_for_op = true;        \n       }        \n    else {\n  var negate = false;\n  if (c == &quot;-&quot;) {\n    negate = true;\n    i += 1;\n    c = code[i];\n  }\n  var num = parseInt(c);\n  if (isNaN(num)) {\n    if (c == &quot;b&quot;)\n      args.push(&quot;blue&quot;);\n    else if (c == &quot;r&quot;)\n      args.push(&quot;red&quot;);\n    else if (c == &quot;y&quot;)\n      args.push(&quot;yellow&quot;);\n    else if (c == &quot;g&quot;)\n      args.push(&quot;green&quot;);\n    else if (c == &quot;w&quot;)\n      args.push(&quot;white&quot;);\n    else\n      args.push(c);          \n  } \n  else {          \n    c = &quot;&quot;;\n    while (!isNaN(num)) {\n      c += code[i];\n      i++;\n      num = parseInt(code[i]);\n    }\n    num = parseInt(c);\n    if (negate) num = -num;      \n    i--;\n    args.push(num);\n  }\n  if (max_args &gt; 0 &amp;&amp; args.length &gt;= max_args) {\n    line.push(args);\n    instructions.push(line);\n    line = [];\n    waiting_for_op = true;       \n  }\n       }\n     }\n\n     i++;\n   }\n\n   for (i = 0; i &lt; instructions.length; i++) {\n     line = instructions[i];\n     op = line[1];\n     if (op == &quot;=&quot; || op == &quot;!&quot;)\n       instructions[i][2][1] = get_label(instructions, instructions[i][2][1]);\n     else if (op == &quot;@&quot; || op == &quot;0&quot; || op == &quot;~&quot;)\n       instructions[i][2][0] = get_label(instructions, instructions[i][2][0]);\n\n   }\n\n   for (i = 0; i &lt; instructions.length; i++) \n  instructions[i].shift();\n\n   return instructions;\n }\n\n\n\n function get_label(lines, label) {\n   for (var i = 0; i &lt; lines.length; i++) {\n     if (lines[i][0] == label)\n       return i;\n   }\n   return -1;\n }\n\n\n function repeat(fn, n) {\n   if (n == undefined)\n     fn();\n   else\n  for (var i = 0; i &lt; n; i++)\n  fn();\n }\n\n function eq(color) {\n   if (typeof(color) == &quot;number&quot;)\n     color = colors[color];\n   if (color == &quot;white&quot;)\n     color = false;\n   return color == getColor();\n }\n\n function g(c) {\n  color = getColor();\n   if (!color) \n     color = &quot;white&quot;;\n\n   if (c == undefined)\n     colors.push(getColor());\n   else if (c == -1)\n     colors.unshift(getColor());\n   else\n  colors[c] = getColor();\n }\n\n function s(c) {\n   if (c == undefined)\n     color = colors.shift();\n   else if (c == -1)\n     color = colors.pop();\n   else\n     color = colors[c];\n\n   if (color == &quot;white&quot;)\n     color = false;\n   setColor(color);\n }\n\n function u(n) {\n   repeat(up, n);\n }\n\n function d(n) {\n   repeat(down, n);\n }\n\n function r(n) {\n   repeat(right, n);\n }\n\n function l(n) {\n   repeat(left, n);\n }\n\n function a(n) {\n   if (n == undefined)\n     acc = remainingDots();\n   else\n     acc = n;\n }\n\n function add(n) {\n   if (n == undefined)\n     acc++;\n   else\n  acc += n;\n }\n\n function sub(n) {\n   if (n == undefined)\n     acc--;\n   else\n     acc -= n;\n }\n\n &#x2F;&#x2F; level  1  d7r5u2r2\n &#x2F;&#x2F; level  2  d6r3u2r2d3\n &#x2F;&#x2F; level  3  d2 g d3r2 s r2u\n &#x2F;&#x2F; level  4  d4r1g ds r2urg ds r2\n &#x2F;&#x2F; level  5  .:r2 =bB =rR r B:d @. R:u @.\n &#x2F;&#x2F; level  6  r =bB u4 =b&gt; lu &gt;:ru B:d4 =b&lt; rd &lt;:ld\n &#x2F;&#x2F; level  7  .:=r&gt; d @. &gt;:r2 u9 @.\n &#x2F;&#x2F; level  8  d8 r2 u7 r2 d7 r2 u7 r2 d7 r1\n &#x2F;&#x2F; level  9  .:r100 d100 @.\n &#x2F;&#x2F; level 10  a8 .:d g - ~. dr a8 #:s ru - ~# u\n &#x2F;&#x2F; level 11  .:=gG=yY=bB=rR G:r=wG@. Y:d=wY@. B:u=wB@. R:l=wR@.</code></pre>')