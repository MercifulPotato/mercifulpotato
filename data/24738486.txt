Item(by='masklinn', descendants=None, kids=None, score=None, time=1602332779, title=None, item_type='comment', url=None, parent=24737961, text='&gt; So this essentially means there can never be a NULL object assigned to anythingâ€¦<p>No, it means that you can&#x27;t leave bits off yet claim to have a valid object, either the object is fully initialised or it&#x27;s illegal. This is mostly a concern in older languages like C where you can reserve space for a struct then not fill in anything.<p>In some more recent languages (Java, Go, C# historically though that&#x27;s changing) everything is zeroed by default so you avoid the &quot;random garbage&quot; situation, but it means you need to assume anything <i>can</i> be zero even if that&#x27;s not intentional, and depending on the specifics you might &quot;double write&quot; each location even when that&#x27;s not actually necessary.<p>In the more functional slate of languages, you simply can&#x27;t let any members off. There might be a concept of &quot;default value&quot; but that tends to be opt-in, the baseline is that if you define a type you must fill in every member, explicitly, before the compiler will accept it.<p>Initialising items to null is orthogonal.<p>Now since the rest is predicated on a misunderstanding I&#x27;ve a version of each for &quot;incomplete initialisation&quot; and a version for &quot;null&quot;.<p>&gt; how is [forcing complete initialisation] possible?<p>The compiler just requires that every member of the structure be specified.<p>&gt; how is [things never being NULL] possible?<p>Don&#x27;t make NULL an implicit member of every type.<p>&gt; is [incomplete initialisation] avoided by throwing exceptions instead of returning NULL?<p>it&#x27;s avoided by the compiler refusing to compile your code if you leave off members.<p>&gt; is [things never being null] avoided by throwing exceptions instead of returning NULL?<p>It&#x27;s avoided by NULL being a member of a completely different type than anything else, whether that type is a special case or not e.g. in Rust &quot;null&quot; is one member of the Option &quot;wrapper type&quot; so to indicate that, say, a user is optional you write `Option&lt;User&gt;`, then that can either be `None` (no user, ~ null) or `Some(user)`.<p>If you just type something as `User` then it&#x27;s necessarily a valid user and nothing else, because there is no null value you could put into it, you&#x27;d get a type error.<p>* Rust playground which fails to compile because one of the struct members was left off: <a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=560e1ea6c9b767ec9ca6a5f913b955aa" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;editio...</a><p>* Rust playground which fails to compile because trying to put a null (None) in a non-nullable field: <a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4dede06ad070f65e525dfd16c423223f" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;editio...</a><p>* Version of the previous with an optional (nullable) member: <a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a741aab6d7000320c1c5fe736fbb2ef3" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;editio...</a><p>* Version with opt-in default (through Rust&#x27;s Default trait, the default derivation of the Default trait will recursively default each field, which usually means some sort of zeroing): <a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ba0aa527cf597e0abbc250dbabb4b3c3" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;editio...</a>')