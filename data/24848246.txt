Item(by='jlnthws', descendants=None, kids=None, score=None, time=1603290784, title=None, item_type='comment', url=None, parent=24834965, text='Discipline is all what matters, automatizations are imperfect and temporary tools.<p>Simply put: all abstractions are leaky, all abstractions have trade-off, and you cannot necessarily rely on some abstractions in every context.<p>The GC example that the author uses is a good one: having GC in a language does not magically remove all memory allocation issues. Believing this means you just don&#x27;t have much experience programming (or you&#x27;ve been very lucky). I&#x27;ve been working mostly with GC languages and we have memory leak every now and then, good luck to fix that without discipline. Embedded software frequently relies on (very) limited compilers and libraries, most of the time there are no GC and until recently there were even no malloc&#x2F;free for $B things shipped to space: only static arrays and discipline my friend!<p>TCP is another good example: sometimes you need to craft you own congestion management, packet discard rule or what not.<p>ORMs have made my life easier but I&#x27;ve still had to spend days on complex hundreds lines SQL reports. The list goes on.<p>It&#x27;s not &quot;I had to go through this, you should too&quot; out of frustration. It&#x27;s because at some point the same kind of issue will appear again, even though the current available abstractions may seem to shield us from it.<p>It might not scale as easy as you wish, yet you need some disciplined seniors to review and teach your juniors. This very article ironically proves it :)')