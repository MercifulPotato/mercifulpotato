Item(by='ImprobableTruth', descendants=None, kids=[24963087], score=None, time=1604268676, title=None, item_type='comment', url=None, parent=24962310, text='&gt;It is based on dependent products which you need to understand sooner-or-later (sooner, really),<p>Type-theoretic universal quantification _is_ the dependent product (&#x2F;dependent function, a term I prefer). I assume you&#x27;re talking about the Cartesian representation, but that&#x27;s just one way to visualize it, the definition is not dependent on it. If you understand predicate logical quantification it&#x27;s not necessary at all, since the introduction&#x2F;elimination rules for type theoretic quantification are the same as for normal predicate logic quantifiers.<p>&gt;are rather more intricate than FOL<p>Maybe in application and theoretical implications, but to grasp the concept you have just have to understand that it&#x27;s relaxing the restriction on &quot;what you can quantify over&quot;, which really isn&#x27;t a huge jump I&#x27;d say.<p>&gt; Ah, but that&#x27;s the thing. It&#x27;s not a function and it can&#x27;t be (for the same reason you don&#x27;t have an identity function in set theory).<p>Why would it not be a function? With set theory you have the issue that you can&#x27;t take a set as an argument and have the codomain and it&#x27;s elements be dependent on it, but that&#x27;s exactly what dependent function types allow you to do. \nThe universe U is a sort and A is a valid sort too, so<p>forall A:U. forall a : A. A<p>is a perfectly valid function signature and the term would just be (lambda A : U. lambda a : A. a). That doesn&#x27;t strike me as any more complicated than your second TLA+ example. Sure, you have to deal with universe polymorphism, but I&#x27;d say that&#x27;s compensated by the increased complexity from having to use syntactic operator.<p>Lean&#x27;s syntax to specify the universe U is admittedly pretty ugly, but the actual meta-theory isn&#x27;t that complex I&#x27;d say.')