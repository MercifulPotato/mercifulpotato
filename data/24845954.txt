Item(by='AmericanChopper', descendants=None, kids=None, score=None, time=1603270070, title=None, item_type='comment', url=None, parent=24845799, text='It&#x27;s certainly a valid observation that anything that large enterprise does, will end up being more complex than it necessarily needs to be.<p>But if I look at a lot of the SP anti-patterns I&#x27;ve seen over the years, some common themes start to arise. I&#x27;d say the biggest issue is that it is more complex to maintain interfaces between two discrete systems than it is to write monolithic code paths. Seeing SP_ProcedureName accompanied by SP_ProcedureName_New is very common. It&#x27;s easy to get into that situation, and tedious to get out of it.<p>Storing business logic in the DB also presents a lot of very tempting, but ultimately costly, shortcuts to developers. Using a non-temporary table when you should have used a temporary table, because you wanted debugging to be easier, but now you&#x27;ve got a concurrency issue, but it&#x27;ll probably be OK, so you leave it there for 15 years. I have also never seen what I would consider to be a sensible use of a trigger. You also end up with SPs invoking SPs invoking SPs... and figuring out the side effects of calling something becomes a lot more complicated than it would be in a monolith.<p>I don&#x27;t think they&#x27;re always bad, but I do think that reasonable use cases for them are rather uncommon. When you had a lot of services directly consuming one database, SP interfaces used to make a lot more sense. But that&#x27;s not a very common architecture is not very common any more. Even in large enterprises, you&#x27;ll typically see new projects being developed as web applications, even if they&#x27;re only served over the corporate network.')