Item(by='chubot', descendants=None, kids=None, score=None, time=1601848396, title=None, item_type='comment', url=None, parent=24681715, text='Some more info here:<p><i>[ Is a Builtin, But [[ Is Part of the Language</i><p><a href="http:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2016&#x2F;10&#x2F;12.html" rel="nofollow">http:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2016&#x2F;10&#x2F;12.html</a><p>There are lots of subtleties about it, which I don&#x27;t really recommend learning.  Oil fixes a bunch of these problems:<p><a href="http:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2020&#x2F;01&#x2F;simplest-explanation.html" rel="nofollow">http:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2020&#x2F;01&#x2F;simplest-explanation.ht...</a><p>But if you really want to know:<p>* It also has == which does NOT mean equality.  It means fnmatch (glob) the right-hand side.<p>* Similarly, it has =~ to match a regex on the RHS.  However you should avoid using a literal regex, and use a var $pat instead, because bash&#x27;s lexing&#x2F;escaping&#x2F;quoting of the pattern is busted, and it even says so in the bash manual.<p>Summary:<p><pre><code>    [ &quot;$a&quot; == &quot;$b&quot; ] # string equality\n    [ &quot;$a&quot; = &quot;$b&quot; ]  # string equality\n    [[ $a == $b ]]   # fnmatch\n    [[ $a = $b ]]    # fnmatch\n    [[ $a =~ $b ]]   # regex match\n    [[ $a -eq $b ]]  # numeric equality\n    (( a == b ))     # numeric equality\n    (( a = b ))      # numeric assignment!\n</code></pre>\nAgain, if you don&#x27;t want to remember all that, try Oil instead :)  Tell me what happens -- it&#x27;s still open to feedback and change.<p>It has dynamic types and operators like Python or JS.  There&#x27;s only one expression language, which replaces all these inconsistent constructs.')