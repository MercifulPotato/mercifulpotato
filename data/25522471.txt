Item(by='simias', descendants=None, kids=[25523074, 25522558, 25523078, 25522598, 25527269, 25522600, 25522977, 25525686, 25525295, 25523095, 25522553, 25525981, 25523594, 25522515, 25524170, 25525547, 25524670, 25523226, 25524022, 25522543], score=None, time=1608759203, title=None, item_type='comment', url=None, parent=25520353, text='I don&#x27;t really get these modern async APIs. In languages like Javascript I thought they only made sense because JS interpreters are (historically) single-threaded, so you really have no choice but async to express some concepts. Fine.<p>But in Rust you can just spawn threads, share data through channels or mutexes, use OS-provided async IO primitives to poll file descriptors and do event-driven programming etc...<p>I tried looking into Tokio a little while ago and I found that it led to some incredibly complicated, abstracted, hard to think about code for stuff I usually implement (IMO) much more simply with a basic event loop and non-blocking IO for instance.<p>I&#x27;m sure async can get the upper hand when you have a huge number of very small tasks running concurrently because that&#x27;s generally where OS-driven parallelism tends to suffer but is it such a common scenario? That sounds like premature optimization in many situations IMO. Unless you actually think that async code is more expressive and easy to read and write than basic event loops, but then you must be a lot smarter than I am because I have to take an aspirin every time I need to dig into async-heavy code.<p>I guess I&#x27;m trying to understand if it&#x27;s me who&#x27;s missing something, or if it&#x27;s web-oriented developers who are trying to bring their favourite type of proverbial hammer to system development.')