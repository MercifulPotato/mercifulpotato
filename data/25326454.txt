Item(by='imtringued', descendants=None, kids=[25326811, 25327248], score=None, time=1607287497, title=None, item_type='comment', url=None, parent=25322951, text='Unfortunately all programming languages are flawed. It&#x27;s kind of funny how we still have no programming language that does everything to a satisfying degree instead of having one major wart that always means that a different problem requires a different programming language.<p>There are not many languages with a lean runtime. The JVM needs a lot of memory even if you have 0 bytes of heap usage. Javascript applications are often tied to electron.<p>There are not many fast languages that do not cause security issues or cause hard to debug segfaults. The two obvious choices are Rust, Java (or C#) and maybe Go. I personally set the cutoff point for fast enough to be Javascript with v8. Not everything needs to be fast enough to be used for a game engine but at the same time I don&#x27;t want to CPU or user time on gross inefficiencies.<p>There are not many modern languages that everyone agrees to use. Javascript is the pinnacle of this because people are forced to use it. The JVM suffers from having too many languages. Kotlin is the only winner but I am still bitter about that one JVM language that died. I don&#x27;t know why but Rust is one of the most hated languages on HN.<p>There are not many easy to learn languages. C++, Rust, Haskell, Scala all tend to suffer from the ability to write convoluted code bases that nobody understands. People become experts within their own small islands. Java EE also had a phase where everything was done with impenetrable xml files that were getting closer and closer to turing completeness. Java and Go are both a direct response to C++ being too complex.<p>All easy to use languages (primarily JVM languages but also many interpreted languages) fail because they are not fast and lean and nobody uses them.<p>All fast and lean (=low level) languages fail because they are too complicated or suffer from security problems.<p>The answer? I don&#x27;t know. I thought graalvm was going to solve this with it&#x27;s native image mode but my preferred JVM language doesn&#x27;t run on it. I&#x27;m hoping that Java will be good enough if I&#x27;m going with a slightly non standard setup (immutables). The lack of reflection means that you have to avoid a lot of libraries. Ecosystem advantages are disappearing if you go down this route.')