Item(by='akra', descendants=None, kids=None, score=None, time=1608062985, title=None, item_type='comment', url=None, parent=25433397, text='For me this is the point that I feel isn&#x27;t well argued against by GraphQL proponents. Why if I&#x27;m a Javascript developer with probably a similar learning curve I couldn&#x27;t just whip up a simple stateless frontend (in Node since its the same lang) and write the query in SQL? More to the point the skills learnt by doing so are more transferable. You also give your data store a chance to be more performant (e.g. better query plans for a typical DB) using that DSL to query the data store and there&#x27;s a lot less complexity (components, libraries) in your solution.<p>Also from what I&#x27;ve seen the approaches that may result in single ideal query plans in your database increase the complexity of GraphQL significantly with &quot;GraphQL to SQL&quot; compilers which still may not give tuned SQL especially with large graphs. Reminds me of using ORM&#x27;s where often the generated SQL wasn&#x27;t performant&#x2F;slow. Even if it does work the complexity of your solution just increased - all for what? To translate one query language into another? There&#x27;s also times where it may pay NOT to expose too much of your internal domain structure to public API&#x27;s which I feel from a naive developer&#x27;s perspective GraphQL could encourage (direct internal API structure to contract mappings).<p>It feels, at least to me, that it is another abstraction layer that solves a problem that could also be solved at the org level. If there&#x27;s suddenly a use case that requires a tuned query&#x2F;algorithm&#x2F;index as well (happens a lot from my experience) then its easy to add as a separate endpoint and test for regression test against other endpoints&#x2F;use cases supported.')