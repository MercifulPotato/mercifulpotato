Item(by='lathiat', descendants=None, kids=None, score=None, time=1611451234, title=None, item_type='comment', url=None, parent=25883675, text='It won&#x27;t trigger a read if you write a full 4kB page in both size and alignment but does for anything else. And then as you said, it stalls your write.<p>I debugged a Ceph issue being caused by this kind of behaviour except it wasn&#x27;t actually mmap it was pwritev() but the call would stall and take a long time to return in that call that was expected to be async and go into the page cache.<p>It was caused by &quot;unaligned&quot; writes, e.g. non 4kB-sized-and-aligned writes which happens from Windows guests (using 512b alignment, at least by default) but not Linux guests (which use 4kB alignment, even if the disk is 4kB aligned)<p>It was made worse by Ceph behaviour that would write to that page, incur the penalty, immediately use madvise to tell the kernel I DONTNEED that anymore as an optimisation (because its a replica that is write-only, I don&#x27;t need to read it again!), it got dropped, and a millisecond later wrote to it again and had to read it again (because that optimisation did not consider this case of unaligned writes needing to read)<p>Full story here:\n<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_vfGcsvnn6U" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_vfGcsvnn6U</a> &quot;In-depth technical story: Fixing I&#x2F;O performance for Windows guests in OpenStack Ceph clouds&quot;<p>It was at this point I understood memory alignment and why it might matter at a CPU level.')