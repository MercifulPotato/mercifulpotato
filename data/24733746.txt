Item(by='systemvoltage', descendants=None, kids=[24734075, 24733986], score=None, time=1602273206, title=None, item_type='comment', url=None, parent=24733393, text='&gt; Instead the types allow Julia to dispatch your method call to the correct implementation for the type of your variable at runtime. This is Julia&#x27;s secret sauce, and it&#x27;s the main reason you&#x27;ll hear about Julia programmers declaring about how composable Julia packages are. I can &quot;reach into your package&quot;, and define the behaviour of your functions on my own custom types and then whenever anyone tries to call the function&#x2F;method with one of my types, it&#x27;ll just work. I don&#x27;t need to author a pull request to your package or futz around with anything that you&#x27;ve wrote.<p>That&#x27;s not a bug, that&#x27;s a feature. Libraries are abstractions. I get an API and it encapsulates the behavior of the library. That is a <i>nice</i> thing. Being able to modify runtime behavior of internal libraries can lead to insane jumblygoo of code spathetti that would bring the finest programmers to their knees.<p>I don&#x27;t want implicit behavior at runtime. I want explicit behavior in case of non-contractual externalities (wrong user input for e.g. at runtime). I want the program to fail so it can be patched.')