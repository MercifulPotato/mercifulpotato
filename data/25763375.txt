Item(by='qppo', descendants=None, kids=[25764022, 25763764], score=None, time=1610552590, title=None, item_type='comment', url=None, parent=25762218, text='Type inference is great and undeserving of the &quot;bah humbug&quot; type comments. Not a fan of it in function return types but that&#x27;s easy to avoid in code review or linting (both of which you need plenty in C).<p>The closure proposal is much more interesting. I skimmed the discussion and it points out many of the benefits and some syntax proposals, but I&#x27;m wondering about memory management.<p>In C++ a lambda may not be convertible to a function pointer if the captured context is non zero sized, and if the captured context is larger than the size of a pointer it <i>must</i> use some kind of dynamic allocation. C++ has scoped destructors, making implementation of that relatively straightforward (free the context when the lambda goes out of scope), but what would C require? Defer statements? Require a free() without matching call to malloc?<p>Closures in C are still possible using void* as a user context, which is common both for closure semantics in libraries as well as implementing closures in languages transpired to or interpreted in C. The memory management is explicit, the types remain explicit (except for the closed over context), albeit a bit verbose.<p>As much as I love functions as types and programming with them I&#x27;m confused how this is a positive feature for C, which lacks some of the semantics that other languages have making closures sensible.')