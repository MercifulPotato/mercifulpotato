Item(by='xeeeeeeeeeeenu', descendants=None, kids=None, score=None, time=1610627288, title=None, item_type='comment', url=None, parent=25773101, text='Taint mode is a terrible misfeature and modern code should not use it. It&#x27;s one of those things that makes people think &quot;it&#x27;s annoying and makes me do additional work so surely it improves the security&quot;. No, it doesn&#x27;t.<p>For those who are unware what taint mode exactly is: when it&#x27;s enabled, a string may have a hidden &quot;tainted&quot; flag. Passing a tainted string to many (but not all) built-in functions will result in an exception.\nMany built-ins return tainted strings, additionally all strings in @ARGV (cli parameters) and %ENV (env variables) are tainted. You can get an untainted string by accessing a tainted string through a regex capture group ($1, $2 etc.). Taint mode is global, so it affects everything, including third party modules.<p>You may ask &quot;how do I even validate my environmental variables? What&#x27;s the difference between valid and invalid PATH?&quot;. Well, you can&#x27;t. That&#x27;s why programs using taint mode are often littered with code like:<p><pre><code>    my($untainted) = $foo =~ &#x2F;^(.*)$&#x2F; \n</code></pre>\nThe worst thing is that you never know whether a function from a third party (CPAN?) module will return a tainted string or not. It may differ between platforms! For example, File::Spec is sometimes returning tainted strings on unixes, but not on Windows (or the other way around, I&#x27;m not sure!). In practice that means you will have to run your program, check if it throws an exception, and if it does, you have to use the above no-op &quot;validation&quot; regex.<p>Well, that assumes that the said third party code works in taint mode. If it wasn&#x27;t tested with it, it&#x27;s possible that it won&#x27;t work at all and there&#x27;s nothing you can do about it.')