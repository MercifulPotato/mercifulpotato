Item(by='kazinator', descendants=None, kids=None, score=None, time=1609897301, title=None, item_type='comment', url=None, parent=25630096, text='A lot of regex-based solutions are not robust against bad input.<p>Bad input doesn&#x27;t always mean that the regexes don&#x27;t match!<p>Regexes have a very happy home inside lexical analyzers for tokenizing languages. Lexers define what is correct input and match every case with some regex pattern. If there is no match, then the input doesn&#x27;t contain a valid token: the lexer can loudly complain (logging an error that can be treated as fatal by the overall compile job), drop an input character and try matching again.<p>The typical regex solutions in Perl (Awk, ...) scripts go like this: &quot;look for this flimsy, minimal regex somewhere in the stream and assume it&#x27;s the right  thing, then match this other regex in the same line and---woo hoo!--that&#x27;s our item. Oh, false positives, schmozitives.&quot;<p>Basically, if we were to pin it down to a single difference in principles is that using regexes for <i>searching</i> for something small in something large is different from <i>matching</i> an entire input in its totality (and then getting at the desired parts).<p>Searching is the quick and dirty thing that&#x27;s easy to reach for.')