Item(by='sillysaurusx', descendants=None, kids=[25080676, 25084009, 25081605, 25079842], score=None, time=1605237692, title=None, item_type='comment', url=None, parent=25043199, text='I’ve been thinking about how to package macros across a variety of programming languages. Macros are the ability to generate code structures, which are then executed. For example, [“setnull”, “x”] might be compiled to x = null in JavaScript, which is then evaluated. Notice you cannot do this with functions — you can’t access un-evaluated arguments, like the name “x”, or the lexical environment in which it appears (to say nothing of dynamic scope).<p>It’s a hard problem. Clojure has some prior art in this space, but the packaging system relies on creating “their own world” — classes in Clojure aren’t really plain Java classes. Or more specifically, protocols are a completely different thing from what normal Java applications write their programs with.<p>I don’t think building one’s own programming world is a good thing when you bootstrap macros on top of an ecosystem. The most powerful use of this technique is, for example, to have native access to Numpy with python + lisp macros. You can’t really do that with a runtime that has to be embedded with all of your modules.<p>pg’s Bel has some interesting things to say about the topic, if you focus strictly on the interpreter. The ability for functions to be represented by lists — along with their lexical environment being represented by those same lists — is something that appears in elisp, but nowhere else I’ve seen. Self, maybe?<p>It’s an ongoing process. The reason I bring it up is that macros are one of the finest tools of metaprogramming available, so it’s a problem worth solving.')