Item(by='Blikkentrekker', descendants=None, kids=[25981453, 25982160], score=None, time=1612118029, title=None, item_type='comment', url=None, parent=25978190, text='&gt; <i>But it has now taken a new interpretation in the last couple of decades: Static typing is a form of compile-time error checking, so it will help you produce better quality code. It is as if static typing is a magical theorem prover that will verify some deep properties of your program. This is where I call</i> bullsh*t<i>.</i>[<i>sic</i>] <i>I have never had a static type checker (regardless of how sophisticated it is) help me prevent anything more than an obvious error (which should be caught in testing anyway).</i><p>That&#x27;s an anecdote; facts are that serious critical bugs that lead to privilege escalation and loss of data have existed in codebases that would surely have been caught by various static type systems.<p>&gt; <i>In other words, static typing is pointless. It has, maybe, some documentary value, but it does not substitute documentation on other invariants. For example, your invariant might be something like I’m expecting here a monotonically increasing array of numbers with a mean value of such and such and a standard deviation of such and such. The best any static type checking will let you do is “array[float]”. The rest of your invariant must be expressed in words as a documentation of that function. So why subject yourself to the misery of “array[float]”?</i><p>With dependent typing, it&#x27;s actually quite possible to both define a type for “sorted list” and prove to the type checker that a sorting algorithm does sort it.')