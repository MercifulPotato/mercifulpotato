Item(by='ucarion', descendants=None, kids=None, score=None, time=1608832232, title=None, item_type='comment', url=None, parent=25525567, text='For what it&#x27;s worth, there is a pretty solid conventional wisdom in this space.<p>&gt; - A simpler but much faster engine will beat a more complex engine any time because the advantage of another ply easily outweighs the advantage of some clever algo.<p>Depends a lot on what you call &quot;simple&quot;. Stockfish&#x27;s search and evaluation subroutines are pretty complex and distinctly clever:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;official-stockfish&#x2F;Stockfish&#x2F;blob&#x2F;master&#x2F;src&#x2F;search.cpp" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;official-stockfish&#x2F;Stockfish&#x2F;blob&#x2F;master&#x2F;...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;official-stockfish&#x2F;Stockfish&#x2F;blob&#x2F;master&#x2F;src&#x2F;evaluate.cpp" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;official-stockfish&#x2F;Stockfish&#x2F;blob&#x2F;master&#x2F;...</a><p>But I agree that early on, simple is the way to go. It&#x27;s much easier to optimize a simple engine.<p>&gt; - A 10x10 board with an unreachable edge has some advantages [...]<p>Maybe in theory, but FWIW I don&#x27;t know of any modern engine that does this. A more popular variant of the 10x10 or 10x12 idea was, back in the day, the 0x88 layout:<p><a href="https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;0x88" rel="nofollow">https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;0x88</a><p>If you&#x27;re going to be writing an engine today from scratch, use the bitboard representation. It&#x27;s easy to implement and has the most resources out there if you need help.<p>(Bitboards is just the idea of representing the game state as a bunch of 64-bit ints, with one u64 per white&#x2F;black type of piece.)<p>Your example use-case, of knight posisitions, is usually solved with bitboards using an 64-element array mapping squares to a bitboard of all the places a knight on that square can go. Here&#x27;s where Stockfish does that:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;official-stockfish&#x2F;Stockfish&#x2F;blob&#x2F;b06ef36ae5f23fa2d4188c9fe6d95c4f551ab035&#x2F;src&#x2F;bitboard.cpp#L102" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;official-stockfish&#x2F;Stockfish&#x2F;blob&#x2F;b06ef36...</a><p>Other commenters have noted that you can do a slightly fancier version of this lookup table technique to solve for the sliding pieces (bishops and rooks (queens are a bitwise OR of bishops and rooks)), because the raw data is low entropy, so finding a perfect hash function (&quot;magic bitboard&quot;, in the lingo) is fast enough to do on startup:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;official-stockfish&#x2F;Stockfish&#x2F;blob&#x2F;b06ef36ae5f23fa2d4188c9fe6d95c4f551ab035&#x2F;src&#x2F;bitboard.cpp#L139" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;official-stockfish&#x2F;Stockfish&#x2F;blob&#x2F;b06ef36...</a><p>It&#x27;s existing techniques like this that make bitboards a good choice for beginners; if you get stuck, you can find resources online.<p>&gt; - Optimization of engine code is much harder than optimization of the yield function.<p>Big +1 there! The yield function is also much easier to A&#x2F;B test.<p>&gt; - It is much better to not generate &#x27;bad&#x27; moves than it is to prune them away after a lot of extra work has been done. Colin Wrights&#x27; law: &#x27;You can&#x27;t make computers faster, you can only make them do less work&#x27; clearly applies here.<p>Yes, but it&#x27;s pretty hard to reliably get your move generator to generate good moves first. The other side of making mixmax search fast is quickly throwing out branches that aren&#x27;t relevant.<p>For instance, delta pruning and null-move pruning do this by trying to detect if one of the sides has thrown the game with their last move; since minmax is about assuming optimal play on both sides, branches where someone makes a blunder aren&#x27;t worth looking into.<p>&gt; - memoization can bring insane speed gains.<p>Yup! Also, a lot of engines have optimized routines that let you undo a move quickly, without having to keep a redundant stack of every position&#x27;s state, which would involve a lot of memcpy-ing.<p>Have fun! I had to stop doing chess engines, they were becoming too much of a distraction for me. I&#x27;m kind of glad ML-AI is starting to beat human-crafted AI in chess, that way the space can go back to being a fun little hacker cottage industry.<p><i>Edit:</i> Oh! When making a chess engine, start by implementing &quot;perft&quot;:<p><a href="https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;Perft" rel="nofollow">https:&#x2F;&#x2F;www.chessprogramming.org&#x2F;Perft</a><p>That way you can compare how many legal moves your engine thinks there is in a position, versus how many Stockfish or some other known-good engine thinks there is. It&#x27;s the closest thing there is to unit tests in the space.')