Item(by='dmw_ng', descendants=None, kids=None, score=None, time=1602335904, title=None, item_type='comment', url=None, parent=24736559, text='The parser from the article&#x27;s performance is closer to 360mb&#x2F;sec, the 2gb&#x2F;sec is only achieved by over-allocating an incredible amount of hardware. CSV parsing is such a simple problem there is no reason to waste a whole machine on it, and in many contemporary scenarios (AWS Lambda), it&#x27;s simply not possible to waste a whole machine on it.<p>I never finished packaging and writing tests, but <a href="https:&#x2F;&#x2F;github.com&#x2F;dw&#x2F;csvmonkey" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;dw&#x2F;csvmonkey</a> hits 1.9gb&#x2F;sec on certain data sets with one thread, and that implementation is not even representative of the limits of single thread performance. <a href="https:&#x2F;&#x2F;github.com&#x2F;geofflangdale&#x2F;simdcsv" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;geofflangdale&#x2F;simdcsv</a> follows a similar approach to simdjson, where multiple passes over the input are used, but with lower latency vector instructions (csvmonkey used one of the slowest). Character set decoding is also fused into the parser. There are no benchmarks published in that repo, but I expect the approach trounces my effort even if the current implementation doesn&#x27;t.<p>Why be satisfied saturating one NVMe drive when a few threads could saturate the PCIe bus instead?')