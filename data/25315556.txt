Item(by='moron4hire', descendants=None, kids=[25317281], score=None, time=1607184673, title=None, item_type='comment', url=None, parent=25315143, text='With TypeScript, you have kind of an impossible problem: type check a program, but maintain compatibility with extant JavaScript libraries. There are JS idioms that don&#x27;t match to TS very well without creating some pretty complex union types. And it&#x27;s very easy to end up with ad hoc types all over everywhere, only to escape to using `any` when it becomes too much mental overhead.<p>Previously, I had been very diligent about using JSDoc to annotate methods and fields with types, which gave me a lot of information with which to work in my IDE. But JSDoc is not a type system, it&#x27;s very cumbersome to express ad hoc object structures, and being &quot;very diligent&quot; is not &quot;perfectly diligent&quot;, so the TS porting process discovered some subtle bugs where I had, for example, guessed wrong on the type of something coming from a library (I also forked and ported most of my dependencies), or changed the return type of a method but missed a couple of very rare calls of it.<p>Ad hoc union types in signatures gets super line-noisey. You can avoid it by diligently (there&#x27;s that word again) using interfaces and named types. I think type expressions get overused in TS, out of some hope they can make the language into Haskell. That is not the case, and most of the time it&#x27;s better to use interfaces.<p>Still, I have a dependency that can only be included via a script tag. This wasn&#x27;t too much of a burden in JS, because the language does basically nothing for you. But using it in my TS port took a <i>lot</i> of effort. I had to download the source of it, patch in a tsconfig, generate .d.ts files, and fix them up where they had escaped out to `any`. It&#x27;s still not perfect. The quality of the library is pretty low to begin with, but it&#x27;s the only way to interface with a WebRTC server I&#x27;m using. I&#x27;m pretty close to deciding to use a different WebRTC server (probably even one I write on my own), just to fix the remaining issues.<p>That said, if you&#x27;re starting from scratch, TS can be very clean and push you towards much better designs. It&#x27;s hard to do the wrong thing. You can still do it, but it&#x27;s hard. You need to have that ability, though, because there&#x27;s just too much &quot;wrong&quot; with everyone else&#x27;s code out there.<p>I don&#x27;t mind that, too much. The only thing I mind is that it&#x27;s very difficult to distribute a library in such a way that it can be used with a TS project without a lot of warnings or errors, especially if you&#x27;re using Webpack (ugh, Webpack generates some uuuugly bundles). So even though a lot of my dependencies offer TS-generated bundles or .d.ts files, it still doesn&#x27;t work very well. You really need to be distributing TS source for the library, and not relying on any conditional compilation that your consumers will have to replicate in their own builds.')