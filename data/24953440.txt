Item(by='Syzygies', descendants=None, kids=[24953697, 24953915, 24953987, 24957711, 24954182, 24954907, 24956039], score=None, time=1604165725, title=None, item_type='comment', url=None, parent=24949882, text='Functional programming appeals to many of us for reasons other than these practical considerations: Functional programming feels like reasoning in algebra. As in Modern Algebra for math majors (groups, rings, fields) and beyond.<p>There&#x27;s a saying in mathematics that when any field matures it turns into algebra. Life crossed a threshold from chemistry to biology on Earth, and developed exponentially from there. Order in mathematics crosses a similar threshold, as it becomes sufficiently structured to support algebraic reasoning. The subjective experience is like ice melting into a churning liquid, or a land-locked creature learning to fly. Once one has this experience, one cannot imagine thinking any other way. In the case of functional programming, programs written in other languages feel like ad hoc pre-civilization constructions, doing arithmetic by counting pebbles.<p>Advocates of Haskell don&#x27;t tend to express this, because from the outside it can come off like trolling, but this algebraic sense of wonder is at the core of many Haskeller&#x27;s experiences. We all have the example of Lisp in our minds, its &quot;we found God&quot; advocacy did much to hinder its adoption. Nevertheless, understanding this explains much about Haskell. The real point of lazy evaluation is that it best supports this algebraic reasoning, as carbon best supports life. The 47,000 compiler options reflect a primary goal of being a research bed for language constructs derived from mathematical category theory, despite its success as a practical language for those free to choose it.<p>The killer app for Haskell is parallelism. To this day it has the best implementation of parallelism; one can achieve a 7x speedup on 8 cores by adding a handful of lines to a program. This ease is a consequence of the functional model, and of considerable effort by Haskell&#x27;s developers.<p>Idris 2 is itself a joy to learn, if one wants a smaller, cleaner Haskell without the 47,000 compiler options. One gets to learn dependent types. Alas, it doesn&#x27;t offer commercial-grade parallelism.')