Item(by='BlackFly', descendants=None, kids=[25908567], score=None, time=1611565189, title=None, item_type='comment', url=None, parent=25900693, text='Well you have chosen an example that is little more than an API object in the first place.<p><pre><code>    class IdealGas implements EquationOfState {\n        private final double gamma;\n\n       public IdealGas(double gamma) {\n           this.gamma = gamma;\n       }\n\n        public double energyDensity(double pressure, double internalEnergy) {\n            return (1 + gamma) * pressure * internalEnergy;\n       }\n    }\n</code></pre>\nWhy create a separate type over this class which is just a projection of its data? You can just use a JSONObject as the API object. You are already going to need some special tricks to deal with the union with other EquationOfStates on top of some out of band type field to designate which class is to be used.<p>You will have the same sort of boiler plate in either case. Either a `public EquationOfStateData getEOSData()` or a `public JSONObject getJSON()`. In one case you use type safety and the deserializer provides your validation messages but should still do some custom validation on top to handle mismatched unions, in the other case you perform the type check (ordinarily done by using method like `json.getDouble()` and get to give custom messages.<p>Choose your poison, they really aren&#x27;t all that different.')