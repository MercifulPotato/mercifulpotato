Item(by='0xbadcafebee', descendants=None, kids=None, score=None, time=1609286421, title=None, item_type='comment', url=None, parent=25569148, text='Let&#x27;s say you&#x27;re building a home. Foundation is poured and it&#x27;s time to frame it. If you hire some random guys with power tools standing outside a home depot, it&#x27;ll take weeks to months for them to finish, and might well end up crappy. But hire two 55-year-old men with hammers, nails and a single skil-saw, and they can have it up in 3-4 days. Or grab your Amish neighbors and raise a barn in a day.<p>Productivity is not bounded by your access to technology, it&#x27;s bounded by the problem you need to solve and the means you use to solve it.<p><i>&gt; Brooks explicitly dismisses increased computational power as something that will not improve productivity (&quot;Well, how many MIPS can one use fruitfully?&quot;, more on this later), but both storage and CPU power (not to mention network speed and RAM) were sources of accidental complexity so large that they bounded the space of problems Brooks was able to conceive of.</i><p>Yet here in the future, our excess of storage, CPU power and network bandwidth have bounded our ability to be fruitful with them. If you add up the MIPS we use today and compare it to what solutions we&#x27;re implementing with it, we are <i>vastly</i> less productive today. Brooks was right, but in a weird way. There is a bound on programmer productivity, and it is the programmer.<p>In the past, people wouldn&#x27;t have set themselves up to <i>need</i> to collect a billion billion logs to analyze some tiny metric among them. Anyone would&#x27;ve seen that as poor planning and a horrible waste of resources. Why would you bury needles in billions of haystacks, and then need to hastily build a robot that finds needles? Why not just keep the needles in a pile of needles? Do you really even need all those needles?<p><i>&gt; Thinking that the tools you personally use are as good as it gets is an easy trap to fall into.</i><p>This actually seems like a hard trap for most to fall into. Nearly every software engineer I&#x27;ve met either thinks they could make a better tool, or just wants to try for the hell of it. On the other hand, most engineers think that building a better mouse trap will solve all their mouse problems.')