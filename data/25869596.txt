Item(by='raymondh', descendants=None, kids=[25877303], score=None, time=1611303838, title=None, item_type='comment', url=None, parent=25862960, text='Not really.<p>Python&#x27;s lambda does pretty much what you would expect from Scheme.  It creates a callable the binds arguments to parameters in a lexically scoped namespace and then evaluates the body of the lambda in that namespace.  And with an open parenthesis, you can write multiline lambdas and indent it however you want.<p>All the usual wizardry is possible:<p><pre><code>  &gt;&gt;&gt; (\n      lambda n: (lambda fact: fact(n, fact))(\n          lambda n, inner: 1 if n == 0 else (n * inner(n - 1, inner))\n      )\n  )(5)\n  120 \n</code></pre>\nAlso, Python has rough equivalents to some special forms in Scheme:<p><pre><code>  (if testexp posexp negexp)  ⟶  (posexp if testexp else negexp)\n  (cond (p1 e1) (p2 e2) (else e3)  ⟶  (e1 if p1 else e2 if p2 else e2)\n  (begin e1 e2 e2)  ⟶  [e1, e2, e3][-1]\n  (and e1 e2 e3)  ⟶  (e1 and e2 and e3)\n  (or e1 e2 e2)  ⟶  (e1 or e2 or e3)\n</code></pre>\nSome statements do have a functional form but aren&#x27;t well known:<p><pre><code>  class keyword  ⟶ type(name, bases, namespace)\n  import keyword ⟶ __import__(name, globals, locals, fromlist)\n</code></pre>\nYou have <i>map()</i>, <i>filter()</i>, <i>partial()</i>, and <i>reduce()</i>.  The <i>operator</i> module provides function equivalents for most operators.  Also, the <i>itertools</i> were directly based on their equivalents in functional languages or array manipulation languages.<p>That said, Python does lack some essential tooling that you would really miss:<p><pre><code>  - There is no way to create new special forms.\n  - Some important special forms are missing: let, let*, and letrec\n  - The language spec precludes tail call optimization.\n  - Some Python statements lack functional equivalents: try&#x2F;except, with-statement, and assert-statement</code></pre>')