Item(by='adamretter', descendants=None, kids=[24867136, 24868025, 24867220, 24869889], score=None, time=1603440376, title=None, item_type='comment', url=None, parent=24863352, text='The author is obviously technically capable, but makes some ridiculous&#x2F;ignorant claims about XML and Character Encoding.<p>Anyone who works with texts today as a programmer who doesn&#x27;t understand the basics of character encoding is likely in trouble, I find it quite ignorant to claim &quot;Only 90s Kids Will Remember&quot;.<p>Also, most modern XML parser will handle&#x2F;detect the correct encoding for you, so whilst you should understand character encoding, you don&#x27;t need to do the heavy lifting yourself.<p>There are also inaccuracies in this article, the author says:\n&quot;Instead, we’ll use a streaming approach (the XML folks call this “SAX”, for reasons I didn’t care enough to research).&quot;<p>Erm... actually there are multiple streaming approaches available. SAX is just one of them (which was pioneered in Java).<p>The author also says:\n&quot;I decided to go with the quick-xml library because it had good documentation, good performance, and roughly the API I was looking for.&quot;<p>Erm... but... quick-xml provides a StAX like API, NOT a SAX API. The former is pull and the latter is push; quite different things, with different performance characteristics depending on your needs.<p>I guess when everything looks like a nail to the author they reach for the rusty hammer. The amount of time and code they put into solving their problem in a limited way is rather staggering.<p>I would have suggested using - the correct tool for the correct job! If you have a small amount of XML (38GB isn&#x27;t big these days), then work with it as XML.<p>Alternative options would have been to:\n1. Load the XML document into a Native XML Database, which takes all of about 10 minutes whilst you make a cup of Tea. There are several Open Source ones if that&#x27;s a requirement for you. Write probably less than 10 lines of query, and voila you have your CSV.\n2. XSLT 3.0 has a streaming mode. You could write a small amount of XSLT 3.0, execute it using an Open Source processor from the command line (e.g. Saxon), and voila you have your CSV.\n3. If you wanted to go really fast, and can spare a few dollars, they could have rented a cloud instance with more than enough memory for 1 hour, stuck it all in RAM and processed it quickly using whatever temporary scripting language they liked...<p>If there was an article down-vote button, I would be using it!')