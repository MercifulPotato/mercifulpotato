Item(by='User23', descendants=None, kids=[24972453], score=None, time=1604336674, title=None, item_type='comment', url=None, parent=24969910, text='&gt; I can show you why there are good reasons to doubt the programmer&#x27;s ability to reason about a large program in light of computational complexity results accumulated in the last twenty years (and you are simply wrong about the bearings of model checking to the situation)<p>OK. Show me.<p>This is why it&#x27;s important to write the specification with an eye toward keeping the implementation manageable. This is probably a drawback of using a tool like TLA+ to check a specification. The tool makes it relatively easy to write a terribly structured specification, check it with TLA+ and declare victory, and leave the programmer in a hopeless situation. A well designed specification will unsurprisingly mirror well designed code[1]. What I have <i>empirically</i> tested is that keeping my functions&#x2F;methods simple enough to be easily specified also keeps them easy to formally derive correct program text for. The problem of composition is treated entirely separately. You don&#x27;t need to understand the fully concatenated predicate transformers for each function&#x2F;method, you just need to know what wp (or another appropriate predicate transformer) is for each and be sure to satisfy it.<p>&gt; What exactly have you done for over a decade?<p>Please understand this is a greatly abridged response. My general habit is to look at the requirements and infer the implied specification since a formal specification is sadly almost always missing. Thankfully most business code is theoretically trivial so postulating a reasonable specification from the requirements is easy. So, I then document my assumptions about what I believe the customer is actually asking for formally. Before I write code I think about the postcondition that I want that code to establish and determine what preconditions, if any, must hold. I put this as comments in the test modules. Then I do a more or less standard TDD approach, with the tests trivially derived from the specification[2], because management likes tests and they&#x27;re paying the bills. Then I derive the code to make the tests pass from the specification using predicate transformers from the precondition to the desired postcondition. And then I run the tests and move on to the next properly isolated concern.<p>Obviously no human discipline is infallible and I still make mistakes, but I make far fewer mistakes than I would using the typical sloppy approach most programmers use. One time I got chewed out by my manager for allowing one bug to make it into production in nine months, because I had raised expectations of the quality of my code so high. And by the way I&#x27;ve always just presented my methodology as TDD because of the mathematical phobia that&#x27;s so prevalent in American industry. If I tell management that this code is easy to maintain, you just need programmers proficient in the predicate calculus they will dismiss me. If on the other hand I say look I have well over 90% branch coverage I&#x27;ll get an attaboy and management will be happy.<p>By this time I hope it&#x27;s clear that my thoughts on the subject were not formed in the lab, but at a Big Tech Company You&#x27;ve Definitely Heard Of. I hope we can agree that the general tendency in industry to ignore or even deride what computing science can teach us is unfortunate.<p>&gt; formally (which means mechanically checkable, even if it is human directed)<p>Dubious[3]. A mathematical formalism does not require algorithmic automated checking to exist. And even if said checking is decidable, which it mostly isn&#x27;t, it may not run in a practical time on any possible mechanical computer we can conceivably build. However if you mean like any other formal mathematics where &quot;the symbols do the work&quot; so long as you follow the appropriate rules of derivation then I am in complete agreement.<p>[1] Proper separation of concerns and such.<p>[2] Obviously no tests are going to exhaustively check a non-trivial specification, but my approach is still strictly better than the typical practice of primarily optimizing for satisfying coverage tools.<p>[3] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Formalism_(philosophy_of_mathematics)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Formalism_(philosophy_of_mathe...</a>')