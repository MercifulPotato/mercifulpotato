Item(by='MaulingMonkey', descendants=None, kids=None, score=None, time=1605006757, title=None, item_type='comment', url=None, parent=25043948, text='&gt; I don&#x27;t share the same experience.<p>You can say that again!<p>&gt; If you get a ctd, usually a callstack and a bit of thought is enough for figuring out what is going on.<p><i>Very</i> different experiences.  Sometimes that happens.<p>Sometimes the symbols have been evicted from the symbol server.  Sometimes the minidump didn&#x27;t capture relevant memory (and the full dump would be a couple dozen gigs, making external QA reluctant to constantly capture those).  Sometimes the crash is the result of memory corruption from unrelated systems minutes ago that doesn&#x27;t reproduce when you enable any of your debug allocators because reproing relies on pointer reuse in a hashtable.  Frequently custom allocators defeat tools like valgrind and address sanitizer, requiring extra work to either bypass or explicitly annotate valid&#x2F;invalid memory ranges.  Sometimes the process only exit(3)s (technically not even a crash!) from an unrelated thread on a specific bit of UI with no relevant callstacks nor logging, and if you open up the windows charm bar for more than 10 seconds without a debugger attached, and you resort to bisecting p4 history once you&#x27;ve spent the several days even figuring out repo steps.<p>That wasn&#x27;t even our bug, but it was our workaround... even when the codebase is good, the middleware often isn&#x27;t!  And that is but one of many I&#x27;ve had to deal with.<p>&gt; C++ is relatively safe when you have well designed systems where ownership is clear enough.<p>Meanwhile, the poster I was originally replying was pointing out that you can have unclear object ownership full of globals and C++ is somehow supposedly good at dealing with this.  Hopefully you&#x27;re at least agreeing with me here, in disagreeing with that!  :)<p>A lot of gamedev code isn&#x27;t very well designed, IME, and &quot;relatively&quot; safe can be suprisingly unsafe as well.<p>&gt; I have a feeling that if my company suddenly flipped to Rust now, the struggling against borrow checker would be a bigger time sink<p>The first couple months after I picked up Rust, I had that phase.  Now it&#x27;s quite easy for me - sometimes it requires a deep `.clone()` or two, but in the equivalent C++ codebase you wouldn&#x27;t have even <i>dreamed</i> of not making the deep copy - because in equivalent C++ code it&#x27;d be impossible to do the equivalent fancy zero-copy borrowing nonsense even remotely safely.')