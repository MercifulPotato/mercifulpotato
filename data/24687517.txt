Item(by='dathinab', descendants=None, kids=None, score=None, time=1601904231, title=None, item_type='comment', url=None, parent=24687406, text='Lets say you have a language which has some form of macro system or similar to make creation of new thinks which look like literal-like expression easier.<p>E.g. instead of `a = [1,2]` you have `a = vec![1,2]` which de-sugars to `a = Vec::with_capacity(2); a.push(1); a.push(2);`.<p>Now custom data structures can define their own macros like that, e.g. `skip_list![1,2]`.<p>Which would be all fine. But what if now `bad_skip_list![1,2]` accesses a thread local variable (or other implicit provided data) and adds that, too?<p>Now `bad_skip_list![1,2]` might be not equal to `bad_skip_list![1,2]` defined somewhere else. Which is against the ideas behind the rule #5.<p>You should be able to copy-past the literal-like creation of data to any place (e.g. a unit-test) and get the same result.<p>EDIT: If I remember correctly you could override parts of `Array.prototype` and array construction in JavaScript to brake the #5 for JavaScript for thinks like `[1,2,3]` but I&#x27;m not to sure about that anymore.')