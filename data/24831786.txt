Item(by='nendroid', descendants=None, kids=[24832120], score=None, time=1603146913, title=None, item_type='comment', url=None, parent=24831312, text='&gt;You seem to think that FP is the one right answer. You are mistaken. There are places where it&#x27;s the right answer, or at least a very good one - the best definition I&#x27;ve seen is when your program looks like a pipe.<p>All programs are pipes from IO to IO or from one state to another state. Purity lives in the pipes, impurity lives in the IO nodes between the pipes. The goal is to keep the impurity as small as possible and have most of your logic live in the pipe, as combinators are the most composeable primitive. I also never said FP is the one right answer. Most programs need to modify state. In FP everything is immutable so your program cannot be pure FP in most cases. What I am saying is to segregate state and IO from logic. Example:<p><pre><code>    void addOneToState()\n</code></pre>\ncan be broken down into<p><pre><code>    int addNTo(int n, int m)\n\n    void changeStateTo(int x)\n</code></pre>\nI have split the code above into a method that is devoid of logic and only updates state and logic that lives as a stateless combinator. All programs are made from a series of pipes and tubes. You just need to find the pipe and modularize it and seperate it from the parts that can&#x27;t be pipes.<p>&gt;At that point, bundling the data to the functions is warranted.<p>It&#x27;s never warranted. There is no benefit. Whether you couple it or uncouple it from data the logic still exists, the only difference is coupling. Adding coupling does not improve your code in any other way other than adding coupling.<p>&gt;And if you&#x27;re going to say &quot;don&#x27;t structure the data that way&quot;, well, there are times when that&#x27;s the nature of the problem, not just the nature of the program to solve the problem.<p>There is no data structure that has to be coupled with logic. However you structure your data it can always be decoupled from logic. Always.<p>&gt;where your program has state, and there are multiple parts to the state, and those parts have to be kept in sync with each other.<p>This doesn&#x27;t change anything.<p><pre><code>   State makeNewState (State oldState) {\n        newY = addNTo(oldState.y, 1)\n        return New State {\n              x = oldState.x\n              y = newY\n              somethingToBeInSyncTo = newY\n        }\n   }\n\n   void updateState(State x)\n</code></pre>\ny is still in sync with somethingToBeInSyncTo.')