Item(by='byko3y', descendants=None, kids=None, score=None, time=1603323701, title=None, item_type='comment', url=None, parent=24839663, text='Frankly speaking, I had this impression too. The reason why JVM and JS uses own bytecode for implementing JIT-compilation is because main means of optimization are inlining and vector scalarization (convert complex object to simple ones). E.g. you have a container that hold integer and does nothing else, thus when JIT-compiling you can skip the whole boxing&#x2F;unboxing and manipulate a single integer value stored in register. However, you cannot do that in a simple ways if your integer container is a C extension black box — you cannot &quot;inline&quot; the container&#x27;s functions and reduce its store-loads.<p>This is why PyPy reimplements standard library in RPython — so you can JIT-optimize it. But it feels like Mark Shannon knows nothing about these efforts — which is kinda strange considering his position of core CPython developer.<p>&gt;There are other lower hanging fruits, like optimizing core data structures (e.g: the implementation of python dicts)<p>Unfortunately, you cannot easily implement efficient data containers without rewriting existent python code. The latter one relies heavily on dictionary-based access to pretty much everything, and you cannot easily convert &quot;string hash&quot; access into &quot;record offset&quot; access, because you cannot know a priori what object has what structure and converting hash into offset is basically the same dictionary lookup. For example:<p>a = A()\na.field = varname + 1<p>What can you optimize here? What &quot;varname&quot; is? What A&#x27;s structure is? Is &quot;A&quot; a class or a function? Not only you are unable tell the semantic of the code just by looking at the code — you can&#x27;t even tell the semantic after you&#x27;ve examined the &quot;A&quot; and &quot;varname&quot; on some previous iteration, because somebody might&#x27;ve declared&#x2F;modified those on outer scope or directly modified &quot;A&quot; or &quot;varname&quot;.<p>Last year in my spare time I&#x27;ve been working on an unpublished library for python multitasking with shared memory structures (probably will make some blog post in few weeks and link it here), and I also encountered the problem of inherently inefficient implementation of python basic types. However, I&#x27;m yet to find the solution without breaking compatibility with existing code. For example, if you look at ctypes, they have some very efficient containers, but using them in a regular python code is a pain, and the c-python interface eats most performance benefits of efficient containers.<p>So what&#x27;s really needed for optimization of python is some kind of python subset, like RPython but probably more human-friendly, so efficient containers can really become efficient while automatic optimizer can select or create automatically those efficient containers. Just like V8 JS engine does, which stores objects in records with static structure. It happens to works in JS for most cases. Countrary, in Python it does not work for most cases, that&#x27;s why we have so much struggle optimizing the Python.')