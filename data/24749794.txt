Item(by='ddragon', descendants=None, kids=None, score=None, time=1602456593, title=None, item_type='comment', url=None, parent=24749198, text='I&#x27;ll have to disagree with your defeatist generalization here: creating something with better knowledge of the problem and a lot of hindsight will not necessarily get as complicated for the same feature set. In fact the resets are probably necessary so you can get to even higher feature sets before getting so obtuse that it&#x27;s a pain to move another step.<p>Julia doesn&#x27;t even need full parity with numpy because you can trivially write your needs in straightforward Julia (in fact Julia does not have numpy, only Julia arrays). And Pytorch equivalent? Also uses Julia arrays and straightforward methods (as you can just differentiate Julia code directly). Pandas equivalent? It&#x27;s a wrapper over Julia arrays. Need named tensors? Just pick another wrapper over Julia arrays and it will work on Julia&#x27;s Pytorch equivalent without changing anything.<p>I do have to deal with Jupyter Notebooks, but they do have a lot of &quot;real pain points&quot; as well (it&#x27;s always a pain when a data scientist gives one to add for deployment, half the time it does not work because it does not keep track of the whole execution history and need a major rewrite), but the main issue is the disconnect between the exploratory code and the production code. Julia&#x27;s workflow (Revise + REPL) means I still write the structured code as usual, but every change in the code reflects in the REPL, like I&#x27;m interacting with the production code directly (and the Julia language supports a lot of commands to interface with the compiler, from finding source code to dumping the full structure of any object and even all types inferred). And of course, Julia also has Jupyter in the first place as it&#x27;s name suggests, and a very cool alternative for some workflows like Pluto.jl that improves on reproducibility).<p>You might also want to try Erlang&#x2F;Elixir, it&#x27;s really amazing how you can trivially spawn hundreds of thousands  of tasks that are incredibly robust even though it&#x27;s a dynamic language (since you add not only tasks to do something but also to monitor and handle errors). And you can even connect and hot swap parts of the application live (as an example of superior interactivity).<p>I&#x27;m not saying that Python is not good, it wouldn&#x27;t get where it is if it weren&#x27;t. I&#x27;m saying that things can be way better, and we already have examples of it in most particular areas, but none that covers all of Python&#x27;s strengths, which is why it will still be king for the foreseeable future. But I can only hope that we will get better and better tools to tackle more and more complex problems in the most simple and optimal way that we can given all that we learned as a community.')