Item(by='kakwa_', descendants=None, kids=None, score=None, time=1607986492, title=None, item_type='comment', url=None, parent=25424042, text='It&#x27;s far less extensive than what you presented, but on the current project we are working on at work, we are using <a href="https:&#x2F;&#x2F;github.com&#x2F;swaggo&#x2F;swag" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;swaggo&#x2F;swag</a><p>It&#x27;s somewhat specific to golang but so far it has been relatively good for us.<p>The spec is directly next to the code as code comments, so it has far more chances to get updated when changes are made compared to an external documentation.<p>Also, the payloads and responses are directly derived from the Golang structs, so, at least on that aspect, changes in the code are automatically reflected in the spec (apart for description and examples).<p>We also put the interactive documentation directly in our API under &#x2F;doc. It is a useful tool for developers when implementing a new url&#x2F;handler or modifying an existing one. It also creates incentives to keep the documentation matching.<p>Overall, we had very few mismatches between the spec and the actual implementation overall, despite not having deeply tested it (be it manually or automatically). Apart from one or two mismatches that were fixed quickly, I was able to take the spec, generate client libraries from it (swagger-codegen), and use them for quite extensive demos without issues.<p>We are still early in the project (not in production yet), and there are definitely some aspects we need to improve (integration&#x2F;automated tests to be sure doc and code are 100% matching) or to completely figure out (ex: how to handle several versions of the same API). But overall, using swaggo&#x2F;swag has been a pleasant experience.')