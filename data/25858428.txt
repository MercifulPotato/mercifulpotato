Item(by='lifthrasiir', descendants=None, kids=[25858745], score=None, time=1611234552, title=None, item_type='comment', url=None, parent=25858047, text='No, you are creating a literal type which is <i>not</i> same to the corresponding literal. This is evident when you try to use alen and blen (respectively named n and m in your code) in the function code: they are strictly type-level constructs.<p>Also, probably I should have written my example as follows:<p><pre><code>    function concat(\n        alen: number,\n        blen: number,\n        a: ArrayOfLength&lt;alen&gt;,\n        b: ArrayOfLength&lt;blen&gt;,\n    ): ArrayOfLength&lt;alen + blen&gt; {\n        return [...a, ...b];\n    }\n</code></pre>\nMy original code did distinguish two sets of arguments because that&#x27;s the TypeScript syntax closest to currying (and I was lazy to check its implication), but the point of dependent typing is that <i>alen and blen are not necessarily known to the compiler</i>. The compiler may have to deal with the following code then:<p><pre><code>    let abc = concat(a, concat(b, c));\n    abc = concat(concat(a, b), c);\n</code></pre>\n...where the first type `ArrayOfLength&lt;alen + (blen + clen)&gt;` should equal to the second type `ArrayOfLength&lt;(alen + blen) + clen&gt;` for the assignment to be valid. Since the compiler doesn&#x27;t know alen, blen or clen, this means the compiler needs to somehow understand the associativity! This is hard, considering that (a+b)+c is not even generally same to a+(b+c) thanks to floating point.<p>For this reason many dependently typed languages also act as proof assistants or verifiers. If this point is removed, so-called &quot;const generics&quot; will be classified as dependently typed.')