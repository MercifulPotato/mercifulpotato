Item(by='mumblemumble', descendants=None, kids=None, score=None, time=1604498727, title=None, item_type='comment', url=None, parent=24988271, text='I tend to agree, but, even then, one doesn&#x27;t necessarily have to take things quite as far as Haskell does.<p>In Rust, for example, mutable data is allowed, but, when the owner of mutable data shares a reference to it, it gets to decide whether the borrower is also allowed to mutate the data. This doesn&#x27;t eliminate the more challenging things you can do with shared mutable variables, but it does mean that enabling them requires mutual consent.<p>Nim does an interesting thing, too. It has a two-color function mechanism where &quot;procedures&quot; are allowed to have side effects, and &quot;functions&quot; are not. But even functions are allowed to use mutable variables behind closed doors. That can arguably be an ergonomic win. Many people find that, within a sufficiently bounded context, an implementation that uses mutable variables might be more maintainable than a purely functional implementation.<p>The main reason Haskell goes even further, and bans mutable variables from the insides of functions as well, was never really about maintainability, per se. It was done that way because Haskell, as a lazy language, couldn&#x27;t allow anything that might require statements to be evaluated in a particular order. That design decision turned out to lead to an impressive bounty of interesting and useful discoveries. But there also seems to be something of a tendency to swaddle the bathwater with the baby.')