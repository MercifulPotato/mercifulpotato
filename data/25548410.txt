Item(by='chrismorgan', descendants=None, kids=None, score=None, time=1609037713, title=None, item_type='comment', url=None, parent=25547716, text='Sometimes you want a cursor so you can resume where you left off without worrying about new entries that may have come in which would otherwise mess up your pagination.<p>Sometimes you want position-based queries, because you explicitly <i>do</i> want everything to be positional.<p>Sometimes you want to combine the two techniques, e.g. if you jump to the middle of a large, ever-changing list, and then want to retrieve the next batch of results after wherever you happen to be.<p>I like the design that JMAP ended up with &lt;<a href="https:&#x2F;&#x2F;tools.ietf.org&#x2F;html&#x2F;rfc8620#page-45" rel="nofollow">https:&#x2F;&#x2F;tools.ietf.org&#x2F;html&#x2F;rfc8620#page-45</a>&gt;: you can specify a <i>position</i> integer, or an <i>anchor</i> ID and optionally an <i>anchorOffset</i> integer. An anchor is a restricted case of a cursor, being the ID of an entity in the result set rather than an opaque type that could embed other information (such as coroutine addresses, thinking back to the old days of HN), but has the notable advantage of being client-controllable.<p>(Because JMAP is very much an object synchronisation protocol and not just an API for objects that don’t record their history in any way, like your common-or-garden REST API, this is also paired with change tracking so that you can be notified when the set of entities matching the query changes; this is how Fastmail’s webmail (probably the most-used JMAP client for now) updates its message lists for mailboxes (roughly `Email&#x2F;query { filter: { inMailbox: <i>inbox</i> } }`) and search results (roughly `Email&#x2F;query { filter: { text: &quot;foo&quot; } }`). Such a principled approach to changing state is extremely valuable for supporting live updating of a UI, and pretty much essential for offline support.)')