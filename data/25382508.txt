Item(by='mmalone', descendants=None, kids=[25383205], score=None, time=1607663164, title=None, item_type='comment', url=None, parent=25380301, text='Appreciate the thoughtful response!<p>Reading it over, I think we mostly agree on the facts. It&#x27;s easy to do mTLS and x509 wrong. The question, then, is what&#x27;s easier &#x2F; more secure: doing mTLS&#x2F;x509 right or doing something else? I think that&#x27;s somewhat subjective: it depends on your requirements, your environment, and your skillset.<p>One point that I&#x27;d like to reiterate is this: if you want a consistent cryptographic solution that works everywhere, TLS is pretty much your only choice. You could use something else for client authentication, but you probably still need TLS.<p>As a strawman, here&#x27;s a sketch of how I&#x27;d recommend doing TLS in a microservice system. I consider this &quot;right&quot; for most garden-variety microservices-in-cloud scenarios and don&#x27;t think it&#x27;s particularly hard to do. Most of this is already implemented in <a href="https:&#x2F;&#x2F;github.com&#x2F;smallstep&#x2F;certificates" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;smallstep&#x2F;certificates</a>:<p><pre><code>  * Deploy the root cert via automation (so it&#x27;s quickly rotatable) and&#x2F;or keep it in a managed HSM&#x2F;KMS. You might harden root rotation a bit by signing your new root with your old root. But, generally, trust config management or container orchestration to push root(s) (you already trust it to push code and secrets). Root rotation (and, thus, bulk revocation) is now as fast as secret rotation (secrets are generally pushed the same way).\n\n  * Issue short-lived certificates per logical entity. If it gets a box and a name in your architecture diagram, it should get an identity and each instance should get a certificate. Use domain names and email addresses that you control for names. Keep certs simple: one SAN. Certificates bind a name to a public key. That&#x27;s it.\n\n  * Automate certificate issuance. ACME can work for this, but there are other options (single-use tokens issued by config management, cloud-managed instance identity documents or service accounts, an existing device certificate issued by a manufacturer, etc.)\n\n  * Automate certificate renewal. A simple mTLS HTTPS request works for this. This is easy to implement and easy to scale out with multiple intermediates. &quot;Revoking&quot; a certificate just marks it as &quot;not renewable&quot;. To reduce risk of outage, in this architecture, it&#x27;s safe to renew an expired certificate as long as it&#x27;s not revoked (ACME-STAR basically does this, but it&#x27;s push instead of pull).\n\n  * If you really need active revocation, fine. One good solution is to push CRL to a cloud storage bucket. Short-lived certs will keep your CRLs small. If you need to do a mass rotation, rotate roots (push new root, wait for rotation, pull old root).\n\n  * Use secure NTP for time.\n\n  * Index issued certificates. CT (trillian) is cool if you want to be fancy. Your existing database or SIEM also works. zcertificate can parse x509 and output a JSON representation of a certificate that you can map to something like an Elastic Search schema: https:&#x2F;&#x2F;github.com&#x2F;zmap&#x2F;zcertificate\n</code></pre>\nI want to respond specifically to your first and final points.<p>On your first point: I understand that in theory an attacker could slip a request across a secure channel, and binding authentication to a request could in theory prevent that. I don&#x27;t understand how that&#x27;s likely to happen in the context I&#x27;m thinking of here. Which may be different than the context you&#x27;re thinking of. So let me clarify.<p>Suppose I have `&lt;end-user&gt; -&gt; &lt;service-a&gt; -&gt; &lt;service-b&gt; -&gt; &lt;database&gt;`. Let&#x27;s focus on `&lt;service-a&gt; -&gt; &lt;service-b&gt;`. I don&#x27;t see how using end-to-end mTLS, terminating in `&lt;service-a&gt;` and `&lt;service-b&gt;` application code, would be any more vulnerable to this variety of attack than an HTTP Basic header like `Authorization: Basic base64(service-a:password)`. Surely, the logic in `&lt;service-a&gt;` is simply &quot;insert HTTP Basic header into requests on their way out to `&lt;service-b&gt;`&quot;. It doesn&#x27;t matter if we&#x27;re authenticating the request or the channel. If you&#x27;re able to smuggle something malicious into that request, it&#x27;s gonna get sent over to `&lt;service-b&gt;` with proper authentication attached.<p>Are we talking past one another? Are you trying to make `&lt;end-user&gt;`&#x27;s authenticated identity carry through `&lt;service-a&gt;` to `&lt;service-b&gt;`? If that&#x27;s the case, then yes: I see what you&#x27;re saying and you shouldn&#x27;t use mTLS for that. I&#x27;m not sure if there&#x27;s a term-of-art here, but I call this &quot;end user identity propagation&quot;. You need something like a top-of-stack ticket service (a bearer token) for that. Or, better yet, macaroons. I consider those two separate things, though. mTLS is for authenticating your immediate peer. For end-user identity propagation mTLS is a poor choice.<p>On your final point: you could, in theory, express claims in x509. I&#x27;m sure you&#x27;re aware, but it&#x27;s been tried before (e.g., SPKI&#x2F;SDSI). However, I agree that, unless you <i>really</i> know what you&#x27;re doing, x509 is too complicated for that. Don&#x27;t do it. You&#x27;ll likely screw it up. If you&#x27;re parsing x509 and ASN.1, you&#x27;re doing it wrong. If you&#x27;re <i>processing strings</i> that you&#x27;ve <i>extracted</i> from a certificate, and you&#x27;re not in the habit of writing your own formal languages, you&#x27;re definitely doing it wrong. Just put a flat name in a SAN. The only thing you should ever need to do with that string is an exact string comparison. If you need to know roles or groups or some other metadata look them up in a database.<p>(Or use macaroons)')