Item(by='ragnese', descendants=None, kids=[25303214], score=None, time=1607092860, title=None, item_type='comment', url=None, parent=25301449, text='You&#x27;re getting downvoted because of your snarky opening statement.<p>But I do think it&#x27;s important&#x2F;relevant to compare virtual threads to Kotlin coroutines.<p>I agree with your point that tacking all of this onto the existing (flawed) Thread API is a risky move. I understand the reasoning on both sides, but I&#x27;m not usually a huge &quot;backwards compatible at all costs&quot; or &quot;don&#x27;t make people learn new things&quot; proponent on anything. So that&#x27;s my bias.<p>I think you&#x27;re painting the `suspend` keyword a bit rosy, though. The fact that Kotlin has colored functions is a huge pain in the ass. You have to design different APIs sometimes to account for a &quot;suspend version&quot; and a &quot;non-suspend version&quot;.<p>The idea with Loom (like goroutines, which is the first green thread model I&#x27;ve used) is that async stuff is so cheap that you can almost pretend it doesn&#x27;t even matter if something calls a coroutine. I&#x27;m not sure if that&#x27;s the <i>best</i> solution, though. One advantage that colored functions do have is that you see it and &quot;know&quot; that the thing involves expensive and&#x2F;or blocking work. With coroutines, how do you know if calling a function will slow your current thread down as it waits for the results? That&#x27;s a question we could ask Go devs today, I suppose.<p>I agree with your prediction that Kotlin&#x27;s coroutines might just sit on top of virtual threads on the JVM in the future.')