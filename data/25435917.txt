Item(by='tsimionescu', descendants=None, kids=None, score=None, time=1608070374, title=None, item_type='comment', url=None, parent=25429026, text='You&#x27;re right, and the optimization wouldn&#x27;t have kicked in in the original example if p and q had been pointers to elements of the same array.<p>However, if they are pointers to different local variables, the compiler knows something else: it knows that p and q do not alias each other, so writes to p can&#x27;t change the value pointed by q and vice versa.<p>Now, in the original code, there seems to be a write to a pointer casted from an integer, which would be allowed to alias any other pointer - so after the <i>(int</i>)ip = 10 write, both p&#x27;s and q&#x27;s value would normally have to be assumed to be potentially changed.<p>However, step 2 in the optimizations has removed this information - by replacing the integer pointer with a write to the p pointer, it has again enabled the compiler to reason that no (valid) writes to q have been performed, so q&#x27;s vue can&#x27;t have changed.<p>Note that the intermediate program after optimization 2 would have UB if written directly in C, since dereferencing one-past-the-end pointers is UB (creating them, comparing them, or casting them to uintptr_t is valid behavior, however).<p>Instead, if p and q pointed into the same object, such as an array, p+1 could very well be an alias for q, so there would be no way to prove that q&#x27;s value hasn&#x27;t changed.<p>What the article is getting at is that the compiler is relying on the origin of the pointers to allow it to make optimization 3 (it knows p+1 is a pointer to a local variable, q is a pointer to a different local variable, so they can&#x27;t be aliased) ; but it previously optimized away a code change that is supposed to destroy this provenance information - a pointer-from-integer is allowed to alias any pointer in the whole program (if we ignore restrict&#x2F;noalias).')