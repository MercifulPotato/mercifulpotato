Item(by='cosmie', descendants=None, kids=None, score=None, time=1603471493, title=None, item_type='comment', url=None, parent=24867057, text='Also for those who didn&#x27;t know, and are just getting started with them:<p>They&#x27;re incredibly handy for a variety of reasons, but can also have unexpected performance impacts. For example, here are functionally equivalent queries written with a CTE vs an inlined&#x2F;derived table:<p><pre><code>  WITH cte_foo AS \n  (SELECT * FROM bar LIMIT 1000000)\n  SELECT * FROM cte_foo LIMIT 1\n</code></pre>\nand<p><pre><code>  SELECT * FROM \n  (SELECT * FROM bar LIMIT 1000000) \n  as inlined_foo LIMIT 1\n</code></pre>\nDepending on the database you&#x27;re using, those two could have wildly different performance due to a concept called an optimization fence[1]. In Postgres versions 11 and below, the CTE would have truly returned&#x2F;materialized 1 million rows, <i>then</i> the outer query would execute and ultimately return 1 row for the resultset. Whereas the second version would have been optimized such that the outer <i>LIMIT 1</i> would have been pushed into the subquery and not materialized those extraneous 999,999 rows to begin with.<p>As mentioned in [1], Postgres 12 (and 13) have started to tackle that optimization fence within Postgres. But it&#x27;s still a concern&#x2F;concept to be aware of, since many databases that support CTEs have varying levels of optimization fences, and you&#x27;ll want to be sure you understand what optimization&#x2F;performance impacts exist for your particular database before you go down the CTE path.<p>[1] <a href="https:&#x2F;&#x2F;auto1.tech&#x2F;postgres12-a-precious-release&#x2F;" rel="nofollow">https:&#x2F;&#x2F;auto1.tech&#x2F;postgres12-a-precious-release&#x2F;</a>')