Item(by='ben509', descendants=None, kids=[24852275, 24852910, 24852758], score=None, time=1603313973, title=None, item_type='comment', url=None, parent=24837898, text='&gt; Why simpler is better and why you don&#x27;t need a parser generator.<p>As far as I can see, this isn&#x27;t fully answered, unless the claim is strictly limited to the question of need.<p>In my case, I certainly <i>want</i> a parser generator. I&#x27;m working on a language, and I did a very early version using a hand-rolled recursive descent parser.<p>Then I realized I wanted a syntax that was human friendly, so I graduated to megaparsec. That worked, it&#x27;s an elegant way to describe a parser, but as a language gets complex you have to work in implicit orderings (magic, frankly) to handle the limits of recursive descent.<p>Finally, I realized I needed a spec and an implementation in sync with that spec, so I went with BNFC[2], and it even generates some pretty documentation[1] for me.<p>This is the classic debate over using a domain specific language vs. a general purpose language, so there&#x27;s no hard answer one way or the other. For me, the deciding factor was I didn&#x27;t want to write, test, etc. my own parser, and I think there being a canonical way for others to parse my language (in other languages as well) is helpful.<p>[1]: <a href="https:&#x2F;&#x2F;tenet-lang.org&#x2F;spec-syn.html" rel="nofollow">https:&#x2F;&#x2F;tenet-lang.org&#x2F;spec-syn.html</a><p>[2]: <a href="https:&#x2F;&#x2F;bnfc.digitalgrammars.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bnfc.digitalgrammars.com&#x2F;</a>')