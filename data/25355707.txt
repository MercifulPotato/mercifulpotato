Item(by='stevefan1999', descendants=None, kids=None, score=None, time=1607492279, title=None, item_type='comment', url=None, parent=25350429, text='if we extend the value to (value, is_null: bit&lt;1&gt;) we can have operated on the value field directly while also knowing whether the value is loaded or not. but you are right, maybe the compiler will outright &quot;optimize&quot; this to (value: align_pow2(sizeof T), is_null: byte) since the compiler will have to align value anyway, so that it will always have to expand the &quot;sentinel&quot;.<p>My original idea exactly contrary to your thinking: rather than making 0 NULL and give it the sentinel we always had, why don&#x27;t we just avoid using it like using some data structure magic? You know, the null is infamous for causing the special case in integral constant expression that C++ inherited from C, and is confusing too, because then 0 is can be considered as (void <i>) and thus can cause an overload fiasco, that consider f(void</i>) and f(int), what do you think f(0) would be? So the gist is I always think using x=0 to be able to represent NULL&#x2F;false and !(x=0) to represent true is really really confusing (at least in C&#x2F;C++). This also caused other languages to have some probable cases of negative number being cast to true so like `if (-1) console.log(&#x27;lol&#x27;)` it will print, wat?<p>Also, with my configuration, not only we can always assume the value was intended to have a place to stay without indirection load, but the optional&#x2F;null&#x2F;don&#x27;t-care&#x2F;noninit will always have a stable state between 0 and 1 -- so we can clamp down without having to deal with extra states like I shown above, which is good from theoretical (because we can express its definite intent rather than guessing the type of the wrapped value) &amp; logical standpoint (that we should not think in 3VL for null, rather, judge it by its concrete properties), not quite so in practice however (again, optimization kicks in nullifying all the good works), this might not entirely escape the pointer-not-null-then-consider-valid problem (what if we loaded a garbage value that might have a random 0&#x2F;1? nowhere to tell also).<p>In fact, this kind of configuration is not rare to be found: an open addressing hash table can use this kind of setting to represent &quot;tombstone&quot;&#x2F;deleted field, but in a more optimized manner that we &quot;bit set&quot; because we are going to allocate a contiguous block of memory anyway so like the current universe can have 32 entries then we use lg(32) bytes bit-set at the beginning&#x2F;end, if insert or delete value at entry x then toggle bit-tombstone of x, if search value y then find first i, x in entries if compare(x, y) = exact and !bit-tombstone[i] then (yes, i) else no...so on.<p>But at the end of the day even that I don&#x27;t like using 3VL to represent NULL, and my configuration is still like mapping 3VL into double binary anyway, iirc its like if value = U then don&#x27;t care (either true and false; neither true nor false) else value.<p>An analogy for NULL: if addr = NULL then value is no where to be found&#x2F;random garbage value else load memory from addr.')