Item(by='dpc_pw', descendants=None, kids=[25121055], score=None, time=1605583352, title=None, item_type='comment', url=None, parent=25119609, text='From my experience, the modern Java-style OOP that I&#x27;ve worked with (some of which I produced myself) through all these years leads to terrible code, and all the data-oriented code I&#x27;ve seen and produced seems much, much better in comparison.<p>Other programming styles are often orthogonal. One can have mostly functional OOP and mostly functional data-oriented software, or imperative OOP vs imperative data-oriented software and so on.<p>I&#x27;m mostly focused on OOP vs data-orientation. OOP means a fixation on modeling everything as &quot;a graph of encapsulated objects with associated bits of logic calling each other&quot; while data-orientation means: &quot;pure logic decoupled from data, and a data stored and passed in mostly non-abstract, concrete ways to support required computation&quot;.<p>The success of OOP is dubious: mostly judged by it&#x27;s popularity, which is mostly driven by it being a default methodology tough to people in school. When you look at the actual industry, most of the fundamental, long-lasting software is actually written in some form of data-orientation. From kernels, system tools, things like redis, other databases, etc. Though one could tell that it&#x27;s because fundamental software is usually system software, and not business-logic software and that&#x27;s true.<p>I don&#x27;t have evidence, and it&#x27;s all just my experience, reasoning and intuition, and I&#x27;m intellectually open for debate here, but  IMO fundamentally splitting data into small encapsulated chunk that form  a graph of native references to each other is just a terrible way to organize any form of computation. I don&#x27;t want to repeat myself, so please see my reddit post that I linked before for more details.')