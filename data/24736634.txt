Item(by='Galanwe', descendants=None, kids=[24737021, 24736770, 24736810, 24739306, 24736794, 24736709], score=None, time=1602303081, title=None, item_type='comment', url=None, parent=24736268, text='&gt; In order to support preprocessor macros and C++ templates, referencing a module means recursively &quot;including&quot; a bunch of header files (i.e. reparsing them from scratch), meaning O(n^2) complexity where n is the number of modules. You can speed it up with precompiled headers, but you will still need to separately parse each sequence of references<p>Not sure I really get your point here. Even if you remove macros and templates, reading headers is actually necessary just for the sake of knowing the size of structures, the offsets of attributes, etc.<p>How can _any_ language compile a unit passing a struct Foo on the stack without knowing the size of Foo (and thus having to read, say, foo.h)?<p>Now I agree that if you play with preprocessor to have conditional things in your headers, reparsing will be necessary, but I guess this has been solved by include guards&#x2F;pragma once a long time ago. 99% of preprocessor usage is project wide configuration, so wrapping the whole headers is fine.<p>Not saying this is the best solution, but in practice, that shouldn&#x27;t make much difference.<p>A subtle distinction that can make quite a difference though is to provide independent forward declarations. A lot of times, your compiler will just need to know the symbols and signatures (e.g. When passing by reference), and providing the full structure definition is overkill and slower. I don&#x27;t see enough people taking care to that, which is a pity')