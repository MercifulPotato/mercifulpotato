Item(by='tialaramex', descendants=None, kids=None, score=None, time=1602098969, title=None, item_type='comment', url=None, parent=24711254, text='&gt; I believe TLS 1.3 also had deployment challenges due to middleboxes.<p>There was about one year delay between the point where the protocol was initially &quot;done&quot; and experiments showed it could not be deployed partly because of middleboxes although also due to server intolerance (web servers that go &quot;What? TLS 1.3? No, rather than negotiating TLS 1.2 I&#x27;ll just ignore you and hope you go away you weirdo&quot;) - until the point where the revised TLS 1.3 wire spelling was finished and tested (about six months before it was published as RFC 8446)<p>The core idea in TLS 1.3 as shipped is that the initial setup phase looks outwardly very much like TLS 1.2 resumption. Interpreted as if it was TLS 1.2 the TLS 1.3 client claims to be trying to resume a previous connection, a TLS 1.3 server claims to accept that resumption, but really they actually just agreed a brand new connection. A TLS 1.2 server would see the resumption attempt, but it has no memory of any such prior connection (there wasn&#x27;t one, the &quot;connection ID&quot; is just random bytes) so it offers a new one using TLS 1.2 and everything goes swimmingly.<p>This way of doing things allows TLS 1.3 to be as fast on first connection as TLS 1.2 was on resumption without causing problems with incompatible middleboxes or servers. It does make the &quot;spelling&quot; on the wire pretty weird looking though if you are used to looking at TLS 1.2.<p>The other essential goal was to never back off. A TLS 1.3 client will never go &quot;Huh, TLS 1.3 didn&#x27;t work, let&#x27;s try again with TLS 1.2 instead&quot;. The design means if the remote server can speak TLS 1.2 (or 1.0 or 1.1) it will respond as such to your TLS 1.3 connection. This means adversaries can&#x27;t try to &quot;downgrade&quot; you to a bad older version.')