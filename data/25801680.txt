Item(by='andrewwebber', descendants=None, kids=None, score=None, time=1610798018, title=None, item_type='comment', url=None, parent=25798628, text='After 8 years of writing Golang microservices one observation is comparing the compile times when optimizing for production.<p>A typical Golang CI&#x2F;CD pipeline should \n- compile without CGO enabled and with go build -tags netgo -a -v so that the binary can run on in a minimal docker image like alpine or scratch\n- should be compiled and tested using the race detector\n- should be linted using golanglint-ci<p>All of these flags and linters considerably increase the build time for deployment to production<p>The rust compiler effectively gives me the same outcome using the type system and the compiler advancements when targeting release musl.<p>I have seen many Golang projects where the race detector was skipped because the code base was to large or it was flaky.<p>One the other hand I do miss the code coverage tools. Code coverage for rust seems to only work on Linux')