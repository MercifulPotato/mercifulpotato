Item(by='MauranKilom', descendants=None, kids=[25327972], score=None, time=1607299453, title=None, item_type='comment', url=None, parent=25325426, text='&gt; In the concrete version, the code says that every Zero in the arguments should be un-vanished into 0.0 before doing the calculation; I am assuming that the generic multiply will be monomorphized, the concrete result expressions will be inlined, and constant propagation will turn expressions involving the Zero arguments back into no-ops.<p>Did you actually test whether this happens? If I understand correctly, you want to rely on the optimizer constant-folding multiplications with zero to zero. But strict IEEE floating point conformance notoriously does not allow collapsing multiplication with zero to zero (consider NaNs and infinities), or addition of zero to be a no-op (consider signed zeros).<p>Example:<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;cGv17o" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;cGv17o</a><p>That also affects the overall goal, seeing as the type-level optimizations do assume the above properties. This means that you will get different results in certain edge cases than a &quot;naive&quot; implementation that always stores 16 floating point values for each multivector (and that&#x27;s before getting to things like non-associativity of floating point operations).')