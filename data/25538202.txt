Item(by='triska', descendants=None, kids=[25538404, 25540010], score=None, time=1608921899, title=None, item_type='comment', url=None, parent=25537916, text='The &quot;naive&quot; and straight-forward way to internally represent a non-empty list is to use a structure of the form (CAR . CDR), where car is the first element of the list, and CDR is the rest of the list. So, you need 3 memory &quot;cells&quot; (i.e., pointers, addresses) for each element in the list: First, the indication that this is a structure of this form (a &quot;cons-cell&quot;, in Lisp terminology), then, a pointer to the first element (or that first element itself, if it can be represented in a single tagged cell), and then a pointer to the remainder of the list, which is again of this shape.<p>On 64-bit systems, a cell takes 8 bytes. Therefore, when representing a list of bytes, this representation incurs a 3×8 = <i>24-fold</i> overhead (!) over a plain sequence of bytes in memory. For example, to represent a 1GB file (which is not very large by contemporary standards) in memory, this representation takes 24GB, which is unacceptable. There are ways to compress this slightly (by &quot;slightly&quot;, I mean a small factor, such as a factor of 2), but the fundamental problem remains: Instead of using bytes directly, this representation uses one cell per byte, which is an 8-fold overhead.<p>This is an overarching issue in all languages that represent strings as lists (lists of characters, or lists of integers), such as Erlang, Haskell and Prolog. At the same time, lists – especially lists of characters – are the desired representation we want to use in programs in these languages, because it means that the built-in functionality for reasoning about lists becomes directly available for strings too, and it helps to keep the number of language concepts small.<p>So, how to solve it? Ideally, certainly <i>not</i> by adding another data type to the language (&quot;binary object&quot;, &quot;binary string&quot; etc.), because that would forfeit the advantages we get from using lists, and would also make the language harder to teach and learn.<p>Therefore, we ideally solve this with a better <i>internal</i> representation of strings: We <i>internally</i> (i.e., in the virtual machine), represent strings as sequences of plain bytes. Not cells, but direct bytes, using UTF-8 encoding. And when the virtual machine encounters this type internally, then it acts <i>as if</i> a list were encountered, making this array of bytes appear as a list (of characters, or of integers) to programmers. Internally, the system can &quot;tell&quot; whether a sequence of bytes denotes such a list, for example because they are allocated in a dedicated region of the memory, and suitably tagged pointers are used to refer to such sequences, as is the case for other data types such as large integers.<p>This much more compact representation was first explained by Ulrich Neumerkel in an issue for Scryer Prolog:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog&#x2F;issues&#x2F;24" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog&#x2F;issues&#x2F;24</a><p>The general idea can be applied to Haskell and Erlang too.<p>In another issue, Ulrich explained in more detail how to extend it to <i>partial</i> lists, i.e., Prolog terms that are not lists, but can still <i>become</i> lists:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog&#x2F;issues&#x2F;95" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;mthom&#x2F;scryer-prolog&#x2F;issues&#x2F;95</a><p>This latter issue is unique to logic programming languages like Prolog.<p>Trealla Prolog has already taken the idea to its extreme in that it uses mmap to map an entire file <i>as is</i> into memory when parsing, so that parsing from files becomes extremely efficient: The data from disk appears as a sequence of bytes in memory (the underlying operating system performs the mapping), and the Prolog virtual machine ensures that the byte sequence appears as a list of characters to Prolog programs. So, finally, we can use Prolog for its intended application: efficient, general and convenient parsing of text.<p>PostScript is another good existing example of this combination: Internally, the PostScript interpreter can represent strings very compactly, while to PostScript programs, strings can be used seamlessly like lists. For instance, we get:<p><pre><code>    GS&gt;(hello) { = } forall\n    104\n    101\n    108\n    108\n    111\n</code></pre>\nAs to your other question: These days, I am applying Prolog for example to reason about safety properties of clinical trial designs, and I am interested in applying logic programming to automate cross-border evidence exchange that member states of the European Union must ensure to satisfy the requirements of the Single Digital Gateway Regulation.')