Item(by='beagle3', descendants=None, kids=None, score=None, time=1606414362, title=None, item_type='comment', url=None, parent=25220364, text='What do you mean by &quot;if you translate to C&#x2F;C++ row major order?&quot;<p>What I meant was: In FORTRAN, you idiomatically do Struct-Of-Array=Column-Major order by default, In C&#x2F;C++ you do Array-of-Struct or Array-of-Pointer-to-Struct (both of which are Row-Major) by default. The former tends to be much more efficient than the latter in computational code.<p>It turns out that, often and especially in computationally intensive code, only a small number of fields of an object&#x2F;record are used in every part of the computation pipelines, but almost all records are.<p>As a result, if you do your data in column major order, then the cache usage patterns reflect that - whereas if you are in row major order, a lot more field get loaded into cache when they are not needed (thus, much lower cache utilization and lower performance).<p>FORTRAN did not have structures until quite late (FORTRAN-95 has them for sure, but IIRC FORTRAN-77 and earlier didn&#x27;t). Thus, the idiomatic way to do stuff is have an SoA=Coiumn-Major implementation, rather than the  C&#x2F;C++ AoS=Row-Major order.<p>Furthermore, FORTRAN didn&#x27;t have any pointers. As a result, most code was written with very little pointer chasing &#x2F; foreign key reference chasing -- which also contributes to efficient use of cache and memory bandwidth.')