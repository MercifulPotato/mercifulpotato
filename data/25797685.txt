Item(by='bsder', descendants=None, kids=[25797963, 25797945, 25798816, 25798256, 25798293], score=None, time=1610751538, title=None, item_type='comment', url=None, parent=25797383, text='I&#x27;m glad that&#x27;s true for you, but my personal experience suggests otherwise.  Dijkstra also mentions the Mesa programming language which had all four of the conventions and that anything other than 0-based, half-open leads to errors.  See: <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD08xx&#x2F;EWD831.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD08xx&#x2F;E...</a><p>And for those claiming the world is 1-based, they&#x27;re full of it.  Machining measurement, for example, is <i>ALL</i> 0-based.  We&#x27;re talking a field that has multiple standards for <i>everything</i> and yet they converged on 0-based measurement.<p>The bigger problem, though, is that I even have to use array-based indexing to iterate something.  That&#x27;s just asking for bugs.<p>And, my favorite question for people who like 1-based is &quot;Given index and length N, how do I create index-1?&quot;<p>The answer, of course, is newindex = index - 1 % N.<p>The question is, of course, a trick because the answer is <i>really</i>: newindex = (index - 1) % N.  Don&#x27;t forget the parentheses or you have a bug.<p>Yeah, no.  I&#x27;ll stay in my 0-based languages thanks.<p>Side Note: I have other objections to Lua.  The big one being that it&#x27;s not <i>really</i> compatible between Lua installations.  Everybody compiles different modules so Lua becomes neither small nor is it the same language between any two implementations.')