Item(by='Jtsummers', descendants=None, kids=None, score=None, time=1609690540, title=None, item_type='comment', url=None, parent=25622153, text='&gt; Specifically I mean if you have no REPL and maybe a long compile time you’re forced to put a little more thinking and planning in up front if you don’t want to waste your time<p>Amusingly, to me, this is something people describe as the difference between having to submit punch cards to (or schedule a job on) a mainframe versus having a compiler on your own machine. That having such quick access to the compiler would lead to the &quot;throw stuff at the wall&quot; approach.<p>IME, faster feedback loops <i>do</i> increase the &quot;throw stuff at the wall&quot; approach, but for those of us who still (mostly) sit back and think, it&#x27;s an enabler and not (just) a crutch. I can get in the flow much better in a language like Lisp and stay there. If, for instance, there&#x27;s some confusion in my mind about how a function or data structure works, in C++ it takes me longer (more of a constant factor longer rather than orders of magnitude longer) to write something and test it out (assuming documentation doesn&#x27;t clear it up for me). But while the time to explore it isn&#x27;t <i>huge</i>, I&#x27;ve been pulled out of my focus for longer. With Lisp, I can test it in seconds and get right back to whatever I was doing.<p>But also, when I don&#x27;t have a REPL, I break my programs into smaller programs (libraries&#x2F;modules) which can be composed into the larger program I want. This lets me, partially, recreate the REPL experience. Using a test runner (a proper one or an ad hoc one) and a set of small CLI apps that let me use the smaller modules directly I get something approaching the feedback speed of the REPL. With fewer dependencies for any part under test (or as a CLI app), I get much faster compilation speeds vs needing to recompile a much larger program.')