Item(by='KMag', descendants=None, kids=[25683136], score=None, time=1610091254, title=None, item_type='comment', url=None, parent=25682378, text='&quot;Optimization&quot; is a misnomer with TCO.  Optimization implies that only execution speed is affected without the optimization.  Without TCO, potentially infinite mutually tail-recursive algorithms (or code transformed into continuation-passing style) can&#x27;t be implemented without emulating tail recursion using a heap-allocated stack&#x2F;linked list of states or manually transforming the mutually recursive functions into a trampoline variant of continuation passing style.<p><pre><code>  function factorial(n, accumulator=1) {\n    if (n &lt;= 1) {\n      if (n &lt; 0) throw &quot;Arument must not be negative&quot;;\n      return accumulator;\n    }\n    return factorial(n-1, n * accumulator);\n  }\n</code></pre>\nTCO doesn&#x27;t just affect the speed of this factorial implementation, it greatly affects the largest value that can be computed.<p>It&#x27;s not to tricky to manually convert tail recursion into a loop, but for mutually recursive functions, you&#x27;d probably be best off manually transforming your mutually recursive functions into a trampoline variant of continuation passing, where each function returns a tuple of function and arguments to a trampoline loop that just repeatedly invokes the returned function on the returned arguments.<p><pre><code>  function trampoline(f, ... args) {\n    while (true) {\n      f, args = f(*args);\n      if (args == null) { return f; }\n    }\n  }\n  \n  function fatorial_impl(n, accumulator)\n    if (n &lt;= 1) {\n      if (n &lt; 0) throw &quot;Arument must not be negative&quot;;\n      return [accumulator, null];\n    }\n    return [factorial_impl, [n-1, n * accumulator]];\n  }\n\n  function factorial(n) {\n    return trampoline(factorial_impl, n, 1);\n  }\n</code></pre>\nIt&#x27;s all very mechanical, and you&#x27;d prefer that the compiler does it.  The main argument against TCO is that it&#x27;s easy for an unobservant programmer to accidentally make a change that prevents TCO.  Ideally, the language would have a construct allowing a programmer to cause a given return site to be a syntactic error if it&#x27;s not a TCO-able tail call.')