Item(by='PeCaN', descendants=None, kids=[25147864], score=None, time=1605775336, title=None, item_type='comment', url=None, parent=25146654, text='I&#x27;ve been working on something like this on and off for the past 4 years or so, although with something more like generators than streams.<p>I think it&#x27;s a very, very promising idea (I admit to heavily being biased towards anything APL-influenced) although surprisingly difficult to get right. Gilad Bracha is obviously way smarter than me so I&#x27;m definitely curious where he goes with this.<p>One additional idea that I keep trying to make work is integrating variations of (constraint) logic programming and treating solutions to a predicate as a generator or stream that operations can be lifted to rank-polymorphically. As a simple example a range function could be defined and used like (imaginary illustrative syntax)<p><pre><code>    range(n,m,x) :- n &lt;= x, x &lt;= m\n    \n    primesUpto(n) = range(2,n,r),               # create a generator containing all solutions wrt r\n      mask(not(contains(outerProduct(*, r, r), r)), r)  # as in the video\n    </code></pre>\nI&#x27;ve never really gotten this to work nicely and it always feels like there&#x27;s a sort of separation between the logic world and the array world. However this <i>feels</i> incredibly powerful, especially as part of some sort of database, so I keep returning to it even though I&#x27;m not really sure it goes anywhere super useful in the end.')