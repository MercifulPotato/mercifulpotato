Item(by='UglyToad', descendants=None, kids=None, score=None, time=1601906404, title=None, item_type='comment', url=None, parent=24685772, text='I was pleased and a bit surprised to see this post talk about a database level approach to this problem. As important an idea it is at the application code level where most posts discuss it, especially in the context of type systems like Haskell, I think it gets neglected when it comes to persistence.<p>For those of us developers who are mere CRUD peons I think it&#x27;s the most important factor in system stability that is mostly negected; either in favour of speed of iteration (NoSQL) or checks at the application code layer.<p>As I&#x27;m increasingly coming to appreciate, systems without enforced integrity at the database level are a breeding ground for bugs. You can add checks in application code but all it takes is 1 bad commit, or 1 check that slipped your notice and now you have bad data and all future code in the system needs to support and work around the bad data. With foundations of sand even the most elegant structure in application code is doomed to a short and catastrophic future.<p>As other commenters mention hindsight is 20:20 and you won&#x27;t always know what the constraints should have been until after the fact, or the constraints might be wrong. But the &#x27;trendy&#x27; development practices treat good old fashioned SQL constraints and data integrity as decidedly unsexy, to the detriment of a lot of systems.<p>MySQL didn&#x27;t even have check constraints (well, actually apply them) until version 8 which shows how ignored these things are. I appreciate the post is more about the fundamental design of the stored data but people are also forgetting unique constraints, foreign keys and all the other tried and tested tools which protect the most important part of most CRUD systems, the data, from devolving into an awful mess.')