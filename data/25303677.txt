Item(by='pron', descendants=None, kids=[25304020], score=None, time=1607097218, title=None, item_type='comment', url=None, parent=25303405, text='&gt; So having virtual threads and &quot;raw&quot; threads under the same class has pros and cons, IMO.<p>That&#x27;s one way to think about it. Another is that Java never gives you &quot;OS threads&quot; it always gives you Java threads, an abstraction with multiple possible implementations. One implementation is no more real or raw than the other (in fact, you could even theoretically make virtual threads the carriers for other virtual threads -- a thread is a thread, after all -- but we explicitly blocked that because it&#x27;s not useful). There is no real difference between that and ArrayList and LinkedList both implementing the same List interface. They&#x27;re both just as real, but they have different footprint and performance (the class hierarchy for threads is slightly different, but for uninteresting technical reasons).<p>&gt; Or do you still disagree?<p>I still disagree. That network call might take 1ms, and that bit fiddling might trigger a GC collection that takes 10 times that or more. Moreover, neither Kotlin nor C# mark long subroutines with a different colour, and they don&#x27;t even mark blocking calls with a different colour, just the flavour of them that&#x27;s to be used with coroutines. The real reason that colour is necessary is because of the way the feature is implemented.<p>Originally, that colour meant to signify something else: nondeterminism in mostly-deterministic languages like Haskell, and it is also important in JavaScript. Trying to retroactively find a useful meaning for it in Java is an excuse.')