Item(by='hardwaregeek', descendants=None, kids=[25464305], score=None, time=1608243289, title=None, item_type='comment', url=None, parent=25460948, text='I realize the shadowing might make the Rust example unnecessarily confusing. With overly pedantic names, it might look like:<p><pre><code>    fn parse_file(file_from_input: Option&lt;File&gt;) {\n      let file = file_from_input.ok_or(Error::new(&quot;File must exist&quot;))?;\n    }\n</code></pre>\nWhat I like about the Rust version is that it explicitly unwraps the argument and assigns it to a new variable. In the TypeScript one, the if statement allows the inference algorithm to determine that `file` is a `File` and not a `File | null`. That&#x27;s a testament to the TypeScript team&#x27;s efforts, but it&#x27;s a little less ergonomic (in my view) that variables can change their type without getting mutated or changed in any way.<p>For instance, if I were to open up this file in emacs with no language server, nothing. I&#x27;d have to trace over the file and act like the TypeScript checker, thinking &quot;oh okay so this null check ensures that file cannot be null, therefore it&#x27;s inferred as File&quot;. This is clearly simple, but for other cases it&#x27;s not as easy. Whereas with the Rust code, I know that my argument, file_from_input is an Option&lt;File&gt;. file_from_input.ok_or(Error::new(..)) makes it a Result&lt;File, Error&gt;. The (?) macro makes it a File. Each step produces a consistent type. At no point do I have to understand the inference algorithm to determine what the type may be.<p>That said it&#x27;s totally cool if you find the TypeScript version more readable :D. It&#x27;s not my place to say what&#x27;s readable or not readable to you.')