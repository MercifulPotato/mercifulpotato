Item(by='pjmlp', descendants=None, kids=[25518059], score=None, time=1608730423, title=None, item_type='comment', url=None, parent=25516759, text='Has answered multiple times, including to your previous comments.<p>- bounds checking enabled by default for arrays and strings<p>- real enumerations that aren&#x27;t implicit converted into numeric types (fixed in C++11, if one bothers to use enum classes)<p>- enumerations can be used as indexes (C++ can work around this with enum classes and some boilerplate templates)<p>- most data conversions must be done explicitly<p>- ability to actually define subtypes that are enforced by the type system (C++ offers this, provided one does the required boilerplate class&#x2F;template code)<p>- memory allocation by default doesn&#x27;t require doing math with data sizes (C++ as well, yet there is too much malloc()&#x2F;free() pollution in C++ code bases)<p>- no need to deal with pointers for out parameters, thanks reference parameters, which even in C++ there isn&#x27;t any guarantee they aren&#x27;t null, even though that would actually trigger UB)<p>- in some of the dialects, namely Modula-2 and Oberon and the languages derived from them, unsafe code requires explicit import of SYSTEM package<p>- if one wants to do crazy C like code, all the necessary gear is available, pragmas to turn off bounds checking, pointer arithmetic, unchecked casts, unions, mapping variables to explicit memory addresses, pointers to callbacks, it is everything there in the package. The original bare bones ISO Pascal wasn&#x27;t no longer relevant in the mid-80&#x27;s, unless the teacher didn&#x27;t knew any better.<p>In fact, IBM i, z&#x2F;OS and Unisys ClearPath have done pretty well with PL&#x2F;S, PL.8 and NEWP, only adding support for C and C++ after the market started to care about POSIX support on mainframes.')