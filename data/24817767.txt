Item(by='shepardrtc', descendants=None, kids=None, score=None, time=1603028030, title=None, item_type='comment', url=None, parent=24817224, text='Yes, this is a fundamental part of Python.  By default, a single Python process is single-threaded in the traditional sense.  So, using &quot;threads&quot; (i.e. the Threading module) in Python is actually more like using fibers in some other language.  They&#x27;re not OS threads. So, if you&#x27;re not waiting on I&#x2F;O, then yes, the threads will fight over the GIL and performance will suffer. This is inherent to Python and will not be changed.<p>But there&#x27;s a few more things that can be said about this.  Python &quot;threads&quot; are really just a mental construct for designing programs. The selling point is that you can share variables and data between &quot;threads&quot; without having to worry about locks or data corruption or anything like that. It just works. But, even with that advantage, you&#x27;re relying on Python to switch between &quot;threads&quot; on its own, and that could easily slow things down.  If you&#x27;re willing to drop the mental construct and go for better performance but still use a single process and be able to share variables, the asyncio module will let you control when the main Python process will move between points of code flow.<p>However, if you really want to use traditional multiple processes&#x2F;threads just use the Multiprocessing module. It actually launches multiple Python processes and links them together.  It&#x27;s called in a similar fashion to Threading, so there isn&#x27;t much code change for that part.  But because it&#x27;s no longer a single process - and no longer bound by the GIL - you can&#x27;t share data between the processes as easily. With Multiprocessing, you&#x27;ll need to create slightly more complex data structures (like a multiprocessing manager namespace) to share that data.  It&#x27;s not that hard, but it requires a bit of planning ahead of time.')