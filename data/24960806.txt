Item(by='chubot', descendants=None, kids=[24960938], score=None, time=1604250246, title=None, item_type='comment', url=None, parent=24956470, text='Right, &lt;&lt; and StringBuffer is still less efficient, at least in terms of the asymptotic number of bytes copied.<p>I guess what I&#x27;m saying is that if you &quot;properly&quot; write a template engine, there should be no advantage to ropes at all.<p>Rather than a tree of non-copied fragments in the language runtime (ropes), you can simply create an array of non-copied fragments in the language itself.<p>Following the template engine I wrote in Python and JS:<p>- Fragments come from two places: holes and consts.   holes come from variables, and consts are figured out at template compile time (e.g. which happens when the web server starts, and shouldn&#x27;t be benchmarked).<p>- Fragments are never copied.  They are simply appended to a big array of fragments.  The template engine is a recursive tree walk interpreter that always appends to an array.<p>This is even true for a feature like #include.  Some template engines may do the &quot;right&quot; thing for local fragments, but the copying may sneak back in for #include.  But if you care, it&#x27;s easy to handle #include in a consistent way.<p>So if you use that &quot;obvious&quot; architecture, then I claim there should be no advantage to ropes.  But I guess that&#x27;s not what happens in practice!<p>(Well, seeing some sibling comments about copying being faster, at least the claim is that this architecture should be as fast or as slow as ropes! :) But yeah I think ERB is probably doing something different and even worse, which is not surprising.)')