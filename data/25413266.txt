Item(by='gpm', descendants=None, kids=[25414841, 25413532, 25415253, 25413975], score=None, time=1607917202, title=None, item_type='comment', url=None, parent=25411906, text='5.10 is the first time I&#x27;ve ever used a release candidate kernel to get some of my code to work. Specifically non blocking pidfd&#x27;s.<p>Traditionally processes have reaped dead children by waiting on them, the problem with this is it&#x27;s a synchronous operation that blocks a thread per child.<p>The only historical non-blocking solution was to listen for signals. Signals are great and all, except that the kernel will sometimes (unavoidably) merge multiple signals together, preventing you from getting a list of dead children. This is problematic if you want to know exactly which children died.<p>Linux 5.3 introduced a third system to listen for dead children, pidfd. It&#x27;s a file descriptor which you can pass to epoll to know when a specific child dies. This is great, but it didn&#x27;t yet support O_NONBLOCK, which meant that to use it in asynchronous (rust) code we need to create an extra thread which just sits around listening for it.<p>Linux 5.10 brings the ability to make this fd non blocking, so we can integrate this seamlessly into async event loops. Here&#x27;s some code of mine that does that: <a href="https:&#x2F;&#x2F;github.com&#x2F;gmorenz&#x2F;async-transpiled-xv6-shell&#x2F;blob&#x2F;master&#x2F;src&#x2F;spawn.rs" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;gmorenz&#x2F;async-transpiled-xv6-shell&#x2F;blob&#x2F;m...</a><p>Thanks to Christian Brauner, Josh Triplett, and Oleg Nesterov: <a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;commit&#x2F;?id=6da73d15258a1e5e86d03d4ffba8776d17a8a287" rel="nofollow">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;lin...</a>')