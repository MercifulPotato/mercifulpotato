Item(by='mehrdadn', descendants=None, kids=None, score=None, time=1601939766, title=None, item_type='comment', url=None, parent=24692346, text='&gt; you can signal on an event from the receiver thread, and it doesn&#x27;t wake up the waiting threads instantaneously, even if they are waiting on a kernel-level object.<p>This isn&#x27;t normally the case. You should expect this not to be the case because programs would be <i>insanely</i> inefficient if this happened. My suspicion is there was something else going on. For example, maybe all CPUs were busy running threads (possibly with higher priority?) and so there was no CPU a waiting worker could be scheduled on. But it&#x27;s not normally what&#x27;s supposed to happen; it&#x27;s pretty easy to demonstrate threads get notified practically immediately and don&#x27;t wait for a time slice. Just run this example and you&#x27;ll see threads getting notified in a few microseconds:<p><pre><code>  #include &lt;process.h&gt;\n  #include &lt;tchar.h&gt;\n  #include &lt;Windows.h&gt;\n  \n  LARGE_INTEGER prev_time;\n  \n  unsigned int CALLBACK worker(void *handle)\n  {\n   LARGE_INTEGER pc, pf;\n   QueryPerformanceFrequency(&amp;pf);\n   WaitForSingleObject(handle, 5000);\n   QueryPerformanceCounter(&amp;pc);\n   _tprintf(_T(&quot;%lu us\\n&quot;), (pc.QuadPart - prev_time.QuadPart) * 1000000LL &#x2F; pf.QuadPart);\n   return 0;\n  }\n  \n  int _tmain(int argc, TCHAR *argv[])\n  {\n   HANDLE handle = CreateEvent(NULL, FALSE, FALSE, NULL);\n   uintptr_t thd = _beginthreadex(NULL, 0, worker, handle, 0, NULL);\n   Sleep(100);\n   QueryPerformanceCounter(&amp;prev_time);\n   SetEvent(handle);\n   WaitForSingleObject((HANDLE)thd, INFINITE);\n  }</code></pre>')