Item(by='psykotic', descendants=None, kids=[24895603], score=None, time=1603715352, title=None, item_type='comment', url=None, parent=24895201, text='&gt; Itâ€™s more difficult to get right than one big single source file.<p>For all my personal projects, I use a single main.c file which #includes the topologically sorted .c files for each module, one file per module, preceded by a shared #include block for external library headers. If your module dependency graph is acyclic, you don&#x27;t need any per-module headers; inside a module everything is sorted and you only need forward declarations for mutually recursive functions&#x2F;types. The only real downside for me is that it breaks &#x27;static&#x27; isolation. Even the slower C compilers like gcc, clang and msvc can build 50-100 kloc&#x2F;sec on my aging laptop with code structured like this.<p>You get qualify of life benefits like fast, simple builds (one-liner scripts for building on each platform, no need for the compiler to chew through the same monstrous system headers for every .c file, fewer symbols for the linker to resolve) and less boilerplate you have to write (no redundant copies of declarations in headers, no redundant #include blocks at the top of every .c file). In case it&#x27;s something you care about, structuring your code like this also makes it trivial to automatically amalgamate your entire project into an stb-style single-file header library for distribution purposes: it&#x27;s already &#x27;static&#x27; safe, you&#x27;ve already specified the topological order and you&#x27;ve already eliminated all the redundant boilerplate you wouldn&#x27;t want in a single-file distribution, so it&#x27;s mostly just a matter of writing a script that inlines the #include &quot;foo.c&quot; directives in the main.c file.')