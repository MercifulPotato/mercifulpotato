Item(by='Jweb_Guru', descendants=None, kids=None, score=None, time=1608461848, title=None, item_type='comment', url=None, parent=25482970, text='Well, the problem is that the number of annotations is <i>not</i> finite, and often there are many valid signatures that would work for a function.  Determining which ones make the <i>whole program</i> typecheck is not a decidable problem for most type systems, and even for those for which it is, this often requires sufficient amounts of global knowledge to make the problem totally intractable in practice.<p>This is a problem you run into very quickly--for example, Hindley-Milner is only decidable because it will only infer &quot;forall a&quot; in prenex form (so its &quot;most general&quot; annotation is only most-general in that context). Type inference if you allow non-prenex quantification--even very mild non-prenex quantification--is undecidable, despite these being just as easy to typecheck as the prenex versions!<p>Now, in practice programs are made up finite numbers of terms, so for some of these type systems you could certainly come up with some sort of semidecision procedure by iterating through every possible sequence of type annotations.  But as this kind of brute force algorithm will not terminate if it can&#x27;t find the right set of annotations, and in practice will not terminate within human lifespans even in most cases where the right set of annotations exist, I don&#x27;t think people would be very happy with such a system.<p>This is especially true if the only reason to find the annotations was to perform program optimizations, and not to enforce correctness.  People are already wholly unwilling to give compilers unlimited amounts of time to do interprocedural analysis, which is mostly done in LLVM and such by just inlining everything.  If having effect annotations were actually critical for being able to apply the optimizations from the paper (which, like I said earlier, I don&#x27;t know that they are), this would pretty much be another instance of a global program rewrite too expensive for an optimizing compiler to perform in practice.')