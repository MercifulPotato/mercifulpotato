Item(by='chriswarbo', descendants=None, kids=None, score=None, time=1607438419, title=None, item_type='comment', url=None, parent=25343084, text='Your example is a bit apples-to-oranges, in a few ways.<p>First your examples are using different constructs, as well as different languages. It&#x27;s perfectly reasonable and &quot;lispy&quot; to write a for loop like your first example, e.g. (this is pretty much the same as the first example in <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;reference&#x2F;for.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;reference&#x2F;for.html</a> )<p><pre><code>    (for ((i &#x27;(1 2 3)))\n      (x i)\n      (y i)\n      (z i))\n</code></pre>\nLikewise Lisps don&#x27;t have a monopoly on factoring common functionality out into helper functions like &#x27;map&#x27;, e.g. a C-like equivalent to your second example is not at all unusual:<p><pre><code>    map(\n      seq(x, y, z),\n      range(3))\n</code></pre>\n(I&#x27;ve replaced the symbolic name &#x27;-&gt;&#x27; with a made up non-symbolic name &#x27;seq&#x27;, to do the same job of applying multiple functions to an argument).<p>Secondly you bring up &quot;off-side rule&quot; indentation, like Python, without mentioning I-expressions or their equivalents. These can be used by all Lisps (and anything else based on s-expressions, like DSSSL, since they&#x27;re trivially convertable to&#x2F;from s-expressions. Some Lisps also have native support (e.g. they&#x27;re standardised in Scheme <a href="https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-49&#x2F;srfi-49.html" rel="nofollow">https:&#x2F;&#x2F;srfi.schemers.org&#x2F;srfi-49&#x2F;srfi-49.html</a> ).<p>&gt; map&#x2F;reduce&#x2F;recur&#x2F;let&#x2F;etc are special<p>I agree for &#x27;let&#x27;, and it already is a &quot;special form&quot; in most Lisps. I disagree for &#x27;map&#x27; and &#x27;reduce&#x27;, since they are ordinary function calls that are not special in any way (that&#x27;s part of the appeal for functional programming and macros: that we&#x27;re not stuck with a finite number of first-order &quot;control structures&quot;). I&#x27;ve not encountered &quot;recur&quot; before, I assume it&#x27;s a Clojure workaround for JVM tail-call deficiencies? A quick Google shows that it&#x27;s also a &quot;special form&quot;, like &#x27;let&#x27;.')