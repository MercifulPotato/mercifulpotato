Item(by='munificent', descendants=None, kids=[24841296, 24841405, 24840836, 24871710, 24846089, 24840450, 24840731, 24844540, 24841829, 24841157], score=None, time=1603213019, title=None, item_type='comment', url=None, parent=24837309, text='I&#x27;ve been observing something akin to Zawinski&#x27;s Law (&quot;Every program attempts to expand until it can read mail. Those programs which cannot so expand are replaced by ones which can.&quot;) but for programming languages:<p><i>Every dynamically-typed programming language attempts to expand until it has static types and compiles to machine code.</i><p>* Common Lisp has long had type annotations that can be use to generate specialized code.<p>* JS started out as a simple bytecode VM, then got a JIT from V8 and others, then TypeScript came and gave it static types.<p>* Python has had several JITs over the yearsâ€”Unladen Swallow, PyPy, etc. It got static types with mypy (and others) and is now adding type annotations directly to the core language.<p>* Ruby&#x27;s 3x3 plan involves adding a type-specializing JIT. Sorbet adds static types and I believe Matz wants the core language to go in that direction.<p>* Facebook created Hack to statically type PHP and PHP core added &quot;scalar type dependencies&quot;. Facebook&#x27;s HipHop VM brings a JIT to PHP.<p>* LuaJIT brought a high performance JIT to Lua and there&#x27;s been a number of projects that layer static type annotations onto the language.<p>* Dart started with an optional type system and moved to a fully sound static type system.<p>So what I see is a language that starts out simple and dynamically typed with a set of core libraries and idioms designed around dynamism. Then later people add static types on the front end to help people maintain larger programs. And they add type specializing JITs on the back end to generate faster code.<p>But right in the middle you&#x27;re still stuck with a mountain of existing code designed around the assumption that code and data don&#x27;t need to be statically shaped. So even though you end up doing all the work (and adding all the complexity) to design a static type system and native code generator, you don&#x27;t get the full benefits.<p>The static type systems are almost always unsound in order to play nice with existing dynamic idioms, so the back end can&#x27;t use the static types for optimization purposes. You end up with these fantastically complex type systems like TypeScript&#x27;s and these incredibly complex JITs, but you still don&#x27;t get the performance you get from a simple fully-statically typed language like Go or, hell, Pascal.<p>I think the reasonable take-away is that if you <i>ever</i> intend your language to be used for large programs, just take the hit and start off with static types. Your future self will thank you.')