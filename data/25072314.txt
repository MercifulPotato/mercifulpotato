Item(by='vlovich123', descendants=None, kids=[25072814, 25073893, 25075823], score=None, time=1605202743, title=None, item_type='comment', url=None, parent=25072135, text='It&#x27;s a package manager in the vein of &quot;old-school&quot; package managers that came from Linux distros and whatnot. It maintains a global dependency chain across your entire machine. This can be good for security fixes in that you only have 1 copy of a package &amp; everyone references it. This is not good for development because it doesn&#x27;t provide a sandbox&#x27;ed environment for you to do development in (ala cargo as others have mentioned). It also causes issue if you try to install 2 packages but they rely on incompatible versions of a popular package meaning you have to choose which package you want installed.<p>Some of this has been mitigated with virtualenv but having a project express it&#x27;s packages &amp; have that automatically reflected in the environment.<p>Finally, Cargo to my knowledge actually lets multiple dependencies exist (even within the same project!!!) so that you can have a dependency like:<p><pre><code>                        dep1 -- dep3 &lt;= v1.6\n                      &#x2F;     </code></pre>\n&lt; my awesome project&gt;  -------- dep3 &gt;= 3.0\n                      \\\n                        dep2 -- dep3 &gt;= 2.0<p>That&#x27;s not possible if you don&#x27;t have the right language hooks because module resolution needs to be aware of the version of the library (i.e. when you go `import numpy`, it actually needs to be aware of the package it&#x27;s being imported <i>from</i> to resolve that correctly).<p>Now whether or not it&#x27;s a good idea to support this kind of dependency stuff can be controversial. In practice though clearly it does cause problems the larger your codebase gets as you&#x27;re more likely to have some nested dependency chain that&#x27;s time-consuming to upgrade so you&#x27;d rather move faster than make sure you&#x27;re only running 1 version of the dependency.')