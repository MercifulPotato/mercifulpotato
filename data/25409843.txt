Item(by='dimmke', descendants=None, kids=None, score=None, time=1607890865, title=None, item_type='comment', url=None, parent=25409172, text='&gt;there are a lot of software developers out there who either don&#x27;t have the inclination or skill to push back against their boss&#x27;s boss&#x27;s boss, or question why a particular abstraction is request over another.<p>I definitely agree with you. There are a lot of people who for various reasons (inherently lazy, not engaged with their current role, etc...) would not do this.<p>My problem is that I think this is a learned behavior in a lot of environments. A lot of places try to treat developers as code monkeys, where it&#x27;s actually the brilliant designers and business analysts making the decisions and it&#x27;s just the responsibility of these programmers to execute their vision.<p>This compartmentalization doesn&#x27;t work well and it leads to a lot of really bad software. Here&#x27;s my theory as to why.<p>If you look at all the various jobs involved in creating a piece of software: Design (UX&#x2F;Screen Design), testing, project management, business analyst&#x2F;requirements gathering, programmer. There&#x27;s only one that&#x27;s actually <i>required</i> to produce a functional piece of software: the programmer.<p>And as much as people want to pretend like this isn&#x27;t the case, the programmer often has to do a little bit of every one of those other roles to effectively do their job. In this comment thread, we&#x27;ve been discussing how they have to put on their project management hat and help shape requirements, but it&#x27;s deeper than that.<p>After all, what programmer hands off a feature for testing without themselves testing that it worked? UX might give you a wireframe, but there&#x27;s almost always edge cases not accounted for. As for project management, if you&#x27;re lucky you have a good one who actually makes the project easier but more often you will have a bad one who adds no value and only forwards emails to you and bugs you about timelines, which effectively means you&#x27;re managing the work yourself.<p>And this isn&#x27;t to say that the people in those other roles are necessarily bad at their job - but there&#x27;s a context you get as the person actually building the thing that you can&#x27;t get in these silo&#x27;d, standalone roles. You see issues that other people can&#x27;t and you have an ownership over the end result that they don&#x27;t. The programmer is the most important piece of it all. They tie it all together and the buck really stops with them. Programmers who don&#x27;t take ownership ultimately lead to worse software.<p>If companies understood this on a more fundamental level and tried to select more for it in hiring than whiteboarding questions, they&#x27;d probably be more successful.<p>The parent comment tried to make a distinction between &quot;architect&quot; and &quot;dev&quot; - but this should start at the Jr. levels. Teach them at the beginning of their career.<p>To be clear, I do think those other roles are important and valid. I just think it&#x27;s very very rare for a team to be staffed with people who are good in all of those areas and when someone is deficient, it basically falls on the programmer to make it up.')