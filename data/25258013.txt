Item(by='meowface', descendants=None, kids=[25258575], score=None, time=1606765405, title=None, item_type='comment', url=None, parent=25256385, text='Another issue is the two mutually incompatible ecosystems of async vs. non-async Python libraries and frameworks. You now have these entire mirror universes of code, with &quot;[X]-async&quot; versions of existing synchronous libraries, and new async frameworks which require using these libraries. The years of work that&#x27;ve gone into non-async libraries are now basically all for naught, with lots of people reinventing the wheel for every possible thing that interacts with a network. (I&#x27;m also not a fan of async&#x2F;await in general.)<p>I&#x27;m a big Python fan; it was my first language and still by far my most-used and the one I know best. But the &quot;developer experience&quot; is undoubtedly a giant mess compared to something like Go or Rust. (Rust also appears to be having some growing pains related to async, but everything else seems way more solid.)<p>Despite Python&#x27;s catchphrase &quot;there should be one, and preferably only one, way to do it&quot;, Go really embodies this across every dimension. One way to install the runtime, one way to format, one way to package, one way to do concurrency, one way to test, one way to write most things. And every version is almost completely backwards compatible.<p>It&#x27;s kind of crazy that a language that (justifiably) prides itself in its programming simplicity also makes you deal with tangled messes like <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1987&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1987&#x2F;</a><p>My one solace is that some all-in-one third-party tooling is finally close to the level of convenience you get with Rust. pyenv and poetry save a ton of headache when it comes to managing Python versions and packages, and &quot;just work&quot; in a pretty similar way as rustup and cargo.')