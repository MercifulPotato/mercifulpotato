Item(by='curryst', descendants=None, kids=None, score=None, time=1603800270, title=None, item_type='comment', url=None, parent=24903123, text='I can give some concrete examples.<p>Exceptions create drastically shorter applications versus Go&#x27;s explicit returns.  I&#x27;ll have to see if I can run an analysis later; I would wager that 20-30% of the lines in our monorepo are related to error handling.  This is in large part due to the style of having the if err return err take 3 lines, but that&#x27;s the prevailing style.  Additionally, it requires an explicit handling block everywhere that might return an error, even if you don&#x27;t want to handle that error there (i.e. in a web app, not handling an exception defaults to a 503 error.  It takes 0 code to return a 503 on an error, which is usually the default error path).<p>For generics, I needed to write a map merge for two map[string]interface{} maps.  Fairly basic, for scalar values prefer the value from the first map on conflict, for slices append the two arrays, for maps do a recursive merge.  I used a type switch to get the type of each value, when I realized that []string and []interface{} were different, and that I wouldn&#x27;t be able to append to a []interface{} unless I convert the []string.  Fine, so I need a function that creates an []interface{} and converts each index in the []string to an interface{} and puts it in the array.  Except because of the type signatures, I now also need one for every scalar type in Go.  Is it an overwhelming amount of effort?  No, but it did turn 6 lines of code with 12 lines of unit tests into something like 50 lines of code with 100 lines of unit tests (more type switches).  Generics should have allowed me to say that I don&#x27;t care what type the input is (and interface{} doesn&#x27;t work here).  Worse, now if I adjust a unit test, I have to do it in several places, not just one.<p>Those are the things that frustrate me in Go.  It ends up feeling like I&#x27;m brute forcing software development;  it&#x27;s not the fastest way to do it, but it&#x27;ll work if we&#x27;re just willing to rewrite the same function 10 times with different type signatures, or write if err statements 10 times so that we can get the error up to the 11th caller in the stacktrace, who&#x27;s actually going to do something useful about the error.')