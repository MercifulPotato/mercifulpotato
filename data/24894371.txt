Item(by='chriswarbo', descendants=None, kids=None, score=None, time=1603705782, title=None, item_type='comment', url=None, parent=24894077, text='Haskell also has definitions, which can&#x27;t be used as expressions directly, e.g. we can write:<p><pre><code>    foo = bar\n</code></pre>\nBut we can&#x27;t write:<p><pre><code>    baz = 2 + (foo = bar)\n</code></pre>\nI this case we can get the expected return value by using &#x27;let... in...&#x27; syntax, but we wouldn&#x27;t get the top-level definition, e.g.<p><pre><code>    baz = 2 + (let foo = bar in foo)\n</code></pre>\nLikewise for type definitions, class definitions, etc.<p>One language which handles definitions nicely as expressions is Nix. Nix has &#x27;let&#x27; but I never use it. Instead we can use &#x27;with&#x27;:<p><pre><code>    with {\n      foo = bar;\n    };\n    &quot;hello &quot; + foo\n</code></pre>\nThe thing in braces isn&#x27;t a block of statements; it&#x27;s a key&#x2F;value dictionary (Nix calls them &#x27;attribute sets&#x27; or &#x27;attrsets&#x27;). The &#x27;with...; ...&#x27; syntax acts like &#x27;let... in...&#x27; but both pieces are expressions.<p><pre><code>    with {\n      myAttrs = {\n        foo = bar;\n      };\n    };\n    with myAttrs;\n    &quot;hello &quot; + foo\n</code></pre>\nInterestingly, whilst Lisp distinguishes between &#x27;letrec&#x27; and &#x27;let&#x27; (bindings with and without mutual&#x2F;self-reference, respectively), Nix distinguishes between &#x27;rec {...}&#x27; and &#x27;{...}&#x27; (attrsets with and without mutual&#x2F;self-reference). In other words, when we write &#x27;with rec {...}&#x27; the &#x27;rec&#x27; modifier affects the definition of the attrset (the &#x27;{...}&#x27;), it doesn&#x27;t affect the binding of that attrset into the environment (the &#x27;with&#x27;). For example:<p><pre><code>    with {\n      bar = 42;  &#x2F;&#x2F; To prevent nonRecursive complaining about a missing variable\n      recursive = rec {\n        foo = bar + 1;  &#x2F;&#x2F; The number 6, since &#x27;bar&#x27; is taken from this \n        bar = 5;        &#x2F;&#x2F; The order of definitions doesn&#x27;t matter\n      };  &#x2F;&#x2F; The attrset { foo = 6; bar = 5; }\n\n      nonRecursive = {\n        foo = bar + 1;  &#x2F;&#x2F; The number 43\n        bar = 5;\n      };  &#x2F;&#x2F; The attrset { foo = 43; bar = 5; }\n    };\n    &#x2F;&#x2F; [] is syntax for a list\n    [\n      (with recursive;    foo)  &#x2F;&#x2F; The number 6\n      (with nonRecursive; foo)  &#x2F;&#x2F; The number 43\n    ]  &#x2F;&#x2F; The list [6 43]\n</code></pre>\nOf course, attrsets (recursive or not) can be used as expressions:<p><pre><code>    (rec { foo = bar + 1; bar = 5; }).foo  &#x2F;&#x2F; The number 6</code></pre>')