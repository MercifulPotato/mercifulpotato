Item(by='wahern', descendants=None, kids=None, score=None, time=1611352897, title=None, item_type='comment', url=None, parent=25876525, text='The BSDs basically solved this problem decades ago: &lt;sys&#x2F;queue.h&gt; and &lt;sys&#x2F;tree.h&gt; provide type-safe core data structures sufficient for most C application needs. The amount of wheel reinvention and dependency complexity outside the BSD universe blows my mind. (Though, FreeBSD projects do have a greater tendency to complicate things, perhaps owing to the stronger corporate-induced feature chasing.)<p>The only real universal sore spot IME has been arrays and vectors. But nobody seems to pitch glib as a way to get a fast and ergonomic FIFO buffer. There are many other areas without simple, go-to solutions, but then that&#x27;s the nature of C programming. Most of the C programmers I interact with are multi-language programmers, as opposed to many C++, Java, etc engineers who lean toward single-language, monolithic approaches.<p>I can understand using glib for GUI applications, considering it&#x27;s already a requirement for Gtk, and because of the OOP emphasis in GUI programming. But IMNSHO, in most other areas the <i>right</i> reasons for selecting C as your implementation language are mutually exclusive with the need for cookie-cutter, void-pointer heavy data structure implementations a la glib.<p>EDIT: Removed outdated discussion of systemd + glib.')