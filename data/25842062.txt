Item(by='bob1029', descendants=None, kids=None, score=None, time=1611111227, title=None, item_type='comment', url=None, parent=25841636, text='OOP is domain-specific in its applicability if you are following the original intent. If you are not strictly following the original intent of OOP, you can get the best of all known worlds if you apply strong discipline and your tools are capable enough.<p>For instance, in most OOP languages you can define your domain model as bags of facts without methods. Then, you could define a separate domain service layer that is exclusively permitted to mutate instances of those types. Next, you enforce immutability by defining a copy ctor for every type in your model. When you return anything to a caller from a domain service you always send a copy. Same idea on create&#x2F;update requests. The way I look at it, the domain services (methods) protect the model (facts) from unwanted mutations.<p>Having your facts separate from your methods means you can apply things like normalization and start to leverage functional and&#x2F;or relational techniques. Being able to query your domain model with SQL is next-level productivity if you can manage it.<p>So, the biggest mistake to me in computer science is not OOP, but the blind following of any one specific doctrine to an inevitable dead-end. Good software outcomes require an incredibly difficult balance between many ideologies, as well as conformance to actual realities presented by the real world (i.e. customer requirements, regulations, developers having bad moods, etc.).')