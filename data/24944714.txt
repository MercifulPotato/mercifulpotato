Item(by='coder543', descendants=None, kids=[24945472, 24944959, 24947252, 24946154, 24963180, 24945855, 24949021], score=None, time=1604079116, title=None, item_type='comment', url=None, parent=24944452, text='Things I &quot;love&quot; about REST APIs:<p>- How should I pass an argument? Let me count the many ways:<p><pre><code>    1. Path parameters\n    2. Query parameters in the URL\n    3. Query parameters in the body of the request\n    4. JSON&#x2F;YAML&#x2F;etc. in the body of the request\n    5. Request headers (yes, people use these for API tokens, API versions, and other things sometimes)\n</code></pre>\n- There&#x27;s also the REST verb that is often super arbitrary. PUT vs POST vs PATCH... so many ways to do the same thing.<p>- HTTP response codes... so many numbers, so little meaning! There are so many ways to interpret a lot of these codes, and people often use 200 where they really &quot;should&quot; use 202... etc. Response codes other than 200 and 500 are effectively <i>never</i> good enough by themselves, so then we come to the next part:<p>- HTTP responses. Do we put the response in the body using JSON, MessagePack, YAML, or which format do we standardize on? Response headers are used for... some things? Occasionally, responses like HTTP redirects will often just throw HTML into API responses where you&#x27;re normally using JSON.<p>- Bonus round: HTTP servers will often support compressing the response, but <i>almost never</i> do they allow compressing the request body, so if you&#x27;re sending large requests frequently... well, oops.<p>I don&#x27;t personally have experience with gRPC, but REST APIs can be a convoluted mess, and even standardizing internally only goes so far.<p>I like the promise of gRPC, where it handles all of the mundane transport details for me, and as a bonus... it will generate client implementations from a definition file, and stub out the server implementation for me... in whatever languages I want.<p>Why wouldn&#x27;t you want that?')