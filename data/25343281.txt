Item(by='lmm', descendants=None, kids=[25343335], score=None, time=1607418010, title=None, item_type='comment', url=None, parent=25343202, text='&gt; Relational queries and ACID are still absolute requirements for managing your data. Web frontends are just that, frontends. Is there something mathematically changed that means that relational logic is somehow now false?<p>The web request&#x2F;response model makes ACID pointless. The whole point of ACID is that if two users try to update something at the same time, you won&#x27;t lose either of their updates. No web app implements that: if user A loads the edit page and then user B loads the edit page and makes an edit, their update is going to be lost when A saves the page. (Or maybe the webapp implements its own locking, but it won&#x27;t - and can&#x27;t - use database transactions for it, because there&#x27;s no way to know whether the user is still editing or has closed the page).<p>&gt; MySQL was a hack that people that didn&#x27;t understand relational databases used as a glorified K&#x2F;V store. It was &quot;fast&quot; compared to the alternative of postgres, but of the three qualities of good, cheap, fast, MySQL only won on the last of those and for a definition of &quot;fast&quot; that most of those web frontends didn&#x27;t need.<p>Exactly! MySQL did none of the things that &quot;good&quot; databases do, and yet MySQL-based companies were far more successful. Conclusion: the things that &quot;good&quot; databases do aren&#x27;t actually that valuable.<p>&gt; &quot;SQL is not machine-friendly&quot;? Why not?<p>It&#x27;s irregular, hard to generate safely, and hard to parse. It makes no sense as a machine-to-machine interfaces (and it was never designed as one).<p>&gt; That&#x27;s driven by the performance characteristics, which are driven by the query planner using the statistical analysis of that data.<p>Only if the query is complex enough for those to be a dominant factor. For a simple primary-key lookup, today&#x27;s databases typically spends 3x as long parsing the SQL as actually executing the query.<p>&gt; &quot;...the transaction system means you&#x27;re virtually guaranteed to deadlock...&quot; you mean, if you try to break ACID, then the database enforces constraints to stop you and make you reconsider your data access properly? That&#x27;s like saying Rust&#x27;s borrow checker doesn&#x27;t allow you to program race conditions.<p>It&#x27;s just the opposite: SQL databases rely on magically figuring out the locking for you, and don&#x27;t give you enough visibility or tooling to let you manage it in a safe way. You can&#x27;t look at a query and know which locks it will take, in which order, unless you&#x27;re intimately familiar with that particular database&#x27;s internals. Application programmers know to make sure every thread obtains locks in the same order, or ideally use higher-level abstractions. in SQL queries you don&#x27;t have that option.<p>&gt; Storing JSON in a K&#x2F;V store and doing joins in code is a regression, not an advance. Not expressing your data&#x27;s constraints as actual constraints means that bugs can happen that shouldn&#x27;t.<p>I&#x27;m all for type safe datastores (and RDBMS type systems are pretty limited: no decent collection types, no aggregates unless you count temporary tables which come with a giant set of pitfalls). I can believe that referential integrity could be worthwhile. But SQL is a very poor interface, and datbase-level ACID is worse than useless in today&#x27;s (web-based) architectures.')