Item(by='fn1', descendants=None, kids=None, score=None, time=1601788345, title=None, item_type='comment', url=None, parent=24675016, text='Slightly off-topic, but yes, having fail-fast deserialisation is great.<p>I wrote a json&#x2F;kotlin-serialisation library once and purposely restricted some json-features to achieve that:<p>1. Fields can arrive in any order - this is standard<p>2. Field names are matched case-insensitively - so keyA and keya are the same, because who would use two variables differing only by case. Serialization keeps the original casing of the name.<p>3. Missing fields throw an error. if they are nullable, they have to be explicitly set to null - so that you can be sure the serialization side upgraded to the latest version of a protocol if a field was added, and things don&#x27;t just work by chance.<p>4. Nullable strings are not coerced to empty strings or anything like it. Kotlin is null-safe, so if it&#x27;s a string, it has to be &quot;&quot;. If it&#x27;s, for whatever reason, a nullable string, you can set it to null.<p>5. Enums are also serialized case-insensitively - so you an write &quot;keyA&quot;: &quot;eNumVaLuE&quot; if you want - typos should not break the code here, no on would you two enums differing only by case. IIRC booleans could also be TRUE, tRuE, truE etc. (but NOT t or f, or yes or no, or 0 or 1 or empty).<p>6. Superfluous properties are silently ignored.<p>These rules were a great tradeoff for quick development, mixing languages and having fail-fast behavior with a stable protocol.<p>(<a href="https:&#x2F;&#x2F;medium.com&#x2F;@fabianzeindl&#x2F;generated-json-serialisation-for-kotlin-4470dabe40b8" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@fabianzeindl&#x2F;generated-json-serialisatio...</a>)')