Item(by='boulos', descendants=None, kids=[25525089, 25525781], score=None, time=1608781798, title=None, item_type='comment', url=None, parent=25520353, text='I&#x27;m hopeful that this leads to some focus on the ergonomics of &quot;waiting for async things from sync code&quot;. Lots of &quot;handlers&quot; in the universe have synchronous interfaces, so if you want to implement them you end up needing to poll&#x2F;wait on async from a regular function. I swear that every time I poke at Rust, I seem to find some way to cut my fingers...<p>My specific example is writing a fuse handler (now with cberner&#x2F;fuser formerly zargony&#x2F;rust-fuse) for GCS&#x2F;S3. If you want to use make any async requests (like via hyper), you currently have to roll your own poller, like reqwest does in blocking mode [1].<p>The rust async&#x2F;.await primer [2] offers the reader the seemingly helpful futures::executor::block_on, but basically no two executors can interact (and for good reason!). As others highlight, the ecosystem seems like it&#x27;s going to end up standardizing on tokio (and&#x2F;or some flavor thereof) and that hopefully now that it&#x27;s 1.0, we can have stable enough deps for a while :).<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;seanmonstar&#x2F;reqwest&#x2F;blob&#x2F;5ee4fe5ab64a2e3d81efb9540cb9bdb98b8d6938&#x2F;src&#x2F;blocking&#x2F;wait.rs#L10" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;seanmonstar&#x2F;reqwest&#x2F;blob&#x2F;5ee4fe5ab64a2e3d...</a><p>[2] <a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;async-book&#x2F;01_getting_started&#x2F;04_async_await_primer.html" rel="nofollow">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;async-book&#x2F;01_getting_started&#x2F;04...</a>')