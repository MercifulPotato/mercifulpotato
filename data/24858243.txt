Item(by='cestith', descendants=None, kids=[24858753, 24858735], score=None, time=1603376129, title=None, item_type='comment', url=None, parent=24857433, text='You&#x27;re familiar I&#x27;m sure with your browser authenticating that a TLS certificate is within its valid date range and assigned to the hostname of the server? You&#x27;re probably also aware that your OS and&#x2F;or browser have a list of certificate authorities one of which must have signed the certificate (or via a chain of CAs from a trusted root, with each CA cert signed by one closer to the root). Client certs work the same way except it&#x27;s the server verifying all of this for the client (browser, mail user agent, whatever).<p>At $work we have several systems in which the server only accepts requests, or only accepts certain kinds of requests, from clients with client certificates with specific restrictions. Depending on the application and its authN&#x2F;authZ needs, any of the solutions I&#x27;m about to mention might be combined with some combination of a username&#x2F;password, with a time-based token, a JWT, IP range restrictions, an API key, or whatever else in addition to the client cert requirement - or sometimes the cert is sufficient by itself. Some just trust anything that was issued by the right CA and is in its proper date range. Sometimes we also verify that the certificate matches an assigned hostname of the client. Sometimes we trust certs by the right CA to connect, but parse the hostname out of the cert and check whether that client&#x27;s hostname or the subdomain it&#x27;s in has authorization to do certain things. Semantic hostnames might look long and confusing at first, but they can be used very easily for things like that. Semantic host names and naming schemes could be its own article.<p>This isn&#x27;t a general use case for the general public because of deployment headaches. Which CAs do we trust? Is it the same as those issuing server certs? Will services be set up especially to issue client certs? Who&#x27;s supporting the users to get the certs installed, many of whom enter the wrong email when signing up for services? We can do this in a corporate network pretty easily. We have automation systems for servers. We have another, different automation system for administration of Laptop, desktop, and mobile client devices. We just put what cert we want everywhere we want it.<p>A big problem I see with client certs and the general public is multi-device users. If you&#x27;re logging into Google from your home desktop, your work desktop, a couple of laptops, a tablet, and a phone that&#x27;s one email address but half a dozen different certificates. Some applications, especially cross-platform ones, insist on their own certificate store even if the OS provides a shared one. So for mail, a couple of browsers, and two other native apps, congratulations that&#x27;s maybe two dozen. One can export and import client certs, but there&#x27;s no simple way to get less technical end users to do that. So do we make it easier to configure multiple client devices and all their applications with the same certificate and key? Are end users going to remember to update them all when one is lost in a breach or it expires? Or do we expect all the service providers to trust multiple certificates signed by multiple different CAs for each user, then have the user upload the public (but not the private!) part of each cert&#x2F;key pair to all of those services to say they should be trusted? Or does every service require its own CA to sign your cert for its own service, so you need an Apple cert, a Google cert, an Amazon cert... ad nauseum?<p>Tools like Bitbucket or Gitlab let you upload your public SSH key in the web UI to provide auth for the git repos. You can also have (hopefully with separate keys) automated applications that interact with git auth against a repository or all the repos in a project. That&#x27;s the sort of interface one might expect a web application to offer for TLS certificates. *<p>* A certificate is basically the public key portion of a public&#x2F;private key pair that&#x27;s been signed by some CA. Preferably that CA is a broadly trusted one, except in very particular circumstances.')