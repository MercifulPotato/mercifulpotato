Item(by='ridiculous_fish', descendants=None, kids=[25617094], score=None, time=1609624919, title=None, item_type='comment', url=None, parent=25616569, text='This is confusing, and Rust&#x27;s error messages make it much worse. If you try to remove the `move`, you get an error:<p>&gt; closure may outlive the current function, but it borrows `answer`, which is owned by the current function. To force the closure to take ownership of `answer` use the `move` keyword.<p>But &#x27;answer&#x27; is of course not owned by the current function, and how can you take ownership through a shared reference?<p>The explanation is double indirection. By default, the closure captures a pointer to answer, which is itself a pointer on the stack. Without the &#x27;move&#x27;, inside the closure `answer` has type &amp;&amp;str and points into make_tester&#x27;s stack frame. With the &#x27;move&#x27;, it copies the passed-in pointer. The error message is referring to the pointer itself, and this is not obvious.<p>Incidentally I have never found docs for the &#x27;+&#x27; syntax there, would appreciate a pointer to any.')