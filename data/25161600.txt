Item(by='timdaub', descendants=None, kids=[25161888], score=None, time=1605887702, title=None, item_type='comment', url=None, parent=25159826, text='Let&#x27;s say you refactor code, then you might be inclined to change a type signature somewhere, which means you&#x27;ll adjust your program until the compiler isn&#x27;t complaining anymore. You&#x27;ll work until the compiler is silent.<p>The conpiler being silent, here is only an indication that your types and code match. Not that your assumptions about the program match with its outputs (e.g. the user interface).<p>However, unit tests are usually written to assert assumptions. Or to &quot;freeze&quot; certain parts of the code so that these mismatches don&#x27;t happen.<p>In contrast: Types within the source code and depending on your way of thinking about types, many programmers will not see them as &quot;declarative unit tests&quot;.<p>In practice, this means that you sometimes get &quot;surprised&quot; by some unit tests that are failing after a refactor. That&#x27;s good because it sheds light where you&#x27;ve made mistakes when changing your code.<p>To some degree, of course, this is true for types. E.g. they will always help you to point out when two APIs mismatch. However, a test usually is contained within a unit with a clear description motivating its existence. It&#x27;s so much harder to accidenitally changing a test for the worse than it is to change a typed function signature for the worse.<p>Lastly, very often functions are crucially dependent on input values and not their types. So even if, in a dynamic language, you get b=0 input into div(a, b) return a&#x2F;b and it&#x27;s a valid type, you should test for values as in this case as you  can&#x27;t divide by 0.<p>So in many cases, even with inputs it&#x27;d be necessary to unit test e.g. function signatures etc..')