Item(by='brundolf', descendants=None, kids=None, score=None, time=1607722567, title=None, item_type='comment', url=None, parent=25389516, text='&gt; Rust uses &quot;traits&quot; to do both generic-like things and inheritance-like things. It&#x27;s not clear this was a win. The result seems to be a system which does both badly.<p>IMO the fact that Rust doesn&#x27;t do inheritance well is a feature, not a bug. My understanding is that most people even in OOP circles have realized that composition is better than inheritance, and I see Rust&#x27;s choices around it as a reflection of that.<p>&gt; It&#x27;s not enough that every operation on a type needed by a generic be implemented. The type has to be part of a single trait that provides for all those operations.<p>Maybe I&#x27;m misunderstanding, but do you know that a generic can combine multiple traits? For example:<p><pre><code>  fn foo&lt;T: Copy + Add + Sync&gt;(x: T) {\n    ...\n  }\n</code></pre>\nHere T must implement Copy and Add and Sync.<p>Maybe what you&#x27;re talking about is the fact that methods&#x27; identities aren&#x27;t fully described by their names + types, but also by their trait? i.e.:<p><pre><code>    trait TraitA {\n     fn foo(&amp;self, x: i32) -&gt; i32;\n    }\n    \n    trait TraitB {\n     fn foo(&amp;self, x: i32) -&gt; i32;\n    }\n    \n    struct Foo {\n    }\n    \n    impl TraitA for Foo {\n     fn foo(&amp;self, x: i32) -&gt; i32 {\n      x + 1\n     }\n    }\n    \n    fn requires_b&lt;T: TraitB&gt;(x: T) {\n        x.foo(12);\n    }\n    \n    fn main() {\n        let f = Foo { };\n        requires_b(f);\n    }\n\n    error[E0277]: the trait bound `Foo: TraitB` is not satisfied\n      --&gt; src&#x2F;main.rs:25:16\n       |\n    19 | fn requires_b&lt;T: TraitB&gt;(x: T) {\n       |                  ------ required by this bound in `requires_b`\n    ...\n    25 |     requires_b(f);\n       |                ^ the trait `TraitB` is not implemented for `Foo`\n</code></pre>\nThis was an opinionated decision made by the Rust team - which I think was a good decision - to address the fact that it&#x27;s possible to have unwanted overlaps between trait method signatures. Just because fn foo(&amp;self, x: i32) -&gt; i32 is defined for a struct, doesn&#x27;t mean it&#x27;s the <i>same</i> foo that you&#x27;re wanting to call. Distinguishing things by trait strengthens the contract. It also avoids the diamond problem. You&#x27;re right that this isn&#x27;t directly related to &quot;safety&quot; in a memory sense, but it&#x27;s part of an overarching philosophy of Rust that encourages intentionality and discourages footguns.<p>&gt; Generic parameters can only be types, not numbers.<p>This is a work in progress and has partially been rolled-out; the full implementation is on the way: <a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rfcs&#x2F;2000-const-generics.html" rel="nofollow">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rfcs&#x2F;2000-const-generics.html</a>')