Item(by='BatteryMountain', descendants=None, kids=[25056930, 25057578], score=None, time=1605081744, title=None, item_type='comment', url=None, parent=25048077, text='The forced DI pattern makes sense here because:<p>Most DI containers are not just injectors, but they also manage life cycles&#x2F;scopes of objects: singleton&#x2F;transient&#x2F;scoped.<p>Since in web development, a request hitting a controller endpoint is typically short lived and most objects and services are tied to the main request scope, it makes sense that all your objects should live and die when the request is made and completed. What is the cleanest way to manage this life cycle scopes? Dependency Injection. Most of your object&#x2F;services will be &quot;scoped&quot;, with fewer being transient (aka a pool of reusable objects) and the fewest being singletons that will survive individual requests.<p>A second side effect of DI, it forces you to code by convention. Conventions make maintaining the code 6 months from now a breeze. Want to add a new service? Just let it inherit from an IService and consume it in 10 places, it will auto find&#x2F;inject your new code. No need to new() up and dispose your service in 10 place.<p>Do all of this without DI and use only constructors + Dispose(). Good luck! Mercy on the poor soul who has to maintain all that mess.<p>If you want to go a step further, instead of having 100&#x27;s of IService and each constructor declaring they each need 10 of them (ILoggerService, IAccountService, IEmailService, IStockService etc etc)... that also becomes very gross in large projects: so to go a step further, use the Mediator pattern. You can either implement your own (super easy) or use the Mediatr nuget package. Then each service becomes much cleaner. Each service then only has 1 method that does work. It also ties in nicely with the Unit of Work pattern.<p>Why should my IStockService inject the IEmailService when I just want to check stock levels with GetLatestStock() that return an int and does no other work?<p>Lets say the IStockService has 15 methods to do with stock and 10 dependencies. So on each request where you depend on IStockService, you would also pull in the 10 dependencies and their inner dependencies which may add 1 second to your response time and uses 10mb RAM. But all you wanted to was check stock which takes 10ms and 1mb RAM.<p>This is exactly the scenario that mediator pattern can help solve. So your 15 methods become 15 individual classes, each pulling in ONLY the dependencies it needs and nothing more. Your file and git commits stay small too which makes everything more digestible (less than 100 lines of code if lucky),<p>So my favourite setup is DI + Mediatr. Each file&#x2F;class has only ONE purpose to exist and only one reason to be pulled into a dependency tree, all while DI will manage their life cycles.<p>Edit: For those downvoting, please go read &quot;Dependency Injection by Mark Seemann&quot; and also read <a href="https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;aspnet&#x2F;core&#x2F;performance&#x2F;performance-best-practices?view=aspnetcore-5.0" rel="nofollow">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;aspnet&#x2F;core&#x2F;performance&#x2F;per...</a> . Then try to build your own framework from scratch. Do it. Then come crawl back and upvote this comment. I&#x27;ve have a ton of experience with this stuff and have built 2 or 3 custom frameworks. The core trait that keeps everything sane and fast is to keep things simple, keep dependencies low, keep hot paths lean. The easiest way to get to  that place is DI + Mediatr and to break some services into their own api&#x27;s if they get deployed too often. It&#x27;s that simple.')