Item(by='hansvm', descendants=None, kids=[25727675], score=None, time=1610336183, title=None, item_type='comment', url=None, parent=25722553, text='The example a[-1:0:-1] should be pretty understandable once you&#x27;ve spent enough time in the language -- you&#x27;re inclusive at -1 and exclusive at 0, so the list is reversed and is missing its formerly first element (should one exist).<p>That logic is pretty consistent. The start is always inclusive, so it needs to be `len(a)-`, `-`, or `None`. The end is always exclusive, so you need to choose `None`. As a result, counting all the syntactic sugar available to you, you have 8 slices that can reverse a list. To name a few you have a[::-1], a[None:None:-1], and a[-1::-1].<p>IMO a much more interesting example for the strengths of inclusive indexes is a[len(a)-1:-1:-1]. The result is always empty, but it wouldn&#x27;t be too much of a stretch to think you included len(a)-1, you decremented to -1 exclusively (thus including 0), and hence reversed the entire list. The problem is that -1 is a valid index, and unlike the a[0:len(a)] case you don&#x27;t have any values &quot;before&quot; the beginning of the list to include 0 in an _exclusive_ expression.<p>It&#x27;s all a bit of a moot point though. I know Python especially chose its [inclusive,exclusive) convention largely because it wanted expressions like range(len(a)) to not require additional arithmetic for common use cases given that it had zero-based indexing. Julia has one-based indexing, so for common use cases an [inclusive,inclusive] pattern falls out as the most natural choice. I have no idea if Julia actually cared about that sort of thing or if such a convention came about by accident, but it seems like a clean choice for a one-based language.')