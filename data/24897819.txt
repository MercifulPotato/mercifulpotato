Item(by='benjaminjackman', descendants=None, kids=[24897897, 24900910, 24901136, 24898552], score=None, time=1603729261, title=None, item_type='comment', url=None, parent=24897540, text='Speaking from experience with JVM HFT applications (we used Scala).<p>There are a lot of tricks though to not require 1TB.<p>And allocation in general is a bad idea even if you don&#x27;t collect because it scatters stuff all over memory and messes up cache locality. You really, really don&#x27;t want to allocate in a performance sensitive jvm application if you can avoid it. It&#x27;s the opposite of a lot of what I was told and taught (e.g. never do object pooling), but empirically, in my experience, allocations are the biggest slowdown. You can get an application a lot faster just by opening up the memory allocation tab in a jmc flightrecording and refactoring the biggest allocators, usually there is a lot of easy to optimize low hanging fruit that will give good performance improvements, even better than focusing on hot spots in code (in my personal experience).<p>By far the biggest allocator in trading is going to be marketdata and calculations on it. For reading marketdata from the exchange it&#x27;s best to leave raw data in memory and access it with a ByteBuffer &#x2F; sun.misc.unsafe. Under this pattern classes have 1 value, the memory address to pass into sun.misc.unsafe, then everything from there on is done with offsets onto that address. For calculations it&#x27;s better to write things as static functions, or use object pooling.<p>In the course of optimizing a trading engine I wrote lots and lots of code to get allocations down to zero. It&#x27;s definitely doable, but best done from the start, I refactored an existing trading engine to do that, it was not very fun.')