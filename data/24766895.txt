Item(by='lostcolony', descendants=None, kids=[24767011], score=None, time=1602605391, title=None, item_type='comment', url=None, parent=24766308, text='If you never have a netsplit, that works fine.<p>The whole point of CAP is not what happens when everything is up and talking to each other; the point is what happens when things start to fail (the &#x27;P&#x27;).<p>Let&#x27;s go with two nodes (since you have no quorum, that&#x27;s fine), A and B. A takes a write. Tells B about it.<p>Now what happens?<p>If B commits, acks to A, and -the network fails-,  so that A never receives the ack (and thus says &quot;didn&#x27;t write&quot;), you have a data split. B has committed data A has rejected as failed (and this of course becomes more and more likely the more distributed nodes that you have).<p>How do you resolve that? Maybe you don&#x27;t; it might not matter. A future write (including a retry, since the writing node knows the distributed state is &#x27;indeterminate&#x27;) might update both, and you&#x27;ll never notice. Even if a read is stale, it might not be noticed, or if it is just be shrugged away as a &quot;can&#x27;t reproduce&quot;. Of course, that assumes that B is reachable before you notice an issue; if it&#x27;s a long term netsplit, A can never write over to B, and depending how you handle that you either can&#x27;t take a write, or you allow B to grow very stale, and yet not -know- that it&#x27;s stale (so you presumably are still allowing reads from it).<p>An eventually consistent scheme would accept and attempt to resolve that disparity; in fact, given that the data most likely to be noticed is user data, and users are likely only talking to one node at a time, you likely have an ideal case for eventual consistency.')