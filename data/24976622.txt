Item(by='wk_end', descendants=None, kids=[24977612], score=None, time=1604380962, title=None, item_type='comment', url=None, parent=24974907, text='I used OCaml for several years professionally. It&#x27;s a phenomenal language in many ways, but there&#x27;s no way I&#x27;d seriously consider using it for a new project at this point.<p>I don&#x27;t really agree on the &quot;Learnability&quot; and &quot;Minor annoyances&quot; sections here. In terms of overly academic discourse, well, everyone&#x27;s experiences differ but that&#x27;s simply not a problem I&#x27;ve personally seen in the community (and I&#x27;d happily tell you other languages have that problem in spades). In terms of learnability: Ocaml, (the good parts) is an extremely straightforward language in most respects. The tutorials on the Ocaml website are enough to get you up and running, and Real World Ocaml is freely available and it&#x27;s great. It&#x27;d be nice if v2 ever came out, but...well. Between those two, if you&#x27;re still struggling, give me a call and I&#x27;d be happy to tutor you :)<p>The rest of this article hits most of the nails right on the head. The library support just isn&#x27;t there, the community is too fragmented (why is stdlib vs. Core vs. Batteries and Async vs. Lwt <i>still</i> an issue?), the tooling is still too rough. OCaml&#x27;s lack of multicore isn&#x27;t actually a problem for most use-cases, but the fact that it&#x27;s been in limbo for a decade despite the endless clamouring for it tells you something about what you&#x27;re hitching your wagon to.<p>Twenty years ago OCaml would&#x27;ve been a no-brainer. At this point if I wanted a practical garbage-collected language I&#x27;d choose Scala and get a large and active community, as many Java libraries as there are stars in the sky, and the most sophisticated runtime environment mankind has ever dreamed of (for better or worse). If I truly need a compiled language, well...tragically, I&#x27;ve been bitten by the Rust bug (to the extent that I&#x27;m starting to believe its rigid approach to ownership helps engineer better code - that the ability to freely and thoughtlessly sharing references to objects the way garbage collection grants makes it a mistake, but that&#x27;s a story for another post). And if I need 100% of the power and safety types can give me, Haskell is there waiting, with a better ecosystem to boot. Everything OCaml does well other languages do better, and then some. It&#x27;s an also-ran now.')