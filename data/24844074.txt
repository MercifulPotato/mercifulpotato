Item(by='nendroid', descendants=None, kids=None, score=None, time=1603244351, title=None, item_type='comment', url=None, parent=24843646, text='The point was to prove that I can pull the combinator out of your unsegregated code and moularize IO away from logic.<p>The other point of this was to improve code modularity in every corner of your code. Why is this good? If all your logic can be shifted around then that means that you can reuse code to anticipate future changes.<p>The most insidious form of technical debt is unanticipated technical debt. You encounter it when a new requirement makes you realize that you can&#x27;t reuse segments of your code. You realize that you grouped things together incorrectly. You failed to have the foresight to make your code more modular.<p>It&#x27;s a problem people think they can solve in hindsight but they can&#x27;t in reality because they cannot predict the future so they will inevitably group code incorrectly. And therein lies the problem: grouping. Don&#x27;t group your code. Make all your logic modular and just organize your code with superficial schemes like namespaces.<p>The problem with OOP is that the very nature of an object is a grouping. OOP is all about grouping the code around shared mutable variables within a context. You are forced to assume a grouping and you may be right in some cases (like cruisecontrol) but you will inevitably be mistaken in many other cases. This &quot;mistake&quot; is the origin of the most insidious form of technical debt.<p>The other problem with OOP is that they think that this style of programming is modular. They have no idea how un-modular it is. So they use it extensively with patterns thinking they&#x27;re improving modularity.<p>The most modular primitive is the combinator. That is why to prevent technical debt as much as possible, the key is to move as much code as possible into the combinators.')