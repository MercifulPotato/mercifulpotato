Item(by='puredanger', descendants=None, kids=[25399115, 25377378, 25377140, 25379696], score=None, time=1607626484, title=None, item_type='comment', url=None, parent=25375384, text='I use Clojure because I am not a particularly wise programmer (I have been fortunate to work with many actually wise programmers).<p>I like to write dumb, obvious code. Most Clojure code is about taking your data, representing it a sequence of maps, and transforming them into different sequences of maps. The maps are open (easy to change over time), immutable (impossible to encounter data races, weird equality semantics, or concurrency issues), dynamic (no pre-definition or ceremony required), concise (thanks to a literal representation that does not even require commas between elements), and have a generic access api (no custom functions&#x2F;accessors&#x2F;etc).<p>Because I use the exact same transformation functions on EVERY PROBLEM, there is an enormous amount of reuse of generic operations both within and across Clojure code (even Clojure code that manipulates Clojure code, which is after all, just data).<p>Because the center of our code is open data, coupled with generic functions open to later extension (multimethods, protocols), Clojure is notably good at handling information systems that evolve over time in requirements (a feature of essentially all of them).<p>The core constructs are not hard, certainly they are easier to learn and use than complicated things like mutable classes and locking. The unlearning from other languages is often bigger than the learning. Nubank for example is certainly not hiring 100s of Clojure developers - in most cases they are hiring good people and teaching them Clojure. There are other successful companies doing the same.<p>Large Clojure programs can be hard to reason about because large programs are hard to reason about. One benefit of Clojure programs is that they are often 100x smaller than the equivalent program in a popular OO language. They are also trivial to interact with live in your REPL so that you can inspect the data flowing through them. I will happily take live data and interactive function execution over 1000 classes with custom methods. Both require time to learn but I&#x27;m much happier changing the smaller, simpler one.<p>The idea that &quot;Clojure requires wise developers&quot; is completely backwards. Enormous modern class&#x2F;annotation based OO programs are the ones that require the smartest developers because that&#x27;s what it takes to understand them. Clojure is accessible to all.')