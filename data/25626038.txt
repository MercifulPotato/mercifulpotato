Item(by='felixhuttmann', descendants=None, kids=[25630041], score=None, time=1609714462, title=None, item_type='comment', url=None, parent=25623125, text='A few thoughts:<p>1) AWS dynamodb has a parallel scanning functionality for this exact use case. <a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;amazondynamodb&#x2F;latest&#x2F;developerguide&#x2F;Scan.html#Scan.ParallelScan" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;amazondynamodb&#x2F;latest&#x2F;developerg...</a><p>2) A typical database already internally maintains an approximately balanced b-tree for every index. Therefore, it should in principal be cheap for the database to return a list of keys that approximately divide the keyrange into N similarly large ranges, even if the key distribution is very uneven. Is somebody aware of a way where this information could be obtained in a query in e.g. postgres?<p>3) The term &#x27;cursor pagination&#x27; is sometimes used for different things, either referring to an in-database concept of cursor, or sometimes as an opaque pagination token. Therefore, for the concept described in the article, I have come to prefer the term keyset pagination, as described in <a href="https:&#x2F;&#x2F;www.citusdata.com&#x2F;blog&#x2F;2016&#x2F;03&#x2F;30&#x2F;five-ways-to-paginate&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.citusdata.com&#x2F;blog&#x2F;2016&#x2F;03&#x2F;30&#x2F;five-ways-to-pagin...</a>. The term keyset pagination makes it clear that we are paginating using conditions on a set of columns that form a unique key for the table.')