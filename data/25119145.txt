Item(by='dgb23', descendants=None, kids=None, score=None, time=1605574524, title=None, item_type='comment', url=None, parent=25118484, text='&gt; his combination of data and code in a strict hierarchy means that all data access patterns are baked into this dependency tree<p>I believe OOP is really good at modelling state and really bad at modelling data.<p>With state (and side-effects modeled by state machines) you want a well-defined interface, messages, local retention and so on. This way you get the benefit of reasoning about state in a constrained manner both as the caller and the callee.<p>For example it makes sense to model Mario as a state-machine that receives messages from game-pad (pressed buttons) and collision events. Note that this is a conceptual, high level kind of modelling and not a concrete, structural one.<p>But data is <i>about</i> something. There is data <i>about</i> Mario at any given point in time: his physical dimensions, his velocity, consumed power ups and so on.<p>This is where OOP makes no sense at all. Reading and transforming data should be universal&#x2F;uniform rather than guarded by idiosyncratic getters, setters and so on.<p>This is why SQL, JSON, XML, HTML, Unix filters, AWK, Functional Programming etc. are so powerful. These technologies provide&#x2F;enable a uniform&#x2F;universal way of reading data and composing transformations.<p>(As a side-note: I consider state that never leaks as an implementation detail, usually for performance)')