Item(by='KMag', descendants=None, kids=None, score=None, time=1607471947, title=None, item_type='comment', url=None, parent=25350326, text='I think you&#x27;re mostly correct about the { acyclic } pragma, except that the &quot;Otherwise without&quot; part needs a provisio &quot;if static type analysis doesn&#x27;t prove that objects of the type cannot participate in cycles&quot;.<p>I&#x27;ve worked on a system that used a collector based on that Bacon and Arjan paper linked in the article.  It&#x27;s a very interesting paper.  It has something like seven colors as opposed to the classic three color collector.<p>One of the colors is for objects where static type analysis shows that cycles can&#x27;t exist: ClassA has references to only objects of ClassB and ClassC, ClassC has references to only objects of ClassD, and classes B and D don&#x27;t contain any references, so objects of any of these classes can&#x27;t participate in cycles and are acyclic types.  If ClassD had references to objects of type ClassA, then there would be a possibility of cycles.  Note that tree structures are very common, and static type analysis (without linear&#x2F;affine types) cannot rule out cycles in recursive data structures such as trees.<p>Edit: a quick search appears to show Nim has at least some limited support for affine types in its type system, so trees might be a bad example of where { acyclic } is helpful.<p>Presumably, the { acyclic } pragma is an escape hatch for these cases where the human knows some invariant that isn&#x27;t visible from just type analysis.  As you allude, the GC algorithm is still correct without this information, just less efficient.<p>I also agree that it looks like they run a variant of the GC algorithm when passing a reference between threads: run a variant of the algorithm that doesn&#x27;t actually free unreachable objects and pretend to decrement the reference count on the passed object.  If the GC algorithm shows that all objects reachable through the passed object would have been GC&#x27;d had you decremented its reference count, then it&#x27;s safe to pass the reference between threads.<p>On a side note, my use case of a Bacon-Arjan type collector was in a codebase for a domain-specific language with a functional-reactive programming model.  We actually used the GC for pruning dependency graphs, to remove nodes that didn&#x27;t produce externally visible effects.  Someone somewhere in a big C++ codebase for the DSL interpreter missed incrementing a reference count, resulting in live nodes being pruned from the graph under rare circumstances.  We put a lot of effort into trying to find the missing refcount increment, but ended up ripping out the Bacon-Arjan collector and going with a dead simple mark-and-sweep.  We only needed to run the GC in the rare occasions that the graph topology changed, so the performance difference wasn&#x27;t very noticeable.')