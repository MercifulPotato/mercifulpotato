Item(by='Guvante', descendants=None, kids=None, score=None, time=1609185218, title=None, item_type='comment', url=None, parent=25559423, text='&gt; there is very little information in the community on how to do this kind of engineering efficiently<p>If you aren&#x27;t a huge studio writing a AAA game or thereabouts in complexity you probably can&#x27;t write a game engine efficiently.<p>The number of places that do have that scale and need help on how to be efficient is probably vanishingly small so not a lot of self help pops up.<p>&gt; (at least I haven&#x27;t encountered it nearly as much as I have when I transitioned to application development in higher level languages<p>Pick an engine and use its language whatever that is. Unity gives you C#. Unreal gives you a C++ dialet with some nice features and a blackboard system for scripting that is quite powerful.<p>&gt; there is very little code sharing in the community and zero standardisation<p>From my experience there is little code sharing within a studio so expecting there to be code sharing across the entire community is hard.<p>Assuming you are looking for high performance (AAA) you basically have to write a bespoke engine for your gameplay. And there are a lot of different ways of doing gameplay. Heck whether you have loading zones or continuous loading makes a huge impact on how some fundamental things work (again if you aren&#x27;t huge there are workarounds that make it easier to generalize in exchange for performance)<p>&gt;  everyone reinvents shit from standard library, coding conventions, what subset of the language is &quot;allowed&quot;<p>The standard library has some huge performance problems for video games. Mostly around allocation rules. Unsurprisingly algorithms for millions of things can have bad performance side effects on tens of things (and visa versa).<p>&gt; this means developing good tooling, practices and patterns across large projects is hard<p>To be fair I think this is generally true. Games just tend to build up their codebases super fast but maintaining any huge code base is a pain in the best cases and it is never the best case.')