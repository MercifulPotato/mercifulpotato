Item(by='tabtab', descendants=None, kids=None, score=None, time=1605642236, title=None, item_type='comment', url=None, parent=25119963, text='RE: <i>&quot;The success of OOP is dubious: mostly judged by it&#x27;s popularity, which is mostly driven by it being a default methodology taught to people in school.&quot;</i><p>It&#x27;s worked fairly well for &quot;isolated&quot; groups of services, such as API&#x27;s to file systems, network services, etc. Where it fails is domain modelling and any system or sub-system having more than a few entities. OOP doesn&#x27;t scale when there is a large number of domain nouns and&#x2F;or attributes involved.<p>For example, OOP worked quite well for early and fairly simple GUI&#x27;s. But when GUI systems and applications grew larger and more complicated, OOP GUI&#x27;s turned into spaghetti. I believe something more like an RDBMS is necessary to manage large quantities of nouns and attributes so that one can slice and dice their particular view and grouping as needed for different tasks: query the parts instead of navigate a parts graph. You can navigate graphs like a cave explorer, but you can&#x27;t easily say &quot;show me all nodes (caves) with such and such...&quot;. Perhaps this is the &quot;data orientation&quot; you speak of.<p>(I&#x27;m puzzled why in Java Swing the event handling code for a button click has to be fed into a &quot;listener&quot; instead of attached to the button object itself. The second is more logical in terms of thinking in the domain of UI&#x27;s. Listener is an implementation detail that should be hidden away most of the time.)<p>On a really small scale, trees and nesting work fine. On a medium scale graphs work fine. But on the larger scale, relational or something similar is a better tool. The hard part has been getting RDBMS to manage &quot;blocks of behavior&quot; well (events, snippets, functions, etc.).')