Item(by='johndoe0815', descendants=None, kids=None, score=None, time=1608601415, title=None, item_type='comment', url=None, parent=25498768, text='One interesting point about Modula and Oberon is that these systems were not only the topics of academic research (which are often quickly abandoned when the related project ends). Rather, the systems were used at ETH to educate generations of students over the period of more than a decade, running on custom-designed hardware from day one (the Ceres workstations).<p>We arguably spend too much time teaching our students how to work with complex commercial systems (or nowadays also complex open source systems such as Linux) and should try to rely more on self-developed software which can be understood, adapted and improved in a reasonable amount of time. I&#x27;m trying to revive some of that spirit in my courses and projects.<p>Maybe Oberon errs a bit too much on the side of simplicity. I don&#x27;t think it&#x27;s very problematic that the compiler doesn&#x27;t implement sophisticated optimizations, but the OS part of Project Oberon does not implement memory protection (the older Ceres-based system did to some extent) or preemptive multitasking. This is appropriate considering the system&#x27;s age and the constraints of the FPGA for the original RISC5 system, but due to this the OS part of Oberon is on a similar level as non-NT Windows and classic MacOS. Accordingly, it&#x27;s not a very useful example design today IMHO. Other systems such as xv6 might be more appropriate here, but xv6 was never designed to be used as a desktop os for real-world use.<p>One problem that also affects other bare-metal systems such as Lukas Hartmann&#x27;s Interim OS (<a href="http:&#x2F;&#x2F;interim-os.com" rel="nofollow">http:&#x2F;&#x2F;interim-os.com</a>) or my Smalltalk-80 port (<a href="https:&#x2F;&#x2F;multicores.org&#x2F;blog&#x2F;smalltalk-on-a-small-computer.html" rel="nofollow">https:&#x2F;&#x2F;multicores.org&#x2F;blog&#x2F;smalltalk-on-a-small-computer.ht...</a>) for the Raspberry Pi, is handling the complexity of modern peripheral and communication protocols.<p>Some of the worst &quot;offenders&quot; here are USB and Bluetooth, both of which require driver and protocol stack code that often has  more lines of code and is more complex than the rest of the system. Ethernet and TCP&#x2F;IP might be a bit more manageable, Adam Dunkels&#x27; uIP&#x2F;lwIP are a good example.<p>So, as always in system design, the art is to find the right tradeoffs. Exploring the design space here is interesting, especially within the constraints of a real-world ISA as a basis. And I think projects involving small operating systems and RISC V are lots of fun (I hope Rikke agrees ;-) - we also have students working on Plan9 and Inferno ports to RISC-V) in addition to be educationally worthwhile - IMHO an important point to keep students motivated.<p>I think we should probably all re-read Prof. Wirths &quot;A Plea for Lean Software&quot; (<a href="https:&#x2F;&#x2F;cr.yp.to&#x2F;bib&#x2F;1995&#x2F;wirth.pdf" rel="nofollow">https:&#x2F;&#x2F;cr.yp.to&#x2F;bib&#x2F;1995&#x2F;wirth.pdf</a>) once in a while, but also consider how to apply the principles of this paper carefully instead of going for absolute minimalism. I hope that something along these lines will be a valuable learning outcome for the students working on my projects and attending my courses..')