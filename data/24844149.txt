Item(by='jart', descendants=None, kids=[24845687], score=None, time=1603245333, title=None, item_type='comment', url=None, parent=24842176, text='If the natural logic is broken then you&#x27;ve misunderstood the thing&#x27;s nature. UTF-8 behaves more like a communications stream that was shoehorned into the purpose of character arrays. If you think about it in that way, then decoding can be done simply and elegantly:<p><pre><code>    #define bsr(u)          ((sizeof(int) * 8 - 1) ^ __builtin_clz(u))\n    #define ThomPikeByte(x) ((x) &amp; (((1 &lt;&lt; ThomPikeMsb(x)) - 1) | 3))\n    #define ThomPikeMsb(x)  (((x)&amp;0xff) &lt; 252 ? bsr(~(x)&amp;0xff) : 1)\n\n    void ThompsonPikeDecoder(const char *s) {\n      unsigned c, w = 0, t = 0;\n      do {\n        c = *s++ &amp; 0xff;\n        if (0200 &lt;= c &amp;&amp; c &lt; 0300) {\n          w = w &lt;&lt; 6 | c &amp; 077;\n        } else {\n          if (t) {\n            printf(&quot;%04x\\n&quot;, w);\n            t = 0;\n          }\n          if (c &lt; 0200) {\n            printf(&quot;%04x\\n&quot;, c);\n          } else {\n            w = ThomPikeByte(c);\n            t = 1;\n          }\n        }\n      } while (c);\n    }\n</code></pre>\nThat code generalizes to any 32-bit number. It&#x27;s the full superset of intended behaviors including things like stream synchronization. It&#x27;ll even decode numbers that were arbitrarily banned by the IETF e.g. \\300\\200. Most importantly, since it doesn&#x27;t require a validation pass beforehand, does that mean it goes faster than the OP&#x27;s code in praxis? D:')