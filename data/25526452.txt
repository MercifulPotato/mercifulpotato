Item(by='gr__or', descendants=None, kids=[25526505], score=None, time=1608806353, title=None, item_type='comment', url=None, parent=25526053, text='I think the pain you went through with Java is not quite compareable, as the described havoc (and I do really feel your pain here) would not happen like that in Rust, for the reason that you would have to model these things more explicitly. In detail, it sounds like a cascade of implicit null-ness (aka the billion dollar mistake) and weak references. In Rust null (called None) is explicit through the Option type and the Weak type returns exactly that.<p>More to your point, as I think you were using this as an analogy for the perils of giving up control: Rust&#x27;s explicitness should entail all the semantics of your program, and hence async Rust makes you model out all the potentially-racy async interactions with Arc, Mutex, etc. The same middle-man (the borrow checker) who watches over your regular ol&#x27; sync code&#x27;s memory-correctness, now expects extra constraints to be upheld for values passing through async-boundaries. And for me the whole point of Rust is that this correctness proof will do a better job than any person could, for any moderately sized program. So this is middle man you&#x27;d want between you and the CPU.<p>That said, your async runtime could definitely do shenanigans that screw up your nicely modeled program, but that would be a bug in that specific runtime. I haven&#x27;t deeply read Tokio&#x27;s source and even if I did, making a qualified judgment about it is beyond me.')