Item(by='rottc0dd', descendants=None, kids=None, score=None, time=1610783932, title=None, item_type='comment', url=None, parent=25800508, text='I am a noob and I am happy to be corrected.<p>Every language is designed with a specific design decisions and tradeoffs intended for hopefully wide audience. I think C  and unix culture reflects this in some way. It is home grown environment by handful engineers working initially their own sake. You cannot objectively say, &quot;Everything as file&quot; is good concept, but if you are just handful of people tackling myriad of problems, it should have been liberating to have a too simple of an abstraction. It might be pile of hacks on pile of hacks but, it worked for the time.<p>Whether it is good or bad, depends on what you want to achieve. I think more communities can benefit from more focus on what they are and how they want to do things than trying to be &quot;be all, do all&quot; thing. I might not want to solve problems the way somebody else would solve the problem and I would use a tool to best fits my way of thinking.<p>Even if there is only one language, fragmentation is inevitable. Because, all people might not have the same way of working or thinking. Even if it is written in same language, one might not understand idioms of somebody else.<p>It is easier to read a language with community adopted idioms, than a language that is made for all people. I have been using Java, but the erlang concurrency primitives looks great. But, it would be hell, if single code base  has all possible primitives and style.<p>Asking people to have one language to work is not different from asking people to think in one single way.<p>Edit: added couple more rants.')