Item(by='siraben', descendants=None, kids=[25424362], score=None, time=1607971833, title=None, item_type='comment', url=None, parent=25419740, text='&gt; However, to make the argument that an optimization is correct, the exact semantics of LLVM IR (what the behavior of all possible programs is and when they have UB) needs to be documented.<p>This is a great point as to why formal semantics of programming languages matters.  Even if an optimization seems &quot;obviously&quot; correct, finicky things like introducing the possibility of UB can, as the post outlines, cascade into compiler passes that change the program more and more drastically.  The post mentions that one need not go overly formal with the semantics, but I&#x27;ll demonstrate what could happen when one does.<p>One possible formulation of semantics is denotational semantics, which describes how to map a program source syntax into values, i.e. eval : Expr -&gt; Val.  So when we have an optimization opt : Expr -&gt; Expr, the desired correctness property for that optimization is that<p><pre><code>  Definition opt_correct (opt : Expr -&gt; Expr) := forall (e : Expr), eval e = eval (opt e).\n</code></pre>\nWhen we want to rewrite, say e + 0 ==&gt; e, for any expression e, the correctness can be stated and proved<p><pre><code>  Theorem e_plus_0_to_e_correct : opt_correct e_plus_0_to_e.\n</code></pre>\nOne claim in the blog post that correct optimization passes, e.g. opt1 and opt2 compose into another correct optimization pass can be stated as:<p><pre><code>  Theorem opt_correct_compose (opt1, opt2 : Expr -&gt; Expr) :\n       opt_correct opt1 -&gt; opt_correct op2 -&gt; opt_correct (opt1 âˆ˜ opt2).\n</code></pre>\nWhich means given any two optimization passes opt1 and opt2 such that they are correct, composing them preserves correctness.  The proof is simply;<p><pre><code>    eval (opt1 (opt2 e))\n  = { since opt1 is correct }\n    eval (opt2 e)\n  = { since opt2 is correct }\n    eval e</code></pre>')