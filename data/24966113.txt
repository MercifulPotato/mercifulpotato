Item(by='Twisol', descendants=None, kids=None, score=None, time=1604308893, title=None, item_type='comment', url=None, parent=24963558, text='&gt; The effect systems using free monads seem to keep applying a functor to itself an unlimited amount of times and I really didn&#x27;t get it.<p>I can&#x27;t help with the &quot;effect systems&quot; side of this, but I might be able to elucidate some of the recursive functor thing for you.<p>Suppose you&#x27;ve got a binary tree structure. In something like Haskell, you might model it like so:<p><pre><code>    data BinaryTree t where\n      InternalNode :: (BinaryTree t, BinaryTree t) -&gt; BinaryTree t\n      LeafNode :: t -&gt; BinaryTree t\n</code></pre>\n(I could have written this in Java, but I can&#x27;t bear writing subclasses to make up for a lack of sum types. It looks pretty much the same in Rust, plus Boxes. In C++, this would be `class Node&lt;typename T&gt; { std::variant&lt;T, std::pair&lt;Node&lt;T&gt;* , Node&lt;T&gt;* &gt;&gt; data; }`... or something like that.)<p>When I put a bunch of these nodes together, I get a binary tree. But maybe I want to store these nodes in a database, and I need to store them as rows in a table, where a node&#x27;s children are given by foreign keys into the same table. I could write a whole new type for this...<p><pre><code>    data RowNode t where\n      InternalRow :: (Integer, Integer) -&gt; RowNode t\n      LeafRow :: t -&gt; RowNode t\n</code></pre>\n... but now I&#x27;ve duplicated the structure just to change the references. What if we take the child references as another type parameter?<p><pre><code>    data NodeF t child where\n      Internal :: (child, child) -&gt; NodeF t child\n      Leaf :: t -&gt; NodeF t child\n    \n    type RowNode t = NodeF t Integer\n    \n    data BinaryTree t where\n      MkBinaryTree :: (NodeF t (BinaryTree t)) -&gt; BinaryTree t\n</code></pre>\nNow I get my recursive trees and my flat tables out of the same basic &quot;tile&quot;. NodeF is a functor (although I haven&#x27;t said why, yet), and BinaryTree applies it to itself recursively (using Box as pointer indirection).<p>The MkBinaryTree constructor isn&#x27;t doing anything special. It&#x27;s just wrapping the given node into a new type, like how pointer indirection is necessary in C++ or Rust to avoid infinite-sized types. Similarly, Haskell doesn&#x27;t allow recursive type aliases.<p>That&#x27;s really the key point behind the recursive functors. We&#x27;re extracting the &quot;child&quot; type out as a type parameter, and plugging it back in recursively to get our unbounded-depth tree back. Everything after this point is about what free monads add to this, which might be less interesting -- but I&#x27;ve already written it now, so whoops...<p>Why is NodeF a functor? I can write a function that takes a `NodeF t child` and a function from `child` to `stepchild`, swap the children out using the function, and produce a new `NodeF t stepchild`. That&#x27;s just &quot;fmap&quot; -- and that&#x27;s why we stuck an `F` on the name &quot;NodeF&quot;, as a kind of Hungarian notation.<p><pre><code>    instance Functor (NodeF t) where\n      fmap f (Internal x y) = (Internal (f x) (f y)\n      fmap f (Leaf t) = (Leaf t)\n</code></pre>\nNow, if I pull a random definition of `Free f` from the webs...<p><pre><code>    -- adapted from https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;13357359&#x2F;159876\n    data Free f a where\n      Pure :: a -&gt; Free f a\n      Roll :: (f (Free f a)) -&gt; Free f a\n</code></pre>\n... and inline our `NodeF t` functor into it...<p><pre><code>    data FreeNodeF t child where\n      Pure :: child -&gt; Free t child\n      Roll :: (NodeF t (FreeNodeF t child)) -&gt; FreeNodeF t child\n</code></pre>\nThe &quot;Roll&quot; variant is essentially the same as our BinaryTree construction, in that we can construct arbitrary binary trees with concrete values. The &quot;Pure&quot; variant lets us end the tree, but ending in a &quot;child&quot; instead of a leaf value. It&#x27;ll be helpful to think of this more as a &quot;pause&quot; than as a &quot;stop&quot;.<p>If the `child` is itself a `FreeNodeF t grandchild`, then the whole structure is a `FreeNodeF t (FreeNodeF t grandchild)`, and the canonical thing monads let us do is flatten the nested structure into a `FreeNodeF t grandchild`. In other words, we roll the `Pure` subtree over into the other variant.<p>The &quot;impure&quot; computation our `FreeNodeF` describes is essentially a branching computation. At each step, we can take a value and replace it with a tree of other values. The next step is performed on each of the values in the new subtree, and so on. At any point, each path can terminate in a final `t` value; but other paths might still keep going.<p>Essentially, we&#x27;ve structured our computation <i>itself</i> into a binary tree. The upshot is that the free monad lets you structure your computation into any template given by an appropriate functor. The paths through your structure trace the steps over time taken by your program.')