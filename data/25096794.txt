Item(by='ithkuil', descendants=None, kids=[25098661, 25096931], score=None, time=1605398236, title=None, item_type='comment', url=None, parent=25096084, text='Imagine a cpu that executed this sequence of instructions:<p><pre><code>    r1 = r2 * r3\n    r2 = r3 * r4\n    r3 = r4 * r5\n    r4 = r5 * r6\n</code></pre>\nOn a first glance it might seem that the execution order matters because if you reorder lines in this source coxe the meaning indeed changes (e.g. the first instructions depends on an input in r2 but r2 gets a new value in the second instruction).<p>But if you rewrite the names of the registers (variables) and use a larger set of registers (variables) then you can express the same semantics without overwriting any registers. If you do so you can run the operations in parallel on different execution units within the same core.<p>The ability to run multiple functions at the same time is called &quot;multiple (or wide) issue&quot;.<p>There are different kinds of functional units inside a cpu. For example, some can do basic arithmetic but not divide. At any given time, some functional units will be busy or free. The amount of effective parallelism present in the input stream you can effectively use is bound on whether you can successfully map your instructions into functional units that are free at that time.<p>Often, you while cannot run a given instruction because for example the multiplier unit is busy, the next instruction could be run because it depends on the divider functional unit, which at that time is free.<p>The ability to execute instructions out of order is called, well, &quot;out of order execution&quot;. It depends on the ability to rename registers and keep track of actual data dependencies. The cpu needs some memory to keep track of that data.<p>It&#x27;s unrelated pipelining (which I could give a try explaining too if anybody cares to hear a similar explanation)')