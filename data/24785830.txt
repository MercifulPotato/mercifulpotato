Item(by='brian_cloutier', descendants=None, kids=None, score=None, time=1602746617, title=None, item_type='comment', url=None, parent=24784571, text='Prolog is... different, it&#x27;s going to take some getting used to. The Art of Prolog is a great resource, reading the first few chapters should get you far enough that you can then roughly understand what the code is doing and Google (or skim forward though the rest of the book) to look up the unfamiliar syntax for things like arithmetic. You should probably ignore the cut (the ! Aisha adds) for a while and come back to it once you&#x27;ve written some Prolog and gotten a feel for how it works. cuts are simple, but only once you&#x27;ve wrapped your head around Prolog&#x27;s execution strategy. A good way to know that you get it is that you no longer accidentally write infinite loops.<p>Of course, once you understand logic programming you still have most of this essay left to go through. Even if you&#x27;ve used lisp you&#x27;ve probably never had to implement one! And of course, after you&#x27;ve gotten through all that, now you need to read code written in this strange lisp. A microKanren. <i>almost</i> Prolog, but different in some key ways; it uses a different execution strategy which prevents those infinite loops. The Reasoned Schemer is the second half of this essay but expanded out to book form, it would make a great explanation if you&#x27;re down for a nice read and you have a free Saturday.<p>Once you&#x27;ve gotten through all that the syntax has become completely unrecognizable but the final solution is fun, and makes all the ceremony worth it:<p><pre><code>  balanceo, [lambda, [tree, balanced],\n    [conde, [[rotso, tree, balanced],\n             [balancedo, balanced]]]]\n</code></pre>\n`balanceo` is a relation which is only satisfied if `tree` is a tree and `balanced` is the balanced form. If you pass in `tree` it returns the correct `balanced`. I&#x27;m not sure, but it looks like it probably also works if you only pass in `balanced`, in which case it will return the unbalanced `trees` which correspond to that balanced tree. You might even be able to pass in <i>nothing</i>, in which case it will return a bunch of pairs of unbalanced trees and their balanced forms.<p>The definition of `balanceo`, essentially, says that &quot;[balanceo tree balanced] is only true if balanced can be formed by performing rotations on tree, and balanced is balanced.&quot; MicroKanren figures out the rest. That&#x27;s declarative programming! Pretty great! Though, it only works for small trees, which does tarnish the magic a little.')