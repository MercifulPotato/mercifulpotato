Item(by='nomad010', descendants=None, kids=None, score=None, time=1602351411, title=None, item_type='comment', url=None, parent=24739237, text='I never see many local companies using Immutability and FP, but my tech scene is smaller than Silicon Valley&#x27;s. I mainly get my dose of these subjects from the Internet through blogs and videos.<p>I think both FP and Immutability are tools and, like any tool, they can be used correctly or incorrectly. So the important questions to ask about any tool is:<p>* When should I use this tool?<p>* When should I <i>NOT</i> use this tool?<p>I can&#x27;t speak too much about FP as I don&#x27;t practice it and I don&#x27;t see anyone locally doing the same thing (I do prefer functional style: reduce, map, iterators, etc but I see that as distinct from FP). I can speak a bit about immutability, I&#x27;m going to attempt to convince you that immutability isn&#x27;t a fad, but can be a useful tool when modeling certain problems.<p>I find a lot that immutability is used to describe two related but different things: const&#x2F;immutability bindings and immutable data structures. Usually, trying to make small items constant isn&#x27;t that much of a problem. The problem arises when we start making multiple copies of items containing large data structures. Enter immutable data structures.<p>Immutable data structures try to provide an answer to the inefficiency of copying large data structures by using structural sharing. In the past, these were more typically known as persistent data structures. Tarjan did a lot of work on this topic and the wikipedia page[1] is quite informative.<p>Basically, a persistent data structure allows access to previous versions of itself. I like to think of the version as an additional dimension that one can use to solve a problem. Usually this dimension is just time, but it can sometimes be other things[2].<p>So okay, back to the original questions<p>* When should I use this tool?\nImmutability attempts to make copying the data structure fast. For an example, the RRB trees[3] uses immutability to provide a sequence data structure that can be concatenated quickly. I believe these are the default sequences in Scala and Clojure. You should use them if you require structural sharing or when you require the operations&#x2F;complexities they provide.<p>* When should I <i>NOT</i> use this tool?\nMost of these data structures are implemented as trees so they are likely to not be as friendly to hardware as a flat array&#x2F;vector for example. They add a lot of complexity and I have found bugs in libraries that provide these structures.  If you don&#x27;t require the operations or your problem space isn&#x27;t sufficiently large enough you shouldn&#x27;t use them.<p>Anyway, hope I&#x27;ve managed to convince you that immutable data structures aren&#x27;t a fad and can be useful in many situations.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Persistent_data_structure" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Persistent_data_structure</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Point_location" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Point_location</a><p>[3] <a href="https:&#x2F;&#x2F;infoscience.epfl.ch&#x2F;record&#x2F;169879&#x2F;files&#x2F;RMTrees.pdf" rel="nofollow">https:&#x2F;&#x2F;infoscience.epfl.ch&#x2F;record&#x2F;169879&#x2F;files&#x2F;RMTrees.pdf</a>')