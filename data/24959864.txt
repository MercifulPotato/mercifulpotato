Item(by='speed_spread', descendants=None, kids=None, score=None, time=1604242649, title=None, item_type='comment', url=None, parent=24945281, text='It can be quite terse for a typed imperative language. Macros help a lot with boilerplate.<p>Type inference also helps a lot but is standard in most imperative languages nowadays, so I wouldn&#x27;t count it as a terseness advantage anymore. Also, Rust doesn&#x27;t go full Hindley-Milner as types still have to be declared in function signatures, by design, for readability.<p>Generics are interesting and can save some typing when doing &quot;blanket implementation&quot; of traits, but overall still will count as stuff you wouldn&#x27;t have to deal with in a more dynamic language.<p>The remaining sore point are the lifetimes annotations. Although most are elided by the compiler by now, if you fall into a pattern where you have to explicitly carry lifetimes around, things get tiresome real quick. At that point, I usually take it as a sign that my code is not as optimal as it could be, and try to rewrite in a way that&#x27;s less verbose. This is very much compiler-centric approach and actually reflects the whole Rust experience where programming is akin to having a dialectic conversation with rustc, which although quite smart can also be very pragmatic in its ways.')