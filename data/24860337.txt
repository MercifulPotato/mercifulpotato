Item(by='dragontamer', descendants=None, kids=None, score=None, time=1603386488, title=None, item_type='comment', url=None, parent=24859921, text='The OS level is purely so that multiple programs can talk to the same hardware at the same time. For example, your Firefox Browser may talk to the GPU to render something (H.264 video), or to send audio over the HDMI cable. But at the same time, you&#x27;re playing some video game (Civ-6), and the OS needs to prioritize which gets access.<p>------------<p>When it comes to I&#x2F;O, there are two strategies: memory mapped I&#x2F;O, and I&#x2F;O ports (the &quot;in&quot; and &quot;out&quot; assembly instructions). I&#x27;m pretty sure most modern hardware is memory-mapped type, where you just read to (or write from) certain &quot;memory&quot; locations.<p>Its not really memory (it doesn&#x27;t go to RAM), but instead to some other component, like PCIe root complex for further processing.<p>------<p>Something to note: the whole OSI level exists on the motherboard. You&#x27;ve got physical connections, you&#x27;ve got link-layer connections, and even a network similar to TCP&#x2F;IP. In fact, there are multiple networks: SATA networks, PCIe networks, and USB Networks, that have their own addressing rules and physical protocols. Different USB Ports, different PCIe addresses, and more!<p>From the perspective of the CPU, I expect any &quot;GPU Command&quot; to simply be a link-level call to the PCIe root complex. You send data to the PCIe controller, which then forwards the data to the GPU. Or NVMe RAM, or your network card.<p>To fully make a GPU Command get to the GPU, you need to know the PCIe address, and route the message appropriately (there could be PCIe switches in between). Finally, there&#x27;s a protocol, similar to application-level code (HTTP) where applications talk to the GPU.<p>Given the similarities between DirectX, OpenCL, Vulkan, Metal, and CUDA&#x2F;HIP, I expect that GPUs all have roughly the same &quot;application&quot; interface. Shaders are compiled into machine code. Machine code is loaded into GPU VRAM. Command Queues issue remote-function calls with an event-driven dependency graph that the GPU selects kernels from. Etc. etc.')