Item(by='dack', descendants=None, kids=[25980408, 25982187, 25981365, 25987777, 25984742, 25979725, 25980848, 25982305], score=None, time=1612108114, title=None, item_type='comment', url=None, parent=25979293, text='&gt; What thing that violates a type check would be &quot;perfectly fine to do&quot;?<p>One good example is where you might treat records or &quot;product types&quot; as maps<p>Let&#x27;s say you want to write a function that can capitalize all the string fields in the object passed in. In a dynamic language, you could map over the values and apply capitalization trivially. It would be a one-liner.<p>In a static language, you&#x27;d have a few options, but none are great:<p>1. You could use &quot;reflection&quot; or some dynamic feature to do this, but lose type-safety<p>2. You could make the function take in the union of all possible data types in your system, and then write a mapping function for each one. Then you&#x27;re duplicating the logic N times, or at the least writing a lot of conversion boilerplate.<p>3. You could write two functions for each data type in your system to convert to a Map&lt;String, Object&gt; or some such and back, which lets you operate on the maps. Again, lots of boilerplate. Maybe you use code-generation for this? That would add complexity.<p>In reality, you probably wouldn&#x27;t even try to write such a function in a typed language because of how awkward it is. Maybe you&#x27;d just write specific translation functions for the records you know you happen to need.  But I think that&#x27;s what people mean when they say you&#x27;re restricted by the type-system - because it can&#x27;t verify those types of operations, you find workarounds when maybe that would have been the easiest way to implement something.')