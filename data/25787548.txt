Item(by='dlkinney', descendants=None, kids=None, score=None, time=1610690525, title=None, item_type='comment', url=None, parent=25777992, text='I&#x27;ve never seen anyone complain about this, so maybe I&#x27;m alone, but the runtime error messages are absolute garbage. Especially if you get an unexpected nil that bubbles up, you&#x27;ll often see cryptic erlang messages that don&#x27;t really identify what went wrong. (Think type errors that don&#x27;t identify the expected type nor the type passed.)<p>And by that same line of thought, it&#x27;s frustrating as a functional language given its almost complete absence of built-in monadic types and helpful sugar to use them. Instead of `Maybe`&#x2F;`Option`, for example, you pass tuples around tagged with atoms. This wouldn&#x27;t be the end of the world except that...<p>There&#x27;s no static typing. Which means that `match` blocks can&#x27;t enforce completeness. This isn&#x27;t a huge deal, but for a dynamically typed language, it&#x27;s surprisingly cumbersome to introspect at runtime. Languages like Ruby make such things first class, such brings me to...<p>Elixir is <i>nothing</i> like Ruby. With the exception of `def`, `unless`, and `do`, there are nary a few similarities. This isn&#x27;t necessarily a negative, but the whole notion that Elixir and Ruby share syntax is only <i>barely</i>—and completely superficially—true. In large part, this is because...<p>There is no method-style syntax. That&#x27;s not uncommon for a functional language, but it&#x27;s problematic when the standard library is hugely inconsistent. Is the function you want in the `List` module? Or the `Enum` module? Or is it part of the `kernel`? Hunting around for the right module is a pain, but not as bad as...<p>Inconsistent naming of functions. Sometimes they&#x27;re fully spelled out; other times they&#x27;re abbreviated. And if you&#x27;re really unlucky, if it&#x27;s in the kernel, you can expect 1970&#x27;s Unix-style abbreviations that are so short to be unreadable and have no consistency in how they&#x27;re formed. US state abbreviations follow more strict rules than Elixir kernel function names. At least one thing Ruby got <i>very</i> right were easily-guessable method names.<p>There&#x27;s a <i>lot</i> of good in Elixir; don&#x27;t get me wrong. But I&#x27;ve spent over a year in it and keep stumbling on very un-aesthetic issues. For such an otherwise <i>wonderful</i> developer experience, these pain points ring loudly.<p>Frankly, unless you <i>need</i> a lot of parallel things to happen behind the scenes in real-time, I just don&#x27;t see much use case for Elixir. Its ability to fail and keep going (a major selling point) is great, except that I find it too easy to write code that fails, which can bubble up and create inconsistency in its state. I much prefer something that will help me avoid failure in the first place (Rust us great for that), or something that lets me code fast and loose and makes that experience really enjoyable (like Ruby).<p>I think I&#x27;m alone in these criticisms, however, because I never really see anyone talk about them, so take this all with a grain of salt. I have used a <i>ton</i> of languages in my 25 year career, and I had a lot of hope for Elixir. But, frankly, I just don&#x27;t get it.<p>For highly parallel networked applications, it makes sense. For very small things that would otherwise need external service dependencies (Redis, sqlite, etc), it makes sense.<p>But if your focus is <i>any</i> other use case, I really struggle to justify its adoption. It&#x27;s not as fast as advertised for anything non-realtime parallel. (Go, Java, Rust, et al all provide much faster alternatives.) It&#x27;s not as quick to whip up for medium sized projects. (Like Rails.) And it&#x27;s not as fault tolerant as something like Rust, which can help you avoid the faults in the first place.<p>LiveView—the latest &quot;must have&quot; for web development—is likewise disappointing, in case that intrigues you. Single-language back- and front-end development sounds great. But it&#x27;s just back-end streamed to the front end, which is problematic for any significant latency. None of the benefits of front-end except not refreshing the page. It&#x27;s a fun (and <i>very</i> impressive) toy, but you get almost none of the benefits of a real front-end app. (Such as UI changes while the data is loading.)<p>While I only have a little experience with LiveView, I have plenty experience with latency-laden server-side echoing to know that when it breaks down without the client doing its own best-guess updates, nobody will have a good time.<p>Maybe I&#x27;m just salty because I expected the Elixir experience to be more than it turned out to be. And I do enjoy some of the things it forces you to do, by virtue of its being a functional language. But at the end of the day, I personally find its warts to be significant and not worth dealing with outside of very specific use cases that it uniquely handles very well.<p>Your mileage may vary, but I would ask yourself: does my application <i>need</i> <i>lots</i> of real-time, parallel functionality? If the answer is <i>anything</i> short of &quot;hell freaking yes!&quot;, then I would look elsewhere for serious development.<p>I appreciate all the hard work Jose and Chris (and of course all others) have put into their respective portions of the Elixir experience. But I think it was oversold. And I think the number of packages that haven&#x27;t been touched (or issues responded to) in over 3 years may indicate that others struggle to find its value in many areas in which it was advertised to be a game changer.<p>I want to like it.<p>I really don&#x27;t like it.')