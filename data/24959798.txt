Item(by='formerly_proven', descendants=None, kids=[24963439], score=None, time=1604242170, title=None, item_type='comment', url=None, parent=24958576, text='&gt; Let me ask you: What is it about your first example that makes you call it transactional? If it behaves as badly as you say, shouldn&#x27;t it be called a &#x27;method&#x27; or a &#x27;procedure&#x27;? Because my &quot;fix&quot; for it is to actually use transactions. I suspect your fix would be the same.<p>We have two concurrent tasks both doing exactly the same thing in order to deduct 50 money:<p><pre><code>    BEGIN TRANSACTION;\n    SELECT balance FROM account; &#x2F;&#x2F; = 100\n    UPDATE account SET balance = 50; &#x2F;&#x2F; calculated by application as 100-50\n    COMMIT;\n</code></pre>\nPerhaps I misunderstand you, or you misunderstood the way I presented the example (possibly because I presented it poorly). But in my mind there is hardly a way to describe this code as &quot;not transactional&quot;.<p>I merely showed one possible way how these concurrent tasks may execute in practice leading to bugs. Of course, for casual testing this will actually look and work correctly. As one commenter far up the thread said (as an attempt to refute understanding of concurrency as necessary)<p>&gt; The problem for novices is that a program that behaves correctly looks a lot like a correct program. Until one day it doesn’t.<p>&gt; And because you’re in production and getting random spurious failures, the panicked (but common) reaction is to wrap every shared resource in a synchronized block. Which makes an incorrect implementation worse but possibly correct.<p>Then,<p>&gt; Why did you choose to interleave its steps like that, when &quot;Isolation ensures that concurrent execution of transactions leaves the database in the same state that would have been obtained if the transactions were executed sequentially.&quot;<p>That is only one of the possible ways for transactions to work. Note that IIRC the <i>only</i> database that interprets the SQL standard like this is postgres, while MySQL and Oracle still have (more subtle) serialization issues even on the SERIALIZABLE isolation level (example: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;49425872" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;49425872</a>).<p>Note that you can end up with deadlocks and transaction failures on any level stricter than READ COMMITTED, so the <i>application</i> needs to be able to deal with both of these.')