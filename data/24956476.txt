Item(by='ratww', descendants=None, kids=None, score=None, time=1604191946, title=None, item_type='comment', url=None, parent=24955919, text='I did a lot of stuff with F# and C# together. Calling FP from imperative is nothing special. Calling imperative from FP only requires external purity in the imperative functions (if you want FP to remain pure, of course). Not different from using pure functions in an imperative language.<p>Monads... they&#x27;re just a way of remaining pure (meaning immutable) but still doing imperative-ish stuff. You don&#x27;t need monads to make software: both pure-FP and imperative languages can be Turing-complete, so you can do it all. For doing IO you can just use an imperative shell [1], that &quot;calls&quot; the main function of your pure-FP program (aka: a runtime).<p>Monads for IO make it easier to communicate with this &quot;imperative shell&quot; while still remaining pure. It communicates with it by requiring you to return an IO object all the way to your main function.<p>But Monads can also be used for other things that don&#x27;t need IO, like &quot;internal mutable state&quot;, &quot;maybe monad&quot; or even for simulating an exception system. Those don&#x27;t require you returning anything.<p>Monads are nothing special for real... but you have to use to understand them, since most explanations just make it harder to understand, so I won&#x27;t attempt one.<p>[1] <a href="https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;screencasts&#x2F;catalog&#x2F;functional-core-imperative-shell" rel="nofollow">https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;screencasts&#x2F;catalog&#x2F;funct...</a>')