Item(by='carapace', descendants=None, kids=None, score=None, time=1607477112, title=None, item_type='comment', url=None, parent=25353149, text='&gt; TypeError: &#x27;int&#x27; object is not callable<p>Heh, yeah I did that too when I was wrapping my head around &#x27;em.  The\nthing to remember is that in SKI combinator logic <i>nothing else exists</i>.\nYou can&#x27;t pass &#x27;int&#x27; objects to SKI because they don&#x27;t exist in that\nuniverse.  (Obviously you <i>can</i> in the sense that Python will let you do\nit, but it&#x27;s logically meaningless.)<p>(I had to break out pencil and paper and walk through some evaluations of\nSKI expressions by hand.)<p>Let&#x27;s have versions of I that also print their names and arg as a side effect:<p><pre><code>    def E(x):\n        print(&#x27;E&#x27;, x)\n        return x\n\n    def F(x):\n        print(&#x27;F&#x27;, x)\n        return x\n\n    def G(x):\n        print(&#x27;G&#x27;, x)\n        return x\n</code></pre>\nConsider:<p><pre><code>    S(E)(F)\n</code></pre>\nStart with the definition of S:<p><pre><code>    S = lambda x: lambda y: lambda z: x(z)(y(z))\n</code></pre>\nSubstitute:<p><pre><code>    S = lambda E: lambda y: lambda z: E(z)(y(z))\n</code></pre>\nSo now S returns this new function (call it S&#x27;) that has the E function\nembedded in the closure:<p><pre><code>    S&#x27; = lambda y: lambda z: E(z)(y(z))\n</code></pre>\nThat gets called on F:<p><pre><code>    S&#x27;(F)\n</code></pre>\nSubstitute:<p><pre><code>    S&#x27; = lambda F: lambda z: E(z)(F(z))\n</code></pre>\nAnd this creates S&#x27;&#x27; with both E and F embedded:<p><pre><code>    S&#x27;&#x27; = lambda z: E(z)(F(z))\n</code></pre>\nSo the result is a function that takes some function z, calls F on it,\ncalls G on it, and then calls the result of the first on the result of\nthe second.<p><pre><code>    S&#x27;&#x27;(G)\n\n    E(G)(F(G))\n                E(G) -&gt; G ; prints &quot;E &lt;function G at 0x000001E0A4A741F0&gt;&quot;\n       G(F(G))\n                F(G) -&gt; G ; prints &quot;F &lt;function G at 0x000001E0A4A741F0&gt;&quot;\n       G(G)\n                prints &quot;G &lt;function G at 0x000001E0A4A741F0&gt;&quot;\n         G  &lt;--- G returns itself.\n</code></pre>\nIn action:<p><pre><code>    In [16]: S(E)(F)\n    Out[16]: &lt;function __main__.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt;(z)&gt;\n\n    In [17]: S(E)(F)(G)\n    E &lt;function G at 0x000001E0A4A741F0&gt;\n    F &lt;function G at 0x000001E0A4A741F0&gt;\n    G &lt;function G at 0x000001E0A4A741F0&gt;\n    Out[17]: &lt;function __main__.G(x)&gt;\n\n</code></pre>\nSince G is also a version of I we can get away with passing it anything\n(not just functions):<p><pre><code>    In [18]: S(E)(F)(G)(&quot;Hi!&quot;)\n    E &lt;function G at 0x000001E0A4A741F0&gt;\n    F &lt;function G at 0x000001E0A4A741F0&gt;\n    G &lt;function G at 0x000001E0A4A741F0&gt;\n    G Hi!\n    Out[18]: &#x27;Hi!&#x27;\n</code></pre>\nThat&#x27;s why you can pass anything to SIII (aka S(I)(I)(I) in Python) and it returns it, because SIII = I.<p><pre><code>    In [19]: S(I)(I)(I) is I\n    Out[19]: True\n\n</code></pre>\nHTH')