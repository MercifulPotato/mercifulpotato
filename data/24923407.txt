Item(by='kazinator', descendants=None, kids=[24923719], score=None, time=1603914915, title=None, item_type='comment', url=None, parent=24922796, text='The basic algorithm for reading Lisp is easy, because the read syntax is simple, and every operation has a word that can be looked up the index of a reference manual. Often, the word is alphabetic, rarely symbolic.<p>There is no ambiguity. When you&#x27;re researching what some Lisp word does, it is very clear from the nested parentheses in the code which parts of the program are direct arguments of that word, which parts are nested in those arguments, and which are entirely outside of that call to the word.<p>So if the documentation says that the word&#x27;s third argument has such and such a meaning, you can easily see in the program which expression corresponds to that argument. You know where that expression begins and ends, and that nothing else is part of the third argument.<p>The trick is that you must begin on the outside and work your way in, because the meaning of any expression depends on what it is enclosed in. Because of the uniform syntax, there are sometimes elements in an expression which look like forms being evaluated, but are in fact only fragments of the surrounding expression. So there is a difficulty in reading Lisp and it comes from not being able to grok some enclosed X, if you don&#x27;t know the enclosing Y.<p>If you don&#x27;t guess that <i>defclass</i> defines a class, and then ignore it and start reading the interior, then you might wrongly that <i>(defclass a (b c))</i> is calling somne function called <i>b</i>, with argument <i>c</i> rather than have the correct idea that <i>(b c)</i> are superclasses being inherited by <i>a</i>. You cannot just casually ignore the meaning of a form that you don&#x27;t know, and just read its interior naively.  This is the difficulty in reading Lisp: not having the vocabulary to know what &quot;part of speech&quot; are the constituents of a form, even though its structure is completely unambiguous: you know exactly which parts of the program are the constituents.<p>The shape of <i>(defclass a (b c))</i> is exactly the same as that of, say, <i>(setf a (b c))</i>. That shape is informative and helpful, but not with regard to the semantics. The number of expressions which can share this exact shape, yet have entirely different meaning from each other, including the model of evaluation. This is not true in languages that don&#x27;t have extensible syntax.<p>Lisp has a lot of unfamiliar vocabulary: <i>destructuring-bind</i>, <i>with-slots</i>, <i>rplacd</i>, <i>block</i>, <i>lambda</i>, <i>unwind-protect</i>, ... and without knowing some vocabulary item which appears in code, you can&#x27;t properly read it. If you ignore something that you don&#x27;t know and make a guess about how to read its interior, that can turn out to be spectacularly wrong.')