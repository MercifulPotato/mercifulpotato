Item(by='pron', descendants=None, kids=[24961695, 24961621], score=None, time=1604248280, title=None, item_type='comment', url=None, parent=24960476, text='&gt; Typically, these tools allow for end-to-end proof based on the actual code; they don&#x27;t require it.<p>TLA+ also allows for end-to-end proof, but it&#x27;s not primarily designed for it. Because those other tools are primarily designed for it but not for arbitrary-level specification, they are drastically more complicated. This is necessarily the case. To allow execution, you must separate your computation level from your specification level (e.g. there is a distinct, syntactic spec&#x2F;program or type&#x2F;object divide), but that&#x27;s not the case in TLA+. If you&#x27;re familiar with, say, type-theory-based proof assistants, TLA+ is analogous to being at the type level only (except with an infinite hierarchy in <i>both</i> directions).<p>In the time in took me to grasp Lean&#x27;s type-theoretic universal quantification I was writing specifications of large, real-world systems in TLA+; I still find it hard to explain the meaning of universe-polymorphic operators like `id`. Plus, few if any of those languages have model-checkers, which also have a generally and drastically better cost&#x2F;benefit than writing formal proofs. TLA+ has a very good proof assistant, but we rarely use them because writing a formal deductive proof after a successful model-checking is usually a terrible return on investment, unless your goal is publishing an algorithm rather than delivering a production system.<p>Due to the scale limitation of sound verification, a system primarily designed for arbitrary-level specification and verification is more widely applicable than a system primarily designed for end-to-end verification, although the latter is certainly valuable in niche circumstances. It is, therefore, unsurprising that TLA+ is more commonly used in the field on systems that are too big&#x2F;complex for feasible end-to-end verification (which is most &quot;ordinary&quot; software) than any of those primarily end-to-end tools. It is much easier to learn, especially for non-specialists, and thanks to the available model-checkers, it&#x27;s also much easier to get results with.')