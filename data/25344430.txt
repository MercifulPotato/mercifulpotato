Item(by='lmm', descendants=None, kids=None, score=None, time=1607431637, title=None, item_type='comment', url=None, parent=25344159, text='&gt; - Database transactions ensure that when you ask the database to modify X, it either happens in its entirety or it doesn&#x27;t. It&#x27;s not meant to prevent concurrent edits, it&#x27;s meant to keep the data in the database consistent.<p>It keeps the database consistent. But fundamentally that&#x27;s only worth something if you can use it to make things consistent for the user.<p>&gt; - CRDT&#x27;s allow user A and B to edit object X concurrently, because it&#x27;s mathematically proven that two instances of the CRDT can be merged later without conflict.<p>Right. But the way that works in practice is that your datastore needs to store both user A&#x27;s edit and user B&#x27;s edit and then handle that convergence, and if you use a datastore that&#x27;s actually designed for distributed use like Riak or Cassandra then it will give you the tools for doing that. An RDBMS simply can&#x27;t do that because it&#x27;s built around maintaining the illusion that there&#x27;s a single version of each row (even when it&#x27;s actually using MVCC behind the scenes). Yes, you can build your own CRDTs &quot;in userspace&quot; but you have to do things like use two tables to represent a 2P-set (two columns would be bad enough, but no, SQL databases don&#x27;t have collection column types so you really do have to create two extra tables for each set property you have), at which point the database won&#x27;t be giving you any help.<p>&gt; Add a column &quot;version&quot; to your table and when the user submits a change, include this version number in the change request. Then upon database UPDATE, check if the version in the DB still matches expectations. If it doesn&#x27;t you reject the UPDATE and you can report back to the user what happened. You could easily apply this logic using triggers which will ensure that no matter the source of the UPDATE statements, it will be a certainty older versions can&#x27;t overwrite newer versions.<p>That&#x27;s hacky and manual - you&#x27;re effectively duplicating something that the database itself is doing at a lower-level, so you could do it much more efficiently with a datastore that would just expose that to you. And it still doesn&#x27;t really give the behaviour you want - you don&#x27;t want to refuse to store the incompatible change, you want to save both versions and somehow merge them in the future (possibly by asking the user to do so); an approach that destroys data by default is not ideal.<p>Yes, databases are Turing-complete and you can build whatever you want in them, but if you don&#x27;t go with the grain of what the tools and built-in features expect then you&#x27;re giving up all the advantages of using that kind of database in the first place. You&#x27;re better off picking a datastore that has first-class support for being used in the kind of way you want to use it.')