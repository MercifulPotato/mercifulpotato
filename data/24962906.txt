Item(by='ordu', descendants=None, kids=[24969053], score=None, time=1604268033, title=None, item_type='comment', url=None, parent=24962210, text='I have a question about those state machine: did you tried to do it without goto with functions only? The idea is a straightforward one, just chuck all branches into functions and call functions instead of goto. Rust wouldn&#x27;t be happy with that, if you try to make branches into local functions, because they would access &quot;global&quot; mutable variables on stack. Borrow checker might misunderstand your intentions and go mad. But we could think a way around it, how about state as a struct-like variable passed by a mutable reference into inline functions?<p>Or maybe not functions, one might consider duplicating code. There is DRY principle, but there is WET principle[1] also. Both of them have their proponents, so at least they are not stupid. How WET shows itself in a highly-optimized programs? Did you try it? I have no link, and may be wrong, but I believe that John Carmack argued in a favor of WET, and I wouldn&#x27;t say that Carmack doesn&#x27;t bother with a program speed.<p>I mean, I&#x27;m not convinced, that goto is the game changer, I see other ways around the issue, which in some ways are superior to the solution using goto. So I&#x27;m not so sure that your way to use goto is not a misuse.<p><i>&gt; if a developer is already perfect with writing good code, but (s)he needs to do something special, like the state machine in the article, the restriction just makes the developer&#x27;s life harder.</i><p>The trouble is there are no developers who a perfect. So it is not intrinsically bad thing to make live of a developer harder by introducing restrictions. If it forces developer to codify more of his assumptions about his program, then it is harder to be imperfect.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Don%27t_repeat_yourself" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Don%27t_repeat_yourself</a>')