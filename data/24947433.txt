Item(by='smasher164', descendants=None, kids=None, score=None, time=1604096584, title=None, item_type='comment', url=None, parent=24946029, text='async&#x2F;await is really just another formulation of linked stack frames, where control is explicitly yielded. At the end of the day, the thread stack state needs to be reified somehow, and all of these approaches are equivalent in power. The only difference is that now you have a type system that delineates between functions that can and cannot be shuffled between kernel threads.<p>The benefits that Go (and potentially Loom) provide are with the scheduler. When Go code calls into other Go code, it&#x27;s fast because preemption points can be inserted by the compiler. The goroutine is parked when it is blocked (on I&#x2F;O or some foreign function), and in the slow path this logic is executed on a new kernel thread.<p>Although the Go approach involves more overhead in the slow path, wrangling blocking code to work with the scheduler has cross-cutting implications for library design. I.e, I don&#x27;t have to worry that a library I import that does file I&#x2F;O will pin my goroutine to a blocked thread by using a blocking syscall.')