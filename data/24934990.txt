Item(by='sea6ear', descendants=None, kids=None, score=None, time=1604001584, title=None, item_type='comment', url=None, parent=24934591, text='I&#x27;ve been on a bit of a lisp kick recently.<p>Coming across the description of fexprs in earlier (pre Common Lisp and Scheme) Lisp dialects was interesting to me since it I&#x27;m familiar with uplevel and upvar in Tcl, and appears that Tcl&#x27;s upvar&#x2F;uplevel is closely related to Lisp&#x27;s fexprs. It was interesting to see that fexprs basically give all of the power of macros, although possibly (probably?) at a performance cost due to compilation difficulties.<p>The obvious advantage of fexprs is that they are functions and therefore can be applied or passed along as functional arguments in ways that macros cannot.<p>I&#x27;ve been trying to understand why they were dropped from Common Lisp and the mainline Lisp descendants. From the comments I&#x27;ve seen in other locations, (and in the sibling linked paper) it seems that the performance issues of fexprs was a strong reason for the advocacy of dropping them (from Common Lisp especially). Some of the other online references that I&#x27;ve seen mention that perhaps fexprs would not continue to have the same degree of compilation problems in the modern lexically scoped Lisps that they had in the dynamically scoped earlier lisp dialects.<p>One of the things that was interesting about this fragment of document was that it seems to imply that fexprs are explicitly tied to the evaluation strategy, whereas it seems like maybe macros are less intimately tied to the direct structure of the evaluator.<p>As an aside, there are a couple of contemporary Lisp variants (PicoLisp and newLISP) that still maintain implementations of fexprs.')