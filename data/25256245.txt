Item(by='Jtsummers', descendants=None, kids=[25269819], score=None, time=1606756950, title=None, item_type='comment', url=None, parent=25251444, text='I suspect that thy learned these things, but it didn&#x27;t stick. From memory of 2018&#x2F;2019 things that the younger colleagues didn&#x27;t know (or didn&#x27;t know well enough to get without prompting):<p>- When to use CFG versus regex for parsing. Many inputs could be parsed with regexes if you made certain assumptions and got lucky. But CFGs were <i>much</i> easier for some.<p>- Shunting-yard algorithm. This came up, I think, in 2018.<p>- Using fast&#x2F;slow to detect cycles and cycle length (one step at a time versus two, when they collide you can determine that there is a cycle and then determine how long the cycle is). Most used a hash table&#x2F;map but this was not effective (due to RAM requirements) for some very large inputs. This actually comes up a few times. Variants of game of life, or just numeric processes.<p>- Multi-threading. It was <i>very</i> useful to implement the intcode VM using threads in 2019. Everyone who tried to juggle state and run multiple VMs at a time struggled when we later had to have a large number of VMs communicating with each other.<p>- Maybe not CS proper, but typically covered as part of a CS curriculum in a discrete math course. Several times problems related to modular arithmetic and permutations came up. If you understood them, the problem was tractable. If not, you struggled and maybe solved it but it wasn&#x27;t efficient.<p>- Various graph and search algorithms. Particularly A* and Dijkstra&#x27;s. Looking back, it seems there were a couple maze ones in 2019 and several more maze&#x2F;path finding ones in 2018.<p>- Sorting&#x2F;ordering of graph nodes, specifically topological sort. If you know what it is, it makes several of the problems much simpler over the years. I think it was specifically used in 2018.')