Item(by='TeMPOraL', descendants=None, kids=[25025686], score=None, time=1604841695, title=None, item_type='comment', url=None, parent=25025483, text='In context of terminals, if you want to see a modern API-based instead of app-based CLI experience, check out PowerShell. The underlying principle is that all commands like &quot;ls&quot; or &quot;ps&quot;[0] return their results as .NET objects, and not unstructured text. If you just call &quot;ps&quot; in the shell, you&#x27;ll get the default visual representation you&#x27;d expect - but you can also choose a different one (e.g. list view by Format-List, or filterable GUI table view with Out-GridView), but you can also then filter the objects by properties and call methods on them.<p>For example, to find and kill all instances of notepad.exe, you&#x27;d write:<p><pre><code>   Get-Process | ForEach-Object { if($_.ProcessName -eq &quot;notepad&quot;) { $_.Kill(); } }\n</code></pre>\nA bit verbose (and that&#x27;s generally a problem with day-to-day PowerShell usage), but relatively trivial to turn into a cmdlet and alias it to &quot;killall&quot;.<p>Of course, the above example was trivial, but the same principle works for more complex ones - instead of streams of text, you have streams of objects, which you can filter and run methods on, without doing any parsing.<p>--<p>[0] - Them being aliases to PowerShell&#x27;s Get-ChildItem and Get-Process, respectively.')