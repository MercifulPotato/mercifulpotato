Item(by='sdht0', descendants=None, kids=[24703829], score=None, time=1602027589, title=None, item_type='comment', url=None, parent=24693678, text='The other discussions have already pointed out some limitations in your interpretation (heh) of types.<p>I think the key difference between the annotations in Python and types in Java, or even more strongly in languages like Rust and Haskell, is how they are used in the language ecosystem. In Java and Rust, the types are cental to how programmers think in those languages. A large part of the dev cycle goes into ensuring the types are consistent. In python, these type annotations are a relatively recent addition that the community has not completely adopted yet.  A lot of real-world python code will have no types, thus the (3rd party) python type checkers will fail to ensure the benefits of having strong consistent types.<p>And how can we then justify &quot;types&quot; like Object in Java or Any in Rust? Well, sometimes we do want to write code where we want to tell the compiler to stop checking types. However, these are more of an escape hatch rather than a central part of the language ecosystem. As someone else already pointed out, the Java or Rust community does <i>not</i> go about writing code with only Object or Any, even though they can in principle. But in python, that&#x27;s what the community has been doing till now.<p>It goes the other way too. If the python community starts taking the type annotations seriously, it will start approaching the same usefulness as in these other static languages with good type systems. Then we can start expecting that the 3rd party library type annotations being accurate, which started this discussion in the first place.')