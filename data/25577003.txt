Item(by='dnautics', descendants=None, kids=None, score=None, time=1609289219, title=None, item_type='comment', url=None, parent=25576101, text='it&#x27;s pretty trivial to implement a deterministic fork&#x2F;join[0] in actors, mostly by using the strategy &quot;ignore messages&quot;.  Elixir does this with the Task.async&#x2F;1 function.<p><a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;Task.html#module-async-and-await" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;Task.html#module-async-and-await</a><p>[0] determinism can go out the window once there&#x27;s an error.  Can you safely say you know what happens in ruby if you are running async and one of your concurrently running async functions throws?<p>The nice thing in elixir there is zero ambiguity as to what happens if you have (N) async functions running and one of them crashes -- it brings down all of the other threads and triggers their respective resource cleanups in exactly the way that they do as actors, since Task is a fairly trivial wrapping of erlang&#x27;s actors.  (Or you have choices!!, you can async_nolink if you want your async function to plow forward even if its parent dies due to the crash of one of its siblings)')