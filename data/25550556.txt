Item(by='szarnyasg', descendants=None, kids=None, score=None, time=1609071831, title=None, item_type='comment', url=None, parent=25548095, text='Both SPARQL and Gremlin have been adopted to some extent. SPARQL is a W3C standard and Gremlin is reasonably well-specified (it has good documentation and a reference implementation), so it&#x27;s possible to implement a functionally correct SPARQL&#x2F;Gremlin engine with a reasonable development effort.<p>Gremlin&#x27;s main focus is defining traversal operations on property graphs. While it supports pattern matching [1], IMHO its syntax is not as clean as Cypher&#x27;s. Gremlin queries are also difficult to optimize: while it is possible to define traversal rewrite rules, they are more involved than relational optimization rules.\nThe fact that most open-source Gremlin implementations are focusing on distributed setups (e.g. a typical deployment of Titan&#x2F;JanusGraph runs on top of Cassandra) has also implications on single-machine performance, which certainly did not help the adoption of Gremlin -- but this is not necessarily the problem of the query language.\nOverall, Gremlin is great for workloads where complex single-source traversal operations do the bulk of the work but it&#x27;s less well-suited to global pattern matching queries such as the ones in the LDBC Social Network Benchmark&#x27;s BI workload [2].<p>SPARQL focuses on the graph problems of the &quot;semantic web&quot; domain, which include not only pattern matching but semantic reasoning&#x2F;inferencing. One can use it for pattern matching queries but with the following caveats:<p>- Its data model is based on triples so if one wants to return a node and its attributes (properties), one has to specify each of these attributes explicitly.<p>- On the execution side, returning these attributes might necessitate executing a number of self-join operations.<p>- Many SPARQL implementations also have performance limitations due to the extra complexity introduced by self-joins, lack of intra-query parallelism, etc.<p>The &quot;RDF* and SRARQL* approach&quot; is an initiative to amend the self-join problem by introducing nested triples in the data model. It&#x27;s currently being worked on by a W3C community group [3].\nSPARQL also has &quot;property paths&quot;, which allows regular path queries, i.e. traversals where the node&#x2F;edge labels confirm some regular expression (the &quot;property&quot; in &quot;property paths&quot; has nothing to do with &quot;property graphs&quot;).<p>SQL&#x2F;PGQ and GQL target the property graph data model and support an ASCII-art like syntax for pattern matching queries (inspired by Cypher). They also offer some graph traversal&#x2F;shortest path operations (including shortest path and regular path queries). Additionally, GQL supports returning graphs so it&#x27;s queries can be composed.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gremlin_(query_language)#Declarative_pattern_matching_traversals" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gremlin_(query_language)#Decla...</a><p>[2] <a href="https:&#x2F;&#x2F;ldbc.github.io&#x2F;ldbc_snb_docs&#x2F;workload-bi-reads.pdf" rel="nofollow">https:&#x2F;&#x2F;ldbc.github.io&#x2F;ldbc_snb_docs&#x2F;workload-bi-reads.pdf</a><p>[3] <a href="https:&#x2F;&#x2F;blog.liu.se&#x2F;olafhartig&#x2F;2019&#x2F;01&#x2F;10&#x2F;position-statement-rdf-star-and-sparql-star&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.liu.se&#x2F;olafhartig&#x2F;2019&#x2F;01&#x2F;10&#x2F;position-statement...</a>')