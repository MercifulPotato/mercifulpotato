Item(by='jlokier', descendants=None, kids=None, score=None, time=1608682725, title=None, item_type='comment', url=None, parent=25512780, text='&gt; Are you bored and want a fun new take on programming? Or are you truly, in practice, extremely dissatisfied with the current marketplace of C alternatives<p>I think the reason is something else: It&#x27;s not the demand that&#x27;s amazing, it&#x27;s the supply.<p>A lot of people like making languages, and full working environments to go with them.  It&#x27;s fun!  If you&#x27;re into that sort of thing, it might be the most attractive kind of project, with a kind of geek gravity that draws you in when you&#x27;ve got the bug.<p>A new language and its environment is an interesting exercise, even if it takes years.  It&#x27;s something to do to hone your craft.  It&#x27;s not particularly difficult, if you go for it, it just takes time.  You can add all those ideas you wish other languages had but never do.  Probably if you&#x27;re into making languages you have a lot of ideas like that.<p>There&#x27;s lots of interesting things to learn, lots of puzzles to solve, and then you have an artifact at the end which other people can appreciate.  They might even find it useful, which is another reward, another bit of satisfaction.<p>If that&#x27;s a major reason for new languages, why C-like?<p>I think C-like hits a design sweet-spot that is easy to understand and easy to branch out from.  But it&#x27;s also something you know other people are likely to understand and appreciate.  It&#x27;s not too exotic, at least at first glance.  With so much supply and a lot less demand, you want your language to be noticed, to be useful and seen as useful.  Being C-like boosts chances of acceptance as a language to take that bit more seriously.<p>I company I worked for a very long time ago wrote a hardware compiler, with a front-end language for hardware called Handel which was a DSL in Standard ML (great language. ML. by the way).<p>It was used, but it got more popular when they wrote a C-like front end and called it Handel-C.  There was no real difference to the language, and Handel-C was in many ways less powerful (because there was no ML with which to manipulate the syntax tree), but the C-like syntax made it a look familiar, and therefore marketable.')