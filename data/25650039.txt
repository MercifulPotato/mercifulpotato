Item(by='simpleguitar', descendants=None, kids=None, score=None, time=1609875923, title=None, item_type='comment', url=None, parent=25648570, text='Disclaimer: I wrote mostly Java for 10 years, and Go for about 5.<p>Go straddles an interesting space. Currently I work on a back-end data crunching software, distributed (running on hundreds or sometimes thousands of nodes), each node running 64 or 128 cores with 128 or 256GB RAM. The problem we solve is both IO, CPU, and memory bound. Anyway to look at it, it&#x27;s a hard problem.<p>The old version of this program was written in C. Then it was rewritten in Go.<p>The people who decided to switch to Go was looking for the following features:\n- Be able to manually lay out memory for performance. So not Java.\n- Mmap binding to file system, for performance.\n- More abstractions than C, for adding software features.\n- Cross platform. The program sometimes runs on Android and IOs.\n- Easy to learn for beginners. It&#x27;s not possible to only hire PhDs or C++ gurus.  - Easy to dig down into assembly, for performance.\n- GC doesn&#x27;t get in the way, for performance as well as adding features.<p>Maybe these days, C# might work? May Rust? But 6-8 years ago, Go fit the bill and it worked out very well. And the language doesn&#x27;t feel &quot;limited&quot; in any way. Yeah, I miss generics sometimes. Maybe error handling could be better? Sometimes I need to work around the GC. But day-to-day, I think I focus more on solving actual problems (performance bottlenecks, adding features), instead of pondering if I need to create another AbstractFactory, or tuning GC knobs, or figuring out which pointer type to use.<p>To me, Go feels very balanced. I can write python or Java like code and get decent performance. If I need more performance, I can dig down pretty deep make CPU work faster. The abstractions are light enough that a new person can figure out what&#x27;s going on and add features,  fix bugs, or improve performance.<p>I like Go.')