Item(by='brundolf', descendants=None, kids=[25625854], score=None, time=1609711810, title=None, item_type='comment', url=None, parent=25624874, text='Sure, but Rust takes implicity a lot further than most. Implementation details of a function call are one thing; applying an operator in the current context, or adding an invisible generic type (lifetime parameter) to the current context, are something else. I think one key difference is that the unknowns are <i>within</i> the actual code that you&#x27;re writing, not in places where you explicitly delegate to some other code to do something. The other key difference is that they&#x27;re highly irregular: they apply sometimes and don&#x27;t apply other times, which makes them hard to predict. The same syntax means one thing in one situation, and something different (or &quot;nothing&quot;, when it doesn&#x27;t compile) in another situation.<p>I guess I assumed there was some rustc compiler pass that would match certain patterns where stuff (like dereferences or lifetime parameters) has been omitted, and transform it into code where those things have been inferred and explicitly inserted. In which case it would theoretically be easy to skip that pass and turn those omissions into compiler errors.')