Item(by='Animats', descendants=None, kids=[25039630], score=None, time=1604948724, title=None, item_type='comment', url=None, parent=25037147, text='I&#x27;m ambivalent on this.<p>Right now, I&#x27;m writing something 3D game related. It needs considerable parallelism. The existing tool in this area is mostly single threaded, it&#x27;s a mess internally, and everyone who looks at it is scared to try to parallelize it.<p>So I&#x27;m writing in Rust. Safe concurrency is a plus. There are some other wins. You can be bolder about not copying things. When decoding an incoming packet with a lot of structure, I&#x27;m creating linked data structures where most of the big byte array stuff is borrowed from a packet buffer that went into the structure creator. No allocations; it&#x27;s all on stack. There&#x27;s no risk of someone using an item from one of those structures and keeping a reference to data that&#x27;s going to go away.  Wouldn&#x27;t dare do that in C++.<p>I get along with the borrow checker just fine. Once you realize that single ownership is a tree, it makes sense. It&#x27;s the type inference system that causes headaches. Rust has type inference in both directions. There are places where the result type influences what goes in. When the inference system guesses right, it&#x27;s great. When it can&#x27;t solve the problem on its own, trying to figure out what it wants is annoying. Go and C++ only have forward type inference; result types are computed by the compiler.<p>Rust is really a single assignment language, not a functional one. There&#x27;s a lot of &quot;let foo =&quot;, and not much &quot;let mut foo =&quot;. After a while, you get the idea that if you write &quot;let mut&quot;, you&#x27;re doing it wrong.  Single assignment has most of the benefits of functional, but without multi-line expressions that go on to infinity. Plus you&#x27;re not limited to a tree of results; you can have directed acyclic graphs, because you can usually re-use the value from a &quot;let&quot;.<p>The type of error objects is still a mess. Rust needs something like Python&#x27;s exception type hierarchy and a consistent way to convert special error types into more general ones. I notice there&#x27;s a Rust working group on error handling, again.<p>Rust needs a good book. Not &quot;The Rust Programming Language&quot;. That&#x27;s too hard for an introductory book and not detailed enough for a reference manual. A book by someone who didn&#x27;t develop the language is needed.<p>The library situation has improved quite a bit since the last time I tried Rust, a few years ago. Back then, finding a library to do HTTP was &quot;No, the one you&#x27;re using is obsolete, use ...&quot;. Now I&#x27;m finding usable libraries for obscure things like analyzing files from &quot;tcpdump&quot;.<p>They missed a chance on something important to 3D work. Each library which uses 3D vectors has its own structure for them. There&#x27;s a proposal for a common format, &quot;mint&quot;, but it&#x27;s not getting traction. This is an old headache in 3D programs with components from different sources. Back when I was developing ragdoll physics, I had four 3D vector types in one C++ program.')