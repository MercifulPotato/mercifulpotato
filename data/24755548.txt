Item(by='MaulingMonkey', descendants=None, kids=None, score=None, time=1602517190, title=None, item_type='comment', url=None, parent=24753562, text='Rust &quot;doesn&#x27;t&quot; have function overloading, but it effectively does:<p><pre><code>  fn main() {\n      foo((42));\n      foo((12.0, 13.0));\n  }\n\n  pub fn foo(args: impl FooArgs) { args.exec() }\n  pub trait FooArgs { fn exec(self); }\n  impl FooArgs for u32 { fn exec(self) { println!(&quot;A number: {}&quot;, self) } }\n  impl FooArgs for (f32, f32) { fn exec(self) { println!(&quot;{} x {} = {}&quot;, self.0, self.1, self.0 * self.1) } }\n</code></pre>\n<a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b726f7f6e21c250aba62f9fe61e6d5a0" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;editio...</a><p><pre><code>  A number: 42\n  12 x 13 = 156\n</code></pre>\nUsually you won&#x27;t abuse tuples quite like this, but it&#x27;s an option.  The same pattern of using traits - without the tuples - is more common [1].  Or if you need variadic functions, typically you&#x27;d resort to a macro instead.<p>[1]: <a href="https:&#x2F;&#x2F;medium.com&#x2F;@jreem&#x2F;advanced-rust-using-traits-for-argument-overloading-c6a6c8ba2e17" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@jreem&#x2F;advanced-rust-using-traits-for-arg...</a>')