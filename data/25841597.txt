Item(by='wahern', descendants=None, kids=None, score=None, time=1611107181, title=None, item_type='comment', url=None, parent=25837940, text='The creator of Ruby admitted that implicit local was &quot;the single biggest design flaw in Ruby.&quot; <a href="http:&#x2F;&#x2F;blade.nagaokaut.ac.jp&#x2F;cgi-bin&#x2F;scat.rb&#x2F;ruby&#x2F;ruby-talk&#x2F;42266" rel="nofollow">http:&#x2F;&#x2F;blade.nagaokaut.ac.jp&#x2F;cgi-bin&#x2F;scat.rb&#x2F;ruby&#x2F;ruby-talk&#x2F;...</a><p>I think what most people really want is to avoid implicit scoping altogether. But then you need a special keyword to access global environment symbols. That&#x27;s a little awkward in Lua because the &quot;require&quot; function used to import libraries is just a regular function in the global environment table (which is otherwise just a plain table), and so `local string = require&quot;string&quot;` works because undeclared symbols become an index into the global environment table. And libraries like &quot;string&quot;, &quot;math&quot;, etc are also usually prepopulated.<p>A lot of people do `require&quot;strict&quot;` (or if you want to be pedantic, `local _ENV = require&quot;strict&quot;`) early in a Lua source file, which modifies the global environment to throw a runtime error instead of returning `nil` for undefined symbol lookups. (There are various versions of the strict library floating around; it doesn&#x27;t come with stock Lua.) If would be better if this was a static check in the language itself. That, too, isn&#x27;t a difficult addition (it could even be added to a strict library, or you could overload require), but defaults matter when it comes to nitpicking languages, I guess.<p>Maybe in Lua 5.5 or 6.0 this change will be made. Though, statically-checked scoping isn&#x27;t as as straight-forward as you&#x27;d think given Lua&#x27;s common use as a fast-and-loose sandbox for running user code, ad hoc business logic modules, etc, where a lot of preamble boilerplate can seem overly complex. But the upside to Lua having a loose commitment to backward compatibility is that it&#x27;s much easier to experiment with these sorts of changes and keep iterating until they nail down a solid construct. For example, compare setfenv&#x2F;getfenv in Lua 5.1 with the lexical _ENV construct in Lua 5.2.')