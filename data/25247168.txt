Item(by='pmeunier', descendants=None, kids=[25247981], score=None, time=1606676738, title=None, item_type='comment', url=None, parent=25246929, text='&gt; I&#x27;d especially be interested in examples regarding multiple channels &#x2F; branches (one development and several production branches), and then backporting a fix into older versions.<p>I&#x27;ve been maintaining to versions of my SSH library for Rust, called Thrussh (<a href="https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;thrussh" rel="nofollow">https:&#x2F;&#x2F;nest.pijul.com&#x2F;pijul&#x2F;thrussh</a>).<p>For some context, the Rust asynchronous ecosystem is undergoing a change, with a fundamental library called Tokio going from version 0.2 to 0.3. Some crates have made the change, others haven&#x27;t. So if you&#x27;re like me, and some of your code implements both an SSH server and an HTTP server on the same event loop, you might want to stay with Tokio 0.2 (since Hyper, the main HTTP library, hasn&#x27;t published the move yet), while allowing others to benefit from all the bugfixes you find, and start transitioning now.<p>The cool thing about doing this in Pijul is, you can work on your Tokio-0.2 version, and push your changes directly to your Tokio-0.3 version without having to care about cherry-picks, merges and rebases explicitly. Do this locally, test, publish.<p>&gt; How is the workflow if this applies cleanly to rel.22, but not rel.21 anymore? What if the same conflict happens in rel.20, rel.19 and rel.18?<p>Good question. In Pijul, conflicts occur between changes (not between commits or states), and are solved by changes. This is in contrast with e.g. `git rerere`, since the solution to a conflict depends only on the changes that introduced it, not on anything else. This means that once you&#x27;ve solved the conflict in rel.21, you can push it to rel.20, rel.19 (it&#x27;s the exact same change, with the same hash).<p>&gt; What if the conflict resolution changes every single line, but I still want to record that, &quot;Yes, this fix is also in rel.17, even though it does not look like it&quot;.<p>Excellent question. Two answers:<p>- If you&#x27;re really doing this, then your intention cannot really be guessed from your change, which sort of defeats the point of using changes, and you will get another conflict. If you fix that conflict again though, that fix will apply to any &quot;branch&quot; (Pijul users call these &quot;channels&quot; because they are not exactly the same as Git branches) that has the two changes.<p>- There is ongoing research to extend the theory to allow large restructuring of code to commute with edits to that code. Note that no other system handles that well: Git and Mercurial don&#x27;t even consider commutation (but their merge heuristics handle refactoring correctly sometimes), Darcs doesn&#x27;t do it at all. Since our goal is to get something that works 100% of the time, we have to be a bit more careful.')