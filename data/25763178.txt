Item(by='hajile', descendants=None, kids=[25767157, 25763369], score=None, time=1610551853, title=None, item_type='comment', url=None, parent=25762672, text='&gt; The main difference is that RISC-V is a lot more modular, so it&#x27;s going to be difficult to distribute binaries for but more flexible if you&#x27;re doing something completely vertical. Also a lot of the modules have bundle relatively common&#x2F;easy instructions with niche&#x2F;difficult ones. E.g. multiply with divide.<p>I don&#x27;t think it&#x27;ll be worse than ARM and it&#x27;s decidedly better than x86.<p>There are SEVEN <i>major</i> revisions of ARMv8. Then there&#x27;s v8-R, v8-M, and additional 32-bit variants of each instruction set in addition to both ARMv7 and ARMv6 which also still ship billions of chips per year. Oh, and under pressure from companies, ARM also allows custom instructions now. Those aren&#x27;t just theoretical either -- Apple at least added a ton of custom matrix instructions to the M1.<p>For x86, supporting only semi-recent processors (2006 Core or greater) leaves you still checking for support for: SSE3, SSE4, SSE4.1, SSE4a, SSE4.2, SSE5, AVX, AVX2, AVX512, XOP, AES, SHA, TBM, ABM, BMI1, BMI2, F16C, ADX, CLMUL, FMA3, FMA4, LWP, SMX, TSX, RdRand, MPX, SGX, SME, and TME. That&#x27;s 29 instruction sets and not all of them have use on both Intel and AMD chips.<p>RISC-V seems at least that cohesive. If you&#x27;re shipping a general purpose CPU, you&#x27;ll <i>always</i> have mul&#x2F;div, compression, fusion (not actually instructions), privilege, single precision, double precision, bit manipulation, and probably a few others.<p>Where you&#x27;ll run into mul&#x2F;div missing or no floats are microcontrollers or &quot;Larabee&quot; style GPU cores. In all of those cases, you&#x27;ll be coding to a very specific core, so that won&#x27;t really matter.<p>Thankfully, we&#x27;ve had ways to specify and&#x2F;or check these kinds of things for decades.')