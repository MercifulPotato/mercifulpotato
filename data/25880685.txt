Item(by='torginus', descendants=None, kids=None, score=None, time=1611391004, title=None, item_type='comment', url=None, parent=25879869, text='Well, this is tricky.<p>I&#x27;m assuming you&#x27;re trying to allocate a large array, since otherwise it&#x27;s pretty difficult to have a large object in .NET.<p>One thing you can do is use Marshal.AllocHGlobal (this is essentially an unsafe malloc) which gives you a pointer (not reference) to a chunk of unmanaged memory, which you can access with unsafe pointer. This is pretty messy.<p>The other, more modern thing is using MemoryPool&lt;T&gt;, which gives you a manually managed &quot;array&quot; (Span, .NET-s version of slice) of structs of type T, which you can manually release after you&#x27;re done with them.<p>The third option, is just allocate it using new and abandon all references, the create a different copy. The memory pressure of allocating a big object, will probably trigger a GC. This is dangerous, since there can still be dangling references to the old object (that might not even present in the source, but compiler generated), leading you to retain both the old and new memory.')