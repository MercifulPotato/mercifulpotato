Item(by='eyelidlessness', descendants=None, kids=None, score=None, time=1610854811, title=None, item_type='comment', url=None, parent=25801288, text='&gt; Thank you for elaborating! I remember I was really curious when they introduced them, since there had been a lot of focus in the community on stateless functional components before, and the benefits of their purity. Now suddenly they were renamed to function components instead, and as you say, are no longer guaranteed to simply be a function of their props.<p>Thank you for engaging thoughtfully and with some curiosity! I&#x27;m sorry it took me a while to come back to this, but I do want to answer because it&#x27;s worth exploring.<p>&gt; What problems do you feel the current hooks API is causing, that could be solved with a different API?<p>Frankly, once you introduce hooks, you can no longer trust that a function is a function. You can&#x27;t <i>call</i> it without knowing whether it&#x27;ll cause side effects. You have to know the hooks internals to know what those side effects actually do, and you have to know the internals of <i>every component</i> before you consider calling a component. It&#x27;s a breaking change of huge consequence, with no type-level (whether you&#x27;re using TypeScript or JSDoc or just web docs) indication of what a thing is. So now, <i>allllll</i> functions are not functions.<p>A way a different API could solve this would be to make the construction and render explicitly separate (just like all of the pre-hooks state APIs for react). Modifying the example from the hooks intro:<p><pre><code>        import React, { useState } from &#x27;react&#x27;;\n\n        function Example() {\n          const [count, setCount] = useState(0);\n\n    ---  return (\n    +++  return () =&gt; (\n            &lt;div&gt;\n              &lt;p&gt;You clicked {count} times&lt;&#x2F;p&gt;\n              &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n                Click me\n              &lt;&#x2F;button&gt;\n            &lt;&#x2F;div&gt;\n          );\n        }\n</code></pre>\nThis isn&#x27;t where I&#x27;d dust off my hands and call it a day. A more ideal hooks API, with chaining and composition in mind, would not just produce free-floating values and state update functions. You could instead wrap props and essentially have a component-local API for a props&#x2F;state combination where the component still is just a function of props:<p><pre><code>    import React, { useState } from &#x27;react&#x27;;\n\n    function Example(props) ({\n      const setCount = useState(props, (props, state) =&gt; {\n        ...props,\n        count: state,\n      }));\n\n      return (props) =&gt; (\n        &lt;div&gt;\n          &lt;p&gt;You clicked {props.count} times&lt;&#x2F;p&gt;\n          &lt;button onClick={() =&gt; setCount(props.count + 1)}&gt;\n            Click me\n          &lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n      );\n    }\n</code></pre>\nA comment adjacent to yours (which I don&#x27;t have time or patience to respond to right now) asked how another API would deal with hooks which are instantiated per-render (which... I guess exists but it&#x27;s mind-boggling because it&#x27;s not how hooks are explained to the public), take either of these examples and nest them for each state&#x2F;props case you&#x27;d encounter. This is the Python principle of <i>explicit is better than implicit</i> (which means, yeah, writing a bit more code might be a pain in the butt but you&#x27;ll understand what&#x27;s happening), and in FP is referred to as referential transparency (&quot;If I call f(x) -&gt; y, y will always be the same for the same x&quot;).')