Item(by='vinay_ys', descendants=None, kids=[24954253], score=None, time=1604170378, title=None, item_type='comment', url=None, parent=24949322, text='I think we don&#x27;t learn and codify standards from our mistakes in software engineering in the same way we have learnt in civil, mechanical or electrical engineering. I guess it could be because we think the consequences in software mistakes are not as serious&#x2F;permanent as they are in those other engineering fields.<p>Also the speed of innovation&#x2F;change has been super fast compared to those other fields. But I doubt if we can keep up this pace of innovation for much longer without the software engineering process becoming the bottleneck.<p>I came across a startup of 50 people in which there were 4-5 different application stacks for server-side micro services – each team had decided to go their own way and there were no standard end to end observability and release management tooling and they were struggling to debug a latency issue – which itself was happening because they didn&#x27;t have proper parallelization of RPCs and didn&#x27;t have proper timeouts, isolation etc. This problem of not following well-understood design patterns, or keep stumbling into known anti-patterns (and worse yet failing to recognize them as such even after repeated punishing failures&#x2F;outages) – I&#x27;ve seen various versions of this at different sized companies (from multi-million to multi-billion $$ ones).<p>And in each case, all decision makers didn&#x27;t know&#x2F;have standardized terminology to talk about things, what should have been easy conversations were seemingly unnecessarily hard about what&#x27;s good design pattern vs anti-patterns etc. I can&#x27;t help but think that this is uniquely a software engineering discipline problem.')