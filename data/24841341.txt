Item(by='marmaduke', descendants=None, kids=[24841636], score=None, time=1603221689, title=None, item_type='comment', url=None, parent=24841280, text='Thanks for the example, I am interested in trying these packages in the future, but here&#x27;s a current snippet of ISPC,<p><pre><code>    varying float aff[nc], xh[nn], wij[nn], x[nc];\n    varying int ih[nn];\n    uniform int t_ = t &amp; (nl - 1);\n    uniform float k;\n    for (int j=0; j&lt;nc; j++)\n        aff[j] = 0.0f;\n    for (int j=0; j&lt;nn; j++)\n        for (int i=0; i&lt;nc; i++)\n            aff[i] += wij[j] * shuffle(xh[j], ih[j]);\n    for (int i=0; i&lt;nc; i++)\n        x[i] = 0.1f*(x[i] + x[i]*x[i]*x[i]&#x2F;3.0f + k*aff[i]);\n    for (uniform int i=0; i&lt;nn; i++)\n        xh[i] = insert(rotate(xh[i], 1), 0, extract(x[i&#x2F;nl], i&amp;(nl-1)));\n</code></pre>\nJust being able to absorb SIMD lanes into the notion of varying vs uniform makes this easy to write, not to mention SIMD operations like shuffle or rotate.  In Julia or Numba or CUDA I have to index into arrays, ensure compatible data layout etc.  I imagine this could be done with more macrology in Julia, but again why not use something which already works.')