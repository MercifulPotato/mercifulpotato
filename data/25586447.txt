Item(by='haberman', descendants=None, kids=[25586639], score=None, time=1609364266, title=None, item_type='comment', url=None, parent=25585778, text='&gt; Google&#x27;s implementations, at least C++ and Java, are a bunch of bloated crap (or maybe they&#x27;re very good, but for a use case that I haven&#x27;t yet encountered).<p>As someone who has been working on protobuf-related things for &gt;10 years, including creating a size-focused implementation (<a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;upb" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;upb</a>), and has been working on the protobuf team for &gt;5 years, I have a few thoughts on this (thoughts are my own, and I don&#x27;t speak for anybody else).<p>I think it is true that protobuf C++ could be a lot more lean than it currently is (I can&#x27;t speak to Java as I don&#x27;t work on it directly). That&#x27;s why I created upb to begin with.  But there&#x27;s also a bit more to this story.<p>The protobuf core runtime is split into two parts, &quot;lite&quot; and &quot;full&quot;.  If you don&#x27;t need reflection for your protos, it&#x27;s better to use &quot;lite&quot; by using &quot;option optimize_for = LITE_RUNTIME&quot; in your .proto file (<a href="https:&#x2F;&#x2F;developers.google.com&#x2F;protocol-buffers&#x2F;docs&#x2F;proto#options" rel="nofollow">https:&#x2F;&#x2F;developers.google.com&#x2F;protocol-buffers&#x2F;docs&#x2F;proto#op...</a>).  That will cut out a huge amount of code size from your binary.  On the downside, you won&#x27;t get functionality that requires reflection, such as text format, JSON, and DebugString().<p>Even the lite runtime can get &quot;lighter&quot; if you compile your binary to statically link the runtime and strip unused symbols with -ffunction-sections&#x2F;-fdata-sections&#x2F;--gc-sections flags.  Some parts of the lite runtime are only needed in unusual situations, like ExtensionSet which is only used if your protos use proto2 extensions (<a href="https:&#x2F;&#x2F;developers.google.com&#x2F;protocol-buffers&#x2F;docs&#x2F;proto#extensions" rel="nofollow">https:&#x2F;&#x2F;developers.google.com&#x2F;protocol-buffers&#x2F;docs&#x2F;proto#ex...</a>).  If you avoid these cases, the lite runtime is quite light.<p>However, there is also the issue of the generated code size.  Unlike the runtime, this is not a fixed cost, but is proportional to the number of messages you use. If you have a lot of messages it can quickly dwarf the size of the runtime.  For this reason, C++ also supports &quot;option optimize_for = CODE_SIZE&quot; which uses reflection-based algorithms for all parsing&#x2F;serialization&#x2F;etc instead of using generated code.  This means you pay the fixed size hit from linking in the full runtime, but the generated code size is much smaller.  On the downside, &quot;optimize_for = CODE_SIZE&quot; has a severe ~10x speed penalty for parsing and serialization.<p>I have long had the goal of making <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;upb" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;upb</a> competitive with protobuf C++ in speed while achieving much smaller code size.  With the benefit of 10 years of hindsight and many wrong turns, upb is beginning to meet and even surpass these goals.  It is an order of magnitude smaller than protobuf C++, both in the core runtime and the generated code, and after some recent experiments it is beginning to significantly surpass it in speed also (I want to publish these results soon, but the code was merged in this PR: <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;upb&#x2F;pull&#x2F;310" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;upb&#x2F;pull&#x2F;310</a>).<p>upb has downsides that prevent it from being fully &quot;user ready&quot; yet: the API is still not 100% stable, there is no C++ API for the generated code yet (and C APIs for protobuf are relatively verbose and painful), it has a bunch of legacy APIs sitting around that I am just on the verge of being able to finally delete, and it doesn&#x27;t support proto2 extensions yet. On the upside, upb is 100% conformant on every other protobuf feature, it supports reflection, JSON, and text format, but also lets you omit these if you don&#x27;t want to pay the code size.<p>I hope 2021 is a year when I&#x27;ll be able to publish more about these results, and when upb will be a more viable choice for users who want a smaller protobuf implementation.')