Item(by='jnxx', descendants=None, kids=[24817354], score=None, time=1603020970, title=None, item_type='comment', url=None, parent=24809283, text='&gt; C++ can be vastly simpler and more readable, while retaining 100% control over memory and layout.<p>But unlike assembly, you don&#x27;t have control over CPU flag registers and special instructions. Can you explain why and when, exactly, 100% control over memory is needed? Outside of OS kernels, high-frequency trading engines, and real-time control systems? If using assembly is too costly, why is using C++ economical?<p>And, do you really have control what happens at the machine level? Second and third level caches, hyperthreading, multicore, out-of-order execution, CPU affinity, NUMA, TLB, virtual memory, all that stuff, there is nothing in C++ which controls that.<p>And I would even argue that this <i>in most cases</i> is a good thing, because unless you are writing an OS kernel, it is none of your programs business - what it should focus on is the logical flow of the computation.<p>And this is what modern optimizing compilers do: They transform expressions into machine code which has an equivalent observable effect, and executes that what the programs specifies as fast and efficient as possible. Fi you write:<p><pre><code>  int a = 0;\n  for (int i=0; i &lt; 100; i++)\n    a += i;\n  printf(&quot;a = %i\\n&quot;, a);\n</code></pre>\nyou could be <i>tempted</i> to believe that the CPU executes increments on a 32-bit or 64-bit register. This is not what happens on a modern optimizing compiler. Look at that link (which uses -O3):<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,j:1,lang:___c,selection:(endColumn:6,endLineNumber:2,positionColumn:6,positionLineNumber:2,selectionStartColumn:6,selectionStartLineNumber:2,startColumn:6,startLineNumber:2),source:&#x27;&#x2F;&#x2F;+Type+your+code+here,+or+load+an+example.%0Aint+f(int+num)+%7B%0A++++int+a%3B%0A++++for+(int+i%3D0%3B+i+%3C+100%3B+i%2B%2B)%0A+++++++a+%2B%3D+i%3B%0A++++return+a%3B%0A%7D&#x27;),l:&#x27;5&#x27;,n:&#x27;0&#x27;,o:&#x27;C+source+%231&#x27;,t:&#x27;0&#x27;)),k:50,l:&#x27;4&#x27;,n:&#x27;0&#x27;,o:&#x27;&#x27;,s:0,t:&#x27;0&#x27;),(g:!((h:compiler,i:(compiler:cg102,filters:(b:&#x27;0&#x27;,binary:&#x27;1&#x27;,commentOnly:&#x27;0&#x27;,demangle:&#x27;0&#x27;,directives:&#x27;0&#x27;,execute:&#x27;1&#x27;,intel:&#x27;0&#x27;,libraryCode:&#x27;1&#x27;,trim:&#x27;1&#x27;),fontScale:14,j:1,lang:___c,libs:!(),options:&#x27;-O3&#x27;,selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:&#x27;5&#x27;,n:&#x27;0&#x27;,o:&#x27;x86-64+gcc+10.2+(Editor+%231,+Compiler+%231)+C&#x27;,t:&#x27;0&#x27;)),k:50,l:&#x27;4&#x27;,n:&#x27;0&#x27;,o:&#x27;&#x27;,s:0,t:&#x27;0&#x27;)),l:&#x27;2&#x27;,n:&#x27;0&#x27;,o:&#x27;&#x27;,t:&#x27;0&#x27;)),version:4" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;#g:!((g:!((g:!((h:codeEditor,i:(fontScal...</a><p>- the compiler reduces it to a single move and return instruction. This is not specific to C++ compilers - a good Lisp or D or Ocaml compiler will to the same, while managing the memory for you.<p>Now, control is, as in psychology, a double-edged sword. It allows you to take influence, but too much control is not a good thing, as the example of micro-management shows. In the case of the compiler, if you control too much, it interferes with the compiler&#x27;s job to transform your expression into efficient equivalent machine code. The fine-tuned code you write today might be optimized for some of the modern hardware, but while it will probably still compile, it might be much less than optimal 15 years from now, and in the case of C++ without the compiler having any leeway to optimize it because you told it way to explicitly what to do.<p>It also interferes with <i>your</i> job to produce clear, valid, and readable algorithms and code. And the numerous controls which C++ gives make for a very broad and very fuzzy interface, which in turn makes it <i>more difficult</i> to produce good code and <i>hard</i> to do that in a way which is both reliable, strictly valid, and easy to understand. The issue with non-ASCII characters in words in the original article is a good example. Here is another one:<p>Take<p><pre><code>  include &lt;vector&gt;;\n  include &lt;algorithm&gt;;\n\n  std::vector&lt;bool&gt; vb(100);\n  \n  std::fill(vb.begin(), vb.end(), false);\n</code></pre>\nis this valid code?<p>The C++ reference says:<p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;container&#x2F;vector_bool" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;container&#x2F;vector_bool</a><p>&quot;Since its representation may be optimized, std::vector&lt;bool&gt; does not necessarily meet all Container or SequenceContainer requirements. For example, because std::vector&lt;bool&gt;::iterator is implementation-defined, it may not satisfy the LegacyForwardIterator requirement. <i>Use of algorithms such as std::search that require LegacyForwardIterators may result in either compile-time or run-time errors.</i> &quot;<p>Do you think this is funny?')