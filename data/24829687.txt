Item(by='lerptime', descendants=None, kids=None, score=None, time=1603134179, title=None, item_type='comment', url=None, parent=24829404, text='No you&#x27;re very wrong.<p>&gt;No, one kind of technical debt arises that way. Not the only kind. There&#x27;s another kind that arises when everything is in such small pieces that nobody can tell how the pieces relate to each other. You can easily understand each piece, but you have to go through a chain of a bazillion function calls to see what&#x27;s actually going on.<p>All this logic must exist regardless of whether it&#x27;s coupled or uncoupled. You do not alleviate the logical burden by coupling logic together or uncoupling the logic. If you call this &quot;technical debt&quot; then you cannot get rid of it. Why even call it debt then as logic is intrinsic to application.<p>In fact decoupling logic can improve readability as it marks each piece of logic with a contextual function name. Either way you do not alleviate complexity by coupling logic. You alleviate this complexity problem by providing logical layers, using namespaces, and using good function naming.<p>Coupling logic into Objects does nothing objectively as it does not eliminate complexity it only makes sure that the complexity is LESS modular.<p>Let&#x27;s be clear though. I am saying that the lower levels of your application should be ALL uncoupled logic. Then you build logical layers on top of your primitives that consists of compositions of your logic that build higher and higher. So a person on layer 5 only needs to go to layer 4 to understand it, and does not need to go to layer 1 to understand every primitive.<p>&gt;This is like economists, who have correctly predicted nine of the last two recessions. Sure, you&#x27;re prepared for when the change comes (if you can find where to make it - see above). You&#x27;ve also prepared for all the changes that never come. That&#x27;s rather wasteful.<p>Analogies don&#x27;t offer proof of an argument. Additionally it&#x27;s not a good analogy. Economists don&#x27;t completely understand what causes recessions and how to prevent them. We do, however, completely understand the difference between uncoupled logic and coupled logic.<p>&gt;Sure, it may. And when that happens, we&#x27;ll decouple it. And in the meantime, we&#x27;ll enjoy the coupling that, at the moment, is the correct thing.<p>This is the main point of tech debt. It is hard to decouple. You can have all logic decoupled at the lowest layer and still have everything be readable. I think the previous sentence is just a type of programming you haven&#x27;t dealt with. You&#x27;ve never wrote a program with decoupled logic that was readable. Think deeper. There is no reason why coupled logic should be more readable then decoupled logic. The Logic still exists either way, you either compose two modules and give it a name or you don&#x27;t even use modules shove all your logic into a module with a single name.<p>&gt;See, this is all in the context of SOLID, the very first piece of which is &quot;Single Responsibility&quot;. We don&#x27;t couple things on a whim.<p>The problem is OOP does this all the time. It couples state with logic. These two things should be uncoupled.')