Item(by='jerf', descendants=None, kids=None, score=None, time=1604682779, title=None, item_type='comment', url=None, parent=25008884, text='&quot;Mathematical proofs are only applicable where their assumptions are valid. So why would we believe that the where memory isn&#x27;t infinite (everywhere in practice) that Turing&#x27;s halting analysis is applicable?&quot;<p>Because adding the assumption in that memory is finite doesn&#x27;t make the analysis easier, it makes it <i>harder</i>. There&#x27;s a reason the abstract mathematical model assumes infinite memory; it isn&#x27;t because the abstract mathematical model can assume into existence, so, you know, why not, it&#x27;s to <i>simplify</i> it. Now in addition to all the other things the mathematical proof has to worry about, it has to be constructed in such a way that if at any point memory is exceeded, it also &quot;halts&quot;. That is <i>way</i> easier said than done.<p>As a homework exercise, try to take the halting problem proof and update it to include the possibility that either the halting-detection machine or the machine it is simulating (within the boundaries of the halting-detection machine&#x27;s resources!) runs out of memory. Pro-tip: If you think you cracked it in a couple of minutes, you did not. For instance, now rather than just waving at the fact the halting-detection machine is running a Universal Turing machine that simply has some &quot;linear&quot; factor of expansion in memory usage and&#x2F;or runtime and not worrying since you have infinite amounts of both, now your proof is going to be intimately concerned with the details of exactly <i>how</i> the universal turing machine is encoded. What you end up with at the end won&#x27;t be some neat claim about how the halting problem is impossible, you&#x27;re going to end up with some rather complicated contingent claim with terms that will include specific details about the size of the encoding and the amount of memory given to the detection machine.<p>If you do this work honestly and thoroughly, you&#x27;ll quickly learn that adding finiteness of resource doesn&#x27;t make the problem <i>more</i> tractable. Rather than a cute little statement about the halting problem, you&#x27;ll end up with an incredibly complicated statement with dozens of terms in it about what the detection machine can and can not do, and the resulting mathematical statement will be much harder to use.<p>&quot;This completes in O(2^N) time where N is the size of the memory.&quot;<p>In other words, our computers are finite state machines, which is basically true, so attack them with finite state machine tools. The problem is that even if your &quot;finite state machine&quot; you&#x27;re modeling is, say, a Commodore 64, and even if you ignore external input and just simulate the machine itself, you have an intractable problem on your hands. The problem grows exponentially as you add <i>each individual bit</i>. Modern computers have a lot more <i>bits</i> than a Commodore 64. This turns out not to be a useful approach.<p>If you&#x27;re going to go this route, what you&#x27;re looking for are sub-Turing programming languages [1] that allow you to write programs in a reduced-power environment that allows more useful assertions to be made. If you are legitimately interested in this, there&#x27;s a lot of research occurring on the fun fringes of programming language research. But... I can tell you that they are certainly far from a magic wand either. At a minimum, it requires a huge mindset change, and it is very difficult to fit even some common problems&#x2F;algorithms into the requisite constraints. And &quot;completes in a finite period of time&quot;, even if you can prove it, can be a rather vague promise to make.<p>[1]: Example from a quick google: <a href="http:&#x2F;&#x2F;ainfosec.github.io&#x2F;crema&#x2F;" rel="nofollow">http:&#x2F;&#x2F;ainfosec.github.io&#x2F;crema&#x2F;</a>')