Item(by='josevalim', descendants=None, kids=None, score=None, time=1610652444, title=None, item_type='comment', url=None, parent=25780314, text='Correct. You can&#x27;t add new syntax to Elixir either.<p>FWIW, the meta-programming models are very distinct. Elixir&#x27;s is based on AST and it works at compile-time (like Lisp but without reader macros). For example, imagine you want to do your html markup in Elixir, you could do this (but don&#x27;t!):<p><pre><code>    html do\n      title &quot;hello world&quot;\n\n      body do\n        ...\n      end\n    end\n</code></pre>\nIn the above, `html` would be a macro that looks at the structure of the code and transforms it into something at compilation time. The macro must exist before being invoked and it has to literally surround the code it changes. Once the code compiles, you can&#x27;t change it.<p>Ruby&#x27;s meta-programming is runtime-based. So the same example above would likely be implemented by calling methods on an object, either pre-defined ones or using method_missing, as you execute the code. In Ruby you can also define (or redefine) methods at any time and it affects the whole runtime.<p>Both languages also have a similar ability to meta-program a class (in Ruby) or a module (in Elixir). Think Rails&#x27; resource macro in a router. But Elixir modules are closed, in contrast to Ruby classes. Many times this is what people refer to as DSLs, even though the term DSL in itself is more general. Python has similar abilities too.<p>PS: you are certainly aware of the Ruby bits but I went for completeness to be a reference for others. :)')