Item(by='pdimitar', descendants=None, kids=[24981928], score=None, time=1604406912, title=None, item_type='comment', url=None, parent=24977612, text='Yep, I completely get the &quot;the grass is NOT greener on the other side&quot; sentiment. I&#x27;ve been a victim of it many times and I am much more careful these days.<p>&gt; <i>I love OCaml is well, and most of your points could be reduced to simply &quot;it&#x27;s lacking manpower&quot; (Scala is lacking it too).</i><p>For the better or the worse, this is literally the #1 priority one has to have before trying to technically evaluate a language &#x2F; framework these days. Otherwise you get sucked on a joyful ride at the end of which you find lack of employability. :(<p>I personally <i>much</i> prefer OCaml&#x27;s syntax but since Rust has much more mindshare and is mostly serving the same niche (with GC being the apples-to-oranges comparison here), I preferred to work with Rust. I still would like to work with OCaml but the odds are stacked against the financial incentives of doing so.<p>&gt; <i>Because all of the &quot;why is stdlib vs. Core vs. Batteries and Async vs. Lwt still an issue&quot; we have in C, C++ and many other popular languages too, but it&#x27;s not a big issue. People complain on meson&#x2F;cmake&#x2F;autotools&#x2F;boost&#x2F;glib&#x2F;qt but not leave for some reason.</i><p>Sure, many other languages suffer from that but it&#x27;s still a very good ideal to strive for -- namely have very few (ideally one) ways of doing things. I personally look for such languages &#x2F; frameworks and sadly they are very few and far between (Elixir and Clojure come to mind as refreshing exceptions and even they don&#x27;t follow it everywhere).<p>---<p>In the end, we all do this for money. If I could work without charging for it then I&#x27;d likely know more languages and even work more overall, but it&#x27;s not the reality we are living in currently.')