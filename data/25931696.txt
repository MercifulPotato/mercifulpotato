Item(by='benlivengood', descendants=None, kids=None, score=None, time=1611771399, title=None, item_type='comment', url=None, parent=25930177, text='Safe client-side SQL sounds like what the author wants.<p>* Consistency when fetching data: define a UI that matches a particular SQL view.<p>* Request batching: It&#x27;s probably not hard to send deltas on a large view with server-side support for sessions.<p>* Avoiding network waterfalls: basically the definition of a SQL view, with some session management to de-duplicate traffic when updating the view.  A lot of clients support batching queries.<p>* UX when fetching data: this seems entirely like an oversite of some UI packages, but when all the other points line up there are very distinct points in application flow when the UI will know a query and potential update is in progress.<p>* Colocation: the definition of a view is necessarily local.<p>* File size: SQL is pretty lightweight on the schema details in results<p>* Type safety: SQL doesn&#x27;t support dependent types, but e.g. postgres is pretty type-y<p>* Versioning: no explicit support in SQL but for changes to the UI a new view can be created. For changes to the data model a compatible change to the view can be committed in the same transaction as the data model change.<p>* Realtime updates: the glaring hole in the glory of SQL.  You&#x27;ll have to do some user-defined triggers server-side to support this.<p>* Consistency when updating data: the relational model with constraints enforces this<p>* Optimistic updates: if the theoretical differential view update described above exists then this is pretty trivial.  Compare local and remote deltas when refreshing the view and indicate to the user the expected state that wasn&#x27;t committed.<p>* Request queueing: this one seems to be more of a data model problem.  If the data model approximates a state machine and queries are on transitions then yes, they need to be serialized.  But why not do complex updates all at once with a multi-statement update transaction that commits or fails atomically?<p>* UX when updating data: presumably a UI tied to a single view is easier to indicate busy-ness for.  If an update transaction is in flight, display a spinner.  When it fails or commits display an OK or error.<p>* Durability when updating data: this could almost certainly be improved for most sql clients.  However, idempotence is definitely covered by conditional update transactions.<p>* Type safety: user defined types if necessary but constraints are where a lot of the type-safety happens in SQL.<p>* Versioning: backward-compatibility by updating mutable views in the same transaction as data model changes.  Forward-compatibility by rendering directly from the view that&#x27;s returned, not expecting any particular view.')