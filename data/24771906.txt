Item(by='scottlamb', descendants=None, kids=[24772164, 24771942], score=None, time=1602635196, title=None, item_type='comment', url=None, parent=24762840, text='One of these things is not like the others.<p>Slabs and bump&#x2F;arena allocators have significant advantages over just using the system allocator. You use them in a constrained way which allows for a more efficient implementationâ€”slabs by having only one size of allocation and bump&#x2F;arena by freeing things all at once (or maybe in LIFO order if you&#x27;re fancy). Thus, they make sense in a lot of performance-oriented programs.<p>A buddy allocator has no such constraints. It&#x27;s general-purpose. Thus, there&#x27;s no obvious opportunity to do better than the system allocator. And it&#x27;s pretty wasteful if your allocations aren&#x27;t close to sizes of 2 (internal fragmentation =&gt; wasted RAM and cache). If you have a system allocator available that uses say size classes instead, I have no idea why you&#x27;d prefer to use a buddy allocator. For that matter, if your system allocator is a buddy allocator (or more likely: some kind of hybrid), I have no idea why you&#x27;d prefer your own implementation.<p>One constraint might be that you promise your buddy allocator&#x27;s usage is single-threaded, and thus no locking is necessary. But a production-quality system allocator likely uses thread-local or CPU-local caches to accomplish much the same thing, so I don&#x27;t think this constraint buys you much efficiency.<p>If you&#x27;re implementing a bare-metal system on a microcontroller and need a very small memory allocator implementation for light usage, implementing your own buddy allocator might make sense. But that&#x27;s a lot of caveats...')