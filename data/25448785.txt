Item(by='Slackwise', descendants=None, kids=None, score=None, time=1608153274, title=None, item_type='comment', url=None, parent=25448326, text='&gt; I personally have found FP hard to debug.<p>I can very honestly say pure functions are the <i>easiest</i> thing to debug and test: Inputs, outputs. Trivial for unit testing.<p>I can&#x27;t speak for MLs&#x2F;Haskell, but debugging pure functions in any language tend to just be glancing at the stack trace, seeing the values on the stack going in, and then seeing where the unexpected wrong output came out, and being fairly confident knowing the issue is going to be in that function.<p>&gt; The &quot;naked state&quot; of imperative programming<p>Are we including OO in this definition? The fundamental design pattern of OO is to <i>encapsulate</i> state. It&#x27;s anything but naked, always being wrapped in object instances, only accessible via getters&#x2F;setters, scattered into a million pieces across many instances of the system.<p>Conversely, Clojure has <i>the most naked state ever</i>. There&#x27;s usually little to no state, and the <i>current state</i> is right there on the stack. Most simple Clojure programs <i>with</i> state have a singular atom aptly named &quot;state&quot; which is passed around, easy to inspect and modify as it&#x27;s a simple data structure.<p>I think, ultimately, there&#x27;s a common conflation of &quot;Functional Programming&quot; meaning &quot;Declarative Type-Driven Functional Programming&quot;, when the reality is there are alternatives to ML&#x2F;Haskell, aside from applying Functional patterns in &quot;non-functional&quot; languages.')