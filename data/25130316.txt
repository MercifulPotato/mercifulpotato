Item(by='arcticbull', descendants=None, kids=[25135159], score=None, time=1605649458, title=None, item_type='comment', url=None, parent=25128642, text='Putting on my embedded engineering hat, it&#x27;s not that I <i>wanted</i> the bare minimum it&#x27;s that I couldn&#x27;t afford anything more than the bare minimum.<p>I couldn&#x27;t afford abstractions, memory safety guarantees, algebraic data types, generics, pattern matching, thread data safety (at least in the context of interrupts). The languages that had these things were hulking languages with giant runtimes and exactly zero support for embedded development. Not to mention no vendor toolchains.<p>Rust supports all these things, with no allocator, no standard library, and often with zero additional cost -- in terms of compute and in terms of memory. Then, being built on LLVM means that the vendor toolchain support is quickly becoming a non-issue. I suspect we&#x27;ll start to see more and more of Rust in embedded, but only time will tell.<p>And as others have called out, Rust has very few OOP features like an optional notion of a `self` on a function bound to a structure. There&#x27;s no classes, no subclassing, no message passing, no inheritance at all (structure, interface or implementation), limited dynamic dispatch, no polymorphism.')