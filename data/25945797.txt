Item(by='segfaultbuserr', descendants=None, kids=[25951264], score=None, time=1611856630, title=None, item_type='comment', url=None, parent=25944866, text='I&#x27;ll simply ask gdb to dump its memory, then I extract my command from its coredump. For example,<p><pre><code>    $ bash\n    $ echo $$\n    477609\n    $ while true ; do echo 1 ; echo 2&gt;&#x2F;dev&#x2F;null ; sleep 30 ; done\n    \n    # From now on, this command cannot be stopped, and by now\n    # the text has been overwritten by new output...\n</code></pre>\nOpen a root shell, install gdb.<p><pre><code>    # gcore 4077609\n    0x00007ae1b321ceca in wait4 () from &#x2F;lib64&#x2F;libc.so.6\n    Saved corefile core.4077609\n    [Inferior 1 (process 4077609) detached]\n\n    # strings core.4077609 | grep while\n    ......(omit huge amount of text)......\n    while true ; do echo 1 ; echo 2&gt;&#x2F;dev&#x2F;null ; sleep 30 ; done\n</code></pre>\nStudying the source code and calling C functions in a debugger, like the author did here, is a clever and accurate way to solve this problem and deserves its pages in sysadmin folklore, but I think my brute-force approach, although boring, is equally acceptable. It&#x27;s also safer, a wrong function call won&#x27;t crash the program. If I can not find what I need immediately, analyzing the coredump safely in a debugger (perhaps on my own machine with more devtools installed, with a cup of tea) is also an option for me.')