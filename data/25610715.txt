Item(by='shalabhc', descendants=None, kids=None, score=None, time=1609566237, title=None, item_type='comment', url=None, parent=25609186, text='If we start with CVS in the 90s (incidentally my first version control system as well) everything looks like great progress.<p>But if we actually look at what was around, both in theory and practice, CVS was a giant leap backwards.<p>Examples:<p>1. Smaltalk ENVY (1990s, I think?): Automatic class&#x2F;method level versioning on save. Programmable, introspectable history to easily build CI type stuff. See user comments here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15206339" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15206339</a>.<p>&gt; you could easily introspect every change to code and by combining introspection of classes and methods quickly determine which changes were happening where. We built a test framework that could list the changes since the last run, then compute dependencies and run an appropriate selection of test cases to check. This cut down test time by 90%<p>2. DOMAIN Software Engineering Environment (1980s): a distributed source control and config system where the provenance of built artifacts to source files was maintained. More than that:<p>&gt; DSEE can create a shell in which all programs executed in that shell window transparently read the exact version of an element requested in the user&#x27;s  configuration thread. The History Manager, Configuration Manager, and extensible streams mechanism (described above) work together in this way to provide a &quot;time machine&quot; that can place a user back in a environment that corresponds to a previous release. In this environment, users can print the version of a file used for a prior release, and can display a readonly copy of it. In addition, the compilers can use the &quot;include&quot; files as they were, and the source line debugger can use old binaries and old sources during debug sessions. All of this is done without making copies of any of the elements.\n(from Computer-Aided Software Engineering in a Distributed Workstation Environment, 1984, <a href="http:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;viewdoc&#x2F;download?doi=10.1.1.575.8272&amp;rep=rep1&amp;type=pdf" rel="nofollow">http:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;viewdoc&#x2F;download?doi=10.1.1.575...</a>)<p>Note again, the above is from 1984.<p>3. PIE reports (1981): Describes a model of &quot;contexts&quot; and &quot;layers&quot; (roughly analogous to branches and revisions) for nodes (not files) that version methods, classes, class categories and configurations. On merging work from multiple authors:<p>&gt;Merging two designs is accomplished by creating a new layer into which are placed the desired values for attributes as selected from two or more competing contexts.<p>(from An Experimental Description Based Programming Environment By Ira Goldstein and Daniel Bobrow, 1981, <a href="http:&#x2F;&#x2F;esug.org&#x2F;data&#x2F;HistoricalDocuments&#x2F;PIE&#x2F;PIE%20four%20reports.pdf" rel="nofollow">http:&#x2F;&#x2F;esug.org&#x2F;data&#x2F;HistoricalDocuments&#x2F;PIE&#x2F;PIE%20four%20re...</a>)')