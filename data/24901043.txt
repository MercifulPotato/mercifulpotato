Item(by='chubot', descendants=None, kids=[24901743, 24902958], score=None, time=1603744415, title=None, item_type='comment', url=None, parent=24900705, text='The wasm paper covers these issues, and is short and pretty readable:<p><a href="https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?cluster=14979605902538775118&amp;hl=en&amp;as_sdt=0,5&amp;sciodt=0,5" rel="nofollow">https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?cluster=14979605902538775...</a><p>tl;dr security introduces a lot of design constraints that RISC V doesn&#x27;t have.<p>section 2.3 on structured control flow:<p><i>WebAssembly represents control flow differently from most stack machines. It does not offer simple jumps but instead provides structured control flow constructs more akin to a programming language. This ensures by construction that control flow cannot form irreducible loops, contain branches to blocks with misaligned stack heights, or branch into the middle of a multi-byte instruction. These properties allow WebAssembly code to be validated in a single pass, compiled in a single pass, or even transformed to an SSA-form\nintermediate form in a single pass.</i><p>Also, wasm is a &quot;Harvard architecture&quot; rather than von Neumann (separate address space for code and data), also for security reasons:<p>section 2.2:<p><i>Linear memory is disjoint from code space, the execution stack, and the engineâ€™s data structures; therefore compiled programs cannot corrupt their execution environment, jump to arbitrary locations, or perform other undefined behavior. At worst, a buggy or exploited WebAssembly program can make a mess of the data in its own memory.</i><p>However, wasm also leaves some things to be desired security wise.  Buffer overflows in C are still buffer overflows once you compile to wasm, and can be chained in to JS exploits.<p><a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;comments&#x2F;icb9ve&#x2F;everything_old_is_new_again_binary_security_of&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;ProgrammingLanguages&#x2F;comments&#x2F;icb9v...</a><p>If you try to use RISC V in the same contexts, you&#x27;ll have the same problems.  If you have an additional layer of process sandboxing, then those could be mitigated.  But then RISC V is not a wasm replacement.<p>Although maybe wasm is hopeless for C code, so you need more sandboxing anyway, so then it&#x27;s on par with RISC V... interesting question.')