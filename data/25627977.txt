Item(by='tmsh', descendants=None, kids=None, score=None, time=1609735252, title=None, item_type='comment', url=None, parent=25620256, text='Having gone through Rustlings these past few days (via <a href="https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;best-way-to-learn-rust-programming&#x2F;47522&#x2F;3" rel="nofollow">https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;best-way-to-learn-rust-program...</a>), I feel like the speed of the Rust compiler has gotten a lot faster since I looked at it a few years ago.<p>And the compiler messages (once you get the hang of it; and the investment in learning the syntax is so trivially worth it in the long run) are so much richer and more helpful than other languages. So it really does &quot;feel&quot; like a REPL or most of the way there as a REPL (and I have one of the few wikis at our work advocating for Common Lisp that I wrote a year ago, and still actively follow Clojure groups, etc.).<p>It&#x27;s just Rust starts and runs so fast (and Cargo makes it easy and clear like Go); so that being able to re-run periodically really fast is like a REPL. Yeah there&#x27;s no retained state or ability to keep a REPL running for days, etc. (though Tmux.. and <i></i>nix as a repl.... more on that later), but it&#x27;s reached a point where compilation is an OOM faster than before, so the loop of: read, eval, print now can  include the compiler.<p>And you get this amazing boost where if you&#x27;re operating e.g. on large data (if you&#x27;re a senior engineer, like Dan Luu blogs <a href="https:&#x2F;&#x2F;danluu.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;</a>, you&#x27;re often scanning codebases or log files or other metadata to answer questions); so being able to tweak and re-run even without caching at OOM faster speeds than other languages is wonderful.<p>I can create complex refactoring scripts in Rust on GBs of data and constantly re-run them until it&#x27;s just right.<p>To my knowledge you can learn the ins and outs of CL or Rust; both fairly specific-knowledge-heavy languages at first (Rust with some syntax, CL with its non-uniformity of functions). It just seems like Rust is the future. It sort of &quot;merges&quot; dynamic languages with REPLs and *nix (with tmux) as the REPL. Pretty exciting.<p>And if someone wrote a CL-like REPL with something like SLIME&#x2F;SLY for debugging for Rust it&#x27;d be kind of game over. And I could see that coming in the next few years (<a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;evcxr" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;evcxr</a> seems cool, but perhaps the dependency on Jupyter complicates it a bit).')