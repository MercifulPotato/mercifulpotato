Item(by='dmitriid', descendants=None, kids=None, score=None, time=1604775230, title=None, item_type='comment', url=None, parent=25015907, text='&gt; They were not in spec because the spec doesn&#x27;t say anything over which medium<p>If not the spec, then original documentation. GET is a late add-on.<p>&gt; How do cache headers not work well with GraphQL GET requests?<p>In REST:<p>- a resource is uniquely identified by it&#x27;s URI<p>- when the server sends back cache headers, any client in between (any proxies, the browser, any http clients in any programming language etc.) can and will use these cache headers to cache the request<p>In GraphQL GET:<p>- <a href="http:&#x2F;&#x2F;myapi&#x2F;graphql?query={user{id,name}" rel="nofollow">http:&#x2F;&#x2F;myapi&#x2F;graphql?query={user{id,name}</a>} and <a href="http:&#x2F;&#x2F;myapi&#x2F;graphql?query={user{name,id}" rel="nofollow">http:&#x2F;&#x2F;myapi&#x2F;graphql?query={user{name,id}</a>} are two different requests<p>- it gets worse for more complex queries, especially if they are dynamically constructed on the client<p>- each of those is viewed as a separate query with separate caching<p>- cache normalisation and query normalisation are a thing in the graphql world (and non-existent in REST) because of that.<p>That&#x27;s a yet another layer of complexity that you have to deal with<p>&gt; And what exactly are those benefits? I&#x27;m here defending GraphQL yet none of the downsides of REST are being taken into account.<p>I wish anyone was willing to discuss the downsides of GraphQL. Bashing REST is the norm, but GraphQL is the holy grail that accepts no criticism.<p>Benefits of REST over GraphQL, off the top of my head:<p>- it&#x27;s HTTP, plain and simple. So everything HTTP has to offer is directly available in REST. See this HTTP decision diagram [1]<p>- caching doesn&#x27;t require you to normalise and unpack every single request <i>and</i> response just to figure out if something is cached<p>- You know your requests, so you can provide optimised queries, resolution strategies, necessary calls to external services as required by the call<p>&gt; There are tools like Postgraphile that solve this. It converts your GraphQL query into one efficient database query.<p>I&#x27;d love to see that proven for any sufficiently complex and large database.<p>&gt; And what prevents anyone from hammering a REST API?<p>No ad-hoc queries prevents anyone from hammering a REST API that you can specifically tune to the specific request and data you need.<p>GraphQL requires significantly more care <i>especially</i> if you&#x27;re not running it on just one database. And even then, oops, joins: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25014918" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25014918</a><p>And we&#x27;re back to requiring the graphql server to be able to limit recursion depth, query complexity, etc. etc.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;for-GET&#x2F;http-decision-diagram&#x2F;tree&#x2F;master&#x2F;doc" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;for-GET&#x2F;http-decision-diagram&#x2F;tree&#x2F;master...</a>')