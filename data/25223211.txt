Item(by='jaysachs', descendants=None, kids=None, score=None, time=1606421791, title=None, item_type='comment', url=None, parent=25222044, text='(kythe googler here)<p>Like beliu said, the Kythe schema is far richer; it has fully abstract semantic layer in the graph, and is a superset of what can be represented with LSIF. It&#x27;s not tied to specified text regions -- there are representations of symbols&#x2F;functions&#x2F;classes&#x2F;variables&#x2F;types that do have pointers to&#x2F;from text regions.<p>Note that because of the richness and abstractness, it&#x27;s theoretically feasible to drive much more than code navigation from the Kythe graph.<p>And yes, the open source is just part. The large scale pieces are basically (1) do instrumented build (2) run through Kythe indexers (3) post-process output for serving.<p>The Kythe OSS project offers solutions for (2) for C++&#x2F;Java&#x2F;Go&#x2F;Typescript&#x2F;protobuf (and early Rust support). We do have plans to open source support for at least some other languages at some point in the future. (Hedging as best I can here.) Note that the best candidates for Kythe indexing are those languages that admit solid static analysis.<p>(1) is inextricably tied to the build system. Bazel support should be nearly turnkey; other systems require more (maybe significantly more) work.<p>There&#x27;s not-full-scale support for (3) available. (Clearly we use something far more sophisticated internally.) While we&#x27;d like to see this fleshed, expansion of that will depend on non-trivial community contributions.')