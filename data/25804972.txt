Item(by='qayxc', descendants=None, kids=[25805583, 25806335, 25809064], score=None, time=1610827222, title=None, item_type='comment', url=None, parent=25804688, text='&gt; My reasoning here is that understanding a computer at this level really helps understand programming, and perhaps more importantly the translation between what you want a program to do and how the computer would actually do it.<p>This logic would&#x27;ve worked in 1985 and maybe, just maybe until 1993. Modern CPUs cannot be programmed at the level that TTL provides. The µArch itself has long since become an abstraction in and of itself.<p>Depending on the instruction set, there&#x27;s often no way to predict beforehand how certain data- and code paths will behave. That&#x27;s why modern compilers use optimisation techniques such as profile guided optimisation.<p>If you think that certain µArchs are easier to understand in that regard than others (e.g. x86 vs ARM), think again. There&#x27;s inaccessible embedded hardware [0], and SoCs hidden behind proprietary RTOSes [1] that prevent direct access.<p>Detailed knowledge about building the hardware is therefore only of very limited use in real-world applications; unless you plan to become a firmware-, driver-, or compiler developer.<p>Even in the embedded world, data sheets can be deceiving and ultimately knowing your (compiler-) toolchain and knowing how to test the behaviour in practise is far more valuable.<p>General knowledge should be required, yes, but going so far as to build an actual computer &quot;from scratch&quot; isn&#x27;t as helpful as it might seem.<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25801500" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25801500</a>\n[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;VideoCore" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;VideoCore</a>')