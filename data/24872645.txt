Item(by='gregjor', descendants=None, kids=None, score=None, time=1603479445, title=None, item_type='comment', url=None, parent=24871348, text='Much of the discussion and worry about technical debt stems from a few fallacies programmers seem to fall into:<p>1. Some objectively &quot;right&quot; or &quot;best&quot; way to write software exists. We refer to &quot;patterns&quot; and &quot;best practices&quot; as if those had the force of science behind them, even though at the same time we can&#x27;t, as a profession, agree on what we mean.<p>2. Code we (or someone else down the road) has to maintain wasn&#x27;t written correctly or perfectly in the first place. Programmers tend to hate maintenance work.<p>3. We imagine that we could write the perfect program if only our managers and customers didn&#x27;t impose time and budget constraints, or interfere with their stupid product and marketing directives.<p>4. Failing to write perfect code that lasts forever indicates a failure on the part of the programmer or the team.<p>5. Perfectionism (a symptom of obsessive-compulsive behavior) and the increasing worry among programmers about how others perceive and critique their code.<p>Writing perfect code that requires minimal maintenance in the future would require knowing that future, and all of the changes to requirements and constraints that will happen during the lifetime of the code. We can only work with the requirements we know, and those we can reasonably anticipate. Trying to code for requirements we don&#x27;t have is usually called &quot;overengineering,&quot; which means something else in other engineering contexts (as a few other commenters pointed out).<p>I have worked in software development for 40 years so I know that almost no one likes doing maintenance work, especially on someone else&#x27;s code, and especially with languages and tools no longer in fashion. Maintenance programming is often given to new hires and junior programmers, while the senior developers get to write new code and play with the latest toys. This class division among programmers, often expressed in terms of what makes a programmer junior or senior, gets exacerbated by the personal quality of programming. Programming is a craft, not a science, not even engineering, but we forget that and try to express aesthetic preferences in terms of objective quality, even when we don&#x27;t have agreed-upon ways to measure objective quality of code.<p>Most software has a short lifespan, which means the &quot;technical debt&quot; will disappear when the code gets rewritten or replaced by a SAAS product or the requirements change. Bridges are expected to stand for decades or even centuries. Jumbo jets have lifespans measured in decades. Very few software projects will stay in use that long. I routinely work on web sites that will stay online for less than a year, because they support short-term marketing goals. American companies have an average lifespan of 18 years, and startups are more likely to go out of business (or get acquired) than to stay in business for even a few years, so focusing on building the equivalent of the Great Pyramid in code at a startup or small company in order to avoid &quot;technical debt&quot; is almost always wasted effort.<p>Businesses factor maintenance into the lifetime cost of software just like they factor maintenance (and depreciation) into the cost of buying a fleet of trucks or a truckload of copying machines. It&#x27;s the programmers who impose unrealistic goals of no&#x2F;low maintenance and frame that inevitable maintenance work as a failure of the original design or implementation, i.e. technical debt.<p>We should try to do our best work, to make code that works (i.e. meets requirements and doesn&#x27;t suffer from preventable bugs), and we should try to anticipate likely changes and make those easy for the next programmer. We should stop imagining a perfectly right way to write code, and stop thinking that maintenance work is beneath us, or a sign that the last team didn&#x27;t know what they were doing.<p>I think programmers would enhance their value and learn a more realistic (and maybe humble) approach to their craft if they didn&#x27;t think of programming as an isolated activity disconnected from the business and customers&#x2F;users their code is meant to serve.<p>James Joyce wrote “What makes most people’s lives unhappy is some disappointed romanticism, some unrealizable or misconceived ideal. In fact you may say that idealism is the ruin of man, and if we lived down to fact, as primitive man had to do, we would be better off....” Joyce wasn&#x27;t talking about programming, but I try to keep that in mind when balancing technical decisions against the larger set of business and customer concerns.')