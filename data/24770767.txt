Item(by='dragontamer', descendants=None, kids=[24771153, 24770815], score=None, time=1602626048, title=None, item_type='comment', url=None, parent=24762840, text='One more allocator to mention:<p>* Fixed size allocator<p>If you don&#x27;t need multiple sizes (like malloc(size)), then a fixed-size allocator is significantly simpler to implement, to the point of absurdity.<p>Step 1: Put all valid memory locations into a stack.<p>Step 2: alloc with stack.pop();<p>Step 3: free with stack.push();<p>The end. You get memory locality, cache-friendliness, O(1) operations, zero external fragmentation. The works. Bonus points: stack.push() and stack.pop() can be implemented with SIMD with help of stream-compaction (<a href="http:&#x2F;&#x2F;www.cse.chalmers.se&#x2F;~uffe&#x2F;streamcompaction.pdf" rel="nofollow">http:&#x2F;&#x2F;www.cse.chalmers.se&#x2F;~uffe&#x2F;streamcompaction.pdf</a>), and can therefore serve as a GPU-malloc as long as one-size is sufficient.<p>--------------<p>The only downsize of &quot;fixed size&quot; allocation is the significant amount of internal fragmentation per node. (Ex: if you only use 8-bytes per node, your 64-byte reservation is mostly wasted). But if you&#x27;re making a custom-allocator, fixed-size is probably one of the easiest to implement in practice.<p>-------------<p>You can extend this to multithreaded operations by simply using atomic-swap, atomic-and, and atomic-or across a shared bitset between threads. 1-bit per fixed-size block. (bit == 1 means something has been alloc(). bit == 0 means something is free()). The stack.push() and stack.pop() operations can run thread-local.<p>I recommend 64-bytes or 128-bytes as your &quot;fixed size&quot;, because 64-bytes is the smallest you get before false-sharing becomes a thing.<p>---------<p>If you have a fixed-size allocator but need items to extend beyond a fixed-size array, then learn to use linked lists.')