Item(by='dragontamer', descendants=None, kids=[25764401], score=None, time=1610547851, title=None, item_type='comment', url=None, parent=25758982, text='&gt; An x86 instruction can theoretically have an unbounded number of prefixes<p>All x86 instructions are strongly bounded by 15 byte lengths, otherwise processors throw an exception.<p>I just searched StackOverflow: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;23788236&#x2F;get-size-of-assembly-instructions&#x2F;23843450#23843450" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;23788236&#x2F;get-size-of-ass...</a><p>Just as I expected: finite-state machine used to decode. Now write a FSM-compiler (which is an undergrad-level project), to automatically parallelize the implementation.<p>The parallelization step is probably Master&#x27;s level, but a very advanced undergrad student can probably accomplish it: since all the individual elements are undergrad projects (Kogge-stone applied to associative operators, finite-state machine compiler &#x2F; regular expressions)<p>The overall process is also documented by Intel in their Opcode map: <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;manuals&#x2F;64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents...</a><p>As a FSM, verification is simple. Just generate all x86 instructions (there are a finite number of them after all), and ensure your FSM properly goes through all of them.')