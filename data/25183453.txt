Item(by='ksaj', descendants=None, kids=None, score=None, time=1606104134, title=None, item_type='comment', url=None, parent=25182266, text='Is it really evolving when any given offspring is likely to crash the environment? It would take way too many iterations to finally achieve offspring that can reproduce since there is no built-in method of finding out if it does &quot;something&quot; well, and then letting that something evolve.<p>The idea is there, but there is the missing concept of &quot;fitness,&quot; as one major example of a necessary function for evolution. Random mutations alone do not result in evolution (although it is an important &#x2F; mandatory step).<p>Since it takes a human to determine whether any of the thousands and brazillions of output files actually work (and possibly restart the shell or reboot the system), and there is no method of measuring functional improvement, it is more of a lottery than anything. And if you find one that does work, which you must do by running it individually or debugging it, you can&#x27;t let that program evolve into a new branch of the family tree. So, your program doesn&#x27;t actually seem to have any evolution occurring.<p>For example, and this might seem off topic or just plain impossible for just a moment, but if you look into it, you&#x27;ll see the connection: the Library of Babel[1] spawns every bit of code that your program spawns, but in MIME format. As a bonus, there is a ROT13 encoded version of every MIME version of your program&#x27;s potential output as well. And there is an English man page for every one of the programs you can find in these formats if you search long enough. Nobody would call this evolution, because that&#x27;s just how pseudo-randomness and true randomness work. And basically how your program works.<p>I&#x27;d even hazard to say that Library of Babel not only already has a fully functional version of your program in it, it has many more advanced versions of it that do output code that evolves and allows them to spawn and continue evolving beyond a single iteration, on their own.<p>Oddly, that makes Library of Babel significantly more efficient than your program, because you can also find a swedish man page for each of them, too. And it can output ports for <i>any</i> platform without requiring a different initial executable (seed). Some versions of the code will even compile without warnings!<p>Don&#x27;t get me wrong. I like the idea of what you&#x27;re doing. But the description is not what it is doing in its current iteration. Maybe you can evolve it to, though. It&#x27;s a good philosophical project, but it&#x27;s got a ways to go to fit the description it&#x27;s been given.<p>Your program could theoretically spawn a program that reproduces the code that creates the Library of Babel. BUT you wouldn&#x27;t have a way of knowing even if you were close, let alone if you got it spot on. And it would certainly take an infinite number of monkeys to test the code to see if it does the job or not, and some of them would still find a version of it already in the Library of Babel.<p>I think you&#x27;d be interested in Artificial Life (alife). It&#x27;s basically what your program is nodding towards, but not fully approaching. Check out this particular area of alife, Evolutionary Computation[2].<p>[1] <a href="https:&#x2F;&#x2F;libraryofbabel.info&#x2F;bookmark.cgi?mertyild" rel="nofollow">https:&#x2F;&#x2F;libraryofbabel.info&#x2F;bookmark.cgi?mertyild</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Evolutionary_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Evolutionary_algorithm</a>')