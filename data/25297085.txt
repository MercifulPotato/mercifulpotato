Item(by='jandrewrogers', descendants=None, kids=None, score=None, time=1607039194, title=None, item_type='comment', url=None, parent=25295627, text='What the paper describes is roughly a software implementation of the Cray MTA[1] supercomputing architecture -- each CPU had 128 threads per core. The ill-fated Cray XMT was the inspiration for applying this technique to databases on arbitrary CPU architectures many years ago.<p>I once emulated the exotic XMT threading behavior and memory model in software on x86 using coroutines, which had the advantage of not requiring me to shell into the supercomputer to test my code -- developer convenience. It turned out that the XMT idiomatic C++, which is strange looking and normally runs poorly on ordinary CPUs, ran faster on this emulator on x86 than the actual XMT CPU. While the XMT CPUs had unusual architectural features that could not be emulated in software (e.g. the XMT CPU knows precisely which threads are stalled on a per clock cycle basis), x86 silicon was so much more advanced at the time that naively scheduling around stalls by inference had higher performance even after the occasional cache miss. Furthermore, this way of designing code greatly improved performance on x86-based supercomputers compared to more conventional multithreading. It changed the way we designed the software<p>At the time, there were a few people straddling the supercomputing and database worlds, which was how the &quot;software XMT architecture&quot; discovery bled over into database engine design. It is more difficult to do robustly in software but it worked really well and you can&#x27;t beat the cost.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cray_MTA" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cray_MTA</a>')