Item(by='Const-me', descendants=None, kids=[25196397], score=None, time=1606204930, title=None, item_type='comment', url=None, parent=25190921, text='&gt; Every other OS and languages have tried their own variant of the libdispatch and from what I have read they all failed to some extent.<p>LibDispatch is Apple&#x27;s re-implementation of SubmitThreadpoolWork WinAPI, introduced in Windows Vista 3 years before libdispatch. Thread pools work better in Windows because OS kernel support.<p>In libdispatch and similar cross-platform libraries, OS kernel is unaware of the thread pool. The kernel implements individual threads and schedules them fairly, the rest of the code is user mode.<p>Windows has I&#x2F;O completion ports (IOCP) in the kernel since forever, more specifically since NT 3.5 shipped in 1994. That newer Vista API is probably built on top, or uses same kernel features.<p>Here&#x27;s an important part from IOCP&#x27;s documentation:<p>&gt; The system also allows a thread waiting in GetQueuedCompletionStatus to process a completion packet if another running thread associated with the same I&#x2F;O completion port enters a wait state for other reasons, for example the SuspendThread function.<p>This is the unique part which can&#x27;t be implemented in a user mode library. If you create a thread pool with 1 OS thread per hardware thread, and call any blocking API from the pool, a hardware thread will go to sleep. If you create a thread pool with multiple OS threads per hardware thread, the OS will use all of them concurrently and you&#x27;ll get overhead from context switches, also latency spikes.<p>The problem can only be solved in OS kernel. That&#x27;s why in Windows, thread pools usually works OK.')