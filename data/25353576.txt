Item(by='nikki93', descendants=None, kids=None, score=None, time=1607473109, title=None, item_type='comment', url=None, parent=25352420, text='An important thing is that with move semantics and good analysis for those at compile time, a lot of assignments can be moves and not need refcount changes. This fact actually comes up in Nim with ARC a lot. Refcounted refs are pretty explicit in Nim and you can use value types for the most part. That allows it to be pretty clear in your architecture what data has a refcount associated, and you can opt into that in a conscious way. The explicitness doesn&#x27;t make the code look weird or unidiomatic either, it feels like a natural part of the language that it gives you the tools to do this and is clearly a core part of its design.<p>The way I&#x27;ve gone about it in Nim so far, the refcounts are actually rare, especially copies (which is where increments occur). You can also look at the generated C and it&#x27;s pretty clear where the overhead is happening, and I&#x27;ve found that in practice it happens rarely enough that this makes a lot of sense. It&#x27;s pretty different from how things go in Python. In my project I also actually just use ARC and for sure don&#x27;t have cycles, and the destructor calls are deterministic.<p>Here&#x27;s a talk that&#x27;s somewhat related (refcounts in the &quot;Lobster&quot; programming language, and how it also elides refcount calls using compile-time logic (which ends up being equivalent-ish to a framing in terms of move semantics)): <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WUkYIdv9B8c" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WUkYIdv9B8c</a>')