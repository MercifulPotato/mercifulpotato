Item(by='chriswarbo', descendants=None, kids=[25992167], score=None, time=1612203245, title=None, item_type='comment', url=None, parent=25990680, text='From my understanding, dependent types can <i>model</i> linearity, but you&#x27;d need to use that model type system rather than the &#x27;native&#x27; type system (similar to how, for example, Bash can <i>model</i> OOP (e.g. using a mixture of naming conventions, associative arrays, eval, etc.), but isn&#x27;t <i>natively</i> OOP). If we go down that route, we&#x27;re essentially building our own programming language, which is inherently incompatible with the dependently-typed language we&#x27;ve used to create it (in particular: functions in the underlying language cannot be used in our linear-types language, since they have no linearity constraints).<p>A common example is a file handle: I can prove that the &#x27;close&#x27; function will produce a closed handle, e.g.<p><pre><code>    close : Handle Open -&gt; Handle Closed\n</code></pre>\nI can prove that those handles point to the same file:<p><pre><code>    close : (f: Filename) -&gt; Handle f Open -&gt; Handle f Closed\n</code></pre>\nI can prove arbitrary relationships between the input values and the output value. Yet nothing I do restrict the <i>structure</i> of a term, like how many times a variable is used, to prevent e.g.<p><pre><code>    foo h = snd (close h, readLine h)\n</code></pre>\nFor that sort of control, we need to build the ability to track things into the term language itself; either by adding linear types (or equivalent) to the language, or building a new incompatible language on top (as I mentioned above).')