Item(by='brandmeyer', descendants=None, kids=[24965314, 24961966, 24962600], score=None, time=1604250449, title=None, item_type='comment', url=None, parent=24959658, text='&gt; Also worth noting, since this always comes up, that these things are super hard for a compiler to optimize away. JSC tries very aggressively but only succeeds a minority of the time (we have a backwards abstract interpreter based on how values are used, a forward interpreter that uses a simplified octagon domain to prove integer ranges,<p>RISC-V has some closely-related sharp corners in indexed address arithmetic as well.  Some choices for the type of the index variable perform much worse on rv64.<p>Consider: an LP64 machine uses 32-bit integers for &#x27;int&#x27; and &#x27;unsigned&#x27;, but 64-bit integers for `long`, `size_t`, `ptrdiff_t` and so on.<p>If you use an array index variable of type `unsigned`, then the compiler must prove that wraparound doesn&#x27;t happen.  That&#x27;s pretty weird considering that half the point of using unsigned is to elide such proofs of correctness.  If it cannot prove the absence of unsigned wraparound, then it will be forced to emit zero-extension sequences prior to using the index variable to generate the addresses.<p>ARMv8 side-steps the whole problem by providing indexed memory addressing modes that include the complete suite of zero and sign extension of a narrow-width index in the load or store instruction itself.<p>So here we have an example of a three-way system engineering choice.<p><pre><code>  - Provide a small amount of hardware that performs the operation on-demand.\n  - Provide new and inventive forms of value-range analysis in the compiler.  Despite decades of research into this problem, the world&#x27;s best solutions still frequently saturate at &quot;the entire width of the type the programmer requested&quot;.\n  - Change the habits of the world&#x27;s C programmers.\n</code></pre>\nRISC-V chose options 2 and 3.')