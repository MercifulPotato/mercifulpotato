Item(by='couchand', descendants=None, kids=[24947393, 24943235, 24943145], score=None, time=1604066853, title=None, item_type='comment', url=None, parent=24941873, text='The best part about Rust is the type system.  For one example, in a web app I&#x27;m building for a client, we have two types to represent invoice ids: one for the invoice id that came back in a response from the API, and one for an invoice id that a user is asking for.  They are distinct because we know that an InvoiceId refers to an actual invoice in the system, and a UnverifiedInvoiceId might not.  Both of them are distinct from a CustomerId or any other id.<p>This might sound like it could get cumbersome fast, but it&#x27;s actually really simple in practice, due to clever uses of traits.  UnverifiedInvoiceId implements rocket::FromParam, so I can deserialize it from a URL parameter.  InvoiceId is only created in the serde::Deserialize implementation of an invoice-returning API response.<p>So a (significantly simplified) endpoint in the app might look like:<p><pre><code>    #[get(&quot;&#x2F;invoices&#x2F;&lt;unverified_invoice_id&gt;&quot;)]\n    pub fn get_invoice_by_id(\n        unverified_invoice_id: UnverifiedInvoiceId,\n        api_conn: ApiConnection,\n    ) -&gt; HtmlResponse {\n        &#x2F;&#x2F; API &quot;search&quot; methods take unverified user input as parameters\n        let invoice = api_conn.fetch_invoice_by_id(unverified_invoice_id);\n\n        &#x2F;&#x2F; API &quot;lookup&quot; methods take verified ids\n        let line_items = api_conn.fetch_invoice_line_items(invoice.id);\n\n        render_invoice(invoice, line_items);\n    }\n</code></pre>\nI can&#x27;t accidentally switch up things that don&#x27;t belong together, even though under the hood they&#x27;re all just unsigned ints.')