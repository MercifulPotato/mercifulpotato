Item(by='dnr', descendants=None, kids=None, score=None, time=1606184242, title=None, item_type='comment', url=None, parent=25193075, text='This is not actually a problem in practice. I had this misconception too before I started using it, though. I&#x27;ll explain for Nix, since I&#x27;ve used it, but I assume Guix works similarly:<p>Packages as defined in nixpkgs don&#x27;t depend on specific versions of shared libraries. They depend on the library by name, just as they do in any other OS. So a single update in nixpkgs addresses all packages on the system &quot;for free&quot;, including ones defined outside of nixpkgs, because they&#x27;re almost certainly going to depend on nixpkgs for those libraries (I mean, they could duplicate the definitions, but why would they?).<p><i>Built</i> packages depend on specific versions. So you just have to be sure to update all your built packages. How does that happen? Well, packages are installed because they&#x27;re requested by name somewhere, either NixOS system packages, or from home-manager, or from a dev environment. Those names point to packages in nixpkgs. So when you update your nixpkgs version (using nix-channel or flake update or however you&#x27;re doing it), and then rebuild NixOS or update home-manager, you get updated versions of everything.<p>If you&#x27;re using a nix-based dev environment with pinned nixpkgs (with niv or a flake or whatever), you&#x27;ll have to update that pin as well, for each project. I suppose you could claim that this makes it easy to use old dependencies. Perhaps, but the entire point of pinning the nixpkgs version is to make everything 100% reproducible, bugs and all, all the way down your dependency stack. So you have to make a deliberate choice between trade-offs there, which seems fair.<p>As far as static linking, nix is essentially static linking, except that you still get the benefits of shared disk space and shared memory for .so files. &quot;True&quot; static linking might be simpler if your dependencies happen to be .so files that also have .a files, but many things aren&#x27;t, e.g. dependencies among python modules, depending on other binaries to exec, data files, etc. Nix lets you &quot;statically link&quot; all of those too.')