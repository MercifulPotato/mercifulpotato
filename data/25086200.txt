Item(by='kentonv', descendants=None, kids=None, score=None, time=1605294934, title=None, item_type='comment', url=None, parent=25085960, text='WebSockets are a feature of Durable Objects.<p>Workers handle WebSockets in a pretty straightforward way. The server-side API is literally the same WebSocket JavaScript API as in browsers. sock.addEventListener(&quot;message&quot;, callback), etc.<p>But if you aren&#x27;t using Durable Objects, then WebSockets on Workers aren&#x27;t particularly useful, because there&#x27;s no way to contact the specific Worker instance that is handling a particular client&#x27;s WebSocket session, in order to send a message down.<p>Durable Objects fixes exactly that. Now you can have worker instances that are named, so you can call back to them.<p>Here&#x27;s a complete demo that uses WebSockets to implement chat: <a href="https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;workers-chat-demo&#x2F;blob&#x2F;main&#x2F;chat.mjs" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;workers-chat-demo&#x2F;blob&#x2F;main&#x2F;ch...</a><p>&gt; Are they automatically terminated after the worker spends too much time active?<p>We&#x27;re still tweaking timeouts and limits, but in general you should be able to keep a WebSocket alive long-term, and reconnect any time it drops (which any WebSocket application has to do anyway, the internet being unreliable).<p>&gt; If so, doesnâ€™t handling the WS handshake have a lot more overhead than a fetch call?<p>Not sure what you mean here. A WS handshake in itself isn&#x27;t terribly expensive. I suppose a typical application will have to establish some state after the socket opens, and that could be expensive, but it depends on the app.')