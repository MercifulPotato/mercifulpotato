Item(by='maccard', descendants=None, kids=None, score=None, time=1602964920, title=None, item_type='comment', url=None, parent=24811594, text='You can do something like<p><pre><code>    &#x2F;&#x2F; Or replace with something like a Strong Type; https:&#x2F;&#x2F;www.fluentcpp.com&#x2F;2017&#x2F;05&#x2F;05&#x2F;news-strong-types-are-free&#x2F;\n    using NodeHandle = int;\n\n    struct OptFloat { float Value; bool bInitialized = false; }; \n\n    NodeHandle CreateNode(NodeHandle* Children, int NumChildren, OptFloat Value);\n    void DestroyNode(NodeHandle ToDestroy);\n\n    void SetValue(NodeHandle ToSet,  OptFloat  NewValue);\n\n</code></pre>\nAside from that, you do raise a good point. If you implemented your C api over your implementation of node, you would be in for a bad time as the owning std::vector&lt;node&gt; won&#x27;t keep valid your pointers valid.. This isn&#x27;t suposed to be ragging on your code, it&#x27;s really to point out the pitfalls of manual APIs.<p>&gt; struct mylib_node { char storage[sizeof c++ struct that was computed manually)]; };<p>You can do;<p><pre><code>    &#x2F;&#x2F; IN C api, fill this in manually\n    #define mylib_storagsize = ?\n\n    struct mylib_node {char storage[MYLIB_STORAGESIZE]; };\n    &#x2F;&#x2F; or;\n    struct mylib_node {void* storage; }\n    &#x2F;&#x2F; in node.cpp - the underlying C++ abstraction;\n    static_assert(sizeof(mylib::node) == MYLIB_STORAGESIZE);\n\n</code></pre>\nIt&#x27;s only _slightly_ better..')