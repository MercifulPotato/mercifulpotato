Item(by='DarkWiiPlayer', descendants=None, kids=None, score=None, time=1610015730, title=None, item_type='comment', url=None, parent=25643940, text='I&#x27;d say the key point is the ability to identify and reason about complexity.<p>Figuring out what the irreducible complexities of a problem are and at what tradeoffs these complexities could be addressed in different components of an application (including handing them off to the user).<p>A few corollaries of this are:<p>- Masters will write less code, as they will eliminate most of the complexity when there is time for this.<p>- Masters can more easily put the complexity where they want it, having more control over trade-offs between performance, usability, flexibility, etc.<p>- Masters will have an easier time estimating the required work needed to implement a project, as experience gives them a good intuition for what the irreducible complexity of a problem is.<p>- Masters will rarely tell you a &quot;right&quot; solution except for simple problems. Their answer will depend as much on your specific requirements as the problem you&#x27;re trying to solve[1].<p>- Masters will often fix problems by simplifying code. Refactoring will be a natural part to their coding workflow, not a separate &quot;housekeeping&quot; activity.<p>- Those who hide complexity behind more complexity are not masters. Those who always fix problems by adding more code are not masters.<p>[1] It could be argued that &quot;add to numbers and do it fast&quot; is a single problem and that&#x27;s not wrong. Requirements like &quot;speed&quot; and &quot;usability&quot; are really just another aspect of the desired outcome of a program, but it&#x27;s rarely thought of as part of the problem to be solved, thus I am considering these constrains as separate from the &quot;core&quot; of the problem.')