Item(by='dragontamer', descendants=None, kids=[25165669], score=None, time=1605908076, title=None, item_type='comment', url=None, parent=25165214, text='<a href="https:&#x2F;&#x2F;www.anandtech.com&#x2F;show&#x2F;16226&#x2F;apple-silicon-m1-a14-deep-dive&#x2F;2" rel="nofollow">https:&#x2F;&#x2F;www.anandtech.com&#x2F;show&#x2F;16226&#x2F;apple-silicon-m1-a14-de...</a><p>The reorder-buffers determine how &quot;deep&quot; you can go out-of-order. Roughly speaking, 600+ means that an instruction 600+ instructions ago is still waiting for retirement. You can be &quot;600 instructions out of order&quot;, so to speak.<p>----------<p>Each time you hold a load&#x2F;store out-of-order on a modern CPU, you have to store that information somewhere. Then the &quot;retirement unit&quot; waits for all instructions to be put back into order correctly.<p>Something like Apple&#x27;s M1, with 600+ reorder buffer registers, will search for instruction-level parallelism all the way up to 600-instructions into the future, before the retirement unit tells the rest of the core to start stalling.<p>For a realistic example, imagine a division instruction (which may take 80-clock ticks to execute on AMD Zen). Should the CPU just wait for the divide to finish before continuing execution? Heck no! A modern core will out-of-order execute future instructions while waiting for division to finish. As long as reorder buffer registers are ready, the CPU can continue to search for other work to do.<p>--------<p>There&#x27;s nothing special about Apple&#x27;s retirement unit, aside from being ~600 big. Skylake and Zen are ~200 to ~300 big IIRC. Apple just decided they wanted a wider core, and therefore made one.')