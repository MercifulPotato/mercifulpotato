Item(by='piinbinary', descendants=None, kids=[24888933, 24888269, 24887911, 24892879, 24888181], score=None, time=1603645724, title=None, item_type='comment', url=None, parent=24887521, text='I find myself reaching for it over other languages when I want to build small servers with a bit of in-memory state or a bit of heavy processing. For little search-engines, Go is perfect. While writing servers in Flask + Python is much more convenient, I still prefer Go because I don&#x27;t run into the limits that Python has.<p>The development process is fluid enough that I wish the language was suited to more usecases. When I need to handle complicated data (e.g. abstract syntax trees), I use Rust or Haskell because of their rich data types. But it tends to be much harder to get things running in those languages (borrow-checker and monads, respectively). I want to reach for Go to make those problems go away, but then realize that it would be really painful to try to express the program in Go. I understand that other people are unhappy with Go&#x27;s development process, particularly if you deal with package versioning.<p>The language design itself may have been backed into a corner where adding generics will create an ugly mess (what will the standard library look like if it tries to maintain backwards compatibility?). Time will tell.<p>The tooling is mostly pretty good, but many things feel half-baked (compared to more mature ecosystems). On the spectrum of &#x27;written in a weekend&#x27; to &#x27;dozens of developer-years of work&#x27;, the package &quot;net&#x2F;http&#x2F;pprof&quot; feels closer to the weekend side. There are bright sides, like having the production parser available as a library.<p>It&#x27;s a language that is frustrating in different ways from other languages. Instead of fighting with Cabal&#x2F;Stack, you have to write a million `if err != nil {}` statements. Part of what makes it frustrating is seeing how good it could have been.')