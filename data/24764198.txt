Item(by='ivanbakel', descendants=None, kids=[24767910], score=None, time=1602586080, title=None, item_type='comment', url=None, parent=24760883, text='&gt;I don&#x27;t understand what this is supposed to mean. How are e.g. coq tactics not the exact same?<p>Coq tactics are <i>code</i> - you write terms using tactics, and you edit the term by editing the tactics. Save and load the file, and only the tactics stick around.<p>In this version, tactics <i>write</i> code - you use tactics to generate a term (Haskell code), and then you can edit the term itself. Save and load the file, and all you get is the Haskell code: the tactics only existed for codegen.<p>&gt;Not having the metaprogram which generated the code around just strikes me more as an anti-feature.<p>Why? The trouble with metaprogramming is that you basically never want to have the power to simultaneously edit the program and the metaprogram. As you yourself pointed out, tactics would be <i>terrible</i> as an opaque metaprogram - they only work if you don&#x27;t care about the particular term they generate.<p>Tactic metaprogramming lets you write terms quickly - it fulfills a need that lots of Haskell programmers have, which is that certain type signatures have &quot;obvious&quot; inhabitants and actually expressing those inhabitants can itself feel like a lot of boilerplate. But since you need to edit the Haskell code itself, the metaprogram must disappear. You won&#x27;t miss it, since you won&#x27;t need to regenerate the program from the metaprogram.<p>&gt;the image presented uses some form of auto tactic to generate an entire term in one go<p>Because it&#x27;s built out of several tactic steps, which the article goes into the construction of. You could still (presumably) have built it piece by piece, by applying each tactic one at a time - and each step only modifies the term slightly, leaving a hole for later steps.')