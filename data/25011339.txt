Item(by='moron4hire', descendants=None, kids=None, score=None, time=1604697986, title=None, item_type='comment', url=None, parent=25010213, text='I&#x27;m in kind of the same boat. I grew very disatisfied with Unity earlier this year and began looking for alternatives. I explored writing my own rendering engine, given that my requirements aren&#x27;t very high.<p>Back in January, I discovered this really cool .NET Standard 2.0 library for abstracting Direct3D 11, Vulkan, Metal, OpenGL 3, and OpenGL ES 3 called Veldrid: <a href="https:&#x2F;&#x2F;github.com&#x2F;mellinoe&#x2F;veldrid" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;mellinoe&#x2F;veldrid</a><p>The documentation is pretty good, for its own parts, and it has a fair number of examples for setting up things like different windowing libraries. I was able to put together a set of code for a single demo running in Windows Forms, WPF, and Xamarin Forms fairly easily. It also has support for SDL2.<p>Currently, I&#x27;m going through a Codevember exercise where I teach myself WebGL from scratch.<p>From what I&#x27;ve learned so far, most of the graphics APIs these days work in very similar ways. And Veldrid polishes over the few differences (esp. in the case of OpenGL). WebGL does, too, in that they present an OpenGL front-end, but the back-end can be implemented in different graphics APIs (for example, on Windows it&#x27;s actually implemented in D3D 11 through ANGLE).<p>In general, you need to create a Shader Program--which is a combination of multipe Shaders of different types, e.g. Vertex, Compute, and Fragment--construct one or more Buffers to which you will load data (generally in a big, ol&#x27; smash of data), and configure how ranges within those Buffers will map to pointer locations within your Shader Program.<p>However, I&#x27;ve generally found that there is little documentation <i>anywhere</i> on how to architect a data pipeline to use all of the various GPU resources efficiently. Everyone talks about &quot;use as few draw calls as possible&quot;. But they don&#x27;t really tell you how to achieve that.<p>My feeling is that a Shader Program is loosely analogous to a Material in something like Three.js or Unity. I&#x27;m guessing that the ideal approach is to take all of the Meshes in Three.js, or all of the Renderers in Unity, that have all of the same Materials, and then combining their Geometries into a single block of memory. And that&#x27;s where Uber Shaders come in, as an attempt to also combine all of the different ways in which you&#x27;d want to render different Materials into a single Shader Program.')