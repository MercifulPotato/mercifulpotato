Item(by='jstimpfle', descendants=None, kids=None, score=None, time=1605350457, title=None, item_type='comment', url=None, parent=25091224, text='I&#x27;ve been thinking a lot about these things lately. I still haven&#x27;t found solutions to all the problems, but here goes...<p>The alternative to asynchronous interfaces (which is basically what GP describes) are blocking interfaces - like system calls, or just waits for a specific event. And these are never an answer, unless it is _guaranteed_ that the blocking call will return withing a given timeframe and you also know that you will have absolutely nothing else to do meanwhile.<p>&gt; State between communication.<p>There are two ways to keep state - locally on the stack or in an explicit data structure. As always in programming, you have to clean up when you destroy an object&#x2F;process&#x2F;stateful thing.<p>&gt; what if the message gets lost<p>This absolutely should not happen, unless the sender doesn&#x27;t expect an answer and the message can clean up itself. The latter is the case for example when sending a message means just copying it towards the destination, like in computer networks. The former is the case in particular in UDP connections.<p>&gt; what if we redeploy A, what if the storage fails<p>You absolutely need to answer all messages that require an answer (called &quot;IO completion&quot; elsewhere). Of course, the answer can be &quot;cancelled&quot; or &quot;failed&quot;.<p>Before destruction or reset, you need to synchronize with all users that hold a direct handle to the object being destroyed. That could just be done by having only a single owner who is responsible to wait for a &quot;cleaned up&quot; event and to then destroy the object. Think Unix processes - processes that exited still appear in the process table until their parent has wait()ed for them.<p>&gt; Message growth. What happens when you have an O(n^2) or worse growth in messages? How do you track and manage that?<p>In general, asynchronous IO is achieved with queues (which are what GP discussed). With queues you have the choice to limit their size right in the queue (if the queue is full, block sending, or reject it temporarily and notify when there is progress). Or you can allow unlimited queues and push responsibility for memory management (and allocation policies) to the users of the queue. For example, users can allocate messages on their own and just link them into the queue - not additional memory allocation needed.')