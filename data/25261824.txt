Item(by='carapace', descendants=None, kids=None, score=None, time=1606791858, title=None, item_type='comment', url=None, parent=25261372, text='<p><pre><code>    ?- E = &quot;pop dup dup * swap abs rollup dup * swap - +&quot;, joy(E, Si, So).\n    E = &quot;pop dup dup * swap abs ro...p - +&quot;,\n    Si = [_56410, int(_56422), int(_56432)|_56428],\n    So = [int(_56454)|_56428],\n    _56422 in 0..sup,\n    _56500+_56422#=_56496,\n    _56422+1#=_56520,\n    _56422^2#=_56544,\n    _56500+_56544#=_56454,\n    _56544 in 0..sup,\n    _56496 in 0..sup,\n    _56432^2#=_56496,\n    _56520 in 1..sup ;\n    E = &quot;pop dup dup * swap abs ro...p - +&quot;,\n    Si = [_57392, int(_57404), int(_57414)|_57410],\n    So = [int(_57436)|_57410],\n    _57404 in inf.. -1,\n    _57482+_57404#=0,\n    _57404+1#=_57502,\n    _57404^2#=_57526,\n    _57482 in 1..sup,\n    _57578+_57482#=_57574,\n    _57578+_57526#=_57436,\n    _57526 in 1..sup,\n    _57574 in 0..sup,\n    _57414^2#=_57574,\n    _57502 in inf..0 ;\n    false.\n\n</code></pre>\nIt&#x27;s a Prolog query with two solutions (because the input to abs could be positive or negative) showing the input and output stack effects (the type signature) and the CLP(FD) constraints between the input and output integers.<p>It&#x27;s a little hard to read, I know, but the code that performs the type inference and constraint generation&#x2F;recording is very brief and elegant.<p>( It&#x27;s a work-in-progress: <a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~sforman&#x2F;Thun&#x2F;tree&#x2F;master&#x2F;source&#x2F;thun.pl" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~sforman&#x2F;Thun&#x2F;tree&#x2F;master&#x2F;source&#x2F;thun.pl</a> )<p>- - - -<p>FWIW I messed about with a Python implementation of Joy (another concatinative language) and I have some notebooks that might be interesting: <a href="https:&#x2F;&#x2F;joypy.osdn.io&#x2F;notebooks&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;joypy.osdn.io&#x2F;notebooks&#x2F;index.html</a>')