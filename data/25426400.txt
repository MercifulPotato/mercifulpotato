Item(by='cpgxiii', descendants=None, kids=[25428416, 25426637], score=None, time=1608000372, title=None, item_type='comment', url=None, parent=25425824, text='&gt; It was one ISA, and a terrible one at that<p>Except, you know, the whole point of VLIW designs was that by offloading complexity to the compiler and runtime you&#x27;d be less limited by hardware design decisions and be able to improve with time. Provide real examples of how Itanium could have been done better.<p>&gt; You&#x27;re missing my point, which is about rewriting the world<p>No, I&#x27;m not. &quot;Compatibility with standard C code&quot; means memory allocations and branches. That&#x27;s it. Most &quot;real&quot; OSs need an MMU, but there are a few research systems that don&#x27;t.<p>You should also keep in mind that lots of different models have been tried. Compiled machine code? Done. JIT-recompiled machine code? Done. GC&#x27;d Lisp on hardware? Done. GC&#x27;d ada on hardware? Done. GC&#x27;d JVM on hardware? Done. Binary translation to &quot;better&quot; hardware? Done, lots of different times. &quot;Rewrite the world&quot; has been tried a fair number of times before, and it didn&#x27;t win out.<p>You&#x27;re also totally missing the point that several architectures, x86&#x2F;x86_64 most notably, have succeeded because ISA and hardware implementation aren&#x27;t locked together tightly. Processor designers and users are not nearly as constrained together as you believe.')