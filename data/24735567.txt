Item(by='nendroid', descendants=None, kids=[24735868], score=None, time=1602287584, title=None, item_type='comment', url=None, parent=24734377, text='&gt;The lack of really natural integration into modern day programming languages (and data model mismatches) is a much bigger issue imo<p>The SQL data types consist of a few primitives like ints strings and chars placed in higher order data types that are tables. These types are easily isomorphic to data structures and primitive types in traditional programming languages. There is zero mismatch here, in fact the data structures in application programming languages tend to be much richer than SQL.<p>See orms for reference. ORMS have their own set of problems but data mismatches are not part of those problems. If the programming language enables the creation of sum types like rust or haskell than there can never be a mismatch as these languages can produce virtually any type.<p>&gt;SQL queries are generally really short. Rarely more than a few lines (might be different for people doing ad-hoc analysis instead of making a db backed application). I don&#x27;t need modularity for a program that is only a few lines long.<p>For complex applications this is not true. In general the classic model for web development is to place as much logic as possible into the SQL query and as little logic as possible into your heavy Python web app. The web app is suppose to serve as something that routes IO the bulk of your code&#x2F;logic and heavy lifting should be shifted to the database. Simple apps can avoid this but in general complex apps cannot.<p>Case in point do you put your where clause in the application program than download the entire table? Or do you throw as much logic as possible into the query so the database outputs a result as close as possible to what you need? The later statement is the right answer.<p>&gt;I don&#x27;t really feel like composability&#x2F;modularity is all that important in SQL.<p>You&#x27;re not completely wrong. The bigger issue is SQL optimization. Because Databases form the backbone of computation for a standard web app SQL provides a layer of indirection that makes optimization harder. For C++ optimization is built into the syntax itself, you make choices while coding to optimize things. For SQL you open up the black box and look into the query planner to see what your High level code is compiling too. SQL is a really bad interface for doing optimizations but that&#x27;s a topic for another day. The topic of this post is modularity and he&#x27;s not wrong... SQL is not a composable language and there&#x27;s no performance loss in making it more composeable.')