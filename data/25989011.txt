Item(by='syllogism', descendants=None, kids=None, score=None, time=1612190123, title=None, item_type='comment', url=None, parent=25988826, text='The improved transformers support is definitely one of the main features of the release. I&#x27;m also really pleased with how the project system and config files work.<p>If you&#x27;re always working with exactly one task model, I think working directly in transformers isn&#x27;t that different from using spaCy. But if you&#x27;re orchestrating multiple models, spaCy&#x27;s pipeline components and Doc object will probably be helpful. A feature in v3 that I think will be particularly useful is the ability to share a transformer model between multiple components, for instance you can have an entity recogniser, text classifier and tagger all using the same transformer, and all backpropagating to it.<p>You also might find the projects system useful if you&#x27;re training a lot of models. For instance, take a look at the project repo here: <a href="https:&#x2F;&#x2F;github.com&#x2F;explosion&#x2F;projects&#x2F;tree&#x2F;v3&#x2F;benchmarks&#x2F;ner_conll03" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;explosion&#x2F;projects&#x2F;tree&#x2F;v3&#x2F;benchmarks&#x2F;ner...</a>. Most of the readme there is actually generated from the project.yml file, which fully specifies the preprocessing steps you need to build the project from the source assets. The project system can also push and pull intermediate or final artifacts to a remote cache, such as an S3 bucket, with the addressing of the artifacts calculated based on hashes of the inputs and the file itself.<p>The config file is comprehensive and extensible. The blocks refer to typed functions that you can specify yourself, so you can substitute any of your own layer (or other) functions in, to change some part of the system&#x27;s behaviour.  You don&#x27;t _have_ to specify your models from the config files like this --- you can instead put it together in code.  But the config system means there&#x27;s a way of fully specifying a pipeline and all of the training settings, which means you can really standardise your training machinery.<p>Overall the theme of what we&#x27;re doing is helping you to line up the workflows you use during development with something you can actually ship. We think one of the problems for ML engineers is that there&#x27;s quite a gap between how people are iterating in their local dev environment (notebooks, scrappy directories etc) and getting the project into a state that you can get other people working on, try out in automation, and then pilot in some sort of soft production (e.g. directing a small amount of traffic to the model).<p>The problem with iterating in the local state is that you&#x27;re running the model against benchmarks that are not real, and you hit diminishing returns quite quickly this way. It also introduces a lot of rework.<p>All that said, there will definitely be usage contexts where it&#x27;s not worth introducing another technology. For instance, if your main goal is to develop a model, run an experiment and publish a paper, you might find spaCy doesn&#x27;t do much that makes your life easier.')