Item(by='Geminidog', descendants=None, kids=None, score=None, time=1608608647, title=None, item_type='comment', url=None, parent=25502401, text='Why n(n-1) pure functions? It makes no sense that you only need n methods in a class and suddenly n(n-1) pure functions. You will always need n(n-1) functions if you want to specify ALL the conversion logic. Think about it. If you&#x27;re not writing it in the method, then that logic must be written down somewhere.<p>I think I get where you&#x27;re coming from though. The class hides a type representation that is used as the &quot;internal&quot; representation of the serial number so you only need to write 2n functions. N function to convert to the special serial types, and N functions&#x2F;logic to convert the special serial types to the internal serial type. The latter N functions are placed in the constructor not as functions but as a series of procedures to deduce the type of the parameter and do the conversion internally. (The effect of this is identical to overloading the constructor).<p>Let&#x27;s say A represents that internal serial type, with all other letters in the alphabet representing the serial types of your oil well. You&#x27;re essentially doing the same as writing:<p><pre><code>  AtoB :: B -&gt; A\n  BtoA :: A -&gt; B\n  \n  CtoA :: C -&gt; A\n  AtoC :: A -&gt; C\n</code></pre>\nIf the goal was to convert B to C with classes you do this:<p><pre><code>  Serial(B).CtoA()\n</code></pre>\nwith functions you do this:<p><pre><code>  AtoC(BtoA(A))\n</code></pre>\nYour BtoA logic is simply hidden in the constructor of Serial. But basically the exact amount of written logic is occurring here.<p>I think your question was a trap. One class with n methods is obviously better then n(n-1)&#x2F;2. I think you were just unable to see that it&#x27;s basically all functions and expressions in the end. When you use classes you are simply tying these functions to structure and internal variables making them less modular, but the amount of logic is exactly the same.<p>But overall, if you want to know which methodology is logically better and more resistant to technical debt then I will tell you.<p>The functional approach is better.<p>Because the functional approach modularized BtoA. BtoA can be reused in other contexts in the functional approach but in the Object Oriented approach the logic of BtoA is tied together with CtoA, DtoA, EtoA and all of that in the constructor. Likely if you needed that logic as a one off... say to print the serials in internal receipts... you would likely be copying and pasting that logic from the constructor and duplicating it in another class when you follow the object oriented approach.<p>This is the main reason why the author of the post promotes pure functions. Greater modularity and greater resistance to technical debt.')