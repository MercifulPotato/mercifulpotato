Item(by='ratww', descendants=None, kids=[25409470], score=None, time=1607877748, title=None, item_type='comment', url=None, parent=25407362, text='I don&#x27;t know if I agree with that.<p>Most of the complexity and bugs I see in software are not because of the problem domain, but rather because of  over-abstraction, under-abstraction and abstraction leaks, and also because of limitations and complexities introduced by the programming model or environment.<p>(unless you consider that &quot;supporting five operating systems and the language must be X&quot; is part of &quot;essential complexity&quot;)<p>Of course, the more complex your domain is, the bigger is the program. But the non-essential complexity that exists due to the bureaucracy of languages&#x2F;libraries&#x2F;frameworks is a much bigger factor in adding complexity, bug and lines of code. Some examples:<p>- Manual allocation and deallocation of memory is a good example of something that we might think as essential, since it&#x27;s intertwined with our domain code, but turns out to be unnecessary (even though the replacement has downsides). The billion-dollar problem (nulls) is another one.<p>- Supporting multiple environments&#x2F;browsers&#x2F;platforms. Competition is good, but the cost is steep for third-party developers. Using multiplatform frameworks partially solves but also has drawbacks: performance, limitations, bugs, leaky abstractions. If you need to be closer to metal, then different OSs have different threading models or API styles. Sometimes they don&#x27;t even expose the main loop to you. You need to work around those limitations.<p>- In most environments we still don&#x27;t have a nice way of handling async operations without leaking the abstraction. The current solution is adding &quot;isLoading&quot; data everywhere (or creating some abstraction around both buttons and the fetching mechanism). Concurrent Mode in React is probably the best thing we have so far.<p>- Most modern Javascript toolchains need multiple parsing steps: in the transpiler (to convert to ES5), in the bundler (to detect dependencies), in the linter, in the prettifier, and in tests. Compatibility between them is not guaranteed, and you might get conflicts which have to be solved by finding a middle ground, and that sometimes take more time than writing features.<p>- Dogmatism is another issue. I remember in one workplace years ago there was a &quot;ORM only&quot; rule and most of us would work the SQL and then convert to Rails ActiveRecord (or worse: Arel). In the end it was a complete waste of time and the results were impossible to maintain.<p>- I also think that the old Peter Norvig quote that &quot;design patterns are missing language features&quot; still stands. Go has proven that it&#x27;s possible to have &quot;dumb, simple code&quot;, but in other languages our best practices involve adding non-essential complexity to products.<p>The only exception to that in my experience is SQL: if a query is too big is not due to some bureaucracy of the language, but rather due to the complexity of the domain itself.')