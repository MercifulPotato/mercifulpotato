Item(by='pjmlp', descendants=None, kids=[25518871], score=None, time=1608735435, title=None, item_type='comment', url=None, parent=25518059, text='&gt; You can make your own explicit bounds checks, or you can use valgrind (which, just like any type system, can understand only simple situations). You can use C++ which actually does allow you to do bounds checking by default, if you&#x27;re into such things.<p>Yeah, apparently Google, Apple, Microsoft think otherwise.<p>&gt; Now tell me, why exactly is &quot;new Foo[count]&quot; safer than &quot;ALLOCATE(Foo, count)&quot;? Or just do this minimal boilerplate by hand, this is not a practical issue unless your code is very badly factored (good code requires only few allocations).<p>1 - Everyone needs to create their ALLOCATE macro, and not everyone does it right<p>2 - Actually it fails with certain kinds of <i>type</i> given as parameter<p>&gt;  I very much like that C keeps it simple and you always see what happens.<p>That is what people that never read ISO C and the myriad of UB cases think they do.<p>That is why I get such a kick of C Pub Quizzes, everyone is so full of themselves in regards to their C knowledge.<p>&gt; This is why I took issue - you can&#x27;t have both low-level bit twidding and &quot;memory safe&quot; programming. At most you can have a language that lets you choose between one or the other in a rather integrated system, but then you&#x27;re still dealing with this abstraction gap, and having to traverse it constantly is not pleasant.<p>That is the whole point, dangerous code that can trigger memory corruption code should only be written when there is no way around to do it in a safer way.<p>And most of the time, it is an optimiser bug that is even the case to start with, unless one is writing drivers or kernel code.')