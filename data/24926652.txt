Item(by='archgoon', descendants=None, kids=[24928471], score=None, time=1603940291, title=None, item_type='comment', url=None, parent=24926558, text='One option is to simply write end to end tests, and not bother with unit tests at all. This does mean that you don&#x27;t know if tests are failing because of a new code change or if the world has changed from underneath you.<p>If you want to write a unit test, then the test would mock the response from the server. You would have an expected sequence of expected requests and their responses. You would only be testing that you made the correct requests and, given the same response from the server, your code parsed it correctly and gave the expected outputs.<p>If the server bans your IP, or changes their response codes, your unit tests will still pass, as they should. Notification that the world has changed around you is not the purpose of a unit test. It is to allow you to feel confident of claims &quot;I refactored the code and behavior is unchanged.&quot; or &quot;I changed the behavior and this is how it has changed&quot; or &quot;I know that my code handles all known error codes from the server.&quot;<p>This is important when the world <i>does</i> change around you; as it lets you identify when that happens.<p>I recognize that test terminology is vague, and people will use competing definitions (I have seen &#x27;functional&#x27;, &#x27;integration&#x27;, and &#x27;end to end&#x27; all used to describe non-unit tests, and I&#x27;ve seen each used to mean the others). I recognize this may seem as an exercise in pedantry. However, there is a valuable distinction to be made between tests that can be run deterministically, and tests that rely on the behavior of third parties outside of your control. These tests types will differ in terms of speed of execution, infrastructure setup (many test environments may not have network access, or may need special credential access)[1], reliability, and also, importantly, the proper response to a failure.<p>[1] Also, if you&#x27;re doing mobile app development, you very much want to distinguish between tests that require a device and ones that don&#x27;t. You will likely have multiple test classifications  if you&#x27;re doing mobile development.')