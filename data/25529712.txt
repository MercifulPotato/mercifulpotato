Item(by='jeff-davis', descendants=None, kids=None, score=None, time=1608832608, title=None, item_type='comment', url=None, parent=25528927, text='Because the standard library (and a lot of other libraries) are mostly blocking. You can&#x27;t use blocking code effectively with async.<p>In other words with async you have to use code that knows how to yield, but the benefit is that you have a lot of flexibility in the runtime. That means you can scale up, scale down, and fit it into weird environments (like in other programs that aren&#x27;t expecting concurrency).<p>Threading (or process model) has a lot of upside though, too. For one, it&#x27;s pre-emptive, so scheduling can be more &quot;fair&quot;. For another, it&#x27;s a lot easier to debug (erlang does a great job here).<p>I&#x27;d generally default to using threads, unless I have a specific reason for async and&#x2F;or the code is fairly low-level and might be used in a variety of environments.<p>Disclaimer: don&#x27;t take my claims as authoritative. I know a few things from seeing what works and not, but I could be wrong on some of the finer points.')