Item(by='chrisseaton', descendants=None, kids=None, score=None, time=1603446086, title=None, item_type='comment', url=None, parent=24866207, text='&gt; But that’s almost always because the designer had to resolve some ambiguities present in the grammar.<p>Not if they started with a grammar that didn&#x27;t have any ambiguity in the first place.<p>I think you&#x27;re coming from the angle that you always start with a CFG, resolve ambiguity, then write a parser.<p>Imagine that I <i>never</i> write a CFG for my language. No CFG exists! Instead - I start by writing a PEG, and then I write a recursive descent parser from that. At no point in this process have I had to resolve ambiguity. I didn&#x27;t start with an ambiguous CFG and then write a PEG from it. I started with a PEG. It&#x27;s never been ambiguous, and never will be ambiguous. There&#x27;s no ambiguity.<p>&gt; The grammar fragment “expr :: IF expr THEN expr ELSE expr” is ambiguous.<p>Right.... but I wouldn&#x27;t write that because I&#x27;m not starting with a CFG I&#x27;m starting with a PEG.<p>&gt; Telling your puzzled users “it’s not ambiguous, it always goes with the farthest IF!” isn’t going to make them happier.<p>I can&#x27;t understand this - if I give them a simple well-defined rule that tells them what the code means they&#x27;ll be happy. What do you think they&#x27;d want instead? No rule? A badly defined rule?')