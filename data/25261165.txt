Item(by='davidhyde', descendants=None, kids=None, score=None, time=1606785717, title=None, item_type='comment', url=None, parent=25253471, text='I write a quite a bit of [no_std] Rust code (i.e. with no standard library) and you don&#x27;t get things like a memory allocator or even a panic handler out of the box. However, I find that creating a custom error enum for each of my modules and piping errors into errors by implementing the From trait for each Error enum referenced inside those modules is not as tiresome as one would expect. It frees me up to use the ? operator wherever I want and add whatever &quot;context&quot; I want by using structured enums. That way, when an Err is returned instead of an Ok result variant you get a pseudo-stacktrace via your error chain and the error variant itself can have data in it (like an index or a key that could not be found). It&#x27;s up to you how specific or generic you want it to be. You can also use &quot;map_err&quot; to decorate fallible code you don&#x27;t control with extra contextual information that will help you locate the source of the error.<p>For example:<p>`Error: CookingError(CakeBaker(TemperatureCOutOfRange(999, 250)))`<p>This has the added benefit of not forcing your error handling methodology on users of your libraries.')