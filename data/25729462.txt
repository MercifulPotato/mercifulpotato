Item(by='uryga', descendants=None, kids=[25729993], score=None, time=1610376439, title=None, item_type='comment', url=None, parent=25728735, text='&gt; In the case above, I&#x27;d pass a function which maps a (pure) date and string into a (pure) bool, to test for EU membership.<p>i doubt you could make (or really, even want to make) `checkEUMembership` pure, I&#x27;m guessing it&#x27;d involve a DB lookup of some kind.<p>in general, you can&#x27;t always &quot;pull out all the IO&quot; into an only-pure-logic &quot;core&quot;; like if you want to look up one thing and then look up another thing based on the result of the first lookup. and that&#x27;s okay!<p>i&#x27;m not going to write a whole monad tutorial, but using an `IO Foo` is kind of like using a `Promise&lt;Foo&gt;`¹; you do stuff like this (in JS syntax):<p><pre><code>  getX(...).then((x) =&gt;\n    getYForX(x).then((y) =&gt;\n      foo(x, y)\n      &#x2F;&#x2F; note - nested lambdas&#x2F;closures, `x` is closed-over\n    )\n  )\n</code></pre>\n&quot;do-notation&quot; lets you avoid callback hell, similarly to async&#x2F;await.<p>---<p>¹ Unfortunately, JS&#x27;s Promise#then mixes two things:<p>• &quot;dirtying&quot; a pure function:<p><pre><code>  getNumberFromDB().then((x) =&gt; x*2)\n</code></pre>\nwhich in Haskell would use<p><pre><code>  fmap :: (a -&gt; b) -&gt; IO a -&gt; IO\n</code></pre>\n• piping the result into another side-effecting function:<p><pre><code>  getNumberFromDB().then((x) =&gt; \n    getNameForNumberFromDB(x)\n  )\n</code></pre>\nwhich in Haskell would use the &quot;bind&quot; operator:<p><pre><code>  (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b</code></pre>')