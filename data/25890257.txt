Item(by='jiggawatts', descendants=None, kids=[25891250, 25892332, 25892526, 25890957], score=None, time=1611475249, title=None, item_type='comment', url=None, parent=25889791, text='In my experience with both classic Win32 programming in the 1990s in C++ and then later in C# and now in Rust is that it is obscenely verbose. It takes a solid page of code to call a <i>single method</i>, and most of that is just noise.<p>A typical method call is:<p><pre><code>    Allocate some struct.\n    Zero it out.\n    Set a &quot;length&quot; field to the length of the struct.\n    Populate the &quot;parameter&quot; fields.\n    Call the API with the struct and 0 for the return buffer size.\n    You get back an expected error code for &quot;buffer too small&quot;.\n    You allocate the required space in your buffer.\n    Call the method again. The amount of data changed! Loop and try again.[1]\n    You get your data! Now to check the error codes.\n    Look up error code using a Win32 method.\n    Free the buffer.\n</code></pre>\nIf on top of that I&#x27;d have to call &quot;into&quot; and &quot;from&quot; for every field and every parameter at every step... I think I might just snap and go become a bricklayer or something.<p>PS: Win32 strings and Rust strings aren&#x27;t compatible. I&#x27;ve already noticed that the current version of the Microsoft code-generator seems to use an awful lot of [u16] arrays, which are <i>not</i> the system OsString struct.<p>For comparison, the C# &quot;String&quot; type isn&#x27;t directly compatible with Win32 strings either, but the FFI engine handles this conversion back-and-forth for you.<p>Similarly, few (any?) languages have good built-in support for the various kinds of &quot;struct-followed-by-dynamic-data&quot; typically returned by system APIs. Notably, C does not have any way to encode this in the type system, so API metadata tends to just leave this out or describe it in the documentation. If the metadata was extented to cover this kind of thing, then the generators could do all sorts of clever things with this scenario...<p>[1] A lot of people don&#x27;t do this, they assume that the second call will always succeed. Programming in this style leads to rare random errors throughout the entire application. A loop is required for correctness for most (but not all) Win32 calls that return dynamic data...')