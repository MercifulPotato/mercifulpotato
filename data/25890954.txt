Item(by='mleonhard', descendants=None, kids=[25891725], score=None, time=1611484983, title=None, item_type='comment', url=None, parent=25888118, text='Some months ago, something snapped and I decided to finally let myself start working on the impossible projects that I have dreamed about for a while.  I got back that feeling I had as a teenager, of coding without any ideas of the limits of my own abilities.<p>Specifically, I want to make some devops tools that I need and don&#x27;t exist yet:<p>- A simple HTTP file server that uses mutual-TLS for auth and all configuration comes from a single TOML file.  Passwords are poisonous to security.  Stateful config APIs are poisonous to maintainability.<p>- A lightweight Dockerd replacement that uses mutual-TLS for auth, fetches binaries from the file server, actually verifies the SHA-256 digest of binaries (dockerd doesn&#x27;t), and receives all configuration by HTTP PUT of a single config.toml file.  It will store VM stdout logs locally and make them available via mutual-TLS HTTP.<p>- A metrics server that fetches logs via mutual-TLS HTTP, stores them in the file server, parses them (as JSON), calculates metrics and alarm states, caches derived data on the file server, serves a dashboard, re-exports specific metrics and alarm states, and notifies third-party services (Pagerduty&#x2F;Opsgenie) on alarm state changes.  All config comes from a single config.toml file.<p>- A simple monitoring daemon that performs repeated website and API requests and emits metrics to logs.  These get picked up by the metrics server.<p>- An infrastructure management tool without the problems of Terraform.  Specifically, it must support creating resources which contain other resources.  And it shouldn&#x27;t require the maintenance nightmare of multi-stage Terraform deployments.<p>I started writing this stuff in Golang.  But I quickly became frustrated with Golang&#x27;s incomplete libraries.  There are stupid things missing like min(int,int) and basic synchronization structs (WaitableBool).  Golang&#x27;s http library doesn&#x27;t support dynamic server-side request timeouts or mutual-TLS.  I guess they want you to run Golang servers behind nginx or expensive Google Cloud load balancers, probably on Kubernetes.  No thanks.<p>I learned Rust and started writing the tools above.  I fell in love with forbid(unsafe).  All of Rust&#x27;s HTTP server libraries contain copious amounts of unsafe code.  And none support mutual-TLS.  So I started writing a safe Rust HTTP client &amp; server library.  Half-way through, I realized how much unsafe code is in tokio &amp; async-std.  So I wrote and released a small safe Rust async runtime, called &quot;safina&quot;.  Amazingly, it works.  I resumed working on the HTTP library, adding TLS support.  Then I realized that rustls has a lot of unsafe Rust&#x2F;C&#x2F;assembly code.  So I started writing a safe Rust TLS 1.3 library.  Now I&#x27;m deep into that project.  It&#x27;s satisfying.<p>I wish you will forget your limitations and try new things without reservation.')