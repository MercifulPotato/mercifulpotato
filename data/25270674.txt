Item(by='Geminidog', descendants=None, kids=None, score=None, time=1606860571, title=None, item_type='comment', url=None, parent=25270378, text='Sure you can prefer OOP.<p>But note your style requires additions and edits and refactoring to existing code. It also requires more code than typically needed. If that code is complex enough it could make refactoring a huge undertaking.<p>The the non-oop style I illustrated there is no need for edits. All new features to code are basically plugins and additions no edits or refactoring needed. This is the ideal that modularity and re-usability strives for that typical OOP patterns fail to achieve.<p>That is a concrete benefit outside of opinion.<p>&gt;I think you have a few misconceptions about the objectives of OOP.<p>The objective of OOP has nothing to do with the actual consequences of it. You can state an objective for modularity and fail to achieve it.<p>The simplicity of what I am saying is this. methods in OOP cannot be used outside of the context of an object. A function can be used everywhere. This is a concrete fact that methods are therefore less re-usable and less modular than pure functional combinators.<p>&gt;It&#x27;s a design choice. I feel that OOP, when used properly, allows me to manage complex abstractions more easily.<p>And my argument is that outside of your personal preference things are objectively worse as a result. There is logical proof that your choice is objectively less modular. Methods cannot be reused, unless you decide to take the entire jungle and inject it into another object just for the banana.<p>Additionally:<p><pre><code>   class Banana:\n     int banana\n</code></pre>\nis objectively more complex than<p><pre><code>   int banana\n</code></pre>\nIt&#x27;s redundant syntax when you encapsulate one entity under a class which is a concept designed to gorup multiple entities.<p>&gt;Ok, if more classes have the same requirement maybe it&#x27;s not a specific behavior, but another abstraction, which could potentially be extract into a new component, mixin or an utility class.<p>So you redesign your initial design. More edits and refactorings and assumptions until the code becomes so complex that one day you find you cannot do this.<p>If you leave everything outside of classes you will find new features are just new additions to modular plug and play code. With OOP new features can end up being complete redesigns simply because the banana has to lug around the entire jungle and people end up needing to refactor the system so it doesn&#x27;t do that.<p>When a code base becomes large enough this is what most people end up doing refactoring logic that&#x27;s tied up in a class so it can be used outside of the class. You can either make it a global function or tie it up into some other container like a mixin which leaves the problem of maybe one day a component of the mixin needs to be extracted....<p>They either do the above or they take on technical debt by replicating the logic elsewhere.')