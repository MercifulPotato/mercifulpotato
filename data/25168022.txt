Item(by='ryan29', descendants=None, kids=[25168187, 25169039], score=None, time=1605936253, title=None, item_type='comment', url=None, parent=25166179, text='I tried kaniko and didn&#x27;t like it.<p>Having build and push as part of the same job is frustrating and I view it as a sign that a CI system is built with the expectation of having everything happen post commit by shoveling money into a CI auto-scaler.  I know there&#x27;s `--no-push`, but that&#x27;s a poor substitute for independent `build`, `tag`, `push` build steps IMO.<p>Do you have any way of running &#x2F; debugging locally with GitLab CI plus kaniko?  Can you run your build pipeline locally on your workstation against uncommitted code?<p>IMO I can build a way better local workflow that allows me to run builds _before_ committing with Drone (`drone exec`).  I can toggle between a locally bound Docker daemon or a DIND environment that&#x27;s going to be virtually identical to the DIND environment on a build runner.  The `push` step doesn&#x27;t run locally plus the secrets needed to push are only accessible from an official runner.  I can run it on Windows or Linux (and likely Mac) too.<p>I&#x27;ve been trying to find a self-hosted CI system that&#x27;s really good at building Docker (or OCI) images and I don&#x27;t think any exist.  They all have short-comings.  Having build, tag, push act like an atomic build step is one of the areas where I think most fail.  So many claim to enable repeatable builds but none actually do AFAIK.  Whoever writes the Dockerfile needs to know a lot about how images are built to have the slightest chance at creating a repeatable build.  A great example is having `apt-get update` in a Dockerfile.  That command _always_ returns zero, so by itself it makes builds non-repeatable.<p>Sometimes I have a tough time reconciling the development industry because things just don&#x27;t make sense to me.  I remember people complaining about Gradle start times so much they came up with the Gradle daemon.  Now no one bats an eye at CI based build systems where you have to commit your code, wait for a runner to get provisioned, wait for Docker or the OCI runtime to spin up, and wait for your project to actually build on some anemic VM.<p>People used to complain about seconds because the wait was &quot;too slow&quot; for good local iteration, but now waiting for minutes is a &quot;good&quot; build system.  Seriously WTF?<p>I guess I got on a bit of a rant...')