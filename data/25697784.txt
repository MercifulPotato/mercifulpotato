Item(by='Falkon1313', descendants=None, kids=None, score=None, time=1610171894, title=None, item_type='comment', url=None, parent=25663107, text='As someone who started in the late 80s with Apple II, Commodore 64, and then Tandy 1000, I have decades of perspective on this, and I think that both this article and most of the comments are looking the wrong way.<p>Hardware fails and changes.  Now, in post-Moore&#x27;s Law land, we can expect a computer to be modern enough for a decade instead of needing upgrades every couple years.  That&#x27;s great.  But hardware still fails and changes, and designing it to last 100 years isn&#x27;t really worthwhile.<p>Software has become its own mess with the requirement to be online, SAAS, and all that.  In that I agree with the author.  Offline software will work as long as the hardware works.  We need to get back to that.  Not needing constant updates and maintenance on our software and being constrained by complex and constantly-changing dependency hierarchies.<p>The oldest software I have was originally written around 1971 for a mainframe using a teletype as the interface, ported in the 1970s, ported again in the 1990s, and still works just fine on Windows 10 in 2021.  (Thanks to the effort of the porters, who took it through at least two different languages along the way.)  But most software isn&#x27;t going to last 50+ years - especially now, we have way too many dependencies, and way too much complexity.<p>However, one thing can and will last for decades, if not centuries or longer.  Data.  The key to the &#x27;100-year computer&#x27; is neither the hardware nor the software, but making sure the data&#x27;s still accessible and readable 100 years from now.  If you eliminate the irrelevant stuff and look at what the author&#x27;s actual goals are: &quot;a familyâ€™s personal history, passed on from generation to generation&quot;, neither the hardware nor the software matters for that.<p>I&#x27;ve had to try to port data from the era when everything was proprietary binary files.  Hacking those once the software that made them didn&#x27;t run wasn&#x27;t always easy.  I don&#x27;t know if anyone else ever reverse engineered the old Borland Pascal Real48 format (created in a time when most PCs didn&#x27;t have floating point built in to the CPU and didn&#x27;t come standard with floating point co-processors) via a hex editor, but it wasn&#x27;t easy even to identify.<p>The key to a 100-year computer is really just having all data stored in formats that will always be processable.  The hardware and software don&#x27;t matter, as long as you can copy the data forward to new media in a format that can be processed.  We&#x27;ve gotten a lot better about storing data in plain-text files, but that doesn&#x27;t cover everything.<p>Really, we just need to make sure we&#x27;re using future-proof archival data formats, and have a good backup plan using some kind of archival media, and then any computer is a 100-year computer.  Never mind that the hardware and software change along the way.  The core - the data - can live on.')