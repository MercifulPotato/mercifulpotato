Item(by='dgb23', descendants=None, kids=[25741234], score=None, time=1610380891, title=None, item_type='comment', url=None, parent=25729470, text='&gt; Is there really a formal proof or Software Engineering paper that proves this?<p>I wonder if there is one such formal proof as well.<p>Intuitively it is trivial: functions a are a subset of all procedures, state can introduce unique bugs, these bugs are not found in functions, so you&#x27;re dealing with a subset of all possible bugs.<p>Another intuition is this: By introducing state you increase complexity. A procedure in isolation is not necessarily referentially transparent, but a function is. You cannot reduce the procedure with it&#x27;s evaluation at any given point in time, because it is &#x27;connected&#x27; to the surrounding program via that state. Now you&#x27;d have to show that increased complexity introduces unique bugs.<p>I&#x27;m simply not equipped (yet) to make such claims, but I&#x27;d love to hear from experts on these matters. I know that you can formally verify stateful programs, so it is likely not an issue of what is <i>possible</i>. But I damn sure know it is much easier to reason informally about functions than about procedures, except if the procedure merely has local state.<p>&gt; And here&#x27;s where I feel that things fall apart a bit: I feel as if sometimes it&#x27;s much quicker to do things with state, so maybe the time you save debugging is time you add elsewhere?<p>I can only speak for myself here, but yes certain algorithms are more intuitive if implemented imperatively. But I found that the set of these algorithms shrink over time by getting used to FP. Vice versa there are also algorithms that are much more easily written with functions. Then there is core idiom of the language you&#x27;re using. If it is imperative OO, then writing functional programs can sometimes feel cumbersome and less readable.<p>There are many factors that may or may not apply as well. For example functions are easier to compose and decompose, since they are by definition simpler. However imperative procedures are sometimes easier to read &quot;from top to bottom&quot;, because they enable a more real-world-y mechanical&#x2F;visual mental model.')