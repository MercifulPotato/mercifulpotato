Item(by='SoSoRoCoCo', descendants=None, kids=[25126327], score=None, time=1605632882, title=None, item_type='comment', url=None, parent=25124213, text='Reading all of these threads, I think the conclusion is: we still haven&#x27;t figured out how to do revision control in an intuitive way, because it is highly nonlinear and our brains just don&#x27;t work that way. There isn&#x27;t a clear vocabulary for intricacies of revision control, yet. And if you can&#x27;t name something clearly, you can&#x27;t explain it clearly.<p>The author&#x27;s idea of putting an abstraction on top of git is the way to go. As an analogy, Git is a great toolbox, but sometimes you need a plumber. I like how apt and apt-get came into being on Ubuntu.<p>The comments about the logical inconsistencies in Gits command line are a clue.<p>When is the last time you wrote a CLI utility and listed all of the commands, subcommands, and options to make sure they all had a consistent look and feel? Most single-author tools do not do this. It is a consequence of developing in a vacuum. Team-based development allows other eyes to look at it and say &quot;why is checkout used during branch in a different way then branches are checked out?&quot;. Git came from, essentially, one person. That&#x27;s part of it.<p>But that is also a legacy of Unix&#x2F;BSD. Consider `du` and `find`. Both have an option for max depth, but is it --max-depth, -maxdepth, --maxdepth, -d, or -m (or even -L for `tree`). There is a lack of consistency that is a rite of passive for Unix&#x2F;BSD acolytes that even Gnu didn&#x27;t fix... C&#x27;est la vie? Or maybe a &#x2F;bin rewrite? bahahahaa who am I kidding.<p>There&#x27;s no question Git is a powerful tool, it just needs to evolve and gain some consistency. And I think the answer is a higher level abstraction. And for the love of Benji, NOT a GUI.')