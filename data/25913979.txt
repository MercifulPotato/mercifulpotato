Item(by='ActorNightly', descendants=None, kids=[25914176, 25915105], score=None, time=1611653706, title=None, item_type='comment', url=None, parent=25905667, text='&gt;Could I sit down and write a web-facing server from scratch and have a reasonable expectation of safety? Probably not.<p>This is very suprising to me that people think this. I am not a fantastic programmer, but I don&#x27;t see writing safe code diffucly at all, you just have to understand the basics how attacks work, and follow some basic rules when writing code.<p>In order for a piece of software to be exploitable, you need to have an input channel that is not isolated from the functionality- something like  taking the parameters in the url and passing it directly to a shell is a massive failure in isolation.<p>As long as you do proper input sanitation, where the input must have certain format, and certain length for each part, and certain formatting for each part, the attack surface goes down to an absolute minimum.  For example, for all the C&#x2F;C++ code that I have seen that deals with web, only once I remember seeing a check on characters in the passed data being in the set of [0x10, 0x13, 0x20-0x7e], which should be the first check performed on any HTTP data passed to it, even before you start invalidating HTTP characters.<p>As far as memory safety goes, never rely on null terminated strings, allways copy the exact amount of data to a statically defined max, and make the buffer that holds data have the length max+1 with an extra byte that is allways set to null for every copy into the buffer. For malloc&#x2F;free, design your code so that malloc and free are in the same function at the beggining and end, and allways run memcheck and valgrind before deploying to production.<p>Between all the other mechanisms in place, like non executable stack&#x2F;heap, stack canaries, ASLR, and the tools like memcheck and valgrind, the possibility of you making an exploitable software is as low as coding it in a &quot;proven safe&quot; language (if such a thing exists) and messing up some parser input that can lead to unexpected behavior. And of course, there is still the possibility of using a library that has an exploit, or coding in an exploit in higher level logic,  but that is a danger for any language.<p>I would  bet that if taking an exploitation class for CS degrees was a hard requirement, where people understood the concept of stack, heap, and how the different types of exploits work, the outlook on this would change. I also wonder if teaching people C++ instead of C, and relying on built in memory management mechanisms to build software instead of making them manually write all the allocations by hand has an effect of a less understanding on what goes on under the hood.')