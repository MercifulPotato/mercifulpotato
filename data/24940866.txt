Item(by='mehrdadn', descendants=None, kids=[24941552], score=None, time=1604053923, title=None, item_type='comment', url=None, parent=24940744, text='Ah I see, thanks for running it! Yeah so it&#x27;s not this particular loop that&#x27;s interesting (there&#x27;s probably always going to be some simple-looking loop a solver can&#x27;t prove—and I&#x27;m sure we could come up with simpler examples), but rather, the interesting question is whether it can figure out <i>anything</i> that doesn&#x27;t map directly to bounded for&#x2F;while&#x2F;do-while loops. It&#x27;s interesting because:<p>1. If the answer is no, then what is the precise reason? Is there a legitimate reason for it? After all, a bounded loop that loops for too long is just as bad as one that never terminates, so clearly they need a way to upper-bound the instruction count for <i>any</i> loop—at which point, why is the bound even relevant? The only reason I can think of is that they do simplistic analysis (e.g. multiplying the bounds on nested loops to naively approximate an overall bound), but your examples suggest they have more sophisticated (SMT&#x2F;BMC?) solvers, and it&#x27;s not obvious to me why a modern solver would fail on <i>all</i> unbounded loops.<p>2. If the answer is yes, then it would seem they actually do allow unbounded loops after all?<p>The other possibility is they&#x27;re using the word &quot;bounded&quot; differently (e.g. maybe as a synonym for &quot;terminating&quot;), in which case it would be true that they would need bounded loops by definition.')