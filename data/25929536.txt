Item(by='Const-me', descendants=None, kids=[25931651], score=None, time=1611762113, title=None, item_type='comment', url=None, parent=25926016, text='&gt; because they do not even attempt to sync to the screen refresh rate<p>I don’t disagree with that, but I think the underlying reason is X server protocol. It’s hard to implement vsync properly when there’s a socket connecting application to display server.<p>On Windows, various GPU APIs and even parts of the GPU driver are DLLs loaded into the process. DLL functions don’t have latency and API designers don’t need to consider that (except stuff that have good reasons for latency, e.g. asynchronous draw&#x2F;compute&#x2F;copy calls). Works quite well in practice, I don’t remember screen tearing issues on Win10 unless I explicitly disable vsync, e.g. with DXGI_PRESENT_ALLOW_TEARING flag. Most apps don’t do that and don’t tear.<p>The problem statement “implement proper vsync” only looks easy on the surface. If one considers all the hairy details, a good implementation gonna affect many components of the OS, not just GUI related also power management and others. Otherwise it gonna introduce presentation latency (especially bad for online games), consume much more RAM and VRAM, and&#x2F;or waste too much electricity (especially bad for laptops).<p>&gt; If you tell the compositor to fuck of by overriding the windows redirect state or have a compositor that at least detects full screen windows<p>If a developer is in a position to replace OS components, that’s probably an embedded environment. For that case DRM&#x2F;KMS combo is already flawless, at least according to my experience. That’s not just on Pi4, I’ve developed stuff for a few other ARM SoCs, too.<p>Desktop software developers can’t replace OS components or ask users to do so. They need something that works out of the box, is reliable and efficient.')