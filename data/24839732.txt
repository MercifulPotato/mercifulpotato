Item(by='Rusky', descendants=None, kids=[24840666, 24840767], score=None, time=1603213207, title=None, item_type='comment', url=None, parent=24836607, text='I really don&#x27;t see how Rust has <i>most</i> of C++&#x27;s problems. Slow compiler, sure, though things are changing. Most complex languages in history? Only if you squint at it from 10000 feet and ignore what the complexity is doing.<p>C++ has approximately <i>eighteen</i> different partially-overlapping categories of variable initialization, many of which are legacy-but-still-used! [0] And some of those categories have changed their boundaries <i>every language version</i> since C++11 (based on the definition of &quot;aggregate&quot;).<p>C++ has three to five partially-overlapping kinds of type inference all in active use (auto, decltype(id), decltype((expr)), decltype(auto), template argument deduction)! This is interleaved with name lookup and overload resolution (below), so if some subexpression isn&#x27;t compiling how you expect, you have a <i>vast</i> space of language features potentially to blame.<p>C++ has so many kinds of name lookup and namespacing that I&#x27;m not even sure how to count them. There&#x27;s unqualified lookup, argument-dependent lookup, qualified lookup, class member access, etc. Sometimes you can&#x27;t refer to things defined later (outside a class) and sometimes you can (inside a class). There is even <i>undefined behavior</i> if you mess up <i>namespacing</i>! (Undiagnosed ODR violations are every experienced C++ programmer&#x27;s nightmare.)<p>C++ has ad-hoc overload resolution based on un-scoped identifiers, which even crosses namespace boundaries using one of the above name lookup modes. It has <i>two</i> kinds of user-defined implicit conversions (&quot;explicit&quot; and implicit) that also affect this selection process, on top of the zoo of &quot;type promotions&quot; inherited from C.<p>C++ classes have five to six kinds of &quot;special member functions,&quot; some of which may be defined automatically by the compiler, each with its own rules for when and how, based on what else is defined in the class. These also contribute to overload resolution, of course.<p>[0]: <a href="https:&#x2F;&#x2F;blog.tartanllama.xyz&#x2F;initialization-is-bonkers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.tartanllama.xyz&#x2F;initialization-is-bonkers&#x2F;</a><p>Rust has a complexity of its own, but it&#x27;s quite different in scale and quality. There is exactly one way to initialize a variable, exactly one kind of type inference, only two ways for names to be resolved (directly or via an imported trait). Overloading, implicit conversions (of which there is only one kind, Deref), and the replacement for &quot;special member functions&quot; (Copy, Clone, Drop) are all based on exactly one mechanism (again, traits).<p>The article has a pretty accurate description of how people experience Rust&#x27;s remaining C++-like complexity, IMO: &quot;I don&#x27;t remember the order in which methods are resolved during autoderefencing, or how module visibility works, or how the type system determines if one impl might overlap another or be an orphan.&quot;<p>But one important aspect it leaves out (not being a C++ article) is that if you mess up any of these, you just get a compiler error- and Rust is well-known for having extremely helpful error messages. In C++ you <i>may</i> get a compiler error (known for being extremely <i>un</i>helpful) or you may get undefined behavior.<p>Zig is certainly a smaller language than either C++ or Rust, but that comes at a cost. I would much rather hear discussion of those <i>actual</i> trade-offs than yet another &quot;Rust is just as complicated as C++&quot; non-claim.')