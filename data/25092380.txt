Item(by='mpweiher', descendants=None, kids=[25092749], score=None, time=1605363115, title=None, item_type='comment', url=None, parent=25091525, text='So we are agreed that mixing tracing GCs with any other form of memory management (including another GC) is an unsolved problem.  Good.<p>Swift is a disaster, also agreed.  So?<p>For the rest:  actual research disagrees with your forceful but unsubstantiated assertion:<p><a href="https:&#x2F;&#x2F;2013.splashcon.org&#x2F;details&#x2F;oopsla-2013-papers&#x2F;21&#x2F;Taking-Off-the-Gloves-with-Reference-Counting-Immix" rel="nofollow">https:&#x2F;&#x2F;2013.splashcon.org&#x2F;details&#x2F;oopsla-2013-papers&#x2F;21&#x2F;Tak...</a><p>And once again, tracing GCs do well in microbenchmarks where you only check the cost of local operations.  They are <i>horrible</i> when you take the global effects into account, with those local&#x2F;benchmarking advantages not translating into real world use.<p><a href="https:&#x2F;&#x2F;people.cs.umass.edu&#x2F;~emery&#x2F;pubs&#x2F;gcvsmalloc.pdf" rel="nofollow">https:&#x2F;&#x2F;people.cs.umass.edu&#x2F;~emery&#x2F;pubs&#x2F;gcvsmalloc.pdf</a><p>Very similar to JITs, which also do massively better in microbenchmarks than in production code:<p><a href="http:&#x2F;&#x2F;blog.metaobject.com&#x2F;2015&#x2F;10&#x2F;jitterdammerung.html" rel="nofollow">http:&#x2F;&#x2F;blog.metaobject.com&#x2F;2015&#x2F;10&#x2F;jitterdammerung.html</a><p>Oh, and integrating well and without high cost to fast languages where you have even more control is actually an important feature.')