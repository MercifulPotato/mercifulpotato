Item(by='samatman', descendants=None, kids=[24853340, 24852699, 24853403], score=None, time=1603315895, title=None, item_type='comment', url=None, parent=24837898, text='An alternate title: &quot;Just Shotgun Parse Your Inputs&quot;.<p>This isn&#x27;t bad advice <i>across the board</i>, but it is bad advice for many applications.<p>This is how you end up with context-sensitive formats, or ones where the semantics of a particular particle require running the parser, or worse. It exposes a rich surface area for exploitation with adversarial inputs.<p>That said, the advantages cited at the front of the article are all real: error recovery and decent error messages are unsolved problems with existing parser generators, although ANTLR is pretty good at it.<p>But, especially if you&#x27;re developing the data format rather than just implementing it, I strongly suggest using something like Instaparse which can generate a parser directly from a grammar.  Once this is solidified, it&#x27;s reasonable to hand-roll something, but even there, I suggest using a nice parser combinator library, like hammer or Nom.<p>This provides more discipline: as long as you&#x27;re coloring inside the lines, you&#x27;ll end up with a parser which actually implements your spec. When you start adding functions to provide context, recover from errors, and provide meaningful feedback in the form of error messages for unexpected inputs, you&#x27;ll know what you&#x27;re doing: a classic recursive-descent parser can&#x27;t provide the same conceptual separation between the parsing logic and the logic to support ergonomics or one-pass compiling or whatever add-ons you&#x27;re putting in there.')