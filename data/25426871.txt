Item(by='marcan_42', descendants=None, kids=[25427448, 25428127, 25429976, 25428751, 25427746, 25428730, 25427062, 25426990, 25427958, 25431037, 25427527], score=None, time=1608005105, title=None, item_type='comment', url=None, parent=25426195, text='This is still bad engineering on Netflix&#x27;s part. You can&#x27;t and shouldn&#x27;t rely on your audio handler getting called on time via a timer in order to keep playback stable, <i>especially</i> not on a non latency sensitive use case, which Netflix very much isn&#x27;t.<p>If you&#x27;re doing real time audio, your processing loop needs to be <i>directly</i> driven by audio hardware buffer events&#x2F;interrupts (through as many abstraction layers as you want, but a traceable event chain nonetheless, no sleeping guesswork or timers - and ideally all those threads should be marked real-time, never allocate any memory, and never lock or block on anything else). This is what serious real time audio systems like JACK do. And if you&#x27;re not, you need to be capable of buffer filling way more than one frame&#x27;s worth of audio - at least 100ms, preferably much more. Not just for robustness, but also for battery life.<p>Sure, there was an Android bug here, but the way Netflix designed this is fragile and, as someone who has messed with audio&#x2F;video programming enough, wrong. Had they done things properly, they would&#x27;ve been insulated from this OS bug.<p>This kind of bug is best used as a learning experience: what happened here consistently and resulted in completely destroyed playback on one device, is something that has always been happening sporadically and hurting all of your users whenever something causes the CPU to stall or slow for long enough to miss the deadline anyway. Instead of just fixing the bug, make your software robust against these cases, and then all your users win.')