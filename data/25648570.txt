Item(by='dpryden', descendants=None, kids=[25650039], score=None, time=1609869643, title=None, item_type='comment', url=None, parent=25647279, text='I&#x27;d like to chime in and say that I also like C but really dislike Go.<p>C is simple, to what today is nearly an absurd degree, but it at least integrates well with an enormous ecosystem of existing tooling and libraries. Go, by contrast, feels the need to re-invent every possible wheel, often with a seemingly intentional effort to be different <i>just because</i>.<p>C ABIs are rock solid on every platform. Any language or tooling in the world can load functions from a C library. By contrast, try calling Go from another language. You will quickly give up and use network protocols or subprocesses instead.<p>The converse is true too: on major platforms, the C library defines the operating system more than the kernel does. (I mean, in a Unix sytem, the entire libc is documented in the man pages. Documentation for writing C is literally built into the operating system.) By contrast, Go decides to avoid the standard platform ways of calling every operating system function, and instead implements syscalls directly into the kernel, basically just because Go hates interoperating with anything that&#x27;s not Go.<p>C is a good language not because it is a good <i>language</i>, but because it is a good <i>ecosystem</i>. Unix and C are closely intertwined. (Even Win32 and C are pretty closely intertwined!) I could imagine a Go-based Plan9-like system -- if that existed, and had decades of engineering behind it, I could see the argument being made that Go&#x27;s ecosystem compares to C&#x27;s. But while Go may aspire to that, it isn&#x27;t anywhere near there yet.<p>And when you start comparing Go with other languages on the basis of <i>language</i> features, I think Go fails laughably more often than not. (I&#x27;ll give you &quot;C++ is a clumsy mess&quot;, though.) But compare Go with Rust, with C#, with Haskell -- for that matter, compare Go with <i>Java</i> and I think Go is a less powerful, less <i>useful</i> language to write real code in.<p>If I want a lightweight, quick-and-dirty program, I&#x27;ll use Python. If I want to write a reusable library that gets plugged into other software, I&#x27;d go with C (or at least write the interop layer in C). If I want a high-performance server, these days I would probably go with Rust. If I want a pragmatic, well-rounded language to write a large project in, I think C# would probably be my first choice.<p>What space does that leave for Go? Outside of microservices (where I contend that Rust is a <i>much</i> better choice, and there are lots of other options), Go&#x27;s niche seems to be command-line tools. I sort of understand that, because Go&#x27;s static linking makes redistributing binaries relatively easy (although Go by no means has a monopoly on that). But in the space of command-line tools, Go&#x27;s argument handling is frankly bizarre: it looks at decades of precedent about what users expect from argument syntax and behavior and decides to throw it all away and reinvent the wheel.<p>I guess that means this comment (rant?) has ended up where it started: Go defies convention, basically &quot;just because&quot;. By contrast, C <i>defines</i> convention. &quot;If you like C, you will love Go&quot;? Nope, not at all.')