Item(by='Dylan16807', descendants=None, kids=[25027870], score=None, time=1604858605, title=None, item_type='comment', url=None, parent=25024673, text='&gt; You&#x27;d get extremely slow code with this approach!<p>You must be interpreting that differently than I meant it.  The approach I&#x27;m suggesting is &quot;pretend debuggers don&#x27;t exist when optimizing&quot;.  It gives you the fast code.<p>A debugger can break any assumption you make.  Even unoptimized code could crash if a debugger messes with it.  The fear of a debugger should never make you decide not to do an optimization.<p>How would you use a guard if you want to deoptimize because a debugger attached? You&#x27;d have to have a guard between each instruction, and even then it might not be enough.<p>&gt; Yes, you&#x27;re guessing that nobody will attach a debugger and you&#x27;re guarding that no debugger has been attached. That guard is usually implicit.<p>&gt; So you deoptimise when someone starts debugging.<p>If an &quot;implicit&quot; guard means &quot;we&#x27;ll have a function the debugger calls, telling us to redo the compilation&quot;, then that&#x27;s not something you need to do dynamic analysis for, and it doesn&#x27;t make your compilation more complicated.  You don&#x27;t &quot;speculate away&quot; that case unless you&#x27;re using the word &quot;speculate&quot; to include &quot;completely ignore for now, without even a guard&quot;, which I didn&#x27;t think fell under that umbrella.  Does it?<p>&gt; It can be wrong... if someone&#x27;s using a debugger.<p>It&#x27;s not wrong.  A debugger can make 2+2 be 5.  Debuggers don&#x27;t follow any rules, but that doesn&#x27;t mean your compiler should try (and inevitably fail) to make code that works in a world where no rules exist.')