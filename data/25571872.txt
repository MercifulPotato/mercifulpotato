Item(by='jasode', descendants=None, kids=[25572341, 25572363], score=None, time=1609261341, title=None, item_type='comment', url=None, parent=25571298, text='<i>&gt;It was just as easy to develop and deploy a VB app connected to an Access DB in, </i><p>And that VB desktop app was <i>not accessible to web browsers</i>.<p>The business expectations&#x2F;requirements <i>changed</i>.<p>E.g. when I wrote the VB desktop app for <i>internal</i> sales rep, I didn&#x27;t need to code a &quot;login screen&quot; because the rep was already authenticated by virtue of being on the corporate network.<p>But if business says that checking product prices should be &quot;self-service&quot; by <i>outside</i> customers using a web browser,  now I have to code a login screen.  ... which means I also have to create database tables for customer login credentials... and code the web pages to work for different screen resolutions, etc, etc.<p>Yes, VB paradigm shift was a 10x productivity improvement over raw C Language (that&#x27;s a programming syntax and environment change and not just a library) ... but it&#x27;s overshadowed by having to write more code for <i>previously unavailable</i> business capabilities.  New business expectations will always make it seem like we&#x27;re running to stand still.  It&#x27;s not just the ratio of accidental to essential complexity.<p>After writing out of bunch of thoughts on this... I propose a another way to translate Brook&#x27;s paper which is still consistent with his message:  The new business requirements (new essential complexity) will always outpace programming technology improvements (e.g. accidental complexity reductions of using GC to manage memory instead of manual malloc()&#x2F;free()).<p>This is why accidental complexity is always a smaller component of Total complexity.  Thus, the real 10x programming improvements don&#x27;t actually make us 10x faster at finishing business software.<p>EDIT reply: &quot;<i>&gt;business requirements change has little to do with his point:</i><p>I interpret &quot;essential tasks&quot; and &quot;essential difficulties&quot; as modeling the business requirements.  I&#x27;m saying his first paragraph can be interpreted that way.    If you disagree, what would be some example programming code that shows &quot;essential tasks&quot; that&#x27;s <i>not</i> related to business requirements and also <i>not</i> &quot;accidental complexity&quot;?<p>(He&#x27;s saying the <i>essential</i> task is the <i>&quot;complex conceptual structure&quot;</i>.)<p><i>&gt;For most given requirements, it is not 10x easier to do something from scratch today than it was 30 years ago.</i><p>If the given requirements are <i>the same</i> as the 1980s but I also I get to use newer tools that didn&#x27;t exist in 1980s (SQLite instead of writing raw b-trees, dynamic collections instead of raw linked-lists, GUI toolkits instead of drawing raw rectangles to the screen memory buffer by hand, etc), then yes, coding from scratch will be much faster.<p><i>&gt;Of course applications 30 years ago had login screens and were accessed remotely, they just didn&#x27;t do that using HTTP and HTML, which set us back in terms of some capabilities for a while.</i><p>This misses the point of my example.  I was trying to emphasize the new business requirement of <i>customers</i> -- not employees -- accessing corporate database systems.<p>Therefore, a new GC language to alleviate mental burden of malloc() doesn&#x27;t really help with that new complexity.  It wasn&#x27;t about mainframe green screens to http&#x2F;html.  It was about the new business functionality for <i>customers access</i> that makes it seem like programming productivity didn&#x27;t improve at all.<p>The mainframe greenscreen wasn&#x27;t relevant because customers  at homes don&#x27;t have X.25 T1&#x2F;T3&#x2F;ISDN connections to connect to the company&#x27;s mainframe.<p>This is not an example of &quot;web being backwards&quot; or &quot;catching up to old greenscreens&quot;.  The end customers didn&#x27;t previously have access to the mainframe at all.  Therefore, it&#x27;s <i>new business functionality</i> to empower customers that must be coded.<p><i>&gt;we haven&#x27;t developed any new programming paradigm or technique that has increased our ability by much.</i><p>Even if we exclude libraries, I still think garbage collected language (deployed on regular commodity pc instead of expensive Smalltalk workstation) is a 10x productivity improvement over C&#x2F;C++ malloc&#x2F;free&#x2F;new&#x2F;delete for line-of-business apps.  Chasing random pointer bugs will slow productivity way down.  And languages like PHP where the HTML templating was a 1st-class concept alongside the code is 10x improvement over HTML that was generated in CGI stdout of C and Perl scripts.  New programming paradigms do help the <i>coding</i> aspect of productivity a lot.  They just don&#x27;t increase total <i>business projects&#x27; productivity</i>.')