Item(by='dwohnitmok', descendants=None, kids=None, score=None, time=1611248240, title=None, item_type='comment', url=None, parent=25856727, text='&gt; That&#x27;s a strange claim. I mean, yeah, maybe you can say that it&#x27;s more advanced than &quot;vanilla&quot; Haskell, but how many people use no extensions at all?<p>Let me broaden that then. Typescript&#x27;s type system is more expressive than even the proposed list of GHC2021 extensions. You really need to turn on &quot;GHC and the kitchen sink&quot; (basically your code is probably going to be using the singletons library and everything that entails) to get to the feature set of Typescript&#x27;s type system. I think that&#x27;s beyond what the vast majority of Haskellers use or are comfortable with.<p>&gt; But when compared to Scala 3 - is there anything major that you can do with typescript but not with Scala 3?<p>Plenty. Part of it has to do with the fact that interfaces are truly structural types in Typescript whereas traits are still nominal in Scala 3. So for example, Typescript lets you have &quot;complement types&quot; (i.e. give me all the fields of A except those in B) which you cannot do in Scala 3.<p>Here&#x27;s an example of a useful type-level thing I&#x27;ve found myself wanting all the time in Haskell and Scala that is very straightforward in Typescript.<p>Often we have a record<p><pre><code>    data MyRecord = MyRecord\n        { field0 :: Int\n        , field1 :: Bool\n        , field2 :: Bool\n        }\n</code></pre>\nthat must undergo validation first before we can generate the record (e.g. parse out a bunch of strings for each field into Ints and Bools where those parse operations may fail).<p>It is tedious to write a whole new data type which duplicates all the fields, but just adds a Maybe in front of each type. Haskell has a design pattern known as &quot;higher-kinded data types&quot; that tries to mitigate that.<p><pre><code>    data MyRecord f =\n        { field0 :: f Int\n        , field1 :: f Bool\n        , field2 :: f Bool\n        }\n</code></pre>\nIn its more sophisticated form we can use type families instead of normal higher-kinded types along with TypeApplications to make this fully seamless and get rid of a lot of Identity wrappers. Scala 3 allows something similar with match types (in fact you don&#x27;t even need match types for getting rid of Identity wrappers due to Id in Scala being a type synonym and being able to do the equivalent of TypeApplications for higher-kinded type synonyms).<p>This approach, however, doesn&#x27;t quite work if you have multiple validation steps that return multi-field fragments of MyRecord (e.g. one step returns a fully validated field0 and field1 and another returns a fully validated field2). You basically need to resort to writing a bunch of duplicated types again (type families can kind of save you if you happen to have all entirely distinctly types).<p>Typescript&#x27;s mapped and conditional types handle this with aplomb, letting me generate any combination of fields wrapped in any combination of types from a single type definition.<p>Separately, in another comment in this same chain I give an example of (limited) dependent types in Typescript. I think you can replicate it with singletons in Haskell, but that&#x27;s definitely getting into stuff that I would say &quot;doesn&#x27;t compose and does not age very well&quot; in Haskell (ah should the blessed day that dependent Haskell lands arrive soon!). AFAIK you can&#x27;t replicate that in Scala 3 because of a lack of value to type promotion mechanisms (I think even with match types it&#x27;s not quite sufficient).')