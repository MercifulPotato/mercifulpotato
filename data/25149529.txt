Item(by='dkersten', descendants=None, kids=None, score=None, time=1605794634, title=None, item_type='comment', url=None, parent=25124468, text='&gt; &quot;I hate OOP, hence I do Clojure&quot;<p>Which is a bizarre stance. Rich Hickey has always said that Clojure has great OOP support, it just doesn&#x27;t force an all or nothing approach on you. Do you want inheritance without classes? You can have that. Want interface? Dispatch? Encapsulation? Whatever OOP feature you want, Clojure likely has support for it (without dropping to Java, obviously you can use Java OOP if you really want, too), it just lets you mix and match the individual features and apply them as makes sense to you. And Common Lisp has CLOS.<p>So, yeah, I agree that the common &quot;OOP bad, FP good&quot; sentiment is missing the point.<p>With that said, I personally do believe that OOP is a bad default. By which I mean, in any typical non-trivial program I write, the amount of OOP that I feel makes sense is usually not the dominant part (but its still a significant part), that usually I don&#x27;t want to hide data at all preferring data structures that can be accessed directly (like in Python or Clojure) and that most data processing is funcitonal-like transformations. I also feel that immutable state is the best default as mutable state should be carefully thought about and managed. Basically, in my opinion, OOP should be de-emphasized somewhat, but its still an important tool that I use in pretty much every non-trivial project.<p>For example, I&#x27;ve recently written a successful cryptocurrency trading bot where the trading logic is a pure function of market data, state of your orders and your strategies local state, running in a database transaction, and its output is a sequence of actions to be performed (orders to place&#x2F;cancel&#x2F;edit, new local state to persist to database, etc). It uses an OOP style architecture for its top level services and to abstract the different data sources and exchanges, but the actual decision making logic is a pure functional sequence of transformations (under the hood; what the user actually sees is an event driven state machine that generates the desired world state, which gets diffed with the actual world state to produce the required actions). Basically, an FP core wrapped in an OOP set of DI-able services. Its worked out very well.')