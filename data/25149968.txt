Item(by='wlll', descendants=None, kids=[25154782, 25150704, 25158868], score=None, time=1605796904, title=None, item_type='comment', url=None, parent=25148909, text='&gt; I don&#x27;t use Ruby but I faced similar issues with Rust&#x27;s clippy and rustfmt. But I still think it&#x27;s better than the alternative.<p>I also use Go, and haven&#x27;t had issues with the autoformatter there, but I believe that&#x27;s mostly because there is little to no room for ambiguity around intent. You tell the compiler you want to return a Bool, and if you don&#x27;t it&#x27;s a compile time error. There&#x27;s no &quot;I dunno, maybe nil <i>was</i> an intended return value&quot;.<p>&gt; Every time I&#x27;m tempted to override one of these links&#x2F;formats because I feel like my way is better I like to remind myself that it&#x27;s going to set a precedent for the other devs on the project<p>I think this misses the point somewhat. This isn&#x27;t about changing the defaults of Rubocop, it&#x27;s about not having some of those defaults in the first place for the places in Ruby where it&#x27;s possible to express intent in a way that it&#x27;s not possible to check with a linter.<p>&gt; That&#x27;s the thing though: consistency is somewhat objective (and enforceable), readability and maintainability not so much.<p>I&#x27;m still not saying that people should not use linters, just because you can lint <i>something</i> doesn&#x27;t mean you have to lint <i>everything</i>.<p>&gt; TFA is a good example of this: they argue that explicitly returning &quot;nil&quot; is more readable and better communicates intent but I suspect (once again, not being a Ruby coder myself) that other experienced Rubyists could respond that everybody knows that a method finishing without an explicit value ends up returning nil, and that adding explicit code to do is is just clutter and distracts from the important things.<p>Oh, absolutely, most Ruby programmers do know this, but it&#x27;s not really about the code specifically I think, it&#x27;s about the contract. Take this code:<p><pre><code>  def foo\n    @some_instance_var = 123\n  end\n\n</code></pre>\nIt turns out that:<p><pre><code>  &gt; a = foo\n  =&gt; 123\n  &gt; a\n  =&gt; 123\n</code></pre>\nbut you&#x27;ve not actually said that the return value is intended, or a side effect. You&#x27;ve not telegraphed the intent to the consumer of this tiny little API. It looks like returning a is merely something that happens to happen. this leads to uncertainty, guessing and possibly bugs. Take this addition later on:<p><pre><code>  def foo\n    @some_instance_var = 123\n    @some_other_instance_var = 456\n  end\n</code></pre>\nIf someone was (perhapy mistakenly) relying in the return value of foo to be the result of the assignment to @some_instance_var they now likely have a bug. Hopefully tests caught it, but they might not have.<p>We could fix this with (amongst other things):<p><pre><code>  def foo\n    return @some_instance_var = 123\n  end\n</code></pre>\nWe now know two things.<p>1. If we are changing this method we need to respect the return<p>2. If we are consuming this method we know the return is deliberate<p>This unfortunately violates Rubocop&#x27;s redundant return detection and will be rejected (as will other forms).')