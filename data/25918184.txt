Item(by='jerf', descendants=None, kids=None, score=None, time=1611680344, title=None, item_type='comment', url=None, parent=25917205, text='&quot;I havenâ€™t worked on large code bases, only run small ML analyses on tabular data.&quot;<p>While I endorse the other answers, I do want to highlight how the issues only appear at <i>scale</i>. I have no problem using a dynamically typed language for up to low-hundreds of numbers of lines. But that&#x27;s about where I start to get nervous I&#x27;ve picked the wrong language. (Or, putting it a different way, about day 3 of working on the same code base continuously.)<p>When the whole program fits on the screen, essentially, it&#x27;s no big deal to not have types.<p>But as the program grows, the problems emerge.<p>I think I have a minority view on what the problem that emerge is, though. I think the first problem a dynamically-typed code base usually encounters is that there is some function that accepts an object of some kind, and you discover that it actually needs to accept a list of that object sometimes instead. In a statically-typed language, you change the type from &quot;MyObject&quot; to &quot;MyObject[]&quot; and immediately change all the call sites. Possibly you even discover the change reverberates back up the program design, and you push it up higher, with the compiler helping all the way.<p>With dynamic languages, you tend instead to do something like:<p><pre><code>    def myOldFunction(obj):\n        if typeof(obj) != typeof([]):\n            obj = [obj]\n        # function continues\n</code></pre>\nWell, that&#x27;s if you&#x27;re lucky. It seems to be more popular to instead decorate the entire function with if statements every time &quot;obj&quot; is used, but let&#x27;s take this instead.<p>Now you&#x27;ve taken your first step down a dark road, where you now have a function that accepts an object, or maybe an array of those objects. Then you decide to treat None&#x2F;nil&#x2F;whatever as an empty list. Then you realize that sometimes the return value also needs to be a list of whatever it used to return, but you have to add a parameter to the call now to specify you want a list in the return value so you don&#x27;t break all the old callers.<p>You inevitably head down a road where the function is filled to the brim with entangled concerns from a lot of other code. Then you start getting lots of these functions in a codebase together, and the codebase can never again be refactored because it&#x27;ll break everything. (Or, rather, it can be, but only in very constrained ways.)<p>By contrast, I prefer even to prototype in static languages now, because when I make a mistake in the signature a function should have, in just a minute or two, I can <i>fix</i> it, and it&#x27;s <i>gone</i> like the mistake was never there because the compiler made me fix it (and, fortunately, helped). It is <i>much</i> easier to maintain a discipline where every function isn&#x27;t deeply entangled with another when you&#x27;re not carrying along the entire history of the function&#x27;s input and output parameters forever.<p>As you scale up, other problems emerge too, like the difficulty of using static analysis tools and the way documentation and unit tests have to carry a <i>lot</i> more water because the code is so much harder to get a grasp on... but whenever I&#x27;m starting a new code base, or even just a new module in an existing code base, it is <i>always</i> the above problem that is the first one I hit in a dynamic language and the first benefit of a static language I notice. A lot of the other scaling issues take months or even years to develop, but this is the one I notice in days, or in the worst cases even mere hours. I sometimes wonder how much of the &quot;prototype one to throw away&quot; comes from people using dynamic languages; usually with not much extra effort, my statically-typed &quot;prototype&quot; comes out production quality by the time I&#x27;m done working with it this way. The end result may not much resemble what I first sketched out, but I got there with a clear set of easy steps, and usually I don&#x27;t even take that large a step backwards since I pair everything with unit tests and between the static types and tests I&#x27;m usually always moving forwards even as I make rather substantial changes in the codebase that I wouldn&#x27;t dream of doing in dynamic languages because I know from experience that it&#x27;s much harder to avoid breaking things and taking huge steps backwards even as I move some part incrementally forward.')