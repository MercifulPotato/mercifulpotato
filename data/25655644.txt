Item(by='siraben', descendants=None, kids=[25655798, 25667683], score=None, time=1609920695, title=None, item_type='comment', url=None, parent=25654434, text='Lira[0] and its readable paper[1] is a good example of abstracting smart contracts into a statically typed, domain-specific language that describes the contract precisely at a high level.  It&#x27;s not Turing complete, which works for a large class of contracts (for instance, see the American and Asian options examples in [1]).<p>One concern with logic programming is cost of computation, on Ethereum every transaction has a gas associated with it and so you can&#x27;t run computations that go over the gas available in a block.<p>Turner&#x27;s ideas of Total Functional Programming[2] might have application in the smart contract space as well, since you disallow general recursion but allow structural recursion, you can likely precalculate or bound gas costs accurately ahead of time.<p>As for being statically typed, I completely agree, Solidity&#x27;s poor design choices contributed to millions of USD in loss (e.g. DAO hack) because the developers were not able to easily reason about the implicit behavior or concurrency model.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;etoroxlabs&#x2F;lira" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;etoroxlabs&#x2F;lira</a><p>[1] <a href="https:&#x2F;&#x2F;bahr.io&#x2F;pubs&#x2F;files&#x2F;bahr15icfp-paper.pdf" rel="nofollow">https:&#x2F;&#x2F;bahr.io&#x2F;pubs&#x2F;files&#x2F;bahr15icfp-paper.pdf</a><p>[2] <a href="http:&#x2F;&#x2F;www.jucs.org&#x2F;jucs_10_7&#x2F;total_functional_programming&#x2F;jucs_10_07_0751_0768_turner.pdf" rel="nofollow">http:&#x2F;&#x2F;www.jucs.org&#x2F;jucs_10_7&#x2F;total_functional_programming&#x2F;j...</a>')