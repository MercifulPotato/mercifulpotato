Item(by='bullen', descendants=None, kids=None, score=None, time=1610805724, title=None, item_type='comment', url=None, parent=25789295, text='This has been my primary focus for two decades, I litteraly can&#x27;t work in slow environements:<p>1) I encourage people to use Java on the server and hot-deploy to the servers directly with async. non-blocking: <a href="http:&#x2F;&#x2F;github.com&#x2F;tinspin&#x2F;rupy" rel="nofollow">http:&#x2F;&#x2F;github.com&#x2F;tinspin&#x2F;rupy</a><p>2) For clientside: mostly C syntax (compiled with C++ compiler) is your best option and I recently made a in-app debugger for Windows: <a href="http:&#x2F;&#x2F;move.rupy.se&#x2F;file&#x2F;stack.html" rel="nofollow">http:&#x2F;&#x2F;move.rupy.se&#x2F;file&#x2F;stack.html</a> (this delivers something much worse than a Java stacktrace but as good as it gets without a VM).<p>I also hot-deploy the C&#x2F;C++ app code with a .dll to my .exe and the debugger works for that hot-deployed .dll too!<p>On linux the .so hot-deploy works as well, the only reason I have not taken the addr2line source to port the in-app debugger is that I know which hardware I&#x27;m working on as I only plan to ship linux on ARM! Fight features where you can, in this case limit your porting and exposure to unknown unknowns!<p>Potentially I can hot-deploy the client .dll&#x2F;.so over my hot-deployed server pipeline, making the platform a distributed real-time system where you can patch the native code in real-time remotely while users are using your app! Mostly usable for development I guess (¯\\_(ツ)_&#x2F;¯), but still really exiting!')