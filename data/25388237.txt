Item(by='ivanbakel', descendants=None, kids=[25388355], score=None, time=1607707714, title=None, item_type='comment', url=None, parent=25387568, text='&gt;A simple thought experiment - think about the most widely used libraries and tools across the whole developer ecosystem. How many are built in Haskell? I count maybe one, Pandoc.<p>Purescript and Elm are two more. If you don&#x27;t count languages, then Xmonad and Darcs are another two. Both Github and Facebook&#x27;s efforts in mass source-code searching are written in Haskell (though Facebook&#x27;s is not really released to the whole developer ecosystem).<p>This is also a misguided thought experiment - Haskell is relatively unpopular anyways (as Rust is). It has a reputation for being difficult to learn (as Rust does). How many tools across the developer ecosystem are written in Rust? Ripgrep, and maybe Alacritty. Does this reflect badly on Rust? No, it&#x27;s immature and needs a lot of developer support - which is why much of Rust&#x27;s development effort is in new libraries.<p>Does a(n alleged) lack of tools reflect badly on Haskell? No, both because it was for a long time considered an academic language, and because Haskell&#x27;s great successes have also been outside of the &quot;developer ecosystem&quot; - in webservers, for example.<p>And none of this addresses my original objection to your point: why, if simplicity is so productive, is it not easy to replace complicated libraries with simpler versions? In Haskell, the answer is that the simpler versions are much less powerful, and the power of advanced languages features is actually a boon for productivity, because encoding your invariants in a good type system saves you work elsewhere. That&#x27;s the whole benefit of Rust&#x27;s borrow-checker over C++. There is no real risk of Rust getting &quot;too complicated&quot;, because these advanced concepts <i>still let people build shit</i>.')