Item(by='choppaface', descendants=None, kids=None, score=None, time=1603988561, title=None, item_type='comment', url=None, parent=24919893, text='Wow thanks for the extra context here!  My read of capnp was that you probably couldn&#x27;t write capnp with std::unique_ptr and STL streams as-is (or relying on STL would make it really hard), and thus the capnp design necessitates the core of kj, and once you start there you have to add most of the other stuff in kj.  I do very firmly agree that C++11 had holes in either features or support when capnp first rolled out, though C++ has caught up over the years.<p>I still think if you wanted to re-write a capnp library today, you&#x27;d still need kj, or at least most of it, simply for the memory control.  The added benefit of kj is that you don&#x27;t have to deal with C++ STL bugs and quirks.  E.g. I believe C++ spec didn&#x27;t require std::optional to use in-place new until recently ...<p>Also curious if you have any comments on this read of kj from a software management perspective.  I imagine trying to sell the investment of writing something like kj at a company and it being a tough sell, even if capnp was approved.  You clearly knew what you were doing from the outset and certainly nobody could have done it better.  But I believe capnp sits close to the decision boundary of where many companies decide to invest in greatness or not, and reflection might shed light on why some managers make the wrong choice on something like this.')