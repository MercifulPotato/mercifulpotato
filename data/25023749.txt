Item(by='raffraffraff', descendants=None, kids=None, score=None, time=1604819222, title=None, item_type='comment', url=None, parent=24996089, text='Most of these things boil down to a few very simple rules (because I rarely run into these problems and I certainly don&#x27;t have more than a few simple rules).<p>1. If your pattern contains variable expansion wrap it in double quotes (but watch out for shell variable expansion characters like &#x27;$`&#x27;)<p>2. Else wrap your search string in single quotes.<p>3. If you&#x27;re gonna do any sort of regex at all just use the &#x27;-E&#x27; flag so it behaves like a proper regex, and learn how to do basic regex.<p>4. Know your shell. Some of these gotchas come from the way the <i>shell</i> interprets the command. Again, most shell gotchas boil down to a few basic rules too (eg the single or double quote thing). For example, in bash I always surround variables in curly braces: ${THIS}. It avoids accidental bash variable expansion, or confusion about the precise name of the variable when it is concatenated with other strings in the pattern.<p>One trick I like is how to use grep as a highlighter.<p>grep --color -E &#x27;(^|My text)&#x27;<p>This matches every line because of the ^ but has nothing to color except your string (since the start of line character is not visible)<p>Also, the -A and -B flags are useful for grabbing lines after&#x2F;before the pattern. And while -C doesn&#x27;t make as much sense as those, its meaning logically follows A and B: grab the lines before and after.<p>Lastly, if you want to search a gigantic directory structure for files containing an expression, but do not want to hit every single file (eg: restrict it to &#x27;.c&#x27; files), you can use this:<p>find &#x2F;path&#x2F;to&#x2F;dir -name &quot;<i>.c&quot; -exec grep -H &quot;pattern {} \\;<p>The -H forces grep to show the file name. This gets activated by default when you grep multiple files, but find command executes a separate grep on each individual file, so you lose the filename. -H explicitly adds it.<p>Once you the -H parameter, it&#x27;s easy to remember that -h turns filename </i>off*. For example, to make a playlist containing all Bob Marley songs that are used in other .m3u playlists:<p>grep -r -h &quot;Bob Marley&quot; &#x2F;home&#x2F;user&#x2F;My Music&#x2F;playlists&quot; &gt; marley.m3u<p>This simple approach avoids having to pipe the output into another command like sed or awk to strip away the path, which may not be as simple as it sounds because the file paths may contain spaces and all sorts of other junk.')