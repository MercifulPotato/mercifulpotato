Item(by='throwaway894345', descendants=None, kids=None, score=None, time=1608490256, title=None, item_type='comment', url=None, parent=25482410, text='&gt; So what have we now? A “mono repo” codebase, because clearly a Git repository per function in your system would be too much, a large deployment descriptor per fine-grained component, which Spring maybe called “Controller” but is now called “Function”, and instead of combining them all on your desktop, you send them off to someone else’s mega-mainframe. You deploy, get an error message, and login to CloudWatch to see what actually happened - it’s all batch-driven, just like the bad old days, so progress is slow.<p>You could have a repo per function, but if you have functions with common dependencies (whether libraries or build tooling or whatever) then you need to deal with keeping those dependencies up-to-date and notifying upstream when a change breaks downstream. &quot;Monorepo&quot; is just one solution to that problem, and it&#x27;s exactly the same as what monoliths do today. You can have the same problem in a company with many monoliths, but with some amount of code reuse--&quot;monorepo vs multirepo&quot; is orthogonal to &quot;microservice vs monolith&quot;. Note that monolithic monorepos tend to work well because &quot;monolith&quot; typically implies that all dependencies are using the same language, and most languages have decent incremental build tools; however, we don&#x27;t have good polyglot&#x2F;general-purpose build tools--instead we have Bazel&#x2F;etc and Nix which each suck for entirely tractable reasons. As good leadership and investment coalesce, this class of tooling will improve, but for now building and deploying a polyglot environment is painful (but there are other kinds of pain to consider, and the microservices people argue that this pain is less than e.g. organizationally-derived pain points).<p>&gt; Conceptually, hiding a lot of the scaling and coordination machinery is not a bad idea; programming systems like Erlang and OTP have shown for decades how well that can work and Elixir is giving the platform a well-deserved surge in popularity. But there’s a big difference here: a platform like OTP handles pretty much everything that a platform like AWS Lambda handles, but it does it in a single programming language.<p>The author is really close here. What remains is a more careful analysis of why single-language programming systems feel better than multi-language programming systems and vice-versa. For example, Erlang (like any language) isn&#x27;t good at all things (e.g., you might have data-science subsystems that you&#x27;d ideally write in Python or Julia or whatever, but you might also have other parts of the system where performance and quality matter [Pythonistas, this is your cue to downvote me]), so mandating that all components be implemented in Erlang might cost more than making heterogeneous systems talk to each other. Or perhaps procuring Erlang programmers is costlier than programmers in other languages? Ultimately it&#x27;s hard for a single-language environment to beat out a multi-language environment, especially at scale (i.e. &quot;as the diversity of problems grows&quot; not &quot;as the performance demands increase&quot;). I think Erlang actually is a very cool platform, and I wish it well, but it doesn&#x27;t mean that it&#x27;s optimal for many&#x2F;most businesses today.')