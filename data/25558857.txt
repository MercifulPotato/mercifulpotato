Item(by='MaxBarraclough', descendants=None, kids=None, score=None, time=1609160303, title=None, item_type='comment', url=None, parent=25557763, text='Also, the high-level nature of Java bytecode enables&#x2F;simplifies many optimisations in the JIT.<p>For example, dynamic dispatch is handled by the JIT, it&#x27;s not encoded into low-level Java bytecode instructions, so if the JIT can see there&#x27;s only one class loaded that implements a certain interface, it can generate code that directly invokes methods of that implementing class, without going through a vtable. It can do this even across library boundaries. That wouldn&#x27;t be possible (or at least, would be greatly complicated) if Java bytecode provided pre-baked machine code.<p>Modern JVMs also have pretty deep integration of the GC and the JIT, if I understand correctly. The Java bytecode format is high level so the JIT is quite free to implement memory-management however it likes. If the JVM took a truly low-level approach to its IR, we&#x27;d presumably be stuck with 90&#x27;s GC technology.<p>I imagine it would also have implications for the way the JVM handles concurrency. It seems right that it defines its own memory model with its own safety guarantees, rather than defining its model as <i>whatever x86 does</i>.<p>It&#x27;s telling that .Net took the same high-level approach that Java bytecode did.')