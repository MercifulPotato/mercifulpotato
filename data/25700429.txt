Item(by='414owen', descendants=None, kids=None, score=None, time=1610201001, title=None, item_type='comment', url=None, parent=25699574, text='I&#x27;m very sorry OP didn&#x27;t stay the course, and opted to write an angry post instead.<p>&gt; Every few months some newbie comes along to the Haskell reddit and asks why is Haskell documentation so confusing, and the post get destroyed by people telling them to get good or just pointing at academic papers.<p>The Haskell subreddit has a monthly &#x27;Hask Anything&#x27;, and is generally a friendly forum.<p>I searched: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;search&#x2F;?q=documentation%20&amp;restrict_sr=1" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;search&#x2F;?q=documentation%20&amp;...</a> and was unable to find any such behavior. In fact, people asking for documentation were generally helped: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;eo7orr&#x2F;where_to_find_documentation&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;eo7orr&#x2F;where_to_fi...</a><p>&gt; “Haskell doesn’t suck, the development environment does”<p>There are certainly people who would agree with this, however our language server is pretty complete nowadays, we have amazing static analysis tools, a variety of formatters, I can&#x27;t think of any tooling I desperately miss. Then again, I&#x27;m an editor person, not an IDE person...<p>&gt; Write types and interfaces for the types and fill in the blanks. Sounds familiar? Because that’s we’ve been doing with Java and the like using UML<p>Ouch. It&#x27;s very rare to hear anyone complain about having a type system with strong guarantees. UML... Well I guess I&#x27;m not a fan of specifying your design outside of your source code...<p>&gt; Professional developers find themselves describing the system in such concrete ways using types that when the requirements change suddenly their precious castle is reduced to dust<p>Hmm, so generally the better at Haskell you are, the more you express constraints in terms of Haskell constraints, rather than concrete types. It&#x27;s a style called `Tagless Final`. I recommend taking a look. It gives you strong guarantees, without breaking any castles.<p>&gt; Somehow Haskellers think that they are more productive with Haskell when the reality in the real world is that only a few languages can proudly make that claim, such as Python and Lisp. These are languages battle tested in actual software products<p>As other people have pointed out, there are companies that use all three of these. I think it&#x27;s safe to assume OP didn&#x27;t measure the productivity of any developers before writing this.<p>&gt; Abstractions with types is a bad type of abstraction because it ignores the basic fact that programs deal with data, and data has no types<p>Have you heard of datatypes?<p>&gt; In most cases people are looking for schemas, not types<p>Schemas describe the structure of data. Types describe the structure of data.<p>&gt; Types wrap data and treat it like a black box whereas schema describes the shape and content of data<p>The former here is actually more of a slight on encapsulation, which is something you can do in Haskell, but is probably more a goto recommendation of OOP languages. It can be pretty useful to only expose the inferfaces you want, and hide the implementation.<p>&gt; most haskellers would agree that purescript is a better choice compared to GHCJS. No man is an island, and yet Haskellers generally convinced themselves that other languages need to learn from Haskell<p>Are you saying Purescript didn&#x27;t learn from Haskell? Have you seen PureScript?<p>&gt; Instead of explaining Monads like all other design patterns out there, they insist on using some obscure definition from category theory to explain it<p>Pick a monad explanation that suits you. There are plenty of posts &#x2F; tutorials online.\nSome people like burritos, some people like mathematics.\nI recommend looking at the type of (&gt;&gt;=), as in the end, that&#x27;s the only operation a Monad adds (above Applicative)...<p>&gt; Look, when monads are used without the infix notation, the result is horrendous and it looks like yet another callback chain<p>I think you mean when they&#x27;re used without `do notation`.\nThis point seems moot, seeing as we have do notation.\nExplicit binds can be readable, if you&#x27;re going pointfree.<p>&gt; I tried it myself. Of course, there are very smart people who do understand Monads, but most people would just tell you to “get an intuition for it”, which to be honest is total BS<p>You&#x27;ll get there, I recommend leaving the do-notation behind, and writing some functions over Maybe, [], and Writer.<p>Don&#x27;t give up on the learning process, there&#x27;s still time to write a `How I learned Haskell` blog post, or maybe you can write the umpteenth Monad tutorial :)')