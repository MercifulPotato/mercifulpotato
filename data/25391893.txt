Item(by='vlovich123', descendants=None, kids=None, score=None, time=1607724289, title=None, item_type='comment', url=None, parent=25388967, text='I’ve implemented a lot of protocols. The more complex a protocol is and the more moving parts, the harder it is.<p>The fundamental challenge is complexity. Understanding how to build this stuff is a mix between figuring out which complexity to expose to “the masses” (masses here being other developers) and what else to hide in abstractions or better tooling.<p>I think the market would look very different if senior Linux kernel maintainers (including Torvalds) got together and said “this is the Linux power save API - implement it”. The challenge is that the same HW powers Windows (and used to power Macs and probably still does to at least some degree). No protocol worth a damn can handle that much variability. So then the question is can the firmware and driver code be given less to be responsible for rather than more and then let the kernel make all the decision making power. The problem with ACPI (at least as I understand it from reading about it superficially - I’ve never read the spec itself) is that decision making is extremely interdependent with the kernel ultimately not being fully in charge of decisions.<p>For example, a simple design for something like this is defining ACPI-lite that handles 80% of the hardware that ACPI currently supports but that drastically simplified the mental model and lets the kernel implement all the common logic with the driver and firmware not being responsible for anything more than translating kernel commands to the HW. Then you leave ACPI for the remaining 20% of HW that doesn’t fit in the bucket but you also make the warning verbose (you’re running legacy ACPI device X - this may degrade your battery power &#x2F; prevent sleep wake from working effectively).<p>If they can also get Windows kernel engineers on board then you would have a compelling market forcing function on HW makers&#x2F;driver writers to simplify their code.')