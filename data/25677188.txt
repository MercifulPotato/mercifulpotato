Item(by='dragontamer', descendants=None, kids=None, score=None, time=1610052266, title=None, item_type='comment', url=None, parent=25677020, text='&gt; Yes, I am sure that it’s GF(2^4) and not GF(2^16). The problem is not that GF(2^8) or GF(2^16) are “too big”, it’s just that GF(2^4) is faster and uses less CPU.<p>A multiply in GF(2^8) is just a single multiplication lookup. 256 x 256 == 64kB lookup table. I&#x27;m not sure how much faster you can get than a single 8-bit lookup on a table small enough to fit in a typical CPU&#x27;s cache.<p>GF(2^8) is so small that you don&#x27;t even need to do the log-table &#x2F; antilog-table trick. Just store the entire multiplication table, since the multiplication table fits in L2 cache.<p>A GF(2^4) multiply would be a single multiplication lookup 16 x 16 or 256 byte (0.25kB) lookup table. Very, very tiny, probably no faster than the GF(2^8) lookup.<p>&gt; Also note that you’re not just doing one field operation per byte, but several. If I’m remembering correctly, let’s say you’re using an (11,8) code, then you’re doing 24 multiply and 21 addition operations to calculate the encoded message.<p>That RS(11,8) code (probably shortened &#x2F; punctured) could be a GF(2^8) code. The question is: do you want to organize your data in 8-bit bytes in GF(2^8), or 4-bit nibbles in GF(2^4)?<p>I expect that 8-bit bytes is actually faster for modern computers than 4-bit nibbles. Even if you are using a severely shortened &#x2F; punctured code, there are strong benefits to sticking with 8-bit bytes on a modern computer.<p>That&#x27;s the thing: computers usually have 8-bit bytes as the smallest pragmatic unit to use. GF(2^8) lines up with that perfectly, and is used in a variety of high-performance applications (including AES).<p>&gt; The fact that space probes like Voyager use a large field size is just because the cost of resources is different. For space probes, bandwidth is a precious resource. If you spent $250M on a single space probe, you can afford to use a bit more CPU to encode and decode your 100 kHz downlink.<p>If your voyager probe launched in 1977, it was with an utter crap CPU by today&#x27;s standards. Your USB power-cable has more CPU power and RAM than the voyager probe... that tiny USB CPU is used to negotiate the voltage level (5V vs 12V USB power negotiation)')