Item(by='rcxdude', descendants=None, kids=None, score=None, time=1610284433, title=None, item_type='comment', url=None, parent=25703935, text='It&#x27;s very hard to avoid turing completeness, and it&#x27;s normally not particularly valuable to avoid it unless you have some extremely strong requirement for formal reasoning about your code. I&#x27;ve not found that difficulty of understanding correlates well with turing completeness in practice (see regular expressions for an example of a non-turing complete system which are famously difficult to understand).<p>And in the case of a build system specifically, generally if you don&#x27;t give some generally programmable interface to it then another wrapper layer will appear over it which does. Decisions in build systems are often enough complex enough to warrant a configuration language capable of expressing many different things. (This doesn&#x27;t necessarily need to be an integral part of the build system: for example rust&#x27;s package manager&#x2F;build system, cargo, has a fairly simple non-turing complete configuration file but can run a build.rs program which can through a simple protocol of printing out values adjust many of the decisions cargo makes).<p>In fact, I&#x27;d say that CMake suffers most from not embracing that from the start. It&#x27;s scripting language has clearly grown organically in a messy fashion from a configuration language, instead of being designed from the start with scripting in mind (at which point it may have just been a better idea to use an existing language, like lua, tcl, or python).')