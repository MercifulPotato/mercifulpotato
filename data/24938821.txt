Item(by='kazinator', descendants=None, kids=None, score=None, time=1604028310, title=None, item_type='comment', url=None, parent=24934990, text='Lisp compilers assume that certain things are available at compile time, but not at run-time. These assumptions are supported by the particular set of special forms that is handled, and that set is not extensible.<p>Fexprs make the set of special forms open-ended, and allow <i>anything</i> to be available at run-time.<p>If a new special form is introduced which allows something to be dynamic which was previously static, it can cause major work in the compiler.<p>It is not usually reasonable to do major work in the compiler for the sake of some special form that an application needs. It is not even possible unless the users have buildable sources for the compiler.<p>One example of an important facility about which static assumptions are made is lexical scope (a.k.a. static scope). Lisp compilers use a completely different representation for the static scope from interpreters. In a lexically scoped Lisp dialect, fexprs receive the lexical environment as an argument (necessarily so). This is a run-time object, which a fexpr can easily leak to the application directly, or else indirectly (by providing semantics like looking for a variable using a run-time symbol as a key). That is like the upvar business in tcl. It relies on the existence of a searchable structure at run time, which is the antithesis of lexical scope.<p>Still, there can be fexprs that don&#x27;t require the application writer to hack he compiler. Why don&#x27;t we just have those? fexprs users who want their code to compile will just have to write a macro. If they are not able to, then they don&#x27;t get to compile the code.<p>But those who want to compile the code don&#x27;t want to do the work twice: why write a fexpr <i>and</i> a macro, if you can just write a macro? The interpreter can work with the macro expansion, just like the compiler. Application writers want to implement something once, in one way. If you implement something twice, you have to maintain both.<p>Basically, Lisp users historically expressed the desire to compile the code without hacking the compiler, and that steered things away from fexprs toward macros.<p>Here is a big one: macros can be functionally written <i>even if the construct they implement is imperative</i>. Expanding a macro can be a side-effect-free, pure operation. If it is so, you can trust it to produce he same results on the same inputs.\nIt&#x27;s often possible to check that a macro is doing the right thing just from example expansions. The expansion works right there at the call site.<p>A fexpr carries out operations &quot;remotely&quot;, so to speak, because it&#x27;s a function. It&#x27;s a function which has to receive contextual arguments and then uses an API to access the scope. The resulting code is harder to read. The (non-hygienic) macro user just performs an expansion and sees an expression like A or #:G0025, denoting the access to a variable. He or she just has to imagine that code in place of the macro call. To debug fexpr, the user has to read code that uses some API like <i>(get-var env third-var)</i> to do the same thing.<p>Common Lisp&#x27;s mixture of lexical and dynamic scope could cause challenges for fexprs also.')