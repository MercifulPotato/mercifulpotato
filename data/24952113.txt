Item(by='derefr', descendants=None, kids=[24954227, 24952236, 24955800], score=None, time=1604157479, title=None, item_type='comment', url=None, parent=24951313, text='Seconded. It’s silly to learn threads “from the outside in” — thinking of them as an opaque abstraction and trying to understand the API they present. There’s no coherent abstraction there; you’ll only learn to cargo-cult the API, without gaining an intuition for what threads “are” or when and where you’d want to use those APIs.<p>The key thing to know, is that threads <i>aren’t</i> a first-class kernel object. In OS kernels, there are only <i>OS processes</i> and <i>memory regions</i>.<p>To learn about threads, you should just learn about OS processes; and then learn that distinct OS processes can share memory regions between them, often via subprocess-spawn-time inheritance. Learn what fork(2) does on POSIX, and how it manages to be fast.<p>Starting with that intuition, it’s simple to then absorb what “threads” actually are: a <i>usage pattern</i> for spawning and managing OS processes that share memory; and a set of convenience APIs (that may be in-kernel, as in Windows; or purely in userland, as in Linux) for setting up this usage pattern. Everything these “threading” APIs can do, you can do yourself directly using the process-management and memory-mapping APIs. And those same calls are all that e.g. libpthread is doing.')