Item(by='jkarneges', descendants=None, kids=None, score=None, time=1607042648, title=None, item_type='comment', url=None, parent=25294912, text='I believe the rationale goes like this: Rust doesn&#x27;t have a runtime, and the designers prefer to to keep it that way. But, there was also a desire for native-feeling async programming in Rust.<p>In order to reconcile these seemingly opposing stances, an abstract Future trait was added to the standard library with no implementation, along with async and await keywords to operate with it. This way, an async runtime could live outside of the standard library, but developers would still get to use nice built-in keywords.<p>It&#x27;s worth noting that despite there not being an async runtime shipped with Rust, the designers have taken an opinionated stance on the use of &quot;stackless&quot; coroutines. The await keyword is only allowed inside of a function&#x2F;block declared async, and suchs blocks always get rewritten by the compiler.<p>The end result is truly impressive though. Async Rust is more efficient CPU-wise and memory-wise than anything I&#x27;ve ever heard of. So while async Rust might be difficult to understand and use at times, it&#x27;s this way in the name of efficiency (good description of Rust in general :)).<p>I did some benching to compare hand written poll loop code to async code here: <a href="https:&#x2F;&#x2F;github.com&#x2F;jkarneges&#x2F;rust-async-bench" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;jkarneges&#x2F;rust-async-bench</a>')