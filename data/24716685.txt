Item(by='sullyj3', descendants=None, kids=[24721059, 24721465, 24716694, 24717452, 24719477], score=None, time=1602141226, title=None, item_type='comment', url=None, parent=24716525, text='Type systems can encode proofs of properties that you want your data to have. For example, suppose you want to write a function that returns the first element of a list.<p><pre><code>  head :: [a] -&gt; a\n</code></pre>\nThis is the type of a function &quot;head&quot; that takes a list of values of some arbitrary type a, and returns an a.<p>if you feed this function an empty list, what will it do? You can reason from the type signature that the only thing it possibly can do is crash, since there&#x27;s no way to produce a value of type a without knowing what a is in advance.<p><pre><code>  head (h:_rest) = h\n  head [] = error &quot;Our function is badly behaved!&quot;\n</code></pre>\nTo ensure that our function never crashes, we can encode the fact that our list is nonempty in a datatype.<p><pre><code>  data Nonempty a = Nonempty a [a]\n</code></pre>\nIe, a nonempty list must contain a value of type a, and a (possible empty) list of as. Then instead of writing a function that crashes when it receives a nonempty list, we can write a function on nonempty lists that never crashes<p><pre><code>  head :: Nonempty a -&gt; a\n  head (Nonempty x _rest) = x\n</code></pre>\nWhat I&#x27;m getting at is that, yes, this is just the &quot;shape&quot; of our data. But you can encode more interesting and valuable properties in that shape than might be apparent at first. There are many other interesting examples of using types to ensure that properties that we want to hold for our values, do in fact hold.<p>Edit: I should probably add that &quot;If it compiles it works&quot; is absolutely not always true. It&#x27;s more of a community in-joke than an actual belief. But it does turn out to be true surprisingly frequently.')