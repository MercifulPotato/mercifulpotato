Item(by='kingdomcome50', descendants=None, kids=[25990188, 25991931], score=None, time=1612196607, title=None, item_type='comment', url=None, parent=25986316, text='Okay. I don&#x27;t want to go too far off topic here but the OP is about F# so I&#x27;m certain many enthusiasts will be here, and I have been waiting for this moment to get an answer to a very specific question regarding Elmish:<p>What is the point of the Elm architecture?<p>I cannot figure out why the `model`, `view`, `update` architecture is preferable to its OOP counterpart. That is, simply defining an interface for each of the above where `IView` and `IUpdate` each contain a single method with the appropriate parameters. That is objectively[0] cleaner!<p>The current recommendation is to create these ungodly unions for handling the view&#x2F;update logic. It feels ridiculous and really starts to gum up your modules with implementation logic that is _entirely_ unrelated.<p>FP and OOP each provide different (opposite) faculties when dealing with the expression problem. FP says[1], &quot;I want to optimize for adding new _behavior_ to the same pieces of data&quot; (one can add functions that operate on the same data without needing to recompile). OOP says[2], &quot;I want to optimize for adding new _data_ with the same kinds of behavior&quot; (one can add classes encapsulating different data that have the same operations without needing to recompile). How does the above square with an architecture built around a set of _single_ functions that operate on different (changing) pieces of data?<p>The Elm architecture seems to have chosen the exact wrong paradigm (and its associated semantics) for optimizing change! You aren&#x27;t adding behavior as you build out your application in this architecture. You are adding _data_! The &quot;behavior&quot; is defined exactly one time (in the signatures of the `view` and `update` functions) and doesn&#x27;t change. I must be missing something... is this really just so we can say &quot;the complier will let us know if we forgot to handle a case&quot;? That seems like a pretty hefty trade-off if you ask me. F# has this beautiful multi-paradigm capability and, in this case, it&#x27;s been woefully ignored.<p>[0] Okay fine maybe not objectively, but it certainly seems preferable to modularize this logic.<p>[1][2] I get it. They don&#x27;t actually say anything, but the general approach to the EP remains true for most cases.')