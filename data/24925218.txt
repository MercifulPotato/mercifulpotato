Item(by='nyanpasu64', descendants=None, kids=None, score=None, time=1603926592, title=None, item_type='comment', url=None, parent=24920113, text='There are some differences in the details between KJ C++, and both Rust and my Rust-inspired C++ guidelines:<p>&gt; Value types always have move constructors (and sometimes copy constructors). Resource types are not movable; if ownership transfer is needed, the resource must be allocated on the heap.<p>In Rust, all types (including resources) are movable.<p>&gt; Value types almost always have implicit destructors. Resource types may have an explicit destructor.<p>What&#x27;s an explicit destructor? Rust&#x27;s File type closes upon destruction, and one criticism of the design is that it ignores all errors. The only way to know what errors occurred is to call sync_all() beforehand.<p>However, &quot;Ownership&quot; and &quot;Reference Counting&quot; (and &quot;Exceptions&quot; to an extent) feel very Rust-like.<p>&gt; If a class&#x27;s copy constructor would require memory allocation, consider providing a clone() method instead and deleting the copy constructor. Allocation in implicit copies is a common source of death-by-1000-cuts performance problems. kj::String, for example, is movable but not copyable.<p>When you include such a class in a larger structure, it breaks the ability for the outer class to derive a copy constructor automatically (even an explicit one, or a private one used by a clone() method). What&#x27;s the best way to approach this?')