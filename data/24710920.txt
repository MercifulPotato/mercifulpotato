Item(by='Jtsummers', descendants=None, kids=None, score=None, time=1602093840, title=None, item_type='comment', url=None, parent=24703551, text='Learning to argue both sides can help. One of the reasons I&#x27;m (fairly) good at persuading people or at least expressing my rationale even if I fail to persuade is that I have long practiced the counterarguments in my head (and often with others). It helps that I was very introverted and introspective as a teen and college student. That is, I don&#x27;t start from a position of &quot;I&#x27;m right&quot; but a position of &quot;What if I&#x27;m wrong&quot;, and then work towards a set of arguments that either go against my initial position or sufficiently justify it. At that point, I feel comfortable presenting my ideas to others.<p>With enough practice, this becomes something you may be able to do on the fly. If you&#x27;re a relatively slow thinker (I often am), it can help to set the pace. Make enough noise when you&#x27;re thinking something through that others can&#x27;t steamroll over you.<p>--------<p>Learn to express your assumptions. If I go into a design meeting and I say, &quot;X is good and how we should do it.&quot; I should back that up with my assumptions. &quot;We&#x27;re targeting an embedded, resource constrained, real-time system so we should use an appropriate language that gives us tight control over the runtime and memory usage. Therefore, I recommend we use C, given that our team is very familiar with it.&quot;<p>--------<p>A reason for stating assumptions is also that many debates are based on a misunderstanding. You&#x27;re arguing against each other&#x27;s positions because you enter with different assumptions. Using a real experience: A colleague strongly objected to the use of recursion in programs. When we finally worked it out, it wasn&#x27;t that he didn&#x27;t like recursion <i>full-stop</i>, it was that his experience was almost exclusively with real-time, embedded systems where recursion was avoided for good reason (along with things like heap allocation). He&#x27;d internalized so that it was almost a reflex to be anti-recursion. Once we were able to realize why he argued against recursion, though, he was willing to relax his stance given different circumstances (writing desktop applications, or similar environments with relatively few constraints).<p>If you state your assumptions it gives people a better chance to realize where you&#x27;re coming from. And then you can start asking for theirs. Though maybe not using the word &quot;assumption&quot;. Ask &quot;why&quot;: &quot;Why do you object to inheritance ever being used?&quot; or the counter position &quot;Why do you want a 20-deep inheritance hierarchy?&quot;. What about either of those positions makes either the design or the maintenance easier or harder, what are the trade-offs. Maybe they selected a design based on ease and speed of implementation, or ease of testing, or ease of maintenance. But each of those can have tradeoffs with the other so get them (and answer this yourself, don&#x27;t just expect others to answer these) to state their priorities. Then, even if you lose the final argument, you can at least understand <i>why</i> a decision was reached (difference in priorities, different in experiences, whatever).')