Item(by='pizlonator', descendants=None, kids=None, score=None, time=1605900493, title=None, item_type='comment', url=None, parent=25159704, text='This is really great, but RISC CPUs can have microcode too. Nothing stops them from doing that.<p>The big diff is load&#x2F;store:<p>- Loads and stores are separate instructions in RISC and never implied by other ops. In CISC, you have orthogonality: most places that can take a register can also take a memory address.<p>- Because of load&#x2F;store, you need fewer bits in the instruction encoding for encoding operands.<p>- Because you save bits in operands, you can have more bits to encode the register.<p>- Because you have more bits to encode the register, you can have more architectural registers, so compilers have an easier time doing register allocation and emit less spill code.<p>That might be an oversimplification since it totally skips the history lesson. But if we take RISC and CISC as trade offs you can make today, the trade off is as I say above and has little to do with pipelining or microcode. The trade off is just: you gonna have finite bits to encode shit, so if you move the loads and stores into their own instructions, you can have more registers.')