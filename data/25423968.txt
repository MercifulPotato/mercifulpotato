Item(by='bird_monster', descendants=None, kids=[25426219, 25426233], score=None, time=1607983191, title=None, item_type='comment', url=None, parent=25423610, text='I might-should&#x27;ve rephrased my original post to suggest that mocks for non-code-you-wrote deps are a waste, but being able to inject different implementations of code you wrote for the sake of testing still has value.<p>If you want to test how your code behaves when getting&#x2F;setting data from a database, you fundamentally cannot mock the database. If you want to test how your code forms arguments to send to a dependency, you probably can, as long as you do both. If you&#x27;re just testing that your args are correct without actually using them, you&#x27;ll never really know.<p>A specific example stands out in my mind when I watched a TDD-minded developer suggest that their code was complete because they injected a mocked version of DynamoDB into a service and then verified their tests ran. They committed and pushed without actually testing against DynamoDB. When tasked with _actually running it_, they found that there was a fundamental flaw in the way that developer perceived Dynamo&#x27;s behavior, which obviously meant their mock was totally useless.<p>If you want to test that you&#x27;re pulling the right ID off an object to send to a database you can mock. If you want to test how your code actually behaves with a database, including failure scenarios and invalid arguments, you cannot.<p>As usual, solutions are much more nuanced than I previously stated. I&#x27;ve moved away from mocks, not banished them entirely.')