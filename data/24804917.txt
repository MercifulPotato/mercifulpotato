Item(by='elevation', descendants=None, kids=[24805138, 24804958, 24805104], score=None, time=1602881345, title=None, item_type='comment', url=None, parent=24801665, text='&gt; But hereâ€™s where Yocto falls flat for me as a hardware person: it has absolutely no interest in helping you build images for the shiny new custom board you just made. It is not a tool for quickly hacking together a kernel&#x2F;U-Boot&#x2F;rootfs during the early stages of prototyping (say, during this entire blog project).<p>Let me suggest looking into the `devtool&#x27; utility.  It&#x27;s a yocto utility that enables on-the-fly work that the author enjoyed with buildroot.  For instance, running `devtool modify virtual&#x2F;kernel&#x27; will place the configured kernel source in a workspace directory where you can grep and modify and patch to your hearts content; on a new board, I might work for weeks in this state bringing up a new board as I patch drivers, or develop patches to play out-of-tree code over the mainline kernel.  When I&#x27;m happy with my changes, I add them back into my recipe and test it by disabling the temporary workspace `devtool reset virtual&#x2F;kernel&#x27; and building my recipe from scratch again.<p>Yocto has other amenities that ease iteration on existing boards.  For one, it straightforward to cross-compile my python3 extension modules in a recipe in one base layer for my product family.  Later, when I&#x27;m spinning up a derivative project, I can setup a product-specific layer to override the CPP flags, configurations, or patch the source to better target my board.<p>The yocto learning curve may be steeper, but the benefits of proper dependency tracking and layers far outweigh the drawbacks.  At this point, if I use a board from a vendor that ships a buildroot BSP, I&#x27;ll take a day to port it to yocto before moving further.')