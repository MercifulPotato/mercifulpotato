Item(by='Iceland_jack', descendants=None, kids=[24994519], score=None, time=1604534929, title=None, item_type='comment', url=None, parent=24984980, text='Here is one way one might implement a categorical Functor (<a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;eoo16m&#x2F;base_category_polymorphic_functor_and_functorof&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;eoo16m&#x2F;base_catego...</a>).<p>A function S -&gt; T maps a S(ource) type to a T(arget) type, like FunctorOf (-S&gt;) (-T&gt;) does between the source category (-S&gt;) and target category (-T&gt;)<p><pre><code>    type  Functor :: forall (s :: Type) (t :: Type). (s -&gt; t) -&gt; Constraint\n    class (Category (Src f), Category (Tgt f)) =&gt; Functor (f :: s -&gt; t) where\n      type Src (f :: s -&gt; t) :: Cat s\n      type Tgt (f :: s -&gt; t) :: Cat t\n      fmap :: Src f a1 a2 -&gt; Tgt f (f a1) (f a2)\n\n    type FunctorOf :: forall (s :: Type) (t :: Type). Cat s -&gt; Cat t -&gt; (s -&gt; t) -&gt; Constraint\n    type FunctorOf src tgt f = (Functor f, Src f ~ src, Tgt f ~ tgt)\n</code></pre>\nThe usual endofunctor<p><pre><code>    type EndofunctorOf :: forall (ob :: Type). Cat ob -&gt; (ob -&gt; ob) -&gt; Constraint\n    type EndofunctorOf @ob cat f = FuntorOf @ob @ob cat cat f\n</code></pre>\nwe have in Haskell can be defined as FunctorOf @Type @Type (-&gt;) (-&gt;), or<p><pre><code>    type OldFunctor :: (Type -&gt; Type) -&gt; Constraint\n    type OldFunctor f = EndofunctorOf @Type (-&gt;) f</code></pre>')