Item(by='ChrisRackauckas', descendants=None, kids=None, score=None, time=1603242842, title=None, item_type='comment', url=None, parent=24842898, text='Plot recipes are a really good fundamental example of composability in the Julia ecosystem. Extending a plotting library cannot be a function because plotting functions don&#x27;t compose. Want to support plotting quaternions in matplotlib? You&#x27;d write a `plotquaternion` function. Then the ODE solver makes a `plotode` function for the output object of its ODE solver. Now let&#x27;s say you got ODEs solving on quaternions... what about plotting? Well you have to modify `plotode` to call `plotquaternion` or modify `plotquaternion` to call `plotode`, and this is how you get monorepos and the big functions we all know.<p>Plot recipes are different. The Plots.jl system calls the type recipe function recursively on the plotting data `X` until it sees a set of primitives that it knows. Libraries define dispatches to this function to denote how data types should transform to something more primitives. Quaternion numbers become four independent series of numbers (and add keyword arguments for doing things like modulus). The ODE solver library writes a recipe that say, if you try and plot an ODE, transform it into arrays of time series. Now plot on a quaternion ODE solution recurses into 4x time series of the solution, which is the plot you&#x27;d want to have. This is a feature I use all of the time: I don&#x27;t generally do more than just `plot(sol)` since recursive recipes generally give me the plot I want (or else I open an issue because someone is missing a recipe).')