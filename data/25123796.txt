Item(by='chriswarbo', descendants=None, kids=None, score=None, time=1605621736, title=None, item_type='comment', url=None, parent=25121634, text='Others have mentioned closures; there are also a few other patterns that can do similar things.<p>One is &quot;ad-hoc polymorphism&quot;, which lets us associate values with types. This is essentially the same as implementing an interface in languages like Java, except we don&#x27;t need to modify any existing definitions (e.g. we don&#x27;t need to edit a class to say &quot;extends Foo&quot;).  This is useful for picking between pre-defined sets of values, e.g. for your example of logger and base dir we can define an interface like &#x27;Environment&#x27; with methods returning a base dir and a logger; then we can define a &#x27;Production&#x27; type which implements this interface by providing the real logger and base dir, a &#x27;Test&#x27; type which returns a temp dir and stdout logger, a &#x27;Dev&#x27; type whose logger keeps verbose debug messages, etc. We can write our code in terms of a generic Environment, then in our &#x27;main&#x27; function we specify that we&#x27;re using &#x27;Production&#x27;; in our test suite we specify that it&#x27;s &#x27;Test&#x27;; when debugging we can specify &#x27;Dev&#x27;.<p>Another approach is called &#x27;Reader&#x27;, and it&#x27;s based around the following type and helper functions (in Haskell syntax):<p><pre><code>    data Reader a b = R (a -&gt; b)\n\n    read :: Reader a a\n    read = R (\\x -&gt; x)\n\n    runReader :: Reader a b -&gt; a -&gt; b\n    runReader (R f) x = f x\n</code></pre>\nOr in Scala:<p><pre><code>    final class Reader[A, B](f: A =&gt; B) {\n      def run(x: A): B = f(x)\n    }\n\n    final object Reader {\n      def read[A]: Reader[A, A] = new Reader(x =&gt; x)\n    }\n</code></pre>\nNote that this type literally just contains functions from some type A to another type B. The function &#x27;read&#x27; is a wrapped-up identity function (returning its argument unchanged), the &#x27;run&#x27; function just applies a wrapped-up function to an argument.<p>This gets interesting if we do two things. First we can specialise the input type (a or A), e.g. in Haskell:<p><pre><code>    type Application t = Reader (Path, Logger)\n</code></pre>\nOr in Scala:<p><pre><code>    type Application[T] = Reader[(Path, Logger), T]\n</code></pre>\nThe type &#x27;Application[T]&#x27; represents functions from a Path+Logger pair to a T.<p>Next we can define some functions for manipulating Reader values:<p><pre><code>    -- Applies a function f to a Reader&#x27;s result; AKA function composition \n    map :: (a -&gt; b) -&gt; Reader t a -&gt; Reader t b\n    map f (R r) = R (\\x -&gt; f (r x))\n\n    -- Wrap up a value into a Reader, by accepting an argument and ignoring it\n    wrap :: a -&gt; Reader t a\n    wrap x = R (\\y -&gt; x)\n\n    -- Combine two Readers, so they&#x27;re given the same argument and their return values are paired\n    product :: Reader t a -&gt; Reader t b -&gt; Reader t (a, b)\n    product (R f) (R g) = R (\\x -&gt; (f x, g x))\n\n    -- &quot;Unwrap&quot; nested Readers, by passing the argument into the result\n    join :: Reader t (Reader t a) -&gt; Reader t a\n    join (R f) = R (\\x -&gt; runReader (f x) x)\n</code></pre>\nTogether these functions let us write arbitrary functions &quot;inside&quot; this &#x27;Application&#x27; type. For example:<p><pre><code>    -- The &#x27;fst&#x27; function gets the first element of a pair\n    baseDir :: Application Path\n    baseDir = map fst read\n\n    -- The &#x27;snd&#x27; function gets the second element of a pair\n    logger :: Application Logger\n    logger :: map snd read\n\n    -- Use the logger to log the given string (via some &#x27;logWith&#x27; function)\n    log :: String -&gt; Application ()\n    log msg = map (\\l -&gt; logWith l msg) logger\n\n    -- Read the contents of a given file from the base dir\n    openFile :: Filename -&gt; Application String\n    openFile f = map (\\d -&gt; readContents (d + &quot;&#x2F;&quot; + f)) baseDir\n\n    -- Log the contents of a given file from the base dir\n    logContents :: Filename -&gt; Application ()\n    logContents f = join (map log (openFile f))\n</code></pre>\nNote how we can only access the base dir and logger from &#x27;inside&#x27; the Application type; i.e. we can get an &#x27;Application Logger&#x27;, but we can never just get a &#x27;Logger&#x27;. That&#x27;s because the code doesn&#x27;t actually define a logger or base dir anywhere; any value &#x27;Application T&#x27; is really just a function &#x27;(Logger, Path) -&gt; T&#x27;. To extract a result, we need to give it to &#x27;runReader&#x27;, which (in the case of Application) also needs to be given a &#x27;(Logger, Path)&#x27; pair.<p>Using these functions directly can be a bit tedious. Some FP languages have special syntax which makes it nicer, e.g. in Haskell we can write things like:<p><pre><code>    do x &lt;- foo\n       y &lt;- bar x\n       baz x y\n</code></pre>\nThe Scala equivalent is:<p><pre><code>    for {\n      x &lt;- foo\n      y &lt;- bar(x)\n      z &lt;- baz(x, y)\n    } yield z\n</code></pre>\nThese get rewritten to (the equivalent of):<p><pre><code>    join (join ((map (\\x -&gt; map (baz x) (bar x)) foo))\n</code></pre>\nThis API is a combination of Functor (map), Applicative (wrap and product) and Monad (join). Hence people sometimes call this &quot;the Reader monad&quot;; but don&#x27;t let that scare you!')