Item(by='chriswarbo', descendants=None, kids=None, score=None, time=1605533068, title=None, item_type='comment', url=None, parent=25110233, text='Ah, I suppose there was a conflation between (roughly) &quot;business problem&quot; versus &quot;computer science problem&quot;.<p>It&#x27;s completely true that all Turing-complete languages can solve the same set of computer science problems (e.g. recognising certain grammars, implementing certain partial functions, etc.). Of course, actually coming up with such solutions can vary between e.g. Brainfuck versus Java.<p>I was focusing more on &quot;real world problems&quot; or &quot;business problems&quot;, e.g. allowing users to query a server, or adding a plugin mechanism to a game, or distributing an application across multiple locations, etc. These are not &quot;computer science problems&quot; (akin to, say, recognising a grammar) since they&#x27;re underspecified; we&#x27;re free to make various choices about what counts as correct, including the input format.<p>These examples are particularly well-suited to solutions involving a language (e.g. a query language), as opposed to something less expressive (e.g. a pre-determined list of options). For such &quot;real world problems&quot; our choice of language can be the difference between a trivial solution or an undecidable quagmire. For example, in the case of querying we could give users a pure language (with a timeout); that&#x27;s trivially safe from effects, as well as being immune to many side-channels (no shared state, etc.). If we instead allowed users to write queries using Python, we&#x27;d face the impossible task of detecting which programs are safe to run on our server (unless we only provide a safe sub-set of the language; which is just a round-about way of saying we should create a custom language!).<p>&gt; the concern I expressed in my original post is - at what cost?<p>Yes, there&#x27;s always a cost for these things. In my experience, this usually involves explicitly encoding our reasoning&#x2F;assumptions into a form the language will accept (e.g. type annotations, if they can&#x27;t be inferred; refactoring some generic loop to fit a certain pattern; etc.). However, that&#x27;s not all bad, since our programs capture more of our intent, and will warn us if we&#x27;re wrong (either immediately, or after some refactoring invalidates our assumptions).<p>These tradeoffs certainly exist on a spectrum, and the location of the &quot;bang for buck&quot; sweet spots varies depending on the domain. It&#x27;s usually <i>not</i> worth encoding a correctness proof into Coq&#x27;s type system; yet it usually <i>is</i> worth encoding our control flow into structured programming rather than GOTOs. There&#x27;s a whole heap of techniques in between, with varying tradeoffs, which make more or less sense depending on the domain, external constraints, etc.')