Item(by='josephg', descendants=None, kids=[25612738, 25612186, 25611341, 25611504, 25611517], score=None, time=1609572452, title=None, item_type='comment', url=None, parent=25608861, text='Yeah; but thats all so incremental. Better compiler error messages? Really? That makes the top 10 list from 25 years of work?<p>Async&#x2F;await matters. But compared to inventions like threading, filesystems, java&#x27;s write-once run anywhere, HTTP&#x2F;HTML and the invention of the URL? I agree with the author. We&#x27;ve lost our mojo.<p>Computing is pretty unique in that we have near-complete freedom to define what a program even is. A sorting method implemented in haskell is a different sort of expression than the same idea implemented in C. The abstractions we all take for granted - processes, applications, RAM &amp; disks, databases, etc - all this stuff has been invented. None of these ideas are inherent to computing. And yet apparently we only know how to make three kinds of software today: Web apps, electron apps and mobile apps.<p>Here&#x27;s some hairbrained ideas that are only a good implementation away from working:<p>- HTML&#x2F;React inspired UI library that works on all platforms, so we can do electron without wasting 99% of my CPU cycles.<p>- Opaque binary files replaced with shared objects (eg smalltalk, Twizzler[1]). Or files replaced with CRDT objects, which could be turned to support collaboratively editable global state.<p>- Probabilistic computing, merging ML and classical programming languages. (Eg if() statements in an otherwise normal program which embed ML models)<p>- SQL + realtime computed views (eg materialize). Or caching, but using an event stream for proactively updating cached contents. DB indexes as separate processes outside of a database, using an event stream to keep up to date. (Potentially with MVCC to support transactional reads from the index &amp; DB.)<p>- Desktop apps that can be run without needing to be installed. (Like websites, but with native code.). And that can run without needing to trust the developer. (Using sandboxing, like web apps and phone apps).<p>- Git but for data. Git but realtime. Git, except with a good UI. Git for non-developers.<p>- Separate out the model and view layers in software. Then have the OS &#x2F; network handle the models. (Eg SOLID.)<p>- An OS that can transparently move apps between my devices. (Like erlang but for desktop &#x2F; phone &#x2F; web applications)<p>- Docker&#x27;s features on top of statically linked executables.<p>The entire possibility space of what computing is is open to us. Why settle for POSIX and javascript+HTML? Our platforms aren&#x27;t even very good.<p>[1] <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;atc20&#x2F;presentation&#x2F;bittman" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;atc20&#x2F;presentation&#x2F;bittman</a>')