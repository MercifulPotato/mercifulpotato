Item(by='cannam', descendants=None, kids=[24900451], score=None, time=1603722261, title=None, item_type='comment', url=None, parent=24891143, text='I absolutely love ML for the Working Programmer, but I think you have to see it as a philosophical text as much as a tutorial.<p>To these points, I&#x27;d say<p>1. I find Emacs sml-mode is just about up to it. I do have complaints - I wish it would pull back the indentation more in lines that continue an expression, it doesn&#x27;t handle multiple &quot;where&quot; clauses elegantly, it misaligns anonymous function alternatives - but every time I consider trying to fix them I decide they don&#x27;t <i>quite</i> upset me enough. It&#x27;s a slight pity though because I strongly believe a language should be auto-indentable (life&#x27;s too short to indent code yourself), and SML is, just not quite with the existing mode.<p>2. I like to use Poly&#x2F;ML for automatic builds during development and MLton for &quot;production&quot; builds - both producing executables. There are still problems on Windows, which doesn&#x27;t have a properly native MLton port - the existing one uses MinGW which is ok-ish but not what I would prefer. (MLton has a code generator that produces C, so the limitation is that the runtime hasn&#x27;t been ported rather than with the compiler itself.)<p>3. Agree, &quot;rlwrap poly&quot;<p>4. I like inline type decorations, but I also like to omit them most of the time. I think you do get some feel for when it&#x27;s a good idea to add them, to clarify things for the call site or check your own intuition about the deduced types.  Module boundaries (with signatures) also form a natural firebreak for out-of-control type errors.')