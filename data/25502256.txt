Item(by='tw25497050', descendants=None, kids=None, score=None, time=1608604544, title=None, item_type='comment', url=None, parent=25497050, text='Sometimes the architecture&#x2F;algorithm matters, and sometimes the architecture&#x2F;algorithm needs to align with the language. Absent seeing the broader code base [1], I&#x27;m inclined to think that the author&#x27;s larger design led to these expensive functions existing as they did [2].<p>Pure speculation on my part, but if one has a lot of experience with imperative, mutable languages, one might design a system that ends up being not so great when written in a functional, immutable language. If so, then seeing improvements when directly porting to an imperative, mutable language might be not so surprising.<p>Tangent: Regarding the power and importance of code structure, I highly recommend watching &quot;Solving Problems the Clojure Way&quot; by Rafal Dittwald at Clojure North 2019 [3].<p>[1] I didn&#x27;t see a link, but if it&#x27;s available, I&#x27;d love to take a look.<p>[2] The `rule-field-diff` function for example seems to be burdened with some odd choices, e.g., taking in two &quot;rules&quot; as arguments, (which seem to be collections of rules keyed by field), then using two hard-coded &quot;operations&quot; (also keyed by field), and yielding a map whose values are sequences by field (I think). Off the top of my head I don&#x27;t see why this fn needs to work across multiple fields in the first place (i.e., any field-specific &quot;loop&quot; should be in a surrounding context. Ditto for `diff-rules-by-keys`.<p>[3] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;vK1DazRK_a0?t=461" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;vK1DazRK_a0?t=461</a>')