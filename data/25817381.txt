Item(by='eyelidlessness', descendants=None, kids=[25817458], score=None, time=1610935483, title=None, item_type='comment', url=None, parent=25812080, text='&gt; It doesn’t at all allow composition.<p>Of course it does. The most basic programming primitives of composition is functions. Want to compose hooks with these APIs? Call one hook from another. They’re just functions.<p>Edit: or call one hook-using factory&#x2F;HOC from another.<p>&gt; Honestly, it feels like you haven’t spent much time with hooks if this is your improvement<p>It’s true, I do avoid using them. But I spend a lot of time reading the docs, as well as working with a large variety of different JSX APIs.<p>&gt; It&#x27;s a great case of &quot;making it look better but removing the valuable properties in the name of purity&quot;.<p>I don’t know why that’s what you took from my pseudocode, since one of the examples maintained the exact same interface. Why would it be less valuable if hooks-consuming components are factories&#x2F;HOCs?<p>&gt; I already explained fairly well why you want hooks to be inline in render, as they need to handle side effects, they need to compose with each other and react to changing values, and therefore they need to constantly run to check for updates. It’s 100% how they are used by everyone.<p>And all of that is possible with the APIs I suggested.<p>&gt; I hope you find time to actually look at what hooks do more closely and find the power behind them.<p>Please don’t condescend. I’m plenty familiar with the material.<p>&gt; You can try and hide that fact behind more syntax, but it doesn’t change the fact that your inner function you defined is depending on an outer closure that is stateful, breaking your law of no functions that act differently when called with the same values.<p>It’s not about <i>hiding</i> statefulness, it’s about:<p>1. Isolating it: this is every letter in the SOLID principles.<p>2. Maintaining clearly identifiable interfaces that are clear in their boundaries and expected behavior.<p>In Clojure, a language that&#x27;s pure FP by default with clearly defined APIs for mutable escape hatches, this is achieved by convention with @ prefixes for state and ! suffixes for dereference. In JS&#x2F;TS, this is achieved by convention by separating state init from post-init behavior (my factory&#x2F;HOC example), or by passing&#x2F;wrapping state (see common redux patterns). Both have corresponding types that make clear what’s going on.<p>Shoving state and return values into the same space makes that impossible.')