Item(by='tzs', descendants=None, kids=[25217686], score=None, time=1606372290, title=None, item_type='comment', url=None, parent=25216774, text='I&#x27;d replace PC&#x2F;IX with 386&#x2F;ix. PC&#x2F;IX was based on System III, not System V, and it was for the PC XT which did not have protected mode.<p>386&#x2F;ix was ISC&#x27;s port of System VR3 to the 80836. Actually, it was the official port of System VR3 to that processor, done under a contract from AT&amp;T (and maybe Intel...I don&#x27;t remember for sure).<p>There was also a port of System VR3 to the 80286 as part of that same contract.<p>The source for both ports was System VR3 on the AT&amp;T 3B2. The memory management on the 3B2 was close enough to that of the 386 that the people working on that part of the port had no problems.<p>Not so for the 286 port, which I was working on. We tried treating segments as 64 KB pages, and it worked if you didn&#x27;t push it hard.<p>But if you ran a load test with 20 processes that where each large enough so that only a few could be resident simultaneously, and those processes were all compute bound it got into this pattern that was fair in the very long run, but very unfair in the short run.<p>You&#x27;d have one process get something like 90% of the CPU, and a couple others getting about 4% each, and the remaining 2% would be split evenly among the other 17 processes.<p>It would stay this way for something like a half hour, then you&#x27;d get a minute of heavy thrashing, and then that would clear up and you&#x27;d be back to the way it had been, except which process was getting the 90%, which two were getting 4% each, and which 17 were evenly sharing 2% would have changed.<p>So if you took a long enough view, it was fair.<p>Something in the 3B2 paging system algorithms apparently did not like very large page sizes, and the other programmer and I working on the 286 port were having no luck figuring it out.<p>Fortunately, AT&amp;T came to their senses and realized there wasn&#x27;t much demand for a 286 port, dropped it, and I got moved to the 386&#x2F;ix project, where I added a simple in-kernel debugger and a dynamic device driver loading system.<p>AT&amp;T hadn&#x27;t asked for dynamic device driver loading, but the total size of the kernel including all the device drivers that needed to be included was getting bigger than the boot code we had could handle, and the people dealing with the boot code claimed it was obtuse and ugly assembly code that would be very hard to rewrite to handle large kernels, and so I somehow ended up being assigned making drivers dynamically loadable so we could ship smaller kernels.<p>I got it working well, but then the boot bastards went ahead and rewrote the boot code, getting rid of size limits, and my dynamic device loading was no longer needed.<p>I also didn&#x27;t quite escape the 286. I was half the team that did the 286 Unix binary compatibility for 386&#x2F;ix. That was essentially a Wine-like thing, &#x2F;bin&#x2F;i286emul, a 386 process that knew how to load a 286 process into its own address space, set up its memory space, and start it running, with i286emul handling the traps when the 286 code tries a system call and figuring out how to translate between the 286 system calls and the corresponding 386 Unix calls.<p>ISC was a fun place to work.')