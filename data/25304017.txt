Item(by='earthboundkid', descendants=None, kids=None, score=None, time=1607098736, title=None, item_type='comment', url=None, parent=25302464, text='Cancellation is a little tricky. If things can cancel at any point, then it&#x27;s impossible to write safe&#x2F;correct code. Async has the advantage that the await calls are natural sync points, so it&#x27;s (probably) safe to cancel there. But historical experience has also shown that people will forget to yield when they should, and it will lead to cooperation problems.<p>I think the best approach has to look something like Go&#x27;s, but perhaps a bit more structured (dynamic scoping[1] might help perhaps with task nurseries[2]). Unless you&#x27;re writing extremely low level code, you want your language runtime to intercept all syscalls and figure out the async story for you. The language should handle making sure that the M:N mapping works out, no one opens a socket the wrong way etc. Then for you as the program writer, your responsibility is just setting explicit cancellation points as part of the general error handling approach. It&#x27;s still not perfect, but I think that would be the next evolution from what exists today.<p>[1] <a href="https:&#x2F;&#x2F;blog.merovius.de&#x2F;2017&#x2F;08&#x2F;14&#x2F;why-context-value-matters-and-how-to-improve-it.html" rel="nofollow">https:&#x2F;&#x2F;blog.merovius.de&#x2F;2017&#x2F;08&#x2F;14&#x2F;why-context-value-matter...</a><p>[2] <a href="https:&#x2F;&#x2F;vorpus.org&#x2F;blog&#x2F;notes-on-structured-concurrency-or-go-statement-considered-harmful&#x2F;" rel="nofollow">https:&#x2F;&#x2F;vorpus.org&#x2F;blog&#x2F;notes-on-structured-concurrency-or-g...</a>')