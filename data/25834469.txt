Item(by='andonisus', descendants=None, kids=[25835127], score=None, time=1611070698, title=None, item_type='comment', url=None, parent=25820057, text='Doesn&#x27;t this mean the caller may block if there are already the maximum number of inflight requests being run? I use the same type of pattern, but the core loop has a queue of input objects. The loop blocks waiting for input from either a caller or a go routine that completed. It enqueues the request from a caller, or lowers the inflight count from the complete signal. Then, it checks if we have capacity to run the request, and, if we do, dequeues the oldest request and submits it.<p>This means that the queue could grow unboundedly, but that is ok, as this type of structure is not meant for constant request handling but rather for bursts of requests that can happen asynchronously (and in parallel), and allows us to limit the maximum number that can run while also never blocking callers if there are no available go routines to process their request when submitted.<p>Here is a minimially-viable example of how I do it:<p><a href="https:&#x2F;&#x2F;play.golang.org&#x2F;p&#x2F;mD_jpMdoY_g" rel="nofollow">https:&#x2F;&#x2F;play.golang.org&#x2F;p&#x2F;mD_jpMdoY_g</a><p>Contents here:<p>package main<p>import (\n &quot;fmt&quot;\n &quot;time&quot;\n &quot;sync&quot;\n)<p>func main() {\n fmt.Println(&quot;Hello, playground&quot;)\n wg := &amp;sync.WaitGroup{}\n wg.Add(1)\n numRequests := 100<p>inCh := make(chan int)\n go func() {\n  resCh := make(chan int)\n  queue := []int{}\n  inFlight := 0\n  max := 20\n  completed := 0<p><pre><code>  for {\n   select{\n   case m := &lt;- inCh:\n    queue = append(queue, m)\n    fmt.Println(fmt.Sprintf(&quot;Enqueing: %d&quot;, m))\n   case &lt;- resCh:\n    inFlight -= 1\n    completed += 1 \n   }\n   if len(queue) &gt; 0 &amp;&amp; inFlight &lt; max {\n    v := queue[0]\n    queue = queue[1:]\n    fmt.Println(fmt.Sprintf(&quot;Submitting: %d&quot;, v))\n    inFlight += 1\n    go func(_v int) {\n     time.Sleep(1 * time.Second)\n     fmt.Println(fmt.Sprintf(&quot;run: %d&quot;, _v))\n     resCh &lt;- v\n    }(v)\n   }\n   if completed == numRequests {\n    wg.Done()\n   }\n  }\n }()\n \n for i := 0; i &lt; numRequests; i++ {\n  inCh &lt;- i\n }\n \n fmt.Println(&quot;Waiting for completion...&quot;)\n wg.Wait()\n fmt.Println(&quot;All processes completed. Exiting.&quot;)\n}</code></pre>')