Item(by='megameter', descendants=None, kids=None, score=None, time=1606958721, title=None, item_type='comment', url=None, parent=25274158, text='I see it as a tradeoff of where you want your dependencies.<p>In analysis using the structured program theorem, you only have three tools, really: Sequence, selection, iteration. If you copy-paste, you lean on the sequence more; if you add a loop or a cursor structure, you&#x27;re iterating; and if you add more names for things, you&#x27;re selecting on the name. All three create dependency risks, but not in equal measure.<p>What a really long function mostly indicates is that the inherent  dependencies are mostly sequential. This maps with the domains where they appear most naturally: game loops are notoriously single-threaded, embedded code often needs to operate to hard real time constraints.<p>I think the appeal in splitting out  more names has something to do with linguistic comfort zones: Rather than examine long sequences, assume the functions used by the one you are looking at are trustworthy. Then you are &quot;improving&quot; the code each time you factor it out because you can read more names, and because each function is small there is little concern about sequencing errors. It&#x27;s intuitive, but shows its flaws as soon as you use another lens like the structured program analysis; adding the new function makes it harder to examine the sequence across the function boundaries, causing the &quot;flea-jump&quot; code you describe.<p>What I&#x27;ve found works is to let the large functions accumulate and mature, then derive a new dependency - a function, class, or other abstraction - that will simplify maintenance. Not every problem is solved with a new function, sometimes it really takes a compiler to get the desired improvement.')