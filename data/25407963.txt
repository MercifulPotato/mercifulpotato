Item(by='ChrisMarshallNY', descendants=None, kids=[25418157, 25411109], score=None, time=1607878764, title=None, item_type='comment', url=None, parent=25407613, text='My experience, is that &quot;complicated&quot; vs. &quot;complex,&quot; as you define, changes, depending on who is looking at the code.<p>If someone has a philosophical aversion to something like abstraction, then they will label it &quot;complicated,&quot; but I use abstraction, all the time, to insert low-cost pivot points in a design. I just did it this morning, as I was developing a design to aggregate search results from multiple servers. My abstraction will afford myself, or other future developers, the ability to add more data sources in the future, in a low-risk fashion.<p>I also design frameworks in &quot;layers,&quot; that often implement &quot;philosophical realms,&quot; as opposed to practical ones. Think OSI layers.<p>That can mean that adding a new command to the REST API, for example, may require that I implement the actual leverage in a very low-level layer, then add support in subsequent layers to pass the command through.<p>That can add complexity, and quality problems. When I do something like that, I need to test carefully. The reason that I do that, is so, at an indeterminate point in the future, I can &quot;swap out&quot; entire layers, and replace them with newer tech. If I don&#x27;t think that will be important, then I may want to rethink my design.<p>That is the philosophy behind the OSI layers. They allow drastically different (and interchangeable) implementation at each layer, with clear interface points, above and below.')