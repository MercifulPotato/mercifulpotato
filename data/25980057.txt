Item(by='mumblemumble', descendants=None, kids=[25985116, 25980576, 25982967, 25981307, 25984846], score=None, time=1612111467, title=None, item_type='comment', url=None, parent=25979814, text='I 100% agree that disastrous codebases are every bit as likely in other languages. But it somehow hurts more in a lisp.<p>I think that the syntax really is the culprit. In a language like Java, the Byzantine syntax and semantics enforce some minimum level of structure on the code. It&#x27;s not much, but it&#x27;s something, just enough to give an experienced programmer a few extra heuristics they can use to make sense of what they&#x27;re seeing. Even some things that normally drive me nuts about Java, like the way that there&#x27;s no standard way to call an anonymous function (because the invocation is done through a method whose name is allowed to vary) end up being useful bread crumbs when I&#x27;m reading somebody else&#x27;s code.<p>In a Lisp, though, everything looks more-or-less homogeneous. You can memorize the names of special forms, but, beyond that, you can&#x27;t quickly tell whether some thing you&#x27;re looking at is data, a function, or a macro, or what. It all blends together into a disorienting fog. You need to go trace its provenance to see how some new value is defined or constructed before you can even tell what kind of thing it is. (This, tangentially, might be a great argument in favor of lisp-2, though I haven&#x27;t spent enough time in a lisp-2 to have an opinion that&#x27;s worth beans.) It may, in the grand scheme of things, be only a small reduction in what you can assume without careful study. But, in an unfamiliar codebase where you don&#x27;t know much to begin with, every little scrap of knowledge counts.<p>It all points to an insight I should have had 20 years ago when I was working in Perl: Features that make a programming language pleasant to write tend to make it <i>un</i>pleasant to read, and vice versa.')