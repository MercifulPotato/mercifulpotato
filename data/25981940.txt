Item(by='kazinator', descendants=None, kids=None, score=None, time=1612122757, title=None, item_type='comment', url=None, parent=25979293, text='&gt; <i>And such errors happen all the time, the same way without syntax checks typos happen all the time.</i><p>No they don&#x27;t, because syntax is richly varied and nested, even in programs whose &quot;type story&quot; is bland.<p>For instance, in some numerical program, there are lots of opportunities to make typos in the syntax, but the type of just about everything may be either <i>float</i> or else <i>array of float</i> (possiby <i>string</i>, if it has any error-handling code with messages, and <i>bool</i> if there are some logical operations).<p>If you pass an <i>array of float</i> where a scalar <i>float</i> is expected, such that an error occurs, and if you don&#x27;t catch this in your testing, it means you&#x27;re not testing the code.<p>Untested code is of a dubious status, even if it compiles with a static type system; testing is not negotiable.<p>Note that functions like sin and cos have exactly the same type signature, yet it is disastrous if you mix them up. Static type checking doesn&#x27;t help. Static type checking also doesn&#x27;t help with mixed up variables: calling f(x, y) which should have been f(y, x) or something else, where x and y have the same type.<p>In programs, chunks of code that are put together into the same module or function often work with multiple instances of the same type. It&#x27;s more important not to mix up those instances, than to worry about type errors. The code could be wrong in all sorts of ways, yet statically check.<p>That&#x27;s where you need to step up the the argument into &quot;True Scotsman&#x27;s type systems territory&quot;: a sufficiently advanced type system can encode all those properties that prevent the mixups that the everyday type system doesn&#x27;t. Yeah, well, nobody uses that; nobody understands it outside of a narrow slice of academia. Examples of the technique are such that encoding even a trivial property like &quot;list is in sorted order&quot; results in an a considerable increase of program complexity all concentrated in one place, and less easy to understand than a set of test cases against the obvious program. Yet, it doesn&#x27;t eliminate the need for testing; nothing does. There can now be a bug in the way the desired property was encoded into the program. Perhaps the sorted property was correctly encoded, but it should have been descending order. The test case will catch it.<p>When you have a language that is available at compile time, you can execute test cases as part of compilation. Test cases <i>are</i> therefore static checks. Anything happening at build time is a static check. Heck, how a git commit message is formatted is a static check, if a repository commit hook validates it.')