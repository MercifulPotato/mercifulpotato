Item(by='ludocode', descendants=None, kids=None, score=None, time=1609339688, title=None, item_type='comment', url=None, parent=25580912, text='This is true, but your second point is difficult to do in C. You would have to have a set template and a separate lookup template to search the set based on a key type. This is actually how heterogeneous lookup is implemented in C++: it&#x27;s a template within a template. This is not a big deal in C++ because templates are instantiated automatically but we&#x27;re instantiating templates manually in C. It&#x27;s also only available as of C++14 and only on ordered containers, not hash tables.<p>It&#x27;s more straightforward to combine these templates: make map the fundamental type, but make values contain their keys and make the key type default to the value type if omitted. This way it&#x27;s both a map and a set. My own C hash table template does it this way [1]: it stores only a value type and not keys, but there is an optional separate key type used for lookups, hashes and comparisons. To make it a map, you provide both a key comparison expression and an expression to convert values to keys.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ludocode&#x2F;pottery&#x2F;tree&#x2F;master&#x2F;include&#x2F;pottery&#x2F;open_hash_map" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;ludocode&#x2F;pottery&#x2F;tree&#x2F;master&#x2F;include&#x2F;pott...</a>')