Item(by='dathinab', descendants=None, kids=None, score=None, time=1604251589, title=None, item_type='comment', url=None, parent=24958423, text='Having taken a look at the RISC-V ISA spec I&#x27;m wondering if they did cripple LL&#x2F;SC (LR&#x2F;SC in RISC-V).<p>Basically:<p>- LL&#x2F;SC can prevent ABA if the ABA-prone part is in-between a LL and SC instruction<p>- To have a ABA prone problem you need some state implicitly dependent on the atomic state but not encoded in it. Normally (always?) the atomic state is a pointer and we depend on some state behind the pointer not changing in a context of a ABA situation (roughly ~ switch out ptr, change ptr target, switch back in ptr, through often more complex to prevent race conditions).<p>This means in all situations I&#x27;m aware of LL&#x2F;SC only prevents the ABA problem if you at least can do one atomic (relaxed ordering) load &quot;somehow&quot; depending on the LL load. (LL load pointer, offset or similar).<p>But the RISC-V spec doesn&#x27;t only not guarantee forward process in this cases (which I guess is fine) but goes as far as explicitly stating that guaranteed not having forward provess is ok, e.g. doing any load between the load reserved and store conditional is allowed to make the store conditional fail&gt;<p>Doesn&#x27;t that mean that if you target RISC-V you will not benefit from LL&#x2F;SC based ABA workaround and instead it&#x27;s just a slightly more flexible and potential faster compare exchange which can spuriously fail?<p>The spec says you are supposed to detect if it work and potentially switch implementations. But how can you do that reasonable if it means that you have to switch to fundamentally different data structures, which isn&#x27;t something easily and reasonably done at runtime.<p>Or do I miss something fundamental?')