Item(by='jart', descendants=None, kids=None, score=None, time=1608544929, title=None, item_type='comment', url=None, parent=25492119, text='&gt; Traditionally, UNIX commands were written under the assumption they were going to be used primarily by other programs [...] it’s time to shed some of this baggage<p>UNIX commands are absolutely human first. If they weren&#x27;t then the `ls` command would output a JSON PROTOBUF ASN.1 SQL DUMP rather than a plaintext list of file names.<p>&gt; Use a command-line argument parsing library where you can<p>What you&#x27;re doing a good job of here, is granting a loudspeaker to all the fresh community projects and excitement surrounding CLI. That&#x27;s awesome. It&#x27;s not appropriate for a best practices document, which should be making much more conservative recommendations, considering how prevalent arg parsers are in the standard libraries of languages.<p>&gt; you won’t need man pages. Not enough people use man pages<p>If your program is something that&#x27;s installed on the system (i.e. it&#x27;s not distributed as a single-file executable like youtube-dl) then it should have a man page.<p>&gt; Display output on success<p>Very unconventional advice. Strongly disagree.<p>&gt; Disable color if your program is not in a terminal or the user requested it.<p>Now this, is something that contradicts the conventional wisdom, but I wholeheartedly agree with it. I don&#x27;t like playing cat and mouse games with commands that conditionally turn colors off based on isatty(). I just want color. If I didn&#x27;t want color, then it&#x27;s so trivial to filter it out using sed &#x27;s&#x2F;\\x1b\\[[;[:digit:]]*m&#x2F;&#x2F;g&#x27;.<p>&gt; The NO_COLOR environment variable is set.<p>Or more conventionally, TERM=dumb or the sed above. Never heard of NO_COLOR before.<p>&gt; You may also want to add a MYAPP_NO_COLOR environment variable<p>This can be seen as environment variable pollution. Those strings need to be copied every time a process is spawned. Many of the C library routines for editing the environment are O(n) unfortunately because you can&#x27;t assume it&#x27;s sorted like they are on Windows.<p>&gt; Only use prompts or interactive elements if stdin is an interactive terminal<p>Bad advice. Many programs like ispell &#x2F; aspell &#x2F; etc. are interactive in nature while being used primarily through pipes as a subprocess. The best advice I can give is to just never ever check if it&#x27;s a tty because it doesn&#x27;t matter. Just make your program behave the same regardless of environmental conditions. Otherwise it&#x27;s a huge pain to automate, and that which can&#x27;t be automated isn&#x27;t worth doing as a cli program.<p>&gt; Responsive is more important than fast. Print something to the user in &lt;100ms<p>That&#x27;s a low bar even for a web server. It takes 25 microseconds to launch a subprocess and wait for it to complete. That&#x27;s the lower bound imposed by the practicalities of the Linux implementation of a vfork-&gt;execve-&gt;exit-&gt;wait4 roundtrip, which abstracts a heroic amount of work under the hood and decades of effort at improvements. So if you can&#x27;t get your CLI program to do something within at least 100 microseconds, then you&#x27;ve got a serious problem with bloatware or third party telemetry and should seriously reconsider your language&#x2F;library&#x2F;tooling stack.<p>&gt; TERM, TERMINFO and TERMCAP, if you’re going to use terminal-specific escape sequences.<p>That was good advice two decades ago. Just use the VT100 codes. Even Windows CMD.EXE supports VT100. Don&#x27;t bother with the termcap thing unless you&#x27;re trying to support like WYSE terminals or actual teletypewriters. Here&#x27;s the dox on the subject: <a href="https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;cosmopolitan&#x2F;blob&#x2F;1fc91f3&#x2F;tool&#x2F;build&#x2F;lib&#x2F;pty.c#L41" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;cosmopolitan&#x2F;blob&#x2F;1fc91f3&#x2F;tool&#x2F;build...</a><p>&gt; If a user hits Ctrl-C during clean-up operations that might take a long time, skip them. Tell the user what will happen when they hit Ctrl-C again, in case it is a destructive action.<p>Not worth prompting. Just kill it if you ctrl-c twice. I mean, if you&#x27;re going to leave database objects in an inconsistent state, I mean then don&#x27;t stop unless someone runs kill -9 or pulls the power plug. But vast majority of cases, stuff can be interrupted, trust the user, the prog should not whine.<p>&gt; People are going to misuse your program. Be prepared for that. They will wrap it in scripts<p>You must really hate people like me. I&#x27;ve been using Unix for 23 years and I&#x27;m barely a newcomer. I like it because it lets me automate things. If a command line program treats me like a user, rather than being a tool to be used, then I won&#x27;t touch it.')