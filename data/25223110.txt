Item(by='didibus', descendants=None, kids=None, score=None, time=1606420933, title=None, item_type='comment', url=None, parent=25220139, text='Using parsing and abstractions for safety is the basis of why Clojure, even though dynamically typed, is a relatively safe language[1]. The abstractions are safer in Clojure: no for loops, no while loops, only higher level iteration and transformation constructs, data interfaces are all immutable and functional. Shared state can only be used through higher level managed APIs, numbers auto-promote themselves to higher precision, there&#x27;s no linear search APIs to force the use of indexed data-structures instead, etc.<p>And for parsing: Spec is a way to define contracts, but it&#x27;s actually a parser DSL. User defined macros which specify a Spec will have their input parsed by the Spec at read-time, and if the Parser fails, a read error will show up. Unfortunately, this only happens for macro, but the article made me curious about possible value of having this done on functions as well.<p>An example of this is say you have some macro which would let you do:<p>(:from coll :take 5)<p>Your Spec can parse this, and error if the first element isn&#x27;t :from, the second element isn&#x27;t a reference or a collection literal, the third element isn&#x27;t :take, the fourth element isn&#x27;t a reference or an int, as well as if it isn&#x27;t called with exactly 4 elements. And all this happens at read time, when the code is parsed. You could go further, and if a collection literal was used, you could assert that the take int isn&#x27;t bigger then the number of elements in the collection literal.<p>Now, what I&#x27;ve observed is that reference types kind of limit what the parser can do. I&#x27;m not sure the article addresses that. Like in my last example, I can validated the range of take over the size of the collection, but not if the collection is a variable. How do I track those references? Maybe somewhere else in the program you can find the collection literal, but not here.<p>P.S.: It&#x27;s hard to know why Clojure demonstrates relative safety, and I assume here it has a little bit to do with the abstractions it uses and this parser Specifying mechanism. But it&#x27;s also likely it&#x27;s all due to the REPL or something else.<p>[1] <a href="https:&#x2F;&#x2F;www.i-programmer.info&#x2F;news&#x2F;98-languages&#x2F;11184-which-languages-are-bug-prone.html" rel="nofollow">https:&#x2F;&#x2F;www.i-programmer.info&#x2F;news&#x2F;98-languages&#x2F;11184-which-...</a> - Shows Clojure as having some of the least number of defects per commits')