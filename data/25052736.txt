Item(by='Groxx', descendants=None, kids=[25052994], score=None, time=1605046309, title=None, item_type='comment', url=None, parent=25051512, text='Both have at least one shared issue which makes 2+ error wrapping noisy or nasty:<p><pre><code>    func whatev() (err error) {\n        defer helper(&amp;err, &quot;mightFail context to help debugging&quot;, some, vars)\n        try(mightFail())\n    \n        defer helper(&amp;err, &quot;alsoMightFail context to help debugging&quot;, some, vars)\n        try(alsoMightFail())\n    }\n</code></pre>\nif the second call fails, your error has now been wrapped <i>twice</i>.<p>There are of course ways to deal with this.  You can add a &quot;already wrapped&quot; sentinel of some kind (say, a * bool that they check and modify), or use a `helper := once(helperfn)` to do that same kind of thing internally... but that&#x27;s more verbose.  And can&#x27;t be done generically without reflection (though `func(*error, string, ...interface{})` would be quite common, which might be good enough).  Inline handlers shown in many examples are even worse since they can&#x27;t be composed as easily, so you&#x27;d probably end up maintaining a bool var between all handlers.  By hand.<p>They both also require naming your `error` return value, which requires naming all returned values, which has been a depressingly large source of shadowing and not-initialized-value mistakes in my experience.  Improperly-initialized values especially, as those tend to cause problems a fair distance from the cause, and sometimes go unnoticed for quite a while.<p>tl;dr it adds more easily-forgotten boilerplate to non-trivial error handling, and makes it and related code more mistake-prone.  I&#x27;d rather have `return fmt.Errorf(err, ...)`, it fairly naturally resists growing more complex as your func grows more complex.')