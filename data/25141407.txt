Item(by='throwaway894345', descendants=None, kids=None, score=None, time=1605728389, title=None, item_type='comment', url=None, parent=25140634, text='Again, I think you&#x27;re just insisting on evaluating the article based on your own definition of &quot;portability&quot;. Note that I agree that your definition is more standard, and the confusion is attributable to the author choosing to overload that term.<p>Let&#x27;s imagine that the author used a different term--say, distributability--and defined it as something like &quot;how easy it is to get cross-platform software up and running on another system&quot; and the context is &quot;desktop and server computing&quot; as opposed to embedded or whathaveyou. I think this is a perfectly useful criteria for evaluating programming languages (which isn&#x27;t to say that it&#x27;s the most important or even very important, only that it&#x27;s useful).<p>It&#x27;s useful to know whether I&#x27;m going to have a very easy time distributing software (e.g., a self-contained static binary) or a very hard time (e.g., I need to get my non-technical colleague to install brew, use brew to install the right version of python, create a virtualenv, install dependencies--probably including various C dependencies that pip doesn&#x27;t know about, and then install my application). This isn&#x27;t a hypothetical consideration; it&#x27;s an important consideration for me whenever I&#x27;m creating internal tools.<p>However, to your point, this isn&#x27;t helpful for figuring out which languages are going to be able to be deployed to the widest breadth of architectures. They&#x27;re simply different ideas.')