Item(by='jrockway', descendants=None, kids=None, score=None, time=1609871121, title=None, item_type='comment', url=None, parent=25648023, text='I guess I ignored the section on resolving the long dependency graph, and that&#x27;s important to discuss.  The community could do a better job of splitting their clients and servers into separate modules (writing to InfluxDB should not require downloading the code for an InfluxDB server).  (I do love using servers written in Go, though, because my integration tests can just start one up at the beginning of the test and talk to it.  No setup&#x2F;teardown required outside of &quot;go test&quot;; no extra dependencies to make developers install.  It&#x27;s nice!)<p>The language could do a better job of letting you choose &quot;plugins&quot; at runtime; if you use Prometheus for monitoring and not InfluxDB, it&#x27;s not ideal to have a bunch of &#x27;if UseInfluxDB { send to InfluxDB }&#x27; compiled into your binary.  The alternative is to dlopen something that provides monitoring functionality; been there done that with Nginx and OpenTracing, and it&#x27;s hugely painful.  (There simply aren&#x27;t binaries that work together; you can&#x27;t wget a prebuilt plugin into your Nginx docker image.  You have to build both from scratch.)  Or, you can at least defer the monitoring library selection from library to application with an abstraction layer like OpenTelemetry.  The cost to the code author is high, and it still doesn&#x27;t let the operator choose the backend at runtime.  Overall, this is something that a programming language should choose to take on, but it&#x27;s also exceedingly difficult to get right.  I haven&#x27;t seen it done right, anyway; so all you have to go on is a list of ways to get it wrong.<p>It is annoying that there are 600 different logging libraries.  But people are VERY particular about logs, and one person&#x27;s treasure is another person&#x27;s &quot;that is so horrible I can&#x27;t even use it&quot;.  If there is a programming language where everyone uses the same logging library and that library provides structured logging, the log levels are [trace, debug, info, warning, error, fatal], has built-in support for sending to third-party services (Sentry), rate-based sampling, and metrics generation... then that sounds great to me and I&#x27;ll definitely take a look.  But for some reason, I kind of doubt it.  People have a lot of thoughts here, and are very committed to their thoughts.  In the Go world, libraries with wonderful authors let you inject your own logger, and it mostly works well.  GRPC, pgx, Jaeger, etc. all do a good job here.  K8s&#x27;s client_go does a bad job here, but they&#x27;re working on fixing it :)<p>Wasn&#x27;t planning to get sucked into this discussion, but the article does raise some good points.  I&#x27;ll be very honest and say rants like this sound to me like a pre-rant for next year when it&#x27;s &quot;why I quit programming forever and became a beet farmer&quot;.  To succeed at programming, you will have to endure in the face of minor problems with your tools.  You will have to use those tools to program better tools, after all.  And even then, it still won&#x27;t be perfect, and you&#x27;ll see a new set of problems to be mildly annoyed at.  Such is life!  Ultimately, for me, Go has supported my efforts to make stuff.  I run it on STM32 microcontrollers.  I run it on Beaglebones.  I ran it on thousands of servers at Google.  It just kind of gets out of the way and lets you turn your ideas into things that you can use.  Who can complain.')