Item(by='fatbird', descendants=None, kids=None, score=None, time=1606408878, title=None, item_type='comment', url=None, parent=25221137, text='Not the way Mongo does it.<p>The way sharding works in general is that your data gets an additional key (unless it has one that works for sharding already), and a router in the stack does traffic control on the query to send it to the correct shard; on the way back, the data is reassembled into a single result.  This enables parallelism in your query, boosting performance by using something like map-reduce.  Secondarily, your shard management layer can do a lot with shard-level redundancy and dynamic sharding to spread the data evenly across shards.<p>The scaling axis here is the size of your data--in mongo&#x27;s case, the number of documents in a collection.  As the number of documents grows, you shard the collection to keep queries on it fast.  Mongos, the sharding router, only manages sharding with a sharding key on a document, so the only sharding possible is spreading documents from a single collection across multiple shards.  If you have 10 databases that each have 100 collections, you get that on every shard, but each collection only has a subset of the collections docs.<p>I haven&#x27;t looked deeply into the mechanism, but I imagine this floats on top of mongo replication, where the replication layer cooperates with the sharding manager to replicate only the shard&#x27;s docs (as Mongo replicates by tailing the oplog, all a shard has to do is ignore oplog entries for docs without a shard key in the correct range).<p>It&#x27;s the fact that it works at the collection level that makes it useless for us.  Each database, for single entity, is a set timespan of timestream data, with one collection per timestream.  Entities vary by the number of timestreams&#x2F;collections they have, but as they&#x27;re all the same type of entity, their maximum size is pretty consistent and we don&#x27;t have problems querying a single collection.  We don&#x27;t need collection-level query performance.<p>Our axis of scaling is the number of databases, not the number of documents within a collection.  What would be literally perfect for us is a sharding manager that routes by database. We could put each entity&#x27;s database on its own mongo instance&#x2F;cluster, or an instance holding X databases, and scale horizontally almost indefinitely.  We&#x27;re lucky in that per-entity data falls into a clear range of sizes; we&#x27;re unlucky in that no such router exists for such a common scenario, which is bizarre to me.')