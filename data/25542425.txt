Item(by='zesterer', descendants=None, kids=[25550940], score=None, time=1608976272, title=None, item_type='comment', url=None, parent=25537933, text='This is actually pretty easy to do, and indeed vanilla Rust does sort of guarantee that memory leaks can&#x27;t happen, at least when using its normal ownership rules.<p>However, Rust&#x27;s standard library also includes types (implemented with unsafe code, but only accessible through safe interfaces) that allow shared ownership through reference-counting like `Rc`&#x2F;`Arc` and also ways to mutate shared memory like `RefCell`&#x2F;`Mutex`. These two things, in combination, allow the creation of self-referential data (i.e: effectively a leak). For this reason, it&#x27;s necessary to consider leaking a safe (if generally unintended) behaviour.<p>After all, leaking isn&#x27;t &quot;undefined behaviour&quot; and it generally isn&#x27;t intrinsically harmful to the program, except at the limit when the computer runs out of memory in which case you get a safe, well-defined OOM panic. Heck, there are even a plethora of useful techniques that use leaking. Leaking a data structure proves to the compiler that it will stay around indefinitely (i.e: it has a &quot;static&quot; lifetime), for example, which allows you to do things with it that Rust would normally forbid.<p>That is not to say that Rust doesn&#x27;t provide any protection from leaking, however. Its ownership model generally makes leaking <i>extremely</i> difficult to do accidentally, particularly when designing programs idiomatically, and its standard library contains a variety of abstractions that aid in managing shared memory correctly without leaks (Weak RC references, reference swapping, etc.).<p>I don&#x27;t think I&#x27;ve personally ever experienced a leak-related problem that wasn&#x27;t a result of badly-considered unsafe code despite the fact that I&#x27;ve been writing Rust every day for about 5 years and as my day job for the last 2 of those.')