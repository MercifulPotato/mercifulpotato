Item(by='dragontamer', descendants=None, kids=None, score=None, time=1602441535, title=None, item_type='comment', url=None, parent=24747920, text='&gt; That&#x27;s not actually reasonable, it&#x27;s feasible for very specific contexts.<p>I was inventing a new hash function for myself, just for giggles a few weeks ago.<p>I needed a constant: I started by choosing an arbitrary constant (I started with 0x31415926...), but then I realized that the 32-bit space, and even 50+ bit spaces were feasible on my GPU.<p>I ended up rewriting the random-number generator on the GPU, and searched for the number which caused the largest number of &quot;avalanche&quot; bit-flips across the entire 32-bit seed space of the RNG.<p>Where an &quot;avalanche&quot; bit flip is 16 bits flipped, and 16-bits remaining the same, after the RNG was applied to the seed.<p>For example: seed = 1 * K, where K == 0xAAAAAAAA will cause 16-bit flips, and 16-bits to remain the same.<p>Repeat for all 32-bit values of seed, searching for the optimal K. 0xAAAAAAAA wasn&#x27;t the best number (aka: 1010101010101010 binary), but you can see where my thought process was.<p>My RNG was more complicated than just a single multiply, but I think you can see where the general thought process was with my above example.<p>--------<p>There was a time when constants were arbitrarily chosen for these kinds of functions. But today, we can literally test ALL numbers and just pick the best.<p>If K is constrained by some other requirements (in my case: it must be odd, and a few other tidbits to work with my RNG), then you shrink the search space from 64-bits down to something that can be accomplished in just a few days of search.<p>-------------<p>As far as I&#x27;m concerned, the blog post is talking about how modern computers have conquered the 32-bit space.<p>My current post is how the 64-bit space could be feasibly explored. It wasn&#x27;t even that long ago when 64-bit space was considered cryptographic-secure (see DES crypto algorithm or WEP).')