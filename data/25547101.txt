Item(by='hnlmorg', descendants=None, kids=[25547263], score=None, time=1609023272, title=None, item_type='comment', url=None, parent=25546896, text='&gt; <i>This is not true in general. There are older models that which cannot run linux. A few years back I uncessfully tried to flash a very minimal &lt;1 MiB linux on an old TP link router. I was able to flash the rom but I couldn&#x27;t boot, because there was not enough memory available.</i><p>How long ago was &quot;a few years ago&quot;? What model number was that? DD-WRT has been ported to the Archer series but if you&#x27;re talking a ZyNOS based router then you&#x27;re probably out of luck. Those ZyNOS devices are the real bottom end of the market though. Even the ISP routers here in the UK are generally a step up from those. Particularly these days now that households have an expectation to have kids playing online games, streaming Netflix and such like (even before COVID-19 hit ISPs have been banging on for ages about how their routers allow you to do more concurrently). And with TP-Link, the Archer series are all Linux based or Linux compatible and they start from ~Â£50. So you&#x27;d be really scraping the barrel to find something that wasn&#x27;t these days.<p>&gt; <i>I agree that perfromance will be problematic, but this does not render microkernels useless in general for constrained devices.</i><p>Any OS designed around kernels, memory safety etc would be useless in general for constrained devices. This isn&#x27;t an exclusively Linux problem. On such systems the whole design of how software is written and executes is fundamentally different. You don&#x27;t have an OS that manages processes nor hardware, you write your code for the hardware and the whole thing runs bare metal as only one monolithic blob (or calls out to other discrete devices running their own discrete firmware like a circuit). That&#x27;s how the N64 works, it&#x27;s how embedded devices work. It&#x27;s not how modern routers work.<p>In 2020 it&#x27;s hard to think of a time before operating systems but really that is the way how the N64 works. Anything you run on there will eat up a massive chunk of resources if it&#x27;s expected to stay in memory. So you might as well go with a tiny monolithic kernel and thus shave a few instructions from memory protection and symbol loading (not to mention the marginally smaller binary sizes due to any file system metadata, binary file format overhead and other pre-logic initialisation overhead (such as you get when compiling software rather than writing it in assembly). If you&#x27;re going to those lengths though laumars point kicks in: you&#x27;re better off just writing a &quot;bootloader&quot; menu screen rather than a resident OS.')