Item(by='mst', descendants=None, kids=None, score=None, time=1604055188, title=None, item_type='comment', url=None, parent=24927004, text='&gt; But I&#x27;ve found Coro highly reliable and effective, including under stressed and complex loads, for about 6 years.<p>Had that been a more universal experience things might&#x27;ve been different.<p>I did once try and see if I could get a stripped down version to try and push into core but at the point where I&#x27;d deleted 90% of the code and the entire test suite still passed I realised that getting a <i>reliable</i> stripped down version was going to be a problem.<p>&gt; Also I make extensive use of coroutine-local variables<p>I&#x27;ve been using Syntax::Keyword::Dynamically where I need that.<p>&gt; For that dual-use functionality, as far as I can tell with Future::AsyncAwait I&#x27;d need to write two separate versions of most things.<p>I tend to write async by default and then for blocking code I call a blocking version of the API.<p>&gt; I think &quot;reliable&quot; is misleading. Coro is highly reliable (for me anyway), while Future::AsyncAwait has documented gotchas.<p>I&#x27;ll take documented gotchas over undocumented weird shit and an author who refuses to use a bugtracker and has a track record of deleting features if he doesn&#x27;t like how people are using them.<p>&gt; With Coro all the modules just work without anything Coro-specific in them.<p>Or at least they used to. The author no longer supports the past five years or so of perl releases so there&#x27;s no combination of supported perl and supported Coro that exists anymore :(')