Item(by='tptacek', descendants=None, kids=[25492139, 25491905, 25491178, 25491488, 25491745], score=None, time=1608512590, title=None, item_type='comment', url=None, parent=25490138, text='Most examples of BPF code are written in a mix of Python and C using BCC, the &quot;BPF Compiler Collection&quot;, which essentially treats all of LLVM and clang as a library callable from Python code.<p>I can&#x27;t get my head around using it that way, and have found it pretty straightforward to just write C programs, compiled with clang `-target bpf`. Until very recently, writing anything interesting this way required you to declare all functions inline, compile into a single ELF .o, and, of course, avoid most loops. But most of the kinds of things you&#x27;d write in BPF tend not to be especially loopy (you can factor most algorithmic code out into userland, communicating with BPF using maps).<p>A big issue for this kind of development is kernel compat; struct layouts can change from release to release, for instance. This isn&#x27;t a problem for us at Fly, because we just run the same kernel everywhere, but it&#x27;s a real problem if you&#x27;re trying to ship a tool for other people&#x27;s systems. But that&#x27;s changing with CO-RE; recent kernels can export a simplified symbol table in a BPF-legible format called BTF, and  the leader can perform relocations. Facebook has written a bunch of good stuff about this:<p><a href="https:&#x2F;&#x2F;facebookmicrosites.github.io&#x2F;bpf&#x2F;blog&#x2F;2020&#x2F;02&#x2F;20&#x2F;bcc-to-libbpf-howto-guide.html" rel="nofollow">https:&#x2F;&#x2F;facebookmicrosites.github.io&#x2F;bpf&#x2F;blog&#x2F;2020&#x2F;02&#x2F;20&#x2F;bcc...</a>')