Item(by='mistersys', descendants=None, kids=None, score=None, time=1611831077, title=None, item_type='comment', url=None, parent=25933698, text='The answer is simple: Traits<p>The weakness of OOP structurally stems almost entirely from inheritance, which I think is very poor construct for most complex programs.<p>How should the widget situation be handled? Well, what is a widget? It&#x27;s hard to define, because it&#x27;s a poor abstraction.<p>Maybe all your &quot;widgets&quot; should be hide-able, so you implement a `.hide()` and `.show()` method on `Widget`. Oh, and all your widgets are clickable, so let&#x27;s implement a `.click()` method.<p>Oh wait.. but this widget `some-unclickable-overlay` is not clickable, so let&#x27;s build a `ClickableWidget` and `ClickableWidget` will extend `Widget`. Boom, you&#x27;re already on your way to `AbstractBeanFactory`.<p>We got inheritance because it&#x27;s an easy concept to sell. However, what if we talked about code re-use in terms of traits instead of fixed hierarchies?<p>So, our `some-unclickable-overlay` implements Hideable. Button implements Hideable, Clickable. We have common combination of these traits we&#x27;d like to bundle together into a default implementation? Great, create super trait which &quot;inherits&quot; from multiple traits.<p>Rust uses such a system. They don&#x27;t have classes at all. Once you use a trait system, the whole OOP discussion becomes very obvious IMO.<p>1. Shared state can be bad, avoid if possible<p>2. Inheritance is a poor construct, use traits, interfaces, and composition instead.<p>3. Don&#x27;t obsess about DRY and build poor abstractions. A poor abstraction is often more costly than some duplicated code.<p>4. Use classes if they&#x27;re the best tool in your environment to bundle up some context together and pass it around, otherwise don&#x27;t')