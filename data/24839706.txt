Item(by='nendroid', descendants=None, kids=[24839964], score=None, time=1603213069, title=None, item_type='comment', url=None, parent=24839262, text='&gt;35 years professional software engineering, 30 years in embedded. I&#x27;m going to guess that you have less.<p>Doesn&#x27;t change the fact that you&#x27;re wrong and 35 years of programming doesn&#x27;t ensure that you&#x27;re a good developer. There are examples of crap code and patterns that have been around perpetually.<p>&gt;Why is state data used everywhere? Because embedded systems often respond in different ways depending on the state of external inputs<p>State being everywhere doesn&#x27;t preclude it to being segregated from logic.<p>&gt;If those decisions are spread through the bulk of the code, there&#x27;s really not much left to put in your combinator. And there&#x27;s no point in trying to add that paradigm to a system that&#x27;s going to have tons of shared mutable state anyway.<p>The decision is what goes in the combinator.<p><pre><code>   #IO functions.\n\n    Data getIOFromModuleA()\n    void sendIOToModuleA(Response r)\n\n    Data getIOFromModuleB()\n    void sendIOToModuleB(Response r)\n       \n    ....\n\n\n   # combinators, reuseable in both module A and module B because of segregation from IO and State\n\n    Decision makeDecision(Data x)\n    Response createResponse(Decision x)\n</code></pre>\nIt&#x27;s the same pattern for State. Just replace the word IO with State. Response can be anything, it can be the entire new state of the program. It can represent a delta of a change, it can be a response specific to a module. Also again, all threading commands go into State or IO functions.<p>OOP fails to segregate code this way and if you don&#x27;t organize your code like this then you have 35 years of experience of navigating someone elses mess or your own.')