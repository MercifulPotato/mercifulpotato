Item(by='jofer', descendants=None, kids=[25573748, 25577929, 25574535], score=None, time=1609265305, title=None, item_type='comment', url=None, parent=25569526, text='I&#x27;ve used fortran, C&#x2F;C++, matlab, and IDL for many years but primarily work in python these days.  I really do think numpy gets the interface correct.  Modern fortran is quite nice as well, but I&#x27;m a _big_ fan of the way numpy does broadcasting.  I think this is one thing it gets _much_ more correct than, say, matlab does. Also, the fact that numpy arrays are semi-contiguous chunks of memory just like a C arrays makes them _very_ easy to reason about.  It&#x27;s easy to predict memory usage and understand what operations will make temporary copies (assuming you understand how numpy works, anyway).<p>The way numpy uses python&#x27;s built in operators makes it feel very native.  I really don&#x27;t find it awkward at all.<p>I used numeric and numarray in the pre-numpy days, and those did feel more &quot;bolted on&quot;. While numpy is really similar to numeric, a lot of little things were fixed during the transition to make numpy very much a native part of python.<p>Everyone keeps insisting that numpy&#x2F;scipy&#x2F;etc are all really &quot;just written in other languages with a python interface&quot;, but that&#x27;s _far_ from being true.  Core parts are (e.g. ndarray itself + built-in ufuncs), and a lot more is wrappers around widely-used libraries (think BLAS), but you might be surprised at how much of numpy really is python.  Ditto for scipy (though for purely historical reasons, scipy is a dumping ground for X-implemented-in-C stuff).  Ditto for things like skimage&#x2F;sklearn&#x2F;etc.  The bulk of it really is implemented in python.  Sure, operations like + aren&#x27;t, but it might be worth looking through the numpy codebase before stating that it&#x27;s not written in python.<p>Next, yes, if you naievely loop over a python array it will be slow, and this is a real limitation of the language + numpy model.  Yes, you need to use a different mental model when implementing things.  Some problems (e.g. finite-difference-like problems) are best implemented in a way that has poor performance with python+numpy. You do need to drop down to fortran&#x2F;C&#x2F;etc (cython is _great_ for those cases) when you have problems that can&#x27;t be modelled in a particular way.  However, that&#x27;s not the limitation most folks seem to think it is.  It&#x27;s a well-known limitation that there&#x27;s a ton of support for switching approaches when you hit it (e.g. cython, numba, f2py, etc).  Yes, fortran and julia are both nicer in those cases (though my experience with julia is mostly &quot;toy&quot;&#x2F;learning projects).  However, the problems where python+numpy breaks down performance-wise are not anywhere near as common as folks seem to think they are. In my experience, the other types of non-scientific problems are _much_ more common, so it&#x27;s nice to have a very general purpose language to draw on.<p>As for matrix multiplication, is it really that bad to do things like x.T.dot(y) instead of x&#x27; * y? I really don&#x27;t understand the argument that the `dot` method of an ndarray is ugly.  Also, I actually hate that matlab&#x2F;et al treat any 2d array as though it&#x27;s a matrix and fundamentally don&#x27;t have the concept of a 1d array (row vectors and column vectors are 2d, not 1d).  I really do want a 1d array and not a row vector or a column vector most of the time.  That&#x27;s simply impossible in matlab. Also, if you want that behavior in python, it&#x27;s absolutely possible! Use `np.matrix` instead of `np.array`.  Arrays don&#x27;t behave that way because element-wise operations are more common in practice.<p>I get the impression you&#x27;re looking at things from a Julia perspective.  Julia is great, but similar to matlab and fortran it falls apart when you start to move outside its core domain.  I wouldn&#x27;t want to write a web service in Julia (though I&#x27;m sure it&#x27;s possible).  I do very frequently need to implement web services that do relatively heavy number crunching or deal with things that are fundamentally math-on-big-arrays-of-numbers.  Python is _great_ for that type of application.  It&#x27;s also actually pretty good for many &quot;hardcore&quot; number crunching tasks.  I&#x27;ve done things where python falls short, sure.  However, python + numpy&#x2F;et al hits a sweet spot that other languages currently don&#x27;t in what it combines.  Domain specific languages are better in some ways, but surprisingly little of a scientific codebase winds up being pure numerical operations.  There&#x27;s an awful lot of other stuff in there, and that&#x27;s where the scientific python stack is incredibly effective.')