Item(by='User23', descendants=None, kids=None, score=None, time=1604440219, title=None, item_type='comment', url=None, parent=24979395, text='&gt; finding an algorithm that does it (perhaps together with some other latency requirements) is extremely hard and it took many years to find the first one that could do it.<p>I agree.  And correctly implementing those algorithms is much easier using a formal derivation with a mathematical tool such as the predicate calculus than it is by just eyeballing it and hoping your tests catch all errors.<p>&gt; But hard problems come up all the time, especially when concurrency is involved<p>Predicate transformers are well suited for reasoning about nondeterminism and concurrency.<p>&gt; Not if it&#x27;s done formally<p>Program derivation with predicate transformers is done formally. It&#x27;s a chain of equivalences, implications, and consequences as appropriate to the problem. The program text is literally developed as a proof, and each transformation of the code must be justified by axiom, theorem, or lemma and at the end of that derivation all properties of the specification hold. You can&#x27;t possibly be claiming that no formal mathematics was done before the invention of automated checkers, because that would be both ridiculous and observably false.<p>&gt; Here is the proof: X is a program, and so, also a specification,<p>I disagree. A specification maps to either an empty or countably infinite set of programs that satisfy it. Also all programs satisfy countably infinitely many specifications. They are not isomorphic or even dual. In this case that conflation doesn&#x27;t seem to impair our understanding too much though.<p>&gt; and P(X) is some property that you want to verify for X.<p>Right, and the task of the programmer is to write a program text that provably establishes that P(X) holds everywhere in the program state space.<p>&gt; A formal derivation of a program from the specification X âˆ§ P(X) will, therefore, prove P(X)<p>Yes this is what I meant when I said you should use the same techniques to derive the program text that you would to derive any other mathematical proof.<p>&gt; it&#x27;s not a trick, but a basic result in the study of the hardness of program analysis<p>It&#x27;s a trick because it&#x27;s a clever way of saying write a program for which there is no known algorithm. As of now nobody is going to be able to do that regardless of their methodology. I get the impression that you mean this to be a compelling point, but I&#x27;m not grasping how I&#x27;m better off not using mathematical reasoning to derive the programs that I do know how to write.<p>&gt; The claim that it&#x27;s easier to derive than to prove is just mathematically false<p>It&#x27;s not even false it&#x27;s incoherent. But I didn&#x27;t make that claim. Both derivation and verification are ways to prove a program satisfies a specification.<p>As you say, a derivation of a program that satisfies a specification is a proof. Specifically, a proof by construction. The claim is that it&#x27;s considerably easier to derive a program that satisfies some property than it is to verify if an arbitrary program satisfies that property. For example say we have a specification S: &quot;returns a product of two primes&quot; and two programs. P1: &quot;Return 2^82589933-1 * 2^77232917-1&quot; and P2: &quot;Return 2^8258993365541237147-1&quot;. The proof of the correctness of P1 is trivial because I constructed it to be so[1]. As for P2 I have no idea if it satisfies S, but I am certain that it&#x27;ll be considerably harder to convince myself and others that it does than it was for P1.<p>&gt; With regards to claims about informal &quot;proofs&quot; or &quot;derivations&quot; it&#x27;s hard to say anything, because the problem is not well-stated.<p>I&#x27;ve made no claims of the sort.<p>[1] <a href="https:&#x2F;&#x2F;primes.utm.edu&#x2F;largest.html" rel="nofollow">https:&#x2F;&#x2F;primes.utm.edu&#x2F;largest.html</a>')