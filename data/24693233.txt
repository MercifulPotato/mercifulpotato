Item(by='reubenbond', descendants=None, kids=None, score=None, time=1601940790, title=None, item_type='comment', url=None, parent=24692561, text='&gt; Orleans doesn&#x27;t have any ordering guarantees. While this is not a firm requirement of the Actor model itself, both Erlang and Akka guarantee ordering between a given Sender-receiver pair (i.e. messages sent from A to C will be sent in order)<p>Ordering has a performance cost. It needs to either be maintained at all levels, or reconstructed from unordered messages at a later point. Even something simple like an m:n thread pool scheduler can ruin ordering guarantees. My view (Orleans core developer) is this: if you want ordering, await your calls. That way, you are guaranteed ordering regardless of any message reordering that can occur in the scheduling or networking layers, or due to failure and recovery of a host. So you can choose when to pay that cost and when to reap the performance benefits of not paying it (by firing off multiple calls in parallel).<p>&gt; A stable and properly configured Akka Shard cluster will never have more than one of the same entity actor alive at a time.<p>Likewise for Orleans, but the caveat of a &quot;stable cluster&quot; doesn&#x27;t do much for users. &quot;Stable cluster&quot; falls apart frequently in real scenarios, which can be as simple as a single machine being abruptly restarted. Developers must account for the error scenarios.<p>&gt; Akka and Erlang have the concept of Supervision.<p>Orleans does not have supervision, since each grain stands on its own (no hierarchy) and have an eternal nature (managed lifecycle). Grains are not destroyed when a method throws an exception: the exception is propagated back to the caller and the caller can use try&#x2F;catch to handle the exception. This is similar to what .NET developers are used to, since regular objects are also not destroyed when a method throws an exception, and the caller is able to handle the exception. My belief is that this kind of exception handling is usually appropriate, since the caller has context which can be useful in handling the error. The developer can also write per-grain or global call filters which can operate on all calls and handle any exception, so if that&#x27;s preferred, then it&#x27;s available.')