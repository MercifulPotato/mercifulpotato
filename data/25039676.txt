Item(by='pron', descendants=None, kids=[25040868], score=None, time=1604954791, title=None, item_type='comment', url=None, parent=25039152, text='&gt;  This is similar to the case with many statically typed programming languages ... that have worse-than-exponential blow-ups in their type systems that essentially never show up in practice.<p>I&#x27;m not so sure. Type checking&#x2F;inference with &quot;degenerate cases&quot; (e.g. Hindley-Milner) is in FPT (fixed-parameter tractable) as are, AFAIK, all problems that are hard in the worst-case but could be easy in practice (e.g. SAT). Program analysis, (assuming &quot;FSMification&quot;, of course, to avoid undecidability), was proven in 2005 to not be FPT.<p>&gt; Yes if you program in a fragment of a language you&#x27;re fine.<p>I&#x27;m claiming that analogous code to that which would be feasibly checkable in a restricted language would also be feasibly checkable in a non-restricted language, and that <i>both</i> are subject to the same difficulties.<p>&gt; By this standard all programming languages are indistinguishable at a general level (which is true, but not very useful).<p>Right, but that doesn&#x27;t mean that a specific empirical claim should be assumed true until proven false, rather than the opposite, which is the scientific norm.<p>&gt; Barring this, we have weak (but not unusually so for the field of programming) evidence, in the form of user communities of Turing-incomplete languages today, that people aren&#x27;t generally creating heat-death style code on accident.<p>Are you talking about niche languages (like configuration languages) or those intended to be general purpose?<p>&gt; The name of the game when creating programming languages is to target code that &quot;a normal user would write.&quot; Completely restricting the entire language is just another lever in that process.<p>Perhaps, but this claim requires evidence, unless we agree to keep it in the realm of art and aesthetics, which I&#x27;m more than happy to.')