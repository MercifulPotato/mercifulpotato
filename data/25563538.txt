Item(by='ragnese', descendants=None, kids=[25564291], score=None, time=1609191557, title=None, item_type='comment', url=None, parent=25562792, text='I agree that keeping IO sequestered is generally good advice. And it&#x27;s something that I also do in imperative and OO languages as a rule of thumb. But having the type system signalling at IO is happening doesn&#x27;t end up being useful in non-lazy languages where purity doesn&#x27;t actually help an optimizer.<p>I found this blog post to be kind of interesting: <a href="https:&#x2F;&#x2F;blog.ploeh.dk&#x2F;2017&#x2F;02&#x2F;02&#x2F;dependency-rejection&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.ploeh.dk&#x2F;2017&#x2F;02&#x2F;02&#x2F;dependency-rejection&#x2F;</a><p>Skim that and then take a look at the back-and-forth in the comments.<p>Sometimes going out of your way to write mostly pure (or just non-IO) functions can make your code more difficult to reason about. In my experience, you&#x27;re sometimes left with two choices: either do a bunch of IO upfront that you might end up throwing away (if there is an `if` statement in your pure function that determines whether you need the result of some IO op), or pull out logic into the naughty impure edge of your program.<p>If you do the former, you&#x27;re wasting performance. If you do the latter, you&#x27;re not actually fixing anything that pure functions are supposed to help you with, because you still have logic in impure functions.<p>In my experience there are these edge cases where finding the cutoff between &quot;the edge where I&#x27;m allowed to do IO&quot; and the &quot;pure business logic&quot; is not that clear or easy.<p>Also, as the old saying goes: monads don&#x27;t compose well.')