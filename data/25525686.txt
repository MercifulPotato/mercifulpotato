Item(by='scottlamb', descendants=None, kids=[25526022], score=None, time=1608794732, title=None, item_type='comment', url=None, parent=25522471, text='I think async was inevitable for Rust, for better or for worse. My experience is that just using OS-provided threads isn&#x27;t good enough for say a high performance webserverâ€”compare the pre-tokio hyper benchmark results to the post-tokio ones for example. And Go-like green threads aren&#x27;t really possible in Rust given the choice to have no runtime. (Having a stack for every coroutine also probably isn&#x27;t as good for squeezing out that last bit of performance. Every stack&#x2F;guard page means more TLB pressure, for example, and programs can spend a lot of time on TLB cache misses.) Rust aims to be suitable for high-performance, low-level environments, so here we are.<p>I agree async has usability problems. Hopefully they&#x27;ll get better over time; I&#x27;m looking forward to eventually having generators rather than dealing with futures::stream::StreamExt and the like.<p>I don&#x27;t think everyone needs to use async all the time. Take a web app, for example. If the webserver is directly Internet-facing, it has to deal with lots of keepalive connections, so the core webserver logic (hyper or equivalent) should be async. But if you&#x27;re not dealing with too many active requests and don&#x27;t care about the performance difference, I don&#x27;t think there&#x27;s any reason you shouldn&#x27;t have all your request handling just use threads, sending replies to hyper with a channel and blocking when necessary.<p>Last I checked I couldn&#x27;t find an ergonomic and efficient &quot;half-async&quot; bounded channel implementation. By which I mean one that allows you to treat the sender as blocking and the receiver as async, or vice versa. That&#x27;d be really useful for writing synchronous programs that use async libraries. I certainly don&#x27;t see any reason one couldn&#x27;t exist. Maybe it already does and I missed it.')