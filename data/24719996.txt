Item(by='jcelerier', descendants=None, kids=[24720451, 24720014], score=None, time=1602170795, title=None, item_type='comment', url=None, parent=24719301, text='There&#x27;s some tradeoff there though. I&#x27;m doing most of my dev in C++ and run all the time with ASAN &#x2F; LeakSanitizer. I have a leak-causing mistake, what, twice a year maybe ? Definitely not something worth loosing sleep over.<p>The much bigger problems imho are not really tractable. e.g. consider something that does:<p><pre><code>    struct server { \n      std::vector&lt;requests&gt; m_requests_to_process;\n      boo m_running{true};\n\n      void on_web_request(request req) {\n        m_requests_to_process.push_back(req); \n      }\n\n      void process_pending_requests() {\n        while(m_running) { \n          for(auto req : m_requests_to_process) {\n            do_stuff(req);\n          }\n          &#x2F;&#x2F; oops, forgot to clear\n        }\n      }\n    };\n\n</code></pre>\nthere&#x27;s no &quot;leak&quot; in the OS sense as everything will be reclaimed upon server::~server... but your memory usage will be strictly increasing. Can Rust detect those cases ? As in my experience <i>this</i> is the most common leak pattern (of course not in a simple example like this, but when your &quot;server&quot; architecture starts being split across multiple threads and source files...')