Item(by='ben509', descendants=None, kids=None, score=None, time=1603341064, title=None, item_type='comment', url=None, parent=24852275, text='I know people often read headlines and then instantly comment, but I really did read most of the post.<p>What I realized after writing most of my comment was that the author was primarily interested in explaining a recursive descent parser, and the arguments you quoted were simply a hook to get people interested.<p>That&#x27;s why I phrased my objection to not _fully_ answering the question.<p>And it&#x27;s a good question, so I thought the other side deserved some exploration.<p>&gt; You should hand-roll a parser first, and then, when you see the limitations of your hand-rolled parser, adopt a parser generator, now with full understanding of what the generator is doing for you (and not doing for you).<p>Writing your own recursive descent parser only teaches you recursive descent. So, sure, you&#x27;ll have a clear idea of what a parsec derivative is doing since that&#x27;s also RD, but it won&#x27;t help you understand what a LALR parser generated by yacc is doing.<p>The other problem is for someone to use your parser in another language, they have to port the whole thing and maintain that port as your language changes. Talking about &quot;the first time you write it&quot; and pedagogical uses is entirely fair, but it&#x27;s only the beginning of the story.<p>&gt; To be convincing, you&#x27;d need to do what the author did, (even though you say the author didn&#x27;t): you&#x27;d need to justify your argument with specific examples.<p>Nope, never said the author didn&#x27;t provide examples. To be clear, it&#x27;s an excellent tutorial on how to write a RD parser.<p>I&#x27;m not prepared to rewrite a bunch of code in two styles, but you&#x27;re welcome to take a look at the expression parser[1].<p>In this case, I didn&#x27;t want to write a whole precedence scanner for expressions, and I wanted precedence to be clear to a reader.<p>So there&#x27;s some nuance I didn&#x27;t capture: in Haskell parsing, writing your own RD parser starts to look like parsec because it&#x27;s such a natural expression of the problem.<p>If I was going to write my own parsec, I could still probably use an existing combinator[3] because the parsec model is so generic. That&#x27;s why I wanted to use that to do a more human readable, and thus more complex, syntax.<p>But, as I mentioned above, recursive descent kinda sucks. As an example, take the parsing for the left-hand side of an assignment[2]. Sometimes I have &#x27;try&#x27; calls, other times I don&#x27;t. Sometimes the ordering around alternatives (the &lt;|&gt; operator) matters, sometimes it doesn&#x27;t.<p>I know in abstract why it works one way or another. But, honestly, most of that is in there because it got tests to pass. My interest is in writing a language, not a parser.<p>And that&#x27;s really why I switched from megaparsec to a parser generator. Once I got my grammar to be (reasonably) unambiguous, my source was just the plain, trivially readable BNF rules, and I nuked those stupid tests.<p>[1]: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;contravariance&#x2F;tenet-haskell&#x2F;-&#x2F;blob&#x2F;0640c7591d3e0228f455b765e944c61563e1964b&#x2F;library&#x2F;Tenet&#x2F;Parsing&#x2F;Expr.hs#L51" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;contravariance&#x2F;tenet-haskell&#x2F;-&#x2F;blob&#x2F;0640c...</a><p>[2]: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;contravariance&#x2F;tenet-haskell&#x2F;-&#x2F;blob&#x2F;0640c7591d3e0228f455b765e944c61563e1964b&#x2F;library&#x2F;Tenet&#x2F;Parsing&#x2F;Lhs.hs#L24" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;contravariance&#x2F;tenet-haskell&#x2F;-&#x2F;blob&#x2F;0640c...</a><p>[3]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;parser-combinators-1.2.1&#x2F;docs&#x2F;Control-Monad-Combinators-Expr.html" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;parser-combinators-1.2.1...</a>')