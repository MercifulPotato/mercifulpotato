Item(by='Blikkentrekker', descendants=None, kids=[25566198], score=None, time=1609188166, title=None, item_type='comment', url=None, parent=25562214, text='With non-strict semantics, function execution is re-ordered and turned inside out.<p>For instance let us say we have pseudocode:<p><pre><code>   let list       = [1,2,3,4,5];\n   let new_list   = do_something(list);\n   lew newer_list = do_something_else(new_list);\n</code></pre>\nBoth these functions consume and return lists. In a strict language, this process of iterating over the entire list internally in these two functions would happen twice; this would be wasteful.<p>A non-strict language however is permitted to take the side-effect-less code apart, and restructure it in such a way that the list is only traversed once, essentially combining these two functions into one function and letting what each does run successively, for this purpose it is permitted to generate a new function that combines what both does, and doing so iterating the list only once, and optimizers are typically clever enough to be able to do so.<p>Suppose that both of these functions be library function black boxes, provided by a dynamic library, then the implementation can no longer do this as it calls both from a library.<p>The way <i>Haskell</i> is written is completely dependent on this; it would be awfully slow if the compiler weren&#x27;t allowed to do this.<p>The result in practice is that updating a dynamic library written in <i>Haskell</i> requires that all it&#x27;s consumers be recompiled to compile against the new version. Or otherwise said: there is no concept of a stable a.b.i. in <i>Haskell</i>.')