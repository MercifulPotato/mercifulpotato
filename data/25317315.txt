Item(by='quietbritishjim', descendants=None, kids=None, score=None, time=1607195212, title=None, item_type='comment', url=None, parent=25315425, text='&gt; To work around this, you need to wrap the strings in newtypes<p>That is certainly an option, but actually std::variant&lt;string, string, shared_ptr&lt;Node&gt;&gt; does still work for most operations (std::visit is not one of them though). So another option is to use that typelist directly and switch to index-based access, at least for those entries:<p><pre><code>    if (std::string* s = std::get_if&lt;0&gt;(myVariant)) {\n        &#x2F;&#x2F; Use s\n    }\n    else if (std::string* s = std::get_if&lt;1&gt;(myVariant)) {\n        &#x2F;&#x2F; Use s\n    }\n    else if (NodePtr* node = std::get_if&lt;2&gt;(myVariant)) {\n        &#x2F;&#x2F; Use node\n    }\n    else {\n        throw std::logic_error(&quot;Unknown variant entry&quot;);\n    }\n</code></pre>\nAt that point you&#x27;ll probably want to define an enum (an old-school one so it implicitly converts to int) to identify the cases symbollically, which admittedly is pretty messy given that it&#x27;s up to you, the maintainer, to keep the enum in sync with the actual type list in the variant. But it&#x27;s hardly the worst coding sin ever, and better than any alternative I can think of (short of switching to another language). As you can see from my comment further down, I think a chain of if statements is cleaner than std::visit anyway, precisely because of the complexity problems of std::visit discussed in the article.')