Item(by='chriswarbo', descendants=None, kids=[25100989], score=None, time=1605374761, title=None, item_type='comment', url=None, parent=25092676, text='&gt; I tend to think that languages aren&#x27;t that important.<p>&gt; switching languages is no fast path towards solving hard problems<p>If you&#x27;re talking about switching from one mainstream, general purpose language to another, then I mostly agree. Some tradeoffs can be definite wins for particular domains, e.g. for Web development Go is almost always a better choice than C (in terms of memory management, string handling, buffer overflows, etc.). Other choices can just shift problems around, e.g. in Python it&#x27;s easy to get something running, but it requires a lot of testing to avoid errors.<p>However, when it comes to domain-specific, non-general-purpose languages I <i>strongly</i> disagree! There are certain problems that are <i>incredibly</i> difficult to solve (often undecidable) in the context of some generic language; which become <i>trivial</i> when the language is designed with that problem in mind.<p>For example:<p>- Incremental computation <a href="https:&#x2F;&#x2F;inc-lc.github.io" rel="nofollow">https:&#x2F;&#x2F;inc-lc.github.io</a><p>- Resource handling <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Substructural_type_system" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Substructural_type_system</a><p>- Client&#x2F;server&#x2F;DB consistency <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ur_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ur_(programming_language)</a><p>- Ruling out unwanted effects <a href="https:&#x2F;&#x2F;deno.land&#x2F;manual@v1.0.0&#x2F;getting_started&#x2F;permissions" rel="nofollow">https:&#x2F;&#x2F;deno.land&#x2F;manual@v1.0.0&#x2F;getting_started&#x2F;permissions</a> <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Purely_functional_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Purely_functional_programming</a><p>- Hard realtime timing <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Esterel" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Esterel</a><p>There are a load more examples on sites like <a href="http:&#x2F;&#x2F;lambda-the-ultimate.org" rel="nofollow">http:&#x2F;&#x2F;lambda-the-ultimate.org</a><p>Such languages certainly introduce a bunch of problems, like lack of libraries, but they might be the difference between something being difficult, or it being impossible.<p>Another thing to keep in mind with domain-specific languages is that it&#x27;s often useful to &quot;embed&quot; them inside some other, general-purpose language. This lets a DSL avoid the need for its own parsing, tooling, etc. For example <a href="https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Embedded_domain_specific_language#Examples_of_Domain_Specific_Languages" rel="nofollow">https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Embedded_domain_specific_language#E...</a> <a href="https:&#x2F;&#x2F;beautifulracket.com&#x2F;appendix&#x2F;domain-specific-languages.html" rel="nofollow">https:&#x2F;&#x2F;beautifulracket.com&#x2F;appendix&#x2F;domain-specific-languag...</a>')