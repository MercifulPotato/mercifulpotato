Item(by='unabst', descendants=None, kids=None, score=None, time=1609307180, title=None, item_type='comment', url=None, parent=25578346, text='The crux of Brook&#x27;s argument is with irreducible complexity which he calls essential, but also qualifies it with what cannot be reduced with technology:<p>&gt; programming tasks contain a core of essential&#x2F;conceptual1 complexity that&#x27;s fundamentally not amenable to attack by any potential advances in technology<p>Luu is arguing that most of the complexity programmers deal with is of accidental kind. I would describe it as the &quot;incidental to implementation kind&quot;:<p>&gt; I&#x27;ve personally never worked on a non-trivial problem that isn&#x27;t completely dominated by accidental complexity, making the concept of essential complexity meaningless on any problem I&#x27;ve worked on that&#x27;s worth discussing.<p>The OP @ozim that got me thinking reformulated essential as:<p>&gt; Essential complexity from how I read Fred Brooks is a domain knowledge like what an accountant does<p>Which I found quite ingenious. Because it&#x27;s true. Complexity starts from before you sit down to write your program. It&#x27;s what you bring to the computer. And any non-trivial problem would be dominated by accidental complexity in a computer&#x27;s implementation space. Unless the computer was already written for accounting.<p>&gt; essential complexity in Brook&#x27;s sense is completely unavoidable (in the logical sense).<p>The moment you interpret any part as &quot;unavoidable&quot; you lose an important neuance. And I was trying to illustrate how &quot;unavoidable&quot; was determined precisely by where you are sandwiched within the existing abstraction layers not of your making.<p>Even the tax code is written by legislators that are capable of controlling the accidental complexity they implement based on the essential complexity they bring to the table; the requirements they must satisfy before they leave the table.<p>The accidental tax code created by the legislators becomes essential domain knowledge to the accountant.<p>And how is this different from HTML or bash or OS programming? Or working with PayPal APIs? The authors, with avoidable choices, determine what becomes unavoidable for the consumer.<p>The accidental complexity of someone else is now essential complexity to you, by the defintion that 1) it&#x27;s unavoidable, 2) fundamentally not amenable to attack by any potential advances in technology, and 3) it&#x27;s the bedrock upon which all of your accidental complexity lies.<p>So with this model, how do you reduce complexity?<p>We have layers upon layers of expanding specs. It&#x27;s not just a computer problem, but a coding problem that also applies to tax law or any other rule making. And it&#x27;s an entropy problem. Left unchecked, complexity only grows, so how do you fight entropy?<p>Stacking is part of the solution. Each layer shields all that is beneath it. And for someone using TurboTax, they just see English and buttons and fields to fill. The user is shieled even from HTML.<p>The front end coder is immersed in the essential complexities of HTML and all of the TurboTax pages are accidental, in accordance with satisfying the essential requirements of the page. But nevertheless, he is shielded from everything below his HTML stack.<p>We can already see without these layers, the level of sophistication we&#x27;ve obtained with our internet experience may never have been attained. The premise sort of being, TurboTax has never been better. Which I hate to have to admit is sort of true.<p>Refactoring is another part of the solution that we already do with our code. This may entail remodeling, redefining, and reexamining the problem space.<p>But we can also refactor our abstraction layers. JQuery was a new layer on top of javascript that was later refactored out by many, as javascript matured (if you could call it that).<p>In closing, we can refactor code, we can refactor abstraction layers, and we can also abstract more. We need to fight complexity by deleting as much as possible and reorganizing what remains. And part of the solution is finding the minimum number of abstractions that are needed to recreate our solution space.')