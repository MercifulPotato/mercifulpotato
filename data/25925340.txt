Item(by='skissane', descendants=None, kids=[25939105], score=None, time=1611732710, title=None, item_type='comment', url=None, parent=25925230, text='One thing newbies often ask, is why can&#x27;t they write a shell script which changes the environment or directory of their running shell. The answer, of course, is that you can&#x27;t, without sourcing it.<p>People also ask the same question about Windows, and even DOS before it; there you actually could do it from a batch file, since CMD.EXE&#x2F;COMMAND.COM effectively sources all batch files, it doesn&#x27;t run them in a subprocess – but the same issue occurs if you write a program in some other language than batch, it runs in a subprocess and so can&#x27;t modify CMD.EXE&#x2F;COMMAND.COM&#x27;s environment. (People resorted to some tricks though, like having a BATCH1.BAT call their program, and then afterwards call BATCH2.BAT, and their program modifies BATCH2.BAT on disk).<p>Actually on DOS, there is a way to modify COMMAND.COM&#x27;s environment – COMMAND.COM installs an undocumented interrupt, INT 0x2E, which you can use to send commands to COMMAND.COM to run. So you can actually modify COMMAND.COM&#x27;s environment. (Only the root COMAMND.COM installs a handler for INT 0x2E, nested ones do not.) Of course, due to no memory protection, there are also nasty ways of doing this, like modifying COMMAND.COM&#x27;s memory. (And changing COMMAND.COM directory isn&#x27;t an issue, since under DOS, the current directory is system-wide, not per-process.)<p>I was thinking, you could do something like &quot;INT 0x2E&quot; in a Unix shell. Create a Unix domain socket, and the shell listens for commands on it to execute. Put the path to the socket in an environment variable which is inherited by subprocesses, e.g. SHELL_CONTROL. Then, a subprocess can inspect and modify the shell&#x27;s environment, working directory, functions, aliases, running jobs, etc, by reading&#x2F;writing the Unix domain socket mentioned in SHELL_CONTROL.')