Item(by='hnlmorg', descendants=None, kids=[25561405], score=None, time=1609175638, title=None, item_type='comment', url=None, parent=25560224, text='&gt; <i>There are modern microkernels that are POSIX compliant and have a much lower footprint than linux.</i><p>There are... but they&#x27;re not &lt; 1MB. Which was the point being made.<p>&gt; <i>I think the most prominent issue, people points out here is performance.</i><p>That&#x27;s literally what I said at the start of the conversation!<p>&gt; <i>However, it&#x27;s very obvious to me that the extra abstraction of having a kernel vs having no kernel on an constrained device costs performance, and it&#x27;s always a trade-off, both solutions can be found and both solutions are valid.</i><p>Show me a device with the same specs as the N64 which runs an OS and I&#x27;ll agree with you that both solutions are valid. The issue isn&#x27;t just memory, it&#x27;s your CPU clock speed. It&#x27;s the instructions supported by the CPU. It&#x27;s also the domain of the device.<p>Running an OS on the N64 would <i>never</i> have made sense. I guess, in some small way, you could argue the firmware is an OS in the say way that a PC BIOS could. But anything more than that is superfluous both in terms of resources used and any benefits it might bring. But again, if it&#x27;s a case of &quot;both solutions are valid&quot; then do please list some advantages an resident OS would have bought. I&#x27;ve explained my argument against it.<p>Let&#x27;s take a look at what was happening on PCs around the time of the N64&#x27;s release. Most new games were still targeting MS-DOS and largely interfaced with hardware directly. In a way, DOS was little more than a bootstrap: it didn&#x27;t offer up any process management, the only memory management it did was provide an address space for the running DOS application, it didn&#x27;t offer any user space APIs for hardware interfaces -- that was all done directly. And most of the code was either assembly or C (and the C was really just higher level assembly).<p>Fast forward 4 years and developers are using OpenGL, DirectX and Glide (3DFX&#x27;s graphics libraries which, if I recall correctly, was somewhat based on OpenGL) in languages like C and C++ but instead of writing prettier ASM they&#x27;re writing code based around game logic (ie abstracting the problem around a human relatable objects rather than hardware schematics). It was a real paradigm shift in game development. Not to mention consoles shifting from ROM cartridges to CD posed a few new challenges: 1) you no longer have your software exist as part of the machines hardware 2) you now have made piracy a software problem (since CD-ROMs are a standard bit of kit in most computers) rather than a hardware one (copying game carts required dedicated hardware that wasn&#x27;t always cheap). Thankfully by that time computer hardware had doubled a few times (Moore&#x27;s Law) so it was becoming practical to introduce new abstractions into the stack.<p>The N64 exists in the former era and the operating system methodologies you&#x27;re discussing exist in the latter era. Even the constrained devices you&#x27;re alluding to are largely latter era tech because their CPUs are clocked at orders of magnitude more than the N64 and thus you don&#x27;t need to justify every instruction (it&#x27;s not just about memory usage) but in many cases an OS for an embedded device might just be written as one binary blob and then flashed to ROM, effectively then running like firmware.<p>It&#x27;s sometimes hard to get a grasp on the old-world way of software development if it&#x27;s not something you grew up with. But I&#x27;d suggest maybe look at programming some games for the Atari 2600 or Nintendo Gameboy. That will give you a feel for what I&#x27;m describing here.')