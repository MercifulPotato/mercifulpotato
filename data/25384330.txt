Item(by='Twisol', descendants=None, kids=None, score=None, time=1607683727, title=None, item_type='comment', url=None, parent=25384243, text='In principle, the ingredient you need for that use case is &quot;existential types&quot;. I suspect GATs let you define existential types -- after all, the selling point is that the trait defines some type, and you can&#x27;t rely on what type any particular implementor chooses. (But I can&#x27;t quite put my finger on why non-G associated types shouldn&#x27;t be enough.)<p>In Java(!), I have a class `Database&lt;$Database&gt;` whose constructor is private and whose sole static factory returns `Database&lt;?&gt;`. Thus, the caller must assume that every instance they create is parameterized over a distinct unknown type -- even if, in the implementation, $Database = Object. The dollar-sign prefix is a hint to the reader that this type parameter is meant to be a type correlated with a unique value.<p>You can get an `Index&lt;$Database&gt;` from any database, and it&#x27;s parametrized over the owning database&#x27;s unique existential type. Indexes over two different databases can&#x27;t be confused.<p>The only issue (so far) is that you have to be careful not to &quot;forget&quot; the correlation between the type parameters on an index and its owning database. If the type parameter decays back into a wildcard, the correlation is lost.<p>[1] <a href="https:&#x2F;&#x2F;varkor.github.io&#x2F;blog&#x2F;2018&#x2F;07&#x2F;03&#x2F;existential-types-in-rust.html" rel="nofollow">https:&#x2F;&#x2F;varkor.github.io&#x2F;blog&#x2F;2018&#x2F;07&#x2F;03&#x2F;existential-types-i...</a>')