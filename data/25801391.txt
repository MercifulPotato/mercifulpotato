Item(by='vinay_ys', descendants=None, kids=None, score=None, time=1610793082, title=None, item_type='comment', url=None, parent=25800324, text='Firstly software development is not one monolithic job. There are many different jobs within software development.<p>You can be a systems engineer – understand the computers at a fundamental level – with focus on systems software – building low-level high-performance components&#x2F;kernels – for storage systems, databases, in-memory systems etc (each of these have a lot of technical domain knowledge specialisation within them). You can spend 10 years in this field and continuously develop&#x2F;enhance your expertise incrementally – it is quite stable and rewarding experience. A branch of this specialization is distributed systems engineering – where emphasis is on software operating in a distributed cluster over network – which has additional challenges unique to the aspect of being distributed.<p>You can be an applications engineer –  understand application software engineering methodology – with focus on user&#x2F;business facing application feature development in a scalable software team setting. The key focus here is not so much about low-level computer systems but more about software engineering discipline. It is about the inter&#x2F;intra-team sport that is developing and continuously evolving a very large application software code base that is alive with changing&#x2F;evolving user&#x2F;business features. It is about modeling the functional domain of the user&#x2F;business&#x2F;real world. It is about the modern consumer Internet software development techniques – experimentation, live incremental safe feature releases etc.   A branch of this specialization is developing application frameworks and tooling (rather than user&#x2F;business functional features) to make the life of a feature engineer more productive. You can spend 10 years in this field and become an expert at software engineering discipline of churning out quality features on time and on budget.<p>The experience and learning in the above job families transcend any particular technology stack. The learnings are transferable from one tech-stack&#x2F;functional-domain to another with relatively minimal effort. This effort is part of the work itself and doesn&#x27;t turn you into a newbie for having to do it.<p>p.s: A generalist full stack engineer is usually an applications engineer who is somewhat good at systems engineering and is able to glue together systems to achieve the application features well. These engineers can take a startup from start and through initial growth phase and up to start of hyper growth phase. But there&#x27;s a scale&#x2F;performance threshold – where the scale of application deployment grows, performance starts to hurt your users, you need strong systems engineering specialists to fix those deeper systems&#x2F;distributed-systems problems. Public cloud systems have been continuously raising that threshold since the beginning.')