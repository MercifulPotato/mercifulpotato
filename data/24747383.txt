Item(by='tikhonj', descendants=None, kids=None, score=None, time=1602436721, title=None, item_type='comment', url=None, parent=24747026, text='This approach works well until you <i>do</i> encounter a situation like that in production :). It&#x27;s worth testing conservatively because our understanding of our systems is imperfect and because assumptions that may be valid <i>now</i> are likely to change in the future. It&#x27;s especially true for code that might operate at scale or has security considerations, because both of those can magnify the effects of conditions that occur with <i>arbitrarily low probabilities</i>.<p>Personally, I see tests as not just a way to prevent bugs, but as a way to learn about the system being tested—both how it behaves <i>now</i> and, continually, how it behaves in future iterations. In this specific case, understanding what happens if two URIs hash to the same value <i>even if they don&#x27;t &quot;really&quot; do that</i> is an important bit of information: it tells us not only what would happen with a real hash collision but also how our system would behave if there were a bug either in the hashing algorithm itself or in the code that connects the hashing algorithm to the component that <i>uses</i> the hashes.<p>What happens if we introduce a caching layer between where the hash is generated and where it&#x27;s used, and there&#x27;s a cache invalidation bug? I don&#x27;t know how realistic that is <i>in this specific hypothetical</i>, but I&#x27;m sure there are other performance optimizations with the same bug potential that I&#x27;m not even thinking of. Changes like that can lead to absolute debugging <i>nightmares</i>! Testing even &quot;impossible&quot; edge cases helps catch this in a systematic way, without needing full knowledge of which conditions might matter.<p>Of course, none of this talks to the trade-off you pointed out: test code <i>does</i> have a real cost. That is absolutely something to consider. I just don&#x27;t think the answer is to draw a hard line at &quot;don&#x27;t test situations that can&#x27;t come up in production&quot;—and, perhaps naively, I think the &quot;real&quot; solution is less about deciding what is and isn&#x27;t worth testing and more about reducing the costs of testing more. Write application code in a way that&#x27;s easy to test and treat your test code <i>as code</i>—keep it clean, include comments, and invest time in setup and tooling to make your tests as easy to write and maintain as possible.')