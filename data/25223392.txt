Item(by='jandrewrogers', descendants=None, kids=None, score=None, time=1606423499, title=None, item_type='comment', url=None, parent=25222801, text='The issue, beyond having no visible references at compile-time, is that DMA has no concept of objects and has its own rules for how and when it interacts with regions of memory. It is oblivious to ownership semantics. In things like databases, <i>most</i> of your address space is DMA-able memory and therefore &quot;unsafe&quot;. In C++, you can completely hide these mechanics behind constructs that look like unique_ptr&#x2F;shared_ptr but which are guaranteed to be DMA-safe. In this context, all references are treated as mutable because mutability is not a property of references per se. Conflicts can only be resolved at runtime.<p>Instead of using an ownership-based memory safety model, which is clearly broken for systems that use DMA, they can use <i>schedule-based</i> memory safety models, which are formally verifiable. These don&#x27;t rely on immutable references for safety, and also eliminate most need for locking -- many of the concepts originate in research on automated lock-graph conflict resolution in databases. The evolution away from ownership-based to schedule-based models is evident in database kernels over the decades. It was originally motivated by improved concurrency; suitability for later DMA-based designs was a happy accident and C++ allows it to be expressed idiomatically.<p>As for expressiveness, beyond the ability construct alternative safety models, modern C++ metaprogramming facilities enable not only compile-time optimization but also verification of code correctness that would be impractical in languages like Rust.')