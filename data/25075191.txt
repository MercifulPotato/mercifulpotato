Item(by='KaiserPro', descendants=None, kids=[25075353, 25075431, 25079504, 25075791, 25076477], score=None, time=1605215924, title=None, item_type='comment', url=None, parent=25073308, text='&quot;devop&quot; here<p>&gt; doesn&#x27;t scale well.<p>Nothing scales well. scaling requires lots of effort. It doesn&#x27;t matter what language you use, you&#x27;ll rapidly find all its pain points.<p>&gt; bad packaging when there&#x27;s a lot of cross-cutting dependencies<p>Much as I hate it, docker solves this. Failing that poetry or if you must venv. (if you&#x27;re being &quot;clever&quot; statically compile everything and ship the whole environment, including the interpreter) its packaging is a joy compared to node. Even better, enforce standard environments, which stops all of this. One version of everything. you want to change it? best upgrade it for everyone else.<p>&gt; slow performance<p>Meh, again depends on your use case. If you&#x27;re really into performance then dump out to C&#x2F;C++ and pybind it. fronting performance critical code in python is a fairly decent way to allow non specialists handle and interface performance critical code. Its far cheaper to staff it that way too. standard python programmers are cheaper than performance experts.<p>If we are being realistic, most of the time 80% of python programs are spend waiting on network.<p>Granted, python is not overly fast, but then most of the time your bottleneck is the developer not the language.<p>&gt; no concurrency<p>Yes, this is a pain. I would really like some non GIL based threading. However its not really been that much of a problem. multiprocessing Queues are useful here, if limited. Failing that, make more processes and use an rpc system.<p>&gt; typing as second-class citizens<p>The annotation is under developed. being reliant on dataclass libraries to enforce typing is a bit poop.<p>&gt; People stuck in sprawling enterprise codebases, with O(million) lines of code to wrangle, seem almost universally miserable with the language.<p>I work with a _massive_ monorepo. Python isn&#x27;t the problem, its programmer being &quot;clever&quot; or making needless abstractions of abstractions. None of that is python&#x27;s issues, its egotistical programmer not wanting to read other people&#x27;s (un documented) code. And not wanting to spend time make other people&#x27;s code better.')