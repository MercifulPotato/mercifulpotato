Item(by='rattray', descendants=None, kids=None, score=None, time=1604762272, title=None, item_type='comment', url=None, parent=25015437, text='&gt; Client side caching with a normalized cache implementation is very hard to get right<p>Absolutely true! When I worked on this at $prevCo, it was tricky and sometimes caused bugs, unexpected behavior, and confused colleagues.<p>I will say that a proper implementation of a normalized cache on the client must have an ~inherent (thus generated) understanding of the object graph. It also must provide simple control of &quot;whether to cache&quot; at each request. Most of the problems we experienced were a result of the first constraint not being fully satisfied.<p>My impression is that Apollo does a good job on both of these but I haven&#x27;t used it so I can&#x27;t say.<p>I&#x27;ll also note that the approach of &quot;when one component makes an update, tell all other components on the page to refetch&quot; sounds like a recipe for problems too – excess server&#x2F;db load, unrelated data changing in front of users&#x27; eyes (and weird hacks to prevent this), etc.<p>Of course, with the wundergraph architecture, it sounds like answer to these questions would simply be to load a given table only once per page – which means no more defining queries on the &quot;panel&quot; components in the dashboard, for example.<p>All tricky tradeoffs! The right answer depends on what you&#x27;re building. The Wundergraph approach sounds pretty cool for a lot of cases!')