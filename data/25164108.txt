Item(by='jcranmer', descendants=None, kids=[25165601], score=None, time=1605901523, title=None, item_type='comment', url=None, parent=25163838, text='Personally, I think the RISC&#x2F;CISC &quot;question&quot; isn&#x27;t really meaningful anymore, and it&#x27;s not the right lens with which to compare modern architectures. Partially, this is because the modern prototypes of RISC and CISC--ARM&#x2F;AArch64 and x86-64, respectively--show a lot more convergent evolution and blurriness than the architectures at the time the terms were first coined.<p>Instead, the real question is microarchitectural. First, what are the actual capabilities of your ALUs, how are they pipelined, and how many of them are there? Next, how good are you at moving stuff into and out of them--the memory subsystem, branch prediction, reorder buffers, register renaming, etc. The ISA only matters insofar as it controls how well you can dispatch into your microarchitecture.<p>It&#x27;s important to note how many of the RISC ideas <i>haven&#x27;t</i> caught on. The actual &quot;small&quot; part of the instruction set, for example, is discarded by modern architectures (bring on the MUL and DIV instructions!). Designing your ISA to let you avoid pipeline complexity (e.g., branch slots) also fell out of favor. The general notion of &quot;let&#x27;s push hardware complexity to the compiler&quot; tends to fail because it turns out that hardware complexity lets you take advantage of dynamic opportunities that the compiler fundamentally cannot do statically.<p>The RISC&#x2F;CISC framing of the debate is unhelpful in that it draws people&#x27;s attention to rather more superficial aspects of processor design instead of the aspects that matter more for performance.')