Item(by='danielheath', descendants=None, kids=None, score=None, time=1607052826, title=None, item_type='comment', url=None, parent=25295197, text='&gt; If I make the change in code, I can roll it out, test it in prod, and then slowly migrate traffic over in very standard and well defined ways.<p>Advanced methods (like blue&#x2F;green deploys) are invented by people with high-traffic requirements and slowly filter down to everyone else until they are normal practice. 15 years ago server configurations were ordinarily painstakingly handcrafted and somewhat unique.<p>We can reimagine those techniques around a database without <i>too</i> much difficulty.<p>&gt; You can have a bunch of servers, you really only can have one database. This means the database should be very sensitive to changes because it&#x27;s a single point of failure. I don&#x27;t like modifying or changing single points of failure without very good and well tested reasons.<p>This is a strong argument; I agree that very good reasons are required. I have seen scenarios where the reasons are IMO quite good, but agree this isn&#x27;t a widely-applicable technique.<p>&gt; Could you version your procs and have the new version of the code call the new procs? Sure, but now you have to manage deployment of both a service, and the database, and have to handle rollover and&#x2F;or A&#x2F;B for both. If my logic is in there service, I only have to worry about rolling back the service.<p>It has become common to have (and version&#x2F;rollback&#x2F;etc) each of web-frontend, web-backend code, web-backend engine, database schema, database engine.<p>Cutting that back to web-frontend, database http plugin, database schema &amp; database engine is IMO a plausible win some of the time.<p>I&#x27;ve been noodling around for awhile with the concept of a precompiler for stored procedures which alters their names to include a hash of their code.<p>This would give you a safe way to seat multiple versions alongside one another.<p>* The frontend build process would pull in the hashes so it knew which version to call\n * A cron-job could delete the old ones once they&#x27;re (manually marked?) no longer in use - this would be the most hairy bit since it&#x27;s got to be 100% sure it&#x27;s not in use anymore.<p>Rolling back then constitutes putting the old version of the frontend live so it&#x27;ll refer to the previous stored procedures.')