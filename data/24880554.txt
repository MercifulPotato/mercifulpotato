Item(by='formerly_proven', descendants=None, kids=[24880960, 24881921, 24880732], score=None, time=1603559891, title=None, item_type='comment', url=None, parent=24880390, text='zmq is &quot;a better socket()&quot;, but unlike sockets it&#x27;s pretty hard to figure out what&#x27;s going on. E.g. most (all?) socket types don&#x27;t need the other side to be immediately available, it&#x27;ll buffer a couple thousand or so messages and start blocking if it doesn&#x27;t appear. From the app&#x27;s point of view, everything seems fine until the queues are full (which you can&#x27;t introspect, btw.) when suddenly everything starts blocking.<p>It does bring some nice things to the table, but using it has always felt at least a little bit &quot;weird&quot; to me. The docs are a little weird, and there are random caveats sprinkled around the library (e.g. you don&#x27;t need to synchronize the startup of dependent services like described above, unless you were using certain transports in older versions and so on).<p>It used to be marketed somewhat towards developing multi-threaded applications, but it was always rather unclear what exactly the advantage of using, for example, the comparatively slow PUSH&#x2F;PULL socket (ipc:&#x2F;&#x2F; are pipes) over a MPMC (or as needed) queue ought to be.<p>It is also marketed towards resilient distributed apps, but, perhaps I was holding it wrong, but it&#x27;d always behave much like TCP and stuff like REQ&#x2F;REP would pretty much always block forever if the peer goes away, while stuff like PUSH&#x2F;PULL isn&#x27;t reliable when peers go away, so for a distributed app these can&#x27;t really be used anyway. So for this use case it always seemed rather too low-level and its guarantees too weak &#x2F; non-applicable.')