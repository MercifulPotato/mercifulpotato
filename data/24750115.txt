Item(by='phillipcarter', descendants=None, kids=None, score=None, time=1602460088, title=None, item_type='comment', url=None, parent=24748550, text='&gt; Not sure what you mean<p>I work with the C#&#x2F;VB codebase for my job (at Microsoft on compilers and language tooling) and with the compiler and tooling engineers who also use this codebase. It uses nearly everything under the sun, but is most definitely based on immutable data representations at many layers of its &quot;stack&quot;. The very notion of a compilation and a syntax tree are immutable.<p>&gt; Of course immutable data structures, like training wheels, make some things easier. You don&#x27;t have to worry about certain classes of errors, because they just can&#x27;t happen. It&#x27;s the same with garbage collection, you can stop worrying about managing memory, for the most part.<p>I know. I work on a language that is immutable by default.<p>&gt; However, if you can&#x27;t do your job without these helpers at all, that&#x27;s going to be a problem. At some point, there will be something that your garbage collector can not clean up for you. There will be state that is going to be mutated, whether you like it or not. Your brain should be prepared for that.<p>It&#x27;s not quite how you characterized it, but yes there are circumstances where a &quot;mutable core&quot; or even just a mutable domain make sense. Usually it&#x27;s related to performance. The GC &quot;not cleaning things&quot; doesn&#x27;t really have much to do about that though. You can create all kinds of mutable data (e.g., very large arrays) that the GC won&#x27;t clean as a part of a gen0 collection.')