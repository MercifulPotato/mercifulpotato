Item(by='chrisseaton', descendants=None, kids=[24852938], score=None, time=1603312126, title=None, item_type='comment', url=None, parent=24851729, text='&gt; I&#x27;m definitely interested in the subject though if you&#x27;ve got some good reading material?<p>My PhD&#x27;s a good starting point on this subject <a href="https:&#x2F;&#x2F;chrisseaton.com&#x2F;phd&#x2F;" rel="nofollow">https:&#x2F;&#x2F;chrisseaton.com&#x2F;phd&#x2F;</a>, or I maintain <a href="https:&#x2F;&#x2F;rubybib.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rubybib.org&#x2F;</a>.<p>&gt; This really surprised me. Completely eliminated? I&#x27;m really curious how this is possible. Do you have any links explaining this?<p>Through dynamic deoptimisation. Instead of checking if a method has been redefined... turn it on its head. Assume it has not (so machine code is literally exactly the same as if monkey patching was not possible), and get threads that want to monkey patch to stop other threads and tell them to start checking for redefined methods.<p>This is a great example because people said &#x27;surely... surely... there will always be some overhead to check for monkey patching - no possible way to solve this can&#x27;t be done&#x27; until people found the result already in the literature that solves it.<p>As long as you are not redefining methods in your fast path... it&#x27;s <i>literally exactly the same machine code as if monkey patching was not possible</i>.<p><a href="https:&#x2F;&#x2F;chrisseaton.com&#x2F;truffleruby&#x2F;deoptimizing&#x2F;" rel="nofollow">https:&#x2F;&#x2F;chrisseaton.com&#x2F;truffleruby&#x2F;deoptimizing&#x2F;</a>')