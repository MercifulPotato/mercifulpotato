Item(by='cxr', descendants=None, kids=None, score=None, time=1611357454, title=None, item_type='comment', url=None, parent=25877263, text='FP comes with the same jungle, especially if you consider that when most people talk about FP, they&#x27;re allowing for closures.  Even if you don&#x27;t, though, and you do only have pure functions, it&#x27;s a similar bog.<p>Consider a function f that itself relies on being able to call function g.  In FP, you have to either bind by name, which introduces coupling on par with OO (&quot;the jungle&quot;), or you make it parametric, so f doesn&#x27;t know anything about g per se, but <i>somebody</i> doesâ€•perhaps f&#x27;s caller, or its caller, etc.  OO is parametric, too, but in that case they live as slots on the objects, rather than being passed as arguments.<p>People can try to <i>squidge</i> this end of the problem and find that it <i>shquoshes</i> up on the other side, or vice versa.  There&#x27;s no real escape from the problem of dealing with state.<p>Probably the real silver bullet boost to productivity will come when we adapt program execution environments to our dumb brains by way of VR.  Think of something like a cellular automaton such as von Neumann&#x27;s universal constructor:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Von_Neumann_universal_constructor#&#x2F;media&#x2F;File:Nobili_Pesavento_2reps.png" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Von_Neumann_universal_construc...</a><p>... only in 3 dimensions.  When we want to debug a program, we project it into a 3-dimensional space, and we trace its execution the way you can look at something progressing through the assembly line on a shop floor, with pieces that you can reach out and touch, and even pick them up and mark some with blue dots and some without, etc.  That looks a lot more like OO than FP.')