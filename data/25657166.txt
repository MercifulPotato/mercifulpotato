Item(by='YeGoblynQueenne', descendants=None, kids=None, score=None, time=1609936754, title=None, item_type='comment', url=None, parent=25655004, text='&gt;&gt; Many predicates are non-terminating or extremely inefficient when faced with goal inversion, but are often &#x27;fixed&#x27; by simply reversing the order of some of its rules (but making it useless in the original direction in the process). This is disappointing when trying to maximize prolog&#x27;s biggest potential: building true total relations that can project in any direction with a single definition.<p>I don&#x27;t think that&#x27;s a commonly agreed-upon &quot;biggest potential&quot; of Prolog. Prolog is a general-purpose language with the syntax and the semantics of the first-order predicate calculus, albeit limited to Horn clauses and with many other restrictions that are necessary to make for a language that can be used in the real world, for real programming tasks.<p>I cannot easily think of an example where changing the order of clauses (not &quot;goals&quot;) in a predicate definition prevents the program from &quot;runnign backwards&quot;. For example, take the typical append&#x2F;3 predicate:<p><pre><code>  append([],Zs,Zs).\n  append([X|Xs],Ys,[X|Zs]):-\n        fappend(Xs,Ys,Zs).\n</code></pre>\nMoving the first clause, append([],Zs,Zs), after the second, still allows three calling modes:<p><pre><code>  ?- fappend([a,b],[c,d],Xs).\n  Xs = [a, b, c, d].\n  \n  ?- fappend([a,b],Xs,[a,b,c,d]).\n  Xs = [c, d].\n  \n  ?- fappend(Xs,[c,d],[a,b,c,d]).\n  Xs = [a, b] ;\n  false.\n</code></pre>\nAnd complexity does not seem to be affected. Can  you give an example where this is not the case?<p>&gt;&gt; IMO the root of the issue is that prolog has no way to declare a &quot;closed&quot; predicate, and then optimize execution based on their presence. I think cut papers-over (heh) the lack of &quot;closed predicates&quot;.<p>I, like tom_mellor, am also not sure what you mean by &quot;closed predicates&quot;. Could you clarify?')