Item(by='kleiba', descendants=None, kids=None, score=None, time=1601765264, title=None, item_type='comment', url=None, parent=24661231, text='Quite a few comments here already remark on the &quot;computer scientists leaving the room&quot; joke at the beginning of the article.<p>I&#x27;d like to add another computer sciency aspect that hasn&#x27;t been covered yet. If the original question is &quot;what is the fastest algorithm to find the largest number in an unsorted array&quot; you might just answer: &quot;it depends on what you want to do with it afterwards.&quot;<p>Sure, in a job interview or in a computer science class you might want to just look at any one problem independent of anything else. In the real world, context matters though.<p>For example, we know that in an unsorted list (which we&#x27;re dealing with here), an element can be removed by overwriting it with the last element of the list and decrementing the length of the list. So perhaps someone is actually looking at solving a more complex problem, say, processing a list of tasks from highest importance to lowest and removing each task once it has been processed. But they are new to the team, and there is a huge and complicated code base that has been created over years and that they now have to work with. And it just so happens that the actual algorithm is already implemented in the code base, except for one function:<p><pre><code>    while list is not empty:\n        task = find_most_important_task(list) # your TODO\n        process(task)\n        list.remove(task)\n</code></pre>\nNow, this is the same question as in the job interview... or is it? Assuming that find_most_important_task is implemented as a linear search, the above algorithm is O(n^2).<p>However, knowing which task you&#x27;re optimizing for -- that is, the algorithm <i>as a whole</i> -- you can obviously do better. Let&#x27;s say, your list data structure gets a new flag that is true iff the list is sorted. Then you could use the following implementation for the max search:<p><pre><code>    find_most_important_task(list):\n        if list is not sorted:\n            list.sort()\n        return list[list.length - 1]\n</code></pre>\nWith this implementation, a single call to find_most_important_task(list) would be much worse in term of O-notation than linear search: O(nlogn) vs. O(n). However, <i>amortized</i> over the whole algorithm, the complexity of find_most_important_task is actually only O(logn)!<p>So, yeah, I don&#x27;t really know why I wrote all this up. Probably because it is late. Certainly not because it contained anything new. It&#x27;s also contrived. Oh well. Sorry for wasting anyone&#x27;s time...')