Item(by='exhftdev', descendants=None, kids=None, score=None, time=1603750305, title=None, item_type='comment', url=None, parent=24896616, text='I&#x27;ve worked for one of the big trading firms and they used C# including for their ultra-low-latency trading strategies.<p>I&#x27;m a bit surprised by all the chatter about garbage collection because it&#x27;s not as much an issue as it sounds.<p>The thing is not to do allocations (i.e. GC) on the _critical path_.<p>In a trading strategy you react to a stream of market data. It appears constant to the human eye, but in fact it&#x27;s a series of &quot;blips&quot;, sporadic events.<p>When you get a new message you need to react as fast as possible. The fastest code is, of course, no code, so it doesn&#x27;t really matter if it&#x27;s not written in C++, C# or PHP. Here you&#x27;re just going to do the very minimum required. You will find that generally there is no difference in the code compiled whether it&#x27; done by the C# JIT, the Java JIT or a C++ AOT compiler, because the code is simple: you read a few fields from the message and select a pre-computed outcome to decide whether or not to send a (buy|sell) order.<p>Now, after that event has been handled (and perhaps you sent an order), you need to recompute stuff. You generally have plenty of time (a few milliseconds) before the next event arrives, and that&#x27;s where you want to do all your fancy calculations, and here a high-productivity language like Java or C# helps, just because it&#x27;s quicker to iterate and deploy modified trading strategies (typically deployed daily, or at least weekly).<p>Many people assume that you need to do all your fancy calculations very rapidly right after a message arrives. But you don&#x27;t have to because the message is not completely random. The order book is not going to change completely after one message. You can pre-compute a few likely scenarios, and when a message arrives and confirms one of those scenarios, you just mechanically go with the precomputed result.')