Item(by='chriswarbo', descendants=None, kids=None, score=None, time=1604686198, title=None, item_type='comment', url=None, parent=25007095, text='&gt; &#x27;halting&#x27; could have been substitued with &#x27;somewhere in the program variable x gets set to 5&#x27; and you could still construct a program in which it would be impossible to prove whether or not x gets set to 5.<p>Rice&#x27;s theorem extends the Halting Problem in a very general way. The idea is that for any program &#x27;foo&#x27;, we can invent a new program &#x27;bar; foo;&#x27; which will only execute &#x27;foo&#x27; once &#x27;bar&#x27; has halted. Since the halting problem is undecidable in general, and &#x27;bar&#x27; can be any program, it&#x27;s undecidable whether such a program will eventually execute &#x27;foo&#x27;. Any property that depends on whether or not &#x27;foo&#x27; gets executed is hence undecidable.<p><i>However</i>: there are many properties which <i>don&#x27;t</i> depend on whether &#x27;foo&#x27; will eventually be executed. For example &#x27;does this program take more than 1000 steps to halt?&#x27; is decidable, since we can just run the program for up to 1000 steps to see if it halts or not.<p>More subtley, we can check things about the syntax, e.g. &#x27;does this program contain a call to the &quot;LaunchTheMissiles&quot; function?&#x27;. That&#x27;s easy to decide by just looking at all of the tokens in the code. Of course, this doesn&#x27;t tell us whether such a call would ever be reached, e.g. it would flag a program like<p><pre><code>    if (false) {\n      LaunchTheMissiles();\n    } else {\n      ImplementWorldPeace();\n    }\n</code></pre>\nThis program would never launch the missiles, but it&#x27;s often enough to spot <i>potential</i> issues, even if our errors are overly-conservative.<p>Such false-positives can be really annoying when we try to retro-fit such checks on to languages which weren&#x27;t designed for them; e.g. trying to spot pointer errors in C code or potential nulls in Java code. In contrast, designing them into the language from the start can be really useful. For example, that&#x27;s what type systems do. For example, consider the following code:<p><pre><code>    String foo() {\n      if (true) {\n        return &quot;hello&quot;;\n      } else {\n        return 123;\n      }\n    }\n</code></pre>\nThis is perfectly correct, since it claims to return a String and it will return a String. However, every type checker in the world will reject this program due to the mere presence of the &#x27;return 123&#x27; branch.<p>This is quite a common pattern in programming language research: problems which are undecidable in most languages can be made trivial by designing the language with that problem in mind.<p>In this case their &#x27;while&#x27; example in C is very illustrative: there&#x27;s not enough information in the code to know which (if any) of the loop iterations rely on the previous ones having been executed first. The fact that it <i>could</i> rely on execution order means we can&#x27;t safely parallelise it.<p>In contrast, a call like &#x27;map(something, myList)&#x27; implies that each element&#x27;s processing is independent (hence why MapReduce is popular for parallelism!).')