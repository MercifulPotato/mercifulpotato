Item(by='tom_mellior', descendants=None, kids=[24959344], score=None, time=1604236101, title=None, item_type='comment', url=None, parent=24959121, text='&gt; Executing more instructions for a (really) common operation doesn&#x27;t mean an ISA is somehow better designed or &quot;more RISC&quot;, it means it executes more instructions.<p>True. But as bonzini points out (or rather, hints at) in <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24958644" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24958644</a>, the really common operation for array indexing is <i>inside a counted loop</i>, and there the compiler will optimize the address computation and <i>not</i> shift-and-add on every iteration.<p>See <a href="https:&#x2F;&#x2F;gcc.godbolt.org&#x2F;z&#x2F;x5Mr66" rel="nofollow">https:&#x2F;&#x2F;gcc.godbolt.org&#x2F;z&#x2F;x5Mr66</a> for an example:<p><pre><code>    for (int i = 0; i &lt; n; i++) {\n        sum += p[i];\n    }\n</code></pre>\ncompiles to a four-instruction loop on x86-64 (if you convince GCC not to unroll the loop):<p><pre><code>    .L3:\n        addsd   xmm0, QWORD PTR [rdi]\n        add     rdi, 8\n        cmp     rax, rdi\n        jne     .L3\n</code></pre>\nand also to a four-instruction loop on RISC-V:<p><pre><code>    .L3:\n        fld     fa5,0(a0)\n        addi    a0,a0,8\n        fadd.d  fa0,fa0,fa5\n        bne     a5,a0,.L3\n</code></pre>\nThis isn&#x27;t a complete refutation of the author&#x27;s point, but it does mitigate the impact somewhat.')