Item(by='lambda_obrien', descendants=None, kids=[25181022], score=None, time=1606067796, title=None, item_type='comment', url=None, parent=25179116, text='An effects system like this is more about controlling your own code and allowing for switching off implementations easily versus declaring what effects it has. Your declaration of effects on your function is saying, for example, &quot;I need to output some text,&quot; and then in the caller of that function you have to do some action to &quot;consume&quot; that effect. For instance, your example might be an effect called &quot;WriteState&quot; and then you could call that function in a small unit test with a thin layer over a Map, in dev you could call it with a local sqlite db, and in prod you&#x27;d call it with your postgres or whatever. Each implementation shares a common interface, but does something different with the data. If you were writing a library, you&#x27;d give your public API as the base monad of your library, or as IO maybe, or even give a pure API. You should be dealing with the possible failures under that base context and then the user doesn&#x27;t need to know about the inner failures.<p>The effects system <i>effectively</i> acts as an abstraction for some side effect, like an interface, and gets ride of a lot of the boilerplate code needed for mtl or custom transformer stacks.<p>Also, in strict typing it&#x27;s pretty easy to refactor with modern linters and such, it actually makes refactoring an API change delightfully simple, just get rid of the red squiggle lines telling you you types are wrong.')