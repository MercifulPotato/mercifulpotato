Item(by='fwsgonzo', descendants=None, kids=None, score=None, time=1602971314, title=None, item_type='comment', url=None, parent=24813550, text='Well, while an emulator can be anything, it can also be very little. A userspace emulator is one that just loads an ELF binary, provides hooks for system calls, and then just simulates instructions from there. You don&#x27;t technically need to support page protections, but it&#x27;s certainly nice to have and it help you to narrow down problems both inside and outside the guest environment.<p>The riscv-gnu-toolchain does indeed build everything for you, but it has 3 &quot;settings&quot;, so to speak:<p>1. The default is newlib, which is a smaller embedded C-library, but it&#x27;s enough to have most of C and C++ supported. Running &quot;make&quot; or &quot;make newlib&quot; does the same thing.<p>2. &quot;make linux&quot; will build a static glibc, with threads support. I don&#x27;t recommend it, as you will have emulate pthreads, which are very heavy. If you really want threads, I can give you some pointers on how to make your own light-weight ones. And, of course, so can many others.<p>3. &quot;make musl&quot;. Not sure if this works completely, but I do believe it&#x27;s an option. It would have threads too.<p>There is also a more complicated 4th option, which is to use an embedded RISC-V compiler, which you can get from here:<p><pre><code>    $ xpm install --global @xpack-dev-tools&#x2F;riscv-none-embed-gcc@latest\n</code></pre>\nI don&#x27;t recommend it, because it has nothing. You will have to write your entry code and all the libc stuff too. That can be fun, of course. And you get to have really small binaries!<p>My emulator produces debug executables which prints every instruction line by line, and it supports register-dumping too, so it could help you compare for divergences if you are having trouble with some instructions: <a href="https:&#x2F;&#x2F;github.com&#x2F;fwsGonzo&#x2F;libriscv" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;fwsGonzo&#x2F;libriscv</a><p>If you want to emulate an OS you will have to write guest and host drivers (both sides), which is a very complicated thing to do. However, it&#x27;s a perfect opportunity to add the first level of concurrency: Running the host and the guest in separate threads! There is also emulating interrupts, various hardware timers and having a page table in guest memory with protection levels. A lot of work!')