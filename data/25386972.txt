Item(by='derefr', descendants=None, kids=[25405919], score=None, time=1607701513, title=None, item_type='comment', url=None, parent=25383584, text='&gt; In most programming languages you can hand author a value just fine<p>But keep in mind that we’re not <i>inherently</i> talking about programming languages here — nor are we necessarily talking about people capable of programming as our configurators. We’re talking about third-party components that need to be configured by ops people, who <i>may or may not be</i> DevOps people. Usually they’re not — most ops people are just pure ops, and don’t know any programming languages. As well, most amateur integrators (e.g. a person setting up their own blog) aren’t programmers either.<p>The goal of these systems, when choosing a configuration solution, is twofold: to give pure-ops and amateur integrators a config language they can author <i>directly</i>, in a text editor, without learning programming; while also making that language formal&#x2F;structured enough that it’s easy to machine-generate from your programming runtime of choice, if you <i>do</i> have those skills, and a rigorous mindset.<p>Sure, programming languages don’t <i>necessarily</i> require you to use the full-fledged expression syntax they enable, and so can “reduce” to a configuration-language-like subset of themselves.<p>But remember, again — ops people and amateur integrators. What do such people tend to <i>do</i>, to create their config? Read the reference config schema? No. They tend to look up tutorials with samples, or StackOverflow “solutions”, from arbitrary places on the Internet.<p>And what do the creators of those samples have in abundance? Cleverness and a desire for clarity of meaning. Traits that cause them to <i>use</i> the expressive features of whatever the configuration language is, in order to make their answers more “pithy”.<p>Which means that, to wield these “pithy” samples&#x2F;solutions, the ops people and amateur integrators now have to understand how to “patch” one arbitrary piece of complex code into another increasingly-arbitrary piece of complex code.<p>The thing a static data-serialization format gets you, is that the rules for merging any two expression-nodes in it are very simple to learn, because there just aren’t that many types of expressions. There’s no way to be “pithy” with the configuration that requires people to learn entirely-new-to-them syntax.<p>By choosing to configure your system in YAML, you’re guaranteeing that the samples these ops people and amateur integrators find and attempt to glue together, will <i>also</i> just be pure YAML. And since their existing config file, and each new sample, are pure YAML, they’ll likely <i>succeed</i> at doing this gluing-together.<p>Meanwhile, DevOps people and enterprise integrators can create their own programs to generate the YAML — but since there’s no first-party framework for doing this, there won’t be much value in <i>sharing</i> these programs around, and so the samples the pure-ops people and amateur integrators find will never be given “in terms of” writing code for such a framework, but rather only in terms of the config YAML itself.<p>&gt; I think the real issue is reproducibility; and that boils down to purity. [...] If you can rigorously avoid that, there&#x27;s not too much advantage to a static config language.<p>Individual users might be able to rigorously avoid that (though expecting a rigorous approach to formal expression from non-programmers is a bit much.) But often it&#x27;s the <i>system itself</i> that needs purity and reproducibility.<p>Remember, config formats are usually something executed <i>at every startup</i> — in other words, they&#x27;re <i>durable state</i> that happens to be human-modifiable. (Think: the Windows Registry.) As the designer of a system, you don&#x27;t want the same state you serialized today to deserialize to something else tomorrow; and you <i>especially</i> don&#x27;t want the meaning of your state to depend contextually on the environment. You want to &quot;pin down&quot; your state.<p>A good example: programming-language package-ecosystem &quot;lock files.&quot; In most languages, dependency-constraint specification <i>is</i> done in a programming language, such that the generation of those constraint expressions has access Turing-complete features. But once you <i>lock</i> those constraints down to a baked set of choices, the lockfile <i>itself</i> — the predetermined set of choices, that should be environment-independent — is <i>not</i> expressed in a Turing complete language (in any runtime I know of, at least) but rather is always expressed in its own little static declarative language; or at most in a limited &quot;data-expressions only&quot; subset of the parent language (e.g. Erlang&#x27;s `file:consult&#x2F;1` format.)<p>In this case, dep-constraints are the inputs to a config-generator program; while the lockfile is the config format itself. The config format is a <i>necessary</i> intermediate here; it&#x27;d be impossible for the runtime to make the same static guarantees about package management if it wasn&#x27;t! (In fact, see e.g. Python&#x27;s setup.py, where exactly that problem stymies any package-manager the Python ecosystem introduces from pre-determining dependency graphs before actually downloading and attempting installation of the dependencies.)')