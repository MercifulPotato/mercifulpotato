Item(by='Animats', descendants=None, kids=[25389760, 25389748, 25389845, 25398549, 25398273, 25391363, 25389835], score=None, time=1607714159, title=None, item_type='comment', url=None, parent=25386971, text='I kind of get that feeling, too.<p>Rust uses &quot;traits&quot; to do both generic-like things and inheritance-like things. It&#x27;s not clear this was a win. The result seems to be a system which does both badly.<p>Rust generics are very restrictive. They&#x27;re not at all like C++ generics. It&#x27;s not enough that every operation on a type needed by a generic be implemented. The type has to be part of a single trait that provides for all those operations. It&#x27;s like C++ subclassing. So generics over types defined by others can be impossible to write in Rust. This has no safety benefit, since generics are resolved at compile time and all safety tests can be made after generic expansion.<p>Traits and fixed array bounds do not play well together. This is considered a bug, and it&#x27;s been a bug since at least 2017. Generic parameters can only be types, not numbers. This led to a horrible hack involving a Rust crate which has types U1, U2... U50 or so, so small numeric constants can be bashed through the Rust type system.<p>Not seeing the benefit of all this.<p>I have to go struggle with another non-helpful &quot;lifetime `&#x27;static` required&quot; message from the borrow checker now.')