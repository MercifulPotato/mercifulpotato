Item(by='saurik', descendants=None, kids=None, score=None, time=1611236163, title=None, item_type='comment', url=None, parent=25858518, text='I just did some digging, and the Python 3 built-in HTTP stuff seems to represent HTTP headers using a reasonably-comprehensive mechanism that is shared with MIME parsing and the various IMF semantics, and so I am pretty sure you end up getting back an object of type email.header.Header (but I might have misunderstood the documentation just now... I mostly gave up on Python when they moved to Python 3 so I haven&#x27;t experienced this first hand).<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;email.header.html#email.header.Header" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;email.header.html#email.he...</a><p>This actually looks like a really solid implementation--like, I am super impressed by this (though watch it suck... everything sucks ;P)--as it doesn&#x27;t assume any ability to flatten the result! That said, I am also deeply concerned that this might pre-decode something that should <i>actually</i> be in ASCII all the way down from MIME (which, notably, is complex enough of a format to include support for embedded comments). I kind of want to do some auditing here, to make sure there aren&#x27;t some parser discrepancy vulnerabilities in common Python HTTP frameworks ;P.<p>But like, I think this object represents a <i>sequence</i> of strings each with its own encoding, allowing it to &quot;Q&quot; encode the result exactly as specified (and correctly round trip something it parsed, which still does feel a tad dangerous, and maybe the API lets you avoid it in those cases). It then has an __str__ implementation (to let you use it as a string) that explicitly claims to return an &quot;approximation&quot; of the header (which may or may not be a safe thing to use in different circumstances; but like, that in some sense isn&#x27;t the API&#x27;s fault?...).')