Item(by='Twisol', descendants=None, kids=[25575800], score=None, time=1609278290, title=None, item_type='comment', url=None, parent=25570163, text='Whilst trying to avoid the &quot;No True Scotsman&quot; fallacy, I&#x27;d argue that this system is FP only in name, but not in spirit. Even in Haskell, you can spend all your time in the IO monad and use IORefs as shared mutable cells, but you&#x27;d have a hard time arguing that such code is &quot;functional&quot;.<p>&gt; It&#x27;s hidden, and, when it&#x27;s being done in the context of a generally functional idiom, it&#x27;s downright pernicious.<p>I think what we&#x27;re seeing is a distinction between _syntactically FP_ and _semantically FP_ qualities. It&#x27;s easy to apply _syntactic_ idioms obtained from FP, as it allows you to avoid and reduce state wherever possible. However, in a language where mutable state is assumed, and it&#x27;s your responsibility to not use it, you don&#x27;t get the _semantic_ guarantees about the behavior of your program.<p>I don&#x27;t like having to exercise discipline, because no matter how good I am at it, I&#x27;m only a temporary part of any software system. IMHO, the fundamental goal of software architecture is to institute bias directly into a codebase to support the problem domain. The way in which you work with a codebase is informed by how that codebase wants you to work with it: you&#x27;ll naturally avoid things that are made difficult to do, and prefer things that are made easier to do.<p>Programming languages are essentially the basement level of any given architecture, because it is nearly impossible to override the decisions your language makes for you. It is almost always going to be easier to use what the language provides you, and if the language provides global mutable state, it will always be tempting to couple two otherwise separate regions of your codebase by a mutable cell. Some languages especially make FP idioms difficult (hi, Java), so you end up fighting an uphill battle -- unwinnable if you&#x27;re not extraordinarily careful.<p>&gt; There will always be some business constraint that prompts people to take shortcuts.<p>To borrow a phrase, I don&#x27;t think FP can &quot;win&quot; until we deal with the forces that make mutable cells such an attractive choice. There are multiple facets to the problem; it&#x27;s not enough to just pick languages that make FP the easier option (or mutable shared state the harder option). IMO, we need to have an industrial expectation of domain modeling, and architect our systems specifically with our problem domain in mind, so that problems in that domain -- and expected evolution in that domain -- can be handled not only easily, but <i>intuitively</i> within the set architecture. (Lispers go wild over defining their own language within Lisp for exactly this reason -- but all things in moderation.)')