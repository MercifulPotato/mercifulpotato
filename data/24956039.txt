Item(by='nendroid', descendants=None, kids=[24970567, 24960274], score=None, time=1604186376, title=None, item_type='comment', url=None, parent=24953440, text='Not all aspects of programming can be described by math.<p>Mutations and IO are very critical parts of programming and the two areas where FP breaks down. Even the IO Monad leaks the imperative nature of the program over to the programmer.<p>The only way pure FP can sort of work is if there are heavy frameworks abstracting IO and mutation away from the programmer. If you&#x27;re not doing IO or mutating something then your caching framework, database or Haskell runtime is doing it for you. Additionally like I said earlier, Even if your database is handling mutation for you, you still end up embedding mutation commands into the strings of your pure FP function. Updating a database in haskell still necitates the haskell user to place the mutation command in a SQL string.<p>My point is, that math is not the complete solution to the programming problem. What FP allows the programmer to do is to use the framework to segregate combinatorial logic away from mutation and IO. Your combinators will always be more composeable and modular but your IO and mutation functions will be less modular but they still have to exist.')