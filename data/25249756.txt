Item(by='temac', descendants=None, kids=[25249829], score=None, time=1606698544, title=None, item_type='comment', url=None, parent=25249262, text='There are tons of programs that do not go through &quot;the&quot; libc under Linux, everybody and their dogs seem to reimplement their own locks recently for example. Plus the libc actually makes a way greater surface to cover given it gives you access to most of the syscall plus other functions.<p>Plus you still want all the fine semantics of Linux (mmap, cow or at least cow-like, etc.) and for tons of calls the libc is a trivial layer anyway, so you are not gaining much. The layout of processes also. At this point you are back to a big part of picoprocesses again, because you don&#x27;t want the classic NT layout, nor cb to userspaces, etc.<p>Maybe would have been more of a practical idea for a BSD, but even then the remark about the surface of the libc API vs syscalls apply.<p>But Linux has a stable API, so it does not make much sense to do Linux compat without re-implementing it and given you can do just that, well do just that.<p>And you rightly note at the end that syscall support is needed, but at this point the whole architecture would have made absolutely no sense: if you are going to implement syscall eventually, just implement them in the first place, and not <i>more</i> code.<p>Also I doubt the only issues of WSL1 were performance. I doubt they would have been able to follow the upstream quickly enough, at least not without a pretty big <i>dedicated</i> team, and it seems difficult to justify. The WSL2 approach leverages techs that are used for many other things.')