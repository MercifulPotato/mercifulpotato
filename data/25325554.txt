Item(by='dragontamer', descendants=None, kids=None, score=None, time=1607280338, title=None, item_type='comment', url=None, parent=25325004, text='Binary decision trees are basically super optimizers: minimizing the number of gates needed to make a Chip&#x27;s logic (multiply circuits or whatever)<p>&gt; Sure, and unbreakable crypto is notoriously difficult to make<p>Not really. It&#x27;s the unbreakable AND efficient requirement combined that&#x27;s hard.<p>Just run anything over a random xor shift add kernel about 1 million times and it&#x27;s unbreakable (so long as xor &#x2F; shift forms a bijection). It&#x27;s just inefficient.<p>Finding the smallest number of iterations that works is the hard part. Usually, people try to break it (ex, AES was originally broken over 4 iterations) then double or triple your best attempt, and you are set.<p>AES is now broken over 5 iterations IIRC, but still a long way to go to break full 8 iteration AES.<p>More modern ciphers (SHA512) are like 80 iterations of a simpler kernel.<p>Even &#x27;broken&#x27; ciphers like TEA or RC4 are hard to break in practice if you just increase the iteration count up the wazzoo. The problem is: AES gets to security in just 8 iterations.<p>So to be better than AES requires both efficiency AND security. After all, 100 iterations of AES is going to be more secure if you don&#x27;t care about efficiency. (10x more iterations than the default spec)')