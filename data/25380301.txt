Item(by='tptacek', descendants=None, kids=[25382544, 25382508], score=None, time=1607643534, title=None, item_type='comment', url=None, parent=25380003, text='My feeling is that Malone has misconstrued a bunch of Colm MacCárthaigh&#x27;s arguments. I will now do the same thing, by attempting to summarize MacCárthaigh&#x27;s arguments myself.<p>First: TLS (and mTLS) create secure channels. A channel bears many requests and responses. In many designs, a single channel will bear requests for many different users. The job of a textbook secure channel is to prevent an attacker with control of the underlying network from tampering with requests and responses. Binding identities and authorization claims to requests is a different job. The textbook solution to that problem is authenticated requests, not authenticated secure channels. I wouldn&#x27;t have used the word &quot;layering violation&quot;, which I would contend Is Not A Thing, but the point MacCárthaigh makes is important. So: when MacCárthaigh says SQLI and Request Smuggling are &quot;still things&quot;, he&#x27;s not saying that mTLS introduces SQLI, but rather that authenticating at the level of secure channels means that a request smuggling attack is almost automatically a game-over for your application, because you aren&#x27;t authenticating the requests independently of the channel. Even Basic Auth can potentially avoid that problem, if an attacker has to know a secret to slip into a request in order to forge a request on a compromised channel.<p>Second: TLS was designed for the WebPKI, and that&#x27;s its most important application. A consequence of this is that a lot of TLS software is designed for WebPKI threat models. Like everything else the IETF produces, TLS has features that support a lot of other applications, like using heartbeat messages to debug remote processes. But what matters in the real world is the installed base of TLS software, and that installed base does not have sane defaults and safe ergonomics for mTLS. You have to be extra careful rolling it out that way.<p>Third: TLS is built on X.509, and X.509 is extremely complex and error prone. This complexity is deceptive, because we&#x27;ve spent 20 years filing down the complexity of X.509 in the WebPKI deployment mode, and developers mostly don&#x27;t have to care about anything except the filenames for their certificates and keys. That&#x27;s out the window with mTLS, where peers actually have to crack open certificates and look at them to accomplish authn and authz tasks.<p>Fourth: Revocation is a debacle. It&#x27;s a debacle everywhere, but TLS complexifies it, because it has to work at Internet scale. If you&#x27;re managing a fleet for even a large, complex application, you have recourse to designs that make revocation easier to handle.<p>Fifth: Fleet-wide credential rotation is much harder in mTLS than it is in simpler systems, where the root of trust might just be a simple secret you can quickly load on to a given machine and tabletop how to do a fleetwide deployment in a quick meeting. You can add mechanism to automate certificate issuance, but those systems have to be resilient to the total loss of the root of trust, which is something the TLS ecosystem is not generally good at; the WebPKI could suffer a total loss of all trust roots if we broke RSA, but not so much if we just broke OpenSSL.<p>Sixth: The standard modern solution to revocation, short-lifetime certificates, also relies on secure clocks. Breaking clocks Internet-wide might be difficult enough to be outside a reasonable threat model, but breaking clocks in a single data center is not.<p>Seventh: To make short-expiry work in a setting where a compromised certificate isn&#x27;t just a potential coffee shop MITM for a subset of your users but instead a game-over compromise for the entire application, you might need lifetimes so short they&#x27;re hard to operationalize without outages. Part of what we like about public key authentication schemes is that they don&#x27;t require continuous access to a central trusted authority just to keep the system up and running!<p>Eighth: Serious applications want queryable audit trails for inter-service RPCs, which means having ready, often indexed access to principals and roles asserted by credentials. With expansive mTLS designs, this stuff is buried in X.509 certificates, which creates friction to getting these features built; even applications built on simple bearer tokens often do a bad job of getting this right, and adding friction just makes it harder.<p>Finally: If you&#x27;re authenticating and authorizing requests, you want a consistent, preferably rigid structure for expressing claims. X.509 provides you nothing here you&#x27;d ever want to use; instead, you&#x27;re going to slip comma-separated lists into string fields, and then build ad hoc tools to grovel the information you need out of them. You can do this consistently if you (a) build everything in the same language and (b) get everyone to use the same authentication and authorization code paths (as a software security auditor: good luck with that), but you&#x27;re boned as soon as your mostly-Python application introduces a Rust component.<p>I could rebut Malone&#x27;s post point-by-point (for instance: totally unclear to me how a hello-world example of the most simplified APIs a library provides for handling certificates addressing the huge complexity of X.509), but I&#x27;m not yet sure I need to; I think a fuller recitation of what MacCárthaigh was trying to say does a better job.<p>I will say that I&#x27;m actually not an mTLS opponent. As I recall, Colm&#x27;s thread was prompted in part by a draft of my &quot;Child&#x27;s Garden of Inter-Service Authentication Schemes&quot; post, which was mostly motivated by hatred of JWT and originally spoke warmly about mTLS. And I still like mTLS just fine --- for simple network topologies and trust models that are flat and uniform at the network layer. By all means, use mTLS to make sure only real apps in your environment can talk to Consul, and to make it harder to SSRF things. But be wary about asking it to do more than it&#x27;s good at.<p>I await Colm&#x27;s savaging of my attempt to say in 489479837 words what his short Twitter thread did a better job of communicating.')