Item(by='jlokier', descendants=None, kids=None, score=None, time=1601667690, title=None, item_type='comment', url=None, parent=24665711, text='I think you and I are agreeing, but it&#x27;s not obvious ;-)<p>&gt; However system B might take longer to flush it&#x27;s hardware&#x2F;software buffer and the message arrives at mc before message A, for example.<p>There are two message As in your system, the one sent to system b, and the one consumed by hardware mc.  Let&#x27;s call them Ab and Amc.<p>In that situation, message B is a consequence of message Ab <i>which can be tracked</i>, and at system mc (depending on semantics) it might be necessary to use that tracking to process message Amc before message B, at least logically.<p>For example message Ab&#x2F;Amc might be &quot;add new user Foo the our database with standard policy&quot;, and system B might react with &quot;ok, my job is to set the policy for new users, I&#x27;ll tell mc to add permission Bar to user Foo then activate Foo&quot;.<p>That works out fine as long as the logical order relation is maintained, and system mc, the database, processes message Amc first, regardless of arrival order.<p>Dependency tracking can ensure that (without clocks or timestamps), even if messages are transmitted independently.  For example by message B containing a header that says it comes logically after message A.<p>The pubsub queue can also guarantee that order (without clocks or timestamps or dependency tracking), provided all messages go through the same pubsub system, and Ab+Amc are fanned-out by the pubsub system rather than sent independently by A to each destination.  All bets are off if Ab and Amc take other routes.<p>&gt; If you are consuming from sources which you cannot control the accuracy of the clocks, then you must inherently either reduce your reliance on the need for accuracy (many Windows systems have horrendous clock discipline in their software implementation) or find a way of ensuring accuracy. E.g. close proximity NTP or close proximity PTP etc etc.<p>If you think Windows is bad, try just about any cloud VM, which has a virtual clock and is stalled all the time in the guest, including just after the guest reads its virtual clock and before using the value :-)<p>I prefer systems which rely on logical ordering guarantees as much as possible, so clock drift doesn&#x27;t matter.<p>When you are rely on a global clock order to ensure correct behaviour, you have to slow down some operations to accommodate for clock variance across the system, as well as network latency variance (because it affects clock synchronisation).<p>If you rely on logical order, then there&#x27;s no need for time delays; no upper speed limit. Instead you have to keep track of dependencies, or have implicit causal dependencies. And it&#x27;s more robust on real systems because clock drift and jumps don&#x27;t matter.<p>In practice you need some clock dependence for timeouts anyway, and there are protocol advantages when you can depend on a well synchronised clock.  So I prefer to mix the two for different layers of the protocol, to get advantages of both.  Unfortunately for correct behaviour, timeouts are often the &quot;edge case&quot; that isn&#x27;t well tested or correctly implemented at endpoints.')