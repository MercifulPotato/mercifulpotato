Item(by='lambda_obrien', descendants=None, kids=None, score=None, time=1606766662, title=None, item_type='comment', url=None, parent=25256956, text='Excellent! I think that&#x27;s exactly what I was looking for! Thank you so much for going into detail on that, it helped immensely.<p>I have a similar problem (though can&#x27;t talk too many details) with discrete &quot;ticks&quot; and with a constrained CPU (a peak constraint, I have plenty of aggregate CPU power over time). I think I could fit some simple version of the symbolic module optimizer algorithm like you describe into the unused CPU time to optimize the spiky algorithm before I receive events (the events are spread apart pretty good) to return more accurate and timelier results when they do come. I am using a Haskell-like language for this that compiles to a binary format with a similar graph reduction scheme for the compiler as you describe for the symbolic reducer, so it should be very simple for me to compose the modules as you describe.<p>The problem I have now is that when I need to calculate something that&#x27;s very-high-priority (some events have hard deadlines), I would like to have a more optimized algorithm, but I don&#x27;t have time to optimize it on the fly from the information I know (my knowledge is continuous, only the events are discrete), so I have to use less-accurate results or sometimes I don&#x27;t have an answer so I just return a &quot;no answer&quot; response and the process fails. I tried using some crappy default values, but it would still fail most of the time.<p>I think about my problem like a process which has a target and my answer is the &quot;direction to aim at&quot; for the process and so if I return a bad result to this process it&#x27;ll just miss the target, so I just say &quot;sorry, can&#x27;t aim right now, wait 1 more tick&quot; and I then am able to start a calculation for the next round before the process even asks for it and it finishes easily this time, since my events have a low frequency. Using an optimal algorithm (which I can get from a symbolic reduction: that&#x27;s how I did it--by hand--in the first place to get my current algos) will <i>always</i> return the answer in time, based on my models and experiments.')