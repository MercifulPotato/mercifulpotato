Item(by='nendroid', descendants=None, kids=[24956104], score=None, time=1604184842, title=None, item_type='comment', url=None, parent=24955526, text='So you like writing functions that take 3 functions as input parameters and returns a new function that also takes a function as an input parameter and returns another function? In general excessive use of this at great depth leads to code that is not only less readable but less modular.<p>The complexity of higher order functions can easily be reasoned about by looking at the cardinality of the type. Sum types and product types are standard and easy to reason about.<p>However an exponential type that takes in an exponential type and returns another exponential type leads to cardinalities and possibilities that are much harder to reason about.<p>Composition of combinators is a pattern promoted by point free programming that leads not only to higher readability but greater modularity due to the reduced cardinality. Additionally cardinality of the entire type can he reduced to only analyzing the the final result of the composition.<p><pre><code>  F = A . B . C \n</code></pre>\nThe cardinality of F is all that needs to be known. The cardinality of the individual components can be ignored and you don&#x27;t have to reason about this. This is not the case for higher order functions.<p>In general business problems that we deal with do not Require higher order functions. Higher order functions share isomorphisms with two concepts we are already familiar with: frameworks and metaprogramming.<p>Frameworks are programs that call your code and metaprogramming is code that writes and calls code. These things are no different then a function that takes another function in as a parameter and calls it. All three concepts are aspects of the same thing.<p>Therefore all the downsides of metaprogramming and all the downsides of frameworks are applicable to higher order functions.<p>Most of the programming problems we solve in the real world do not require metaprogramming. It can easily be avoided and solved with much more composition of combinators. Again, not saying to avoid the usage completely but the usage of higher order functions like metaprogramming should be minimal and used sparingly.')