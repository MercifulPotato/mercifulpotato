Item(by='jlokier', descendants=None, kids=None, score=None, time=1604801784, title=None, item_type='comment', url=None, parent=25020758, text='&gt; the cost of JIT time is usually consider with end user performance in mind.<p>Indeed it is.  I know that (very well), I guess I didn&#x27;t phrase my comment well though.<p>The article points out that a &quot;const&quot; variable access is faster than a &quot;let&quot; variable access due to removal of certain run time checks in the JIT-generated code.<p>The per-statement cost of lexing, parsing, analysing, and code-generating for each statement of the JavaScript source is far, far greater than the cost of actually executing the generated code for a &quot;const&quot; or &quot;let&quot; variable access.<p>So much so, that if the generated variable access was run as a one-off, the speed difference would be undetectable.<p>So the only way for there to be an end-user visible difference in speed between &quot;const&quot; and &quot;let&quot; is in code where the JIT-code-generated variable accesses are run many times repeatedly.<p>The time to perform &quot;is the &#x27;let&#x27; variable assigned to&quot; is part of the one-off checks, not the repeated executions.  Since we&#x27;re also talking about &quot;optimised code&quot; not &quot;unoptimised code&quot; from the JIT, it&#x27;s also a tiny amount of time compared with most other things done by the optimiser.  It is literally a boolean flag, false by default, set true if any assignment to the variable is seen when parsing or optimising.  And &quot;optimised code&quot; is only produced for code that is run many times.<p>So technically, yes, the check would technically take end user-visible time.  But only in situations where there is another end user-visible time which dominates over it (the slowdown of &quot;let&quot; versus &quot;const&quot; variable accesses done repeatedly), and which the check is intended to remove.  Thus you could say, the check&#x27;s time would be cancelled out.<p>(It&#x27;s a little bit like comparing the O(1) parts of an algorithm with the O(N) parts, when you have been told that N is significant.  If you can do something to reduce the O(N) constant factors and it costs O(1) to do, it&#x27;s a net speedup for sufficiently large N.)')