Item(by='hwayne', descendants=None, kids=None, score=None, time=1604335600, title=None, item_type='comment', url=None, parent=24966154, text='&gt; is supposed to mean exactly. If your predicate makes some data invalid, it&#x27;s just not representable in the refined type.<p>Author here. It&#x27;s representable; the type checker has to prove it never happens in practice. This requires very different techniques from typechecking constructive types. Liquid Haskell shells out to Z3, which can return &quot;unknown&quot; as an answer in addition to &quot;sat&quot; or &quot;unsat&quot;.<p>(There&#x27;s actually a fourth option, which is that Z3 runs forever, but I think LH does a bunch of clever design to avoid that case.)<p>You can also `assume` that refinements are satisfied without proving them, in which case they can be violated at runtime. This would be impossible if the invalid data was unrepresentable.<p>Other approaches to refinement types, such as the original ML paper [0], implemented them constructively and didn&#x27;t have this problem.<p>[0]: <a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~fp&#x2F;papers&#x2F;pldi91.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~fp&#x2F;papers&#x2F;pldi91.pdf</a>')