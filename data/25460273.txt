Item(by='centimeter', descendants=None, kids=None, score=None, time=1608238437, title=None, item_type='comment', url=None, parent=25459846, text='Haskell does a nice job with this as well. There&#x27;s a lot of machinery available for dealing with error handling, much of it through typeclasses.<p><pre><code>    format :: Maybe Int -&gt; String\n    format = maybe &quot;No Int Provided&quot; show\n\n    formatIfFormatterAvailable :: Maybe (Int -&gt; String) -&gt; Maybe Int -&gt; Maybe String\n    formatIfFormatterAvailable formatter int = formatter &lt;*&gt; int\n</code></pre>\nThe latter will work with any error handling type, not just Maybe.<p><pre><code>    formatIfAvailable :: (Int -&gt; String) -&gt; Maybe Int -&gt; Maybe String\n    formatIfAvailable formatter int = fmap formatter int\n</code></pre>\nAnd so on. Using a combination of functor, monad, and applicative typeclasses, you can get really ergonomic error handling. It can be a little confusing to see it at first, where during parsing you have expressions like<p><pre><code>    data Entry = Entry Username Date Dollars\n    parser :: Parser Entry\n    parser = Entry &lt;$&gt; usernameParser &lt;*&gt; dateParser &lt;*&gt; dollarsParser\n</code></pre>\nWhat the above is doing is &quot;first try to parse a username, then try to parse a date, then try to parse a dollar amount, and if they all parse then return an Entry object with all that data&quot;. This is a lot easier than writing out something like 3 nested if statements, checking if any of the parsers returned null each time, or trying to use GOTOs or whatever.')