Item(by='_huayra_', descendants=None, kids=None, score=None, time=1610199467, title=None, item_type='comment', url=None, parent=25700035, text='&gt; With haskell you spend less time on doing these kind of changes because the compiler tells you what needs to be changed.<p>This. I think what all the other folks in this thread that are just throwing shade on Haskell after struggling through a tutorial (admittedly, it can be pedagogically difficult to introduce concepts compared to Python or Ruby or JS, etc).<p>Perhaps Haskell will never beat C++ &amp; friends (Rust, C, maybe Swift?) at performance, but what it will beat is the myriad other web apps written in Python and Ruby, which I bet a lot of folks on this site use. All that it lacks are the same levels of batteries-included frameworks like Django and Rails.<p>I can&#x27;t even begin to mentally enumerate the number of times I&#x27;ve seen Python (and, much less often, Ruby) codebases at the places I&#x27;ve worked that were critical to the infrastructure (often having been the outgrowth of the initial POC that got the product started) that were mysterious Monoliths, which if you tried to change would be some Hydra situation: for every bug fixed, another 2 or 3 or 10 are created.<p>Perhaps if a team of really well-disciplined Python professionals can go 0-60 very quickly due to the language&#x27;s flexibility, but it counts on that discipline being maintained going forward in the code, and training new hires or hiring only experts to work on the project.<p>Haskell is basically like encoding this discipline into the compiler itself. You don&#x27;t have to spend time praying that your test suite is adequate (although tests are still needed) or picking over the minutiae of some pull request trying to remember all the things that the `|` operator may have been overloaded with from that &quot;coding ninja&quot; who decided to put esoteric things in your Python codebase did before he got poached by some other company and peaced out without documenting anything.<p>For all of the pitfalls that Haskell has from a language perspective (which can often be avoided by using an alternate prelude), the advantages when compared to other modern languages made for &quot;moving fast and breaking things&quot; are very prominent: I no longer have to wonder what the `data_object` parameter of my `update_callback_param_cache` method is supposed to be and waste minutes of my life desperately grepping through the code or, if possible, `pdb`ing my way through a live version and trying to trigger that code path.')