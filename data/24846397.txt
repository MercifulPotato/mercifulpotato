Item(by='martinhath', descendants=None, kids=None, score=None, time=1603275920, title=None, item_type='comment', url=None, parent=24843250, text='&gt; a cross compiler can&#x27;t replicate the architecture-specific behaviour of the compiled code because the target architecture is unavailable or possibly even nonexistent at the place and time the compiler runs.<p>I mean, it can&#x27;t possibly be nonexistent when you write the program, since if you don&#x27;t have any idea what the target looks like, how can you output code for it? Do you mean physically existent?<p>I think I see the overall point though, namely that arch specific code would be a mess, with which I agree.\nBut isn&#x27;t this okay? I mean, if you really want to switch on some platform specific thing at compile time, then different behavior for different host platforms is exactly what you want.<p>To me, there&#x27;s basically two uses of compile time execution: precomputation and codegen. If we look at the following snippet<p><pre><code>  const std = @import(&quot;std&quot;);\n  pub fn main() anyerror!void {\n      std.debug.warn(&quot;{}\\n&quot;, .{.{\n          @sizeOf(*usize),\n          comptime @sizeOf(*usize)\n      }});\n  }\n</code></pre>\nwe&#x27;re looking at the size of a `usize`, which is pointer-sized, and we&#x27;re taking it both with and without `comptime`. \nIf I compile and run this on my system, it prints out 8 and 8, since I&#x27;m on a 64-bit system.<p><pre><code>  &#x2F;h&#x2F;m&#x2F;t&#x2F;zig$ zig build run\n  struct:5:21{ .0 = 8, .1 = 8 }\n</code></pre>\nHowever, Zig does support cross compilation, and I can compile this for 32-bit mode, and run it, which then gives me 4 and 4.<p><pre><code>  &#x2F;h&#x2F;m&#x2F;t&#x2F;zig$ zig build run -Dtarget=i386-linux-musl\n  struct:5:21{ .0 = 4, .1 = 4 }\n</code></pre>\nIt&#x27;s worth noting that the docs for `@sizeOf` says &quot;This function returns the number of bytes it takes to store T in memory. The result is a target-specific compile time constant.&quot;.<p>&gt; you a: need two different codegens<p>Won&#x27;t you need `n` different codegens if you support cross compilation to `n` different targets anyways?')