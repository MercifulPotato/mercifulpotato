Item(by='tgbugs', descendants=None, kids=[25631940], score=None, time=1609717511, title=None, item_type='comment', url=None, parent=25622756, text='The author quickly moves on after finding that expand-file-name is the issue and routes around the problem. The last time we hear from it is when it is patched out. But what is really going on?<p>The problem is that many parts of Emacs and libraries built on top of them have not been made fully TRAMP aware. There is an abstraction boundary that is being crossed, assumptions are being violated, etc. because all paths are treated equally, despite the fact that most parts of Emacs can identify that a path is remote (or could be remote).<p>Fixing the underlying issue and providing latency aware variants of commands is not easy (you usually can&#x27;t just run elisp on a remote machine), but when we get there Emacs will be even more powerful!<p>Here is an excerpt from some notes I made back in October.<p>Consider these cases.<p>I have 10k files that I want to move on a remote server.\nI have 10k files that I want to move on a local server.<p>Where do I put the for loop?<p>I want to put it so that I only have to call ssh once.<p>Similar issue with using find and subshells.\nIf I have to invoke a subshell there is significant overhead.<p>Having even a little bit of knowledge about the latency of\nrunning a single command, or the knowledge that certain commands\ncommute under loop reordering would make it much easier to\nproduce efficient code, basically<p><pre><code>  #+begin_src elisp\n  (do-for-values value &#x27;(a b c d e f g)\n    (please-do-this-on-the-remote #&#x27;command value))\n  #+end_src\n</code></pre>\nshould be rewritten to<p><pre><code>  #+begin_src elisp\n  (please-do-this-on-the-remote\n    (do-for-values value &#x27;(a b c d e f g)\n      (command value)))\n  #+end_src\n</code></pre>\nHowever, this is only safe if the values are from the local and not the remote\nand are not functions that are dependent on local state (that doesn&#x27;t really\nmatter in strict languages though).<p>The best way to approach this might be to detect and warn before running.\nOr not, sometimes you do just want to be more efficient, and if you don&#x27;t\nwant the optimization then disable it some other way. The reason is because\nsometimes it is much easier to write the latency multiplying version, and\nthe conversion to the latency efficient form is trivial for a computer but\nextremely easy to screw up for a human being.<p>EDIT: Hah. I though I recognized Richard&#x27;s reply. It was to me.')