Item(by='Xylakant', descendants=None, kids=[25337578], score=None, time=1607362470, title=None, item_type='comment', url=None, parent=25333288, text='&gt; Safety doesn&#x27;t just come from language features, it also comes from the language disallowing dangerous actions.  Rust&#x27;s unsafe mode opens the door to undefined behaviour, of the sort that plagues so many C&#x2F;C++ codebases (buffer overflows etc). A program written in safe Rust offers far better assurances than a program making heavy use of unsafe Rust: safe Rust is unable to result in undefined behaviour.<p>Safety is not an absolute, it&#x27;s a spectrum. No one denies that safe rust is better than unsafe rust on the safety scale.<p>&gt; You may be right that a program written in 100% unsafe Rust might still be less prone to undefined behavior than a program written in C, but that&#x27;s not my point. Excessive use of unsafe features undermines the considerable safety advantages that Rust offers over C, and it&#x27;s regrettable when this is disregarded.<p>It&#x27;s not disregarded. The point you are disregarding that when porting a C application to rust, unsafe rust is a step up from C, not step down from safe rust. Unless you choose to rewrite from ground up (which is infeasible in many places), you&#x27;ll need unsafe rust, either for binding or by using tooling that converts the C sources to rust. But once you have unsafe rust, you already get all the help that the borrow checker brings and you can gradually shrink the unsafe code. It&#x27;s a matter of practicality, you seem to be advocating for absolutes and I think that&#x27;s earning you the down votes you&#x27;re receiving.')