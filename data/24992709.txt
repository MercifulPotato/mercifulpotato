Item(by='brundolf', descendants=None, kids=None, score=None, time=1604521443, title=None, item_type='comment', url=None, parent=24992537, text='Rust&#x27;s key feature - the borrow-checker - relies on the idea that each value has a single &quot;owner&quot; at any given time. This owner can be a function, another value (a parent struct), etc. You can put these values on the heap, but if you use Box (the go-to for heap allocation), that pointer still has to have a single logical &quot;owner&quot;. Under idiomatic Rust, each value effectively lives in one single &quot;place&quot;. This allows the compiler to determine with 100% confidence at what point it&#x27;s no longer being used and can therefore be de-allocated.<p>Now, these values can be lent out (&quot;borrowing&quot;) to sub-functions and such via references (mutable or immutable). Multiple immutable references can be handed out at once, but a mutable reference to a value has to be the only reference to that value of <i>any</i> kind, at a given time.<p>The problem is, some domains really don&#x27;t lend themselves to this restricted model. No two objects or functions can point, mutably, to the same object at the same time. You simply can&#x27;t create a graph of inter-referenced objects where a single value may have multiple &quot;parents&quot;. And sometimes even with a perfectly tree-like ownership structure moving values around can get complicated, because Rust has to know <i>for sure</i> that the ownership model is adhered to. This is where explicit lifetimes and such can come into play. Even writing a linked-list in Rust without using unsafe { } (or Rc&#x27;s) is <i>hard</i> (<a href="https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;too-many-lists&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;too-many-lists&#x2F;</a>).<p>In Rust, Rc&#x27;s are kind of an admission of defeat. You&#x27;re telling Rust not to perform its normal &quot;compile-time&quot; automatic deallocation, instead having it track references at runtime (which comes with overhead) to know when to de-allocate. What this buys you is basically an out from the ownership system: instead of handing off a plain reference to multiple places, which Rust may not let you do, you just clone the Rc and hand off that &quot;new&quot; value which can go anywhere it wants. That Rc is then what gets tracked by the ownership system and de-allocated, and when de-allocated it decrements the count (again, at runtime), and eventually that runtime mechanism (hopefully) decides the real value can be de-allocated.<p>Basically any part of your code that uses Rc&#x2F;Arc is giving up one of the biggest features of Rust. Which is totally fine, if you&#x27;re reaping those advantages elsewhere and you just need to bridge a gap where ownership is too limiting. But if heap-juggling is going to be primary thing your program is doing, you&#x27;ll probably have a better overall time with a GCed language.')