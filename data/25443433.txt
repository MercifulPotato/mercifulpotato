Item(by='ragnese', descendants=None, kids=None, score=None, time=1608131381, title=None, item_type='comment', url=None, parent=25443184, text='Caveat: I&#x27;m not an expert in any of it. I&#x27;ve played around with Guile Scheme, Common Lisp, and did a (small) real-world work project in Clojure.<p>I mean, Common Lisp is perfectly fine. And if you want to use it to write real apps, it&#x27;s a good choice. Especially if you will have dependencies to manage (see quicklisp).<p>There&#x27;s just a few little things that I don&#x27;t like as much about it.<p>There&#x27;s a holy war about &quot;lisp-1 vs lisp-2 (or lisp-n, really)&quot;. Not much point in debating that, but scheme is a lisp-1 and CL is a lisp-2.<p>I like that schemes tend to use #f for false and #t for true, whereas CL just uses nil for false, and for empty-list, and anything else for true (which is usually the symbol t in practice).<p>I like the way things are named more in Schemes: map vs. mapcar, number? vs. numberp, etc.<p>I like that the Scheme standards guarantee tail-call-optimization. I believe all popular CL implementations <i>do</i> implement it, but it&#x27;s not required by the standard.<p>CL has the ugly loop macro, and Schemes emphasize recursion more (also has `do`, though).<p>Schemes have &quot;hygienic macros&quot; which I like much more than unhygienic macros.<p>These things mostly don&#x27;t matter, honestly. It&#x27;s all bikeshedding. Lisps and Schemes are very very similar and also very different than most other languages. You can&#x27;t go wrong with either.')