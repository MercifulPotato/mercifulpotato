Item(by='valenterry', descendants=None, kids=None, score=None, time=1606450071, title=None, item_type='comment', url=None, parent=25222281, text='&gt; I find that many articles written about Haskell, Erlang and Elixir seem to have no meaning outside of their own narrow domain; they try to present some solutions as some universal insight which is applicable to all languages.<p>As a developer who does not use Haskell (but understands most of it), let me put it into perspective:<p>If you write an article about the visitor-pattern or any kind of other OOP pattern, how do you think this is perceived by a developer who ever only wrote assembly?<p>Yes, they will think in the same way you think right now. This phenomenon has been described e.g. here: <a href="https:&#x2F;&#x2F;wiki.c2.com&#x2F;?BlubParadox" rel="nofollow">https:&#x2F;&#x2F;wiki.c2.com&#x2F;?BlubParadox</a><p>Fact is that from the perspective of a Haskell developer, you are writing unorganized spaghetti code when not using the techniques they write about. In the same way you probably would see an assembly developer writing spaghetti code instead of using OOP techniques.<p>&gt; I like languages which stay out of my way<p>Languages that stay out of _your_ way are languages that encourage the style that _you_ are used to. There are no languages that generally stay _out of the way_ because that&#x27;s not possible and not even desired. So saying this just means &quot;I want a language where I don&#x27;t have to learn another way of doing things&quot;. That&#x27;s fair, but it should be emphasized.<p>&gt; my OOP philosophy is so simple, I could explain it to a 10 year old<p>Many people learn Haskell first and than have trouble learning classical OOP in e.g. Java. And the other way around. What does that tell you?')