Item(by='miki123211', descendants=None, kids=None, score=None, time=1603711785, title=None, item_type='comment', url=None, parent=24893416, text='This is exactly what Elixir is doing!<p>It has nice, readable, ruby-like syntax, but it&#x27;s a Lisp at the core. Really powerful macros (see Ecto), and a syntax that isn&#x27;t off-putting to the majority of programmers.<p>Most things in Elixir, including constructions like if and def, operators and even module accesses (`Module.function`) are compiled to a simple AST based on function calls.<p>Because that AST isn&#x27;t usually written by humans, besides the function and the arguments, each node might contain additional context information, like the file and line number the call appeared in. That lets you do some really cool stuff, like distinguishing x (a variable you define) from x (defined by a macro), which is a frequent source of bugs in other languages that support macros.<p>99% of Elixir is syntax sugar over function&#x2F;macro calls, and its true AST is smaller than Clojures.<p>You can read more here: <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;syntax-reference.html#the-elixir-ast" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;syntax-reference.html#the-elixir-a...</a>')