Item(by='TeMPOraL', descendants=None, kids=[24898904], score=None, time=1603709362, title=None, item_type='comment', url=None, parent=24894346, text='Having worked in a Common Lisp startup, I&#x27;ll only agree with half of your counterarguments :).<p>&gt; <i>You want advanced syntax highlighting, linting, automatic refactoring for your special features? Write it yourself!</i><p>That&#x27;s true to an extent. Simple things are simpler in Lisps, because the syntax is trivial. So highlighting and structured editing are easy. The rest, is near impossible, at least for a full-featured Lisp like Common Lisp. That&#x27;s a consequence of being an <i>extremely</i> dynamic language, that ships a compiler and intertwines parsing, compiling and execution. The flip side of being able to run arbitrary computation at compile time is that, in general, you can&#x27;t know what the program will do until you run it. The dominant free CL IDE, SLIME, does just that: it <i>queries</i> your running Lisp image for its current state, to provide you with formatting and autocomplete and other hints.<p>That said, &quot;near impossible&quot; is a function of community size. Had CL anywhere near as much popularity as Java or Python does, I&#x27;m sure folks at IDEA would make automatic refactoring work for CL as well :).<p>&gt; <i>You want outsiders to participate (think: new employees)? Write all documentation yourself, too!</i><p>That I strongly object to. Code generation and compile-time execution aren&#x27;t magic, or even particularly hard concept. They&#x27;re just another flavor of code. You manage it the same way as regular code - you package it into modules with well-defined interfaces, and document them. I&#x27;ve worked with CL in a team settings, and I&#x27;ve worked on legacy CL code that&#x27;s as old as I am; it&#x27;s not harder than &quot;regular&quot; legacy code. And you always have to write your documentation yourself, there&#x27;s no escape from that, no matter what language you use.')