Item(by='ritter2a', descendants=None, kids=[25505690], score=None, time=1608638867, title=None, item_type='comment', url=None, parent=25504286, text='I would claim that the benefits of &#x27;mostly functions&#x27; strongly depend on the task at hand.<p>For the field of compilers, I can for example see value in making program analyses pure functions that just compute information about the program and separate them from the program transformations that use this information to (impurely) manipulate code. This makes the analyses more reusable and probably makes reasoning about correctness easier.<p>For other tasks in the compiler, pure functions can be a pain. My favorite anecdote for this is that of a group of students in a compiler&#x27;s course who insisted on writing the project (a compiler for a subset of C) in Haskell and who, when discussing their implementation in the final code review, cited a recent paper [1] that describes how you can attach type information to an abstract syntax tree (which is an obvious no-brainer in the imperative world).<p>---<p>[1] <a href="http:&#x2F;&#x2F;www.jucs.org&#x2F;jucs_23_1&#x2F;trees_that_grow&#x2F;jucs_23_01_0042_0062_najd.pdf" rel="nofollow">http:&#x2F;&#x2F;www.jucs.org&#x2F;jucs_23_1&#x2F;trees_that_grow&#x2F;jucs_23_01_004...</a>')