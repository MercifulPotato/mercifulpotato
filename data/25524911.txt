Item(by='josephg', descendants=None, kids=[25525883], score=None, time=1608782172, title=None, item_type='comment', url=None, parent=25524498, text='Fair enough; thanks for taking the time to chat about this. I&#x27;m not sure I agree, but I appreciate your perspective and experience.<p>For all that you&#x27;ve said, I still strongly suspect that a standalone rust &#x2F; swift compiler designed for speed above all else could achieve many times the performance of the current LLVM based designs. The resulting binaries might need to lean heavily on dynamic dispatch over monomorphization to achieve that - but during development thats a tradeoff I&#x27;d take just about every time. The common factor in swift and rust is llvm - both using it for codegen and having the compiler <i>think about the program</i> in terms of llvm constructs. The fastest compilers I know about - V8, LuaJIT, Go, Jai(?) are designed with both performance and the target language in mind, and (I assume) don&#x27;t translate the code through a series of complex intermediate representations internally. And you&#x27;re right - none of those languages do complex template specialization.<p>Also its probably no coincidence that maybe except for V8 all of those compilers were designed by a single expert mind, not a huge team spanning multiple companies. As you point out, large scale refactoring (required for top tier performance) gets increasingly difficult as team &amp; code size increases. The reasons are partially political (&quot;your commit conflicts with <i>how much</i>??&quot;), and partially because it gets super difficult for any one mind to conceive of the whole program at once when it has so much code and so many authors. Let alone do large scale refactoring.<p>I don&#x27;t know if its true but I heard the chrome team started with just a dozen or so very senior engineers who all had experience with webkit. Before they brought anyone else onto the team, they spent months iterating together on the internal design of the browser engine until they were happy with it. They did it that way because they figured it would be basically impossible to change the core down the road once they had a larger team hacking on it.<p>&gt; Why are these languages using features such as type inference, stricter and more complicated type systems along with heavy templating? It&#x27;s because now ... these features become viable in the compilers of today vs. the compilers of yesterday.<p>Maybe. I think we also just got better at designing languages. Rust&#x27;s trait system seems both simpler and better than C++&#x27;s classes + templates. Traits would have been just as viable in a compiler decades ago, but OO was trendy and we didn&#x27;t know any better.<p>&gt; just because you like something, it doesn&#x27;t mean most people like it<p>Oh, I know! I&#x27;ve spent enough time working on teams building websites to know I&#x27;m not the average bear. But I don&#x27;t think its because performance work is fundamentally uninteresting. I think its because most engineers working on websites don&#x27;t have enough raw CS skill to comfortably step into the performance arena.')