Item(by='dragontamer', descendants=None, kids=None, score=None, time=1603299371, title=None, item_type='comment', url=None, parent=24849091, text='If A depends on B depends on C, then:<p>* C should have a unit test proving its capabilities.<p>* B is allowed to have a unit test that depends on C (because C&#x27;s unit tests prove its correctness).<p>* A is allowed to have a unit test that depends on B (similar to the B&#x2F;C case).<p>---------<p>It seems like mocking was a way to &quot;cut&quot; the dependency between A and C. In particular, you usually get huge &quot;dependency chains&quot; between your code base. A depends on B, depending on C, depending on D... depnds on E, F, G, H, I... etc. etc. Pulling in all of this code for a unit test seems backwards. IMO, the solution isn&#x27;t to use mocking, but to refactor your code to reduce the dependencies.<p>But if the code is outside of your control (ie: owned by another team, or even a 3rd party), maybe mocking is the best option.<p>&quot;Flattening&quot; your code dependencies, reducing the &quot;height&quot; of your layers will simplify your code logic and software engineering. But its not always an option in reality.<p>------<p>If you have a circular dependency: A depends on B and B depends on A, then:<p>1. Find a way to break the circular dependence. Invent a new class C: Maybe A depends on C, B depends on C, and C represents the shared interface between the two. Once broken up in this manner, A depends on C (and A unit tests depend on C), then B depends on C (and B unit tests depend on C), and finally you write unit tests for C itself. No mocking needed.<p>2. If #1 cannot happen, Both A and B must be unit tested together as a singular component. Trying to split it up using mocking is a fool&#x27;s errand.')