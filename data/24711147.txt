Item(by='orthecreedence', descendants=None, kids=[24714198], score=None, time=1602095306, title=None, item_type='comment', url=None, parent=24699534, text='I know this isn&#x27;t a stylish opinion, but I&#x27;ve been using beanstalkd (<a href="https:&#x2F;&#x2F;beanstalkd.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;beanstalkd.github.io&#x2F;</a>) in production for years now and never had a problem. Once in a while the <i>server</i> it&#x27;s hosted on will have troubles, but the process itself is bulletproof and handles thousands of jobs&#x2F;s without breaking a sweat. It has compacting binlogs, so for mission critical jobs that cannot be recreated you can save them to disk. For jobs that can be re-created, you can run an in-memory instance that can easily handle more jobs than most people here will ever need.<p>If you want redundancy or write-scaling, you can run 2+ of them side by side, round-robin your jobs to the <i>available</i> instances, and have your workers read from them (RR as well).<p>Beanstalkd is a lifesaver for job queues. It&#x27;s the first thing I reach for when I need a queue. I&#x27;m excited to see how Redis&#x27; Disque turns out, but until then I&#x27;m happy with bean.<p>I&#x27;ve evaluated replacing bean with something like Kafka, but it just doesn&#x27;t make any sense at all. A distributed log is NOT a queue, and even using something like RabbitMQ gets tricky if you want to <i>pull</i> jobs instead of <i>push</i> them. For dedicated worker queues at small-to-medium scale, I cannot recommend beanstalkd enough. No, it doesn&#x27;t have native sharding or multi-region replication, but like I said, I run millions of jobs&#x2F;hour through it and never needed any of that crap.')