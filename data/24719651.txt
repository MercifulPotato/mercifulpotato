Item(by='ghostwriter', descendants=None, kids=[24722629], score=None, time=1602169018, title=None, item_type='comment', url=None, parent=24719221, text='Right, so we essentially say that the provided example doesn&#x27;t refute the &quot;it works if it compiles&quot; slogan. It just works according to the provided specification expressed in the types, and it so happened that the specification was not specific enough.<p>My specification doesn&#x27;t make a distinction between absent users and possible error responses because I assume that errors will be processed elsewhere and the <i>getUsers</i> function is applied as part of the &quot;safe core&quot; interface that is not concerned about error handling. If the specification was more precise (even more precise than in your suggestion, for instance, <i>getUsers :: SafeIterable a =&gt; Foo -&gt; a</i> and <i>length :: SafeIterable a =&gt; a -&gt; Integer </i>), it would work differently.<p>The issue in the example has to do with the clarity of the intent encoded in the type signature, not the inherent issue of the type system that cannot guarantee safe runtime of the example. That&#x27;s why I mentioned type constraints for specific iterables as a possible solution to the encoding problem.<p>A better example of the compiled-but-not-working case would be something that currently cannot be expressed well by the type system, something like async exceptions or access to closed resources (will be covered by linear types soon).')