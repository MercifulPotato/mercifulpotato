Item(by='hajile', descendants=None, kids=[24892425, 24895429, 24892136, 24891382, 24891358], score=None, time=1603670426, title=None, item_type='comment', url=None, parent=24890463, text='StandardML really hits a nice sweet spot in language design.<p>The syntax is super-easy to learn (The BNF for the whole fits in a mere 2 pages[0]), but contains a lot of features in that small package. Rather than tacking on functional features (eg, Java with lambdas), these features have been carefully considered and streamlined and include bits like proper tail calls and currying.<p>You get nice bits like actually sound types (hindley-milner types as Milner was also one of the SML spec authors), generics (way better than typical interfaces), type inference that actually works, and modules (super-powerful encapsulation). Pattern matching in all it&#x27;s awesomeness is also on display.<p>SML has an amazing concurrency story (CML is rather like golang channels, but better with better typing and a bit more flexibility) and compilers like PolyML or Mlton are very fast (once again, around the same as golang).<p>Despite this, the language <i>doesn&#x27;t</i> have the academic flaws of its descendants like Haskell.<p>SML isn&#x27;t a lazy language, so reasoning about performance is much easier than some other functional languages. \nSML doesn&#x27;t pretend the world is a pure function. You are free to make functions that have side effects.\nWhile most primitives and data structures are immutable by default, they either have mutable variants (eg, vector and array) or can be used as if mutable with refs (something like typesafe pointers without all the reference&#x2F;dereference bits).<p>[0] <a href="https:&#x2F;&#x2F;cse.buffalo.edu&#x2F;~regan&#x2F;cse305&#x2F;MLBNF.pdf" rel="nofollow">https:&#x2F;&#x2F;cse.buffalo.edu&#x2F;~regan&#x2F;cse305&#x2F;MLBNF.pdf</a>')