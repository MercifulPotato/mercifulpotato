Item(by='fluffything', descendants=None, kids=None, score=None, time=1603273101, title=None, item_type='comment', url=None, parent=24835357, text='What do Zig &quot;generics&quot;&#x2F;&quot;comptime&quot; errors look like ?<p>&gt; One of the key differences between zig and rust is that when writing a generic function, rust will prove that the function is type-safe for every possible value of the generic parameters. Zig will prove that the function is type-safe only for each parameter that you actually call the function with. On the one hand, this allows zig to make use of arbitrary compile-time logic [...]<p>This is fundamentally identical to how C++ templates, constexpr and concepts work. Its a really flexible system (you can implement how you want to type check things using constexpr), but has three cons that Rust system does not have:<p>- can&#x27;t typecheck library APIs, so library authors aren&#x27;t sure if their &quot;constraints&quot; are correct. Testing this requires writing lots and lots of compile-time tests.<p>- errors deep inside a library implementation when user code passes incorrect arguments to generic APIs.<p>- rust traits can be used for static dispatch, or boxed and used for dynamic dispatch, C++ at least can&#x27;t really do this well.<p>It would be cool if someone could explain how Zig fixes or improves upon these problems that this system has in C++. C++ tried to fix this with concepts, but failed.<p>This was a nice read that has motivated me to learn Zig. I want to know how Zig improves on these C++ issues.')