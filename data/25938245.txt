Item(by='Geminidog', descendants=None, kids=[25938480], score=None, time=1611808690, title=None, item_type='comment', url=None, parent=25933121, text='This guy makes a simple concept too complicated.<p>The main thing that&#x27;s different about python OO is the method.<p><pre><code>    class SomeClass\n       def someMethod(self: SomeClass, someVar: int) -&gt; int:\n           return self.x + somVar\n</code></pre>\nThe explicit passing of context through &quot;self&quot; gives python methods combinator-like properties. Because of this, you can copy and paste the method and run it outside of the context of the class:<p><pre><code>           def someMethod(self: SomeClass, someVar: int) -&gt; int:\n               return self.x + somVar\n</code></pre>\nThe above will work in global context. This makes python code significantly more refactorable than other OO languages. For example C++:<p><pre><code>   class SomeClass {\n       int someMethod(int someVar) {\n             return this.x + someVar;\n       }\n   } \n\n</code></pre>\nIf you copy and paste the method outside of the class:<p><pre><code>       int someMethod(int someVar) {\n           return this.x + someVar;\n       }\n</code></pre>\nIt won&#x27;t work.<p>The python way just allows the method to be easily refactored to operate on a generic type (caveat: you have to ignore typing which the python interpreter actually does). Given a self.x, any value for self will be valid so long as it contains an x. Python does this automatically and that is the main difference.<p>The main problem with OO is unfortunately still not resolved under either example. OO promotes context to follow logic around preventing the logic from being reused in other contexts. Ultimately, this is what&#x27;s needed for the greatest modularity:<p><pre><code>     def someMethod(x: int, someVar: int) -&gt; int:\n         return x + someVar\n</code></pre>\nAnd although you can write the above with OO, the style ultimately promotes practices that steers programmers away it.')