Item(by='jakelazaroff', descendants=None, kids=[25474457], score=None, time=1608335473, title=None, item_type='comment', url=None, parent=25459506, text='I feel like I post a link to this comment [1] every time the abstraction vs. DRY topic comes up, but it’s just such good advice. I consciously try to remember it whenever I’m programming.<p><i>&gt; Dependencies (coupling) is an important concern to address, but it&#x27;s only 1 of 4 criteria that I consider and it&#x27;s not the most important one. I try to optimize my code around reducing state, coupling, complexity and code, in that order. I&#x27;m willing to add increased coupling if it makes my code more stateless. I&#x27;m willing to make it more complex if it reduces coupling. And I&#x27;m willing to duplicate code if it makes the code less complex. Only if it doesn&#x27;t increase state, coupling or complexity do I dedup code.</i><p><i>&gt; The reason I put stateless code as the highest priority is it&#x27;s the easiest to reason about. Stateless logic functions the same whether run normally, in parallel or distributed. It&#x27;s the easiest to test, since it requires very little setup code. And it&#x27;s the easiest to scale up, since you just run another copy of it. Once you introduce state, your life gets significantly harder.</i><p><i>&gt; I think the reason that novice programmers optimize around code reduction is that it&#x27;s the easiest of the 4 to spot. The other 3 are much more subtle and subjective and so will require greater experience to spot. But learning those priorities, in that order, has made me a significantly better developer.</i><p>Dan Abramov also has a good talk about this [2].<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11042400" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11042400</a><p>[2] <a href="https:&#x2F;&#x2F;overreacted.io&#x2F;the-wet-codebase&#x2F;" rel="nofollow">https:&#x2F;&#x2F;overreacted.io&#x2F;the-wet-codebase&#x2F;</a>')