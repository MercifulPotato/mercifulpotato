Item(by='notafraudster', descendants=None, kids=[24676300, 24674449, 24676188, 24675031, 24676005, 24674290, 24675764, 24674313, 24675829], score=None, time=1601753946, title=None, item_type='comment', url=None, parent=24671638, text='Responding in hopes some Git non-novices are here and can give some quick advice.<p>I have a fairly large Git repo with 5 years of commits from numerous team members including a bunch of non-technical people who had never used Git before.<p>There were two major issues:<p>1. We started off storing binary files -- mostly images, but also a ton of raw data files that got versioned every day or two -- in this repro and it spiralled out of control size-wise. I ended up using &quot;BFG&quot; to nuke the binary files and I think that worked, but it still feels like the repo is way too large in terms of file size. Is it possible that orphaned old versions of files are floating around somewhere in .git&#x2F;? What are the best practices here?<p>2. The branching strategy was badly wrong. We used two branches: production and dev. New commits are made to dev, dev is merged into production periodically via GitHub PRs. Dev is NOT deleted and we did not use a squash strategy on merges. Somehow this resulted in the repo having 2, 3, 4, or 5 copies of the same commit immediately in a row. I think that somehow a branch got merged into itself? I don&#x27;t know how that would be possible, but I can tell you the symptom is that there&#x27;s a period of time several years ago where every commit appears in quintuplicate, and this slowly decreases until every commit is just doubled, and then at some point we&#x27;re back to a correct commit history. What&#x27;s the likely cause here and what&#x27;s the likely solution?<p>We would like to fix both these things while preserving history (obviously the problem could be immediately &quot;solved&quot; with rm -rf .git &amp;&amp; git init, but we&#x27;d like to avoid that at least partially so that no one who worked on the project has their historical commit record broken and so we can still use blame to know who most recently touched some of the older stuff)<p>My own git-fu is not great, so, thanks for posting these exercises.')