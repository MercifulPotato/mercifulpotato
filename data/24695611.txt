Item(by='jlokier', descendants=None, kids=[24697159], score=None, time=1601971308, title=None, item_type='comment', url=None, parent=24692502, text='&gt; I think the actual issue with TLS is that compilers will happily hoist TLS address computations across function calls.<p>TLS has its own issues, but in every situation where this optimisation is fine with TLS, it&#x27;s fine with FLS too.ยน<p>If you call a function in a fibers &#x2F; stackful coroutines environment, and the function has a context switch inside (say it does some blocking I&#x2F;O), by the time the function returns the original context is valid again.<p>&gt; I do not think that FLS (at least by default) is the right solution as it would consume a lot of memory,<p>Depends on what you store in FLS.  As with TLS, there are situations when it&#x27;s beneficial for memory, compared with storing replicated copies of data all over the place in arguments and data structures, and situations when it isn&#x27;t beneficial.<p>In some it will consume less memory than stackless coroutines, which store copies of the same data in async structures anyway.<p>&gt; increase the switch overhead<p>If we&#x27;re still discussing the article&#x27;s case that stackless coroutines are better, FLS switch overhead is usually lower than stackless&#x2F;async overhead.<p>In the stackless&#x2F;async version you have compiler-generated loads and stores to context-specific structs that need to be executed every time something context switches for an await.<p>FLS overhead is updating a single pointer.  Even that may be free, because you&#x27;re going to update some kind of context structure pointer anyway.  Even in the base case, stackless will update an equivalent pointer at absolute minimum, but often more.<p>This is really the same argument for TLS being sometimes useful in threaded programs specifically for performance, as opposed to explicitly passing around copies of pointers and storing them in data structures all over the place.  (Of course there are non-performance reasons why people choose TLS or avoid it too.)<p>&gt; add complexity for little benefit<p>The benefit is faster programs, and a simpler programming model.  You may reasonably disagree :-)<p>But consider, the Linux kernel is basically all fibers with FLS, and that&#x27;s a top performer :-)<p>With regard to programming model: In Linux, it was found to be very much simpler to use fibers (called &quot;tasks&quot; in Linux) than to build an async I&#x2F;O state machine for filesystems.  This is why Linux didn&#x27;t get useful async I&#x2F;O in filesystems for a long time, because the state machine version of filesystem operations, though people attempted, was just far too complex in practice to implement for all corner cases, so its async properties were unreliable.<p>--<p>ยน At least no problems that are specific to FLS.  If you&#x27;re pointing out there are issues with TLS (without fibers) due to shared library loading&#x2F;unloading or lazy memory instantiation, that&#x27;s an issue but it does not support the article&#x27;s implication that TLS is ok while FLS is not.')