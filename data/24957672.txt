Item(by='andrewjl', descendants=None, kids=None, score=None, time=1604213614, title=None, item_type='comment', url=None, parent=24953130, text='I haven&#x27;t seen any cleverness in reactive code that one wouldn&#x27;t encounter in a non-reactive code base. It is true that one may need to learn new abstractions, but a more imperative coding style requires lots of glue code, much of it having inconsistent quality. You&#x27;ll end up needing ramp-time no matter how you go. Building UI involves the same problems and trade-offs whether using reactive programming techniques or not.<p>Conal Elliott&#x27;s work, while super interesting, does not cover the entirety of reactive programming. I found this[1] write-up to be helpful in defining what reactive programming is and it&#x27;s value. The author is a member of the team working on Swift Concurrency.<p>And SwiftUI is compatible with anything from UIKit, so it actually doesn&#x27;t hold anyone back who wants to try to do something non-trivial. If you watch the demos, particularly from the most recent WWDC, you&#x27;ll see it actually makes quite complex behavior much more doable. Does that reduce the value of esoteric framework knowledge? Perhaps it does, but that means engineers now have <i>more</i> time to spend on the product not less.<p>[1]<a href="https:&#x2F;&#x2F;www.oreilly.com&#x2F;content&#x2F;why-reactive&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.oreilly.com&#x2F;content&#x2F;why-reactive&#x2F;</a>')