Item(by='szarnyasg', descendants=None, kids=None, score=None, time=1609020596, title=None, item_type='comment', url=None, parent=25545415, text='&gt; Traditional relational OLTP databases such as Postgres are already faster than dedicated graph databases for certain graph related tasks<p>It is indeed quite common that relational databases outperform graph databases on certain graph processing problems such as subgraph queries (a.k.a. graph pattern matching). There are two key reasons for this: (1) most graph pattern matching operations can be formulated using relational operations such as natural joins, antijoins, and outer joins; and (2) relational databases have been around longer and have well-optimized operators.<p>A lot of the value that graph databases provide lies in their query languages which (for most systems) allow formulating path queries using a nice syntax (unlike SQL&#x27;s WITH RECURSIVE which many people find difficult to read and write). Their property graph data model supports a schema-optional approach, which makes them better suited for storing semi-structured data. They also &quot;provide efficient programmatic access to the graph, allowing one to write arbitrary algorithms against them if needed&quot; [1].<p>With all these said, graph databases could be much faster on subgraph queries than relational databases and there are recent research results on the topic (worst-case optimal joins, A+ indexes, etc.). But these are not available in any production system yet.<p>[1] <a href="http:&#x2F;&#x2F;wp.sigmod.org&#x2F;?p=1497" rel="nofollow">http:&#x2F;&#x2F;wp.sigmod.org&#x2F;?p=1497</a>')