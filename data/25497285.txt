Item(by='tremon', descendants=None, kids=None, score=None, time=1608572766, title=None, item_type='comment', url=None, parent=25495639, text='<i>Under that scenario, philosophically, OS-design-wise, what are the responsibilties of the kernel?</i><p>Practically speaking, none. The responsibility of the kernel (in Linux terms, but I think it&#x27;s the same across all Unixen) is to start the init system (PID 1), and that&#x27;s where it ends. Should PID 1 ever terminate, the kernel is in an undefined state. The VFS semantics ensure that even when the init binary is removed from the filesystem, it is not actually unlinked until its reference count is zero -- and since the kernel holds a reference to it, the kernel and init are &quot;safe&quot; from harm through deletion.<p><i>Well, we might start by designing our future OS with a tiny shell inside of the kernel, for emergency use only.</i><p>While not in-kernel, systemd is ahead of you, as it offers a shutdown-time ramfs to use as root filesystem so the real root filesystem can be safely unmounted. Previously, Linux didn&#x27;t really unmount the root filesystem (it couldn&#x27;t, because the kernel still had an open handle to the init binary), but mounted it read-only before shutdown.<p><i>we might consider using a file system that doesn&#x27;t actually delete files when they&#x27;re deleted, but rather flags the disk space as &quot;empty&quot;</i><p>This is already the case. &quot;removing&quot; a file in Unix only removes its name from the directory listing, the inode isn&#x27;t reused until it&#x27;s been cleared. And even when it&#x27;s been cleared, only the inode entry is zeroed -- not the data contents. That&#x27;s why tools like &quot;shred&quot; exist -- to make sure a file&#x27;s contents are removed along with the file.<p><i>a very interesting topic for future OS designers to think about</i><p>I think transactional filesystems, snapshots, and log filesystems already do most of what you&#x27;re asking for.')