Item(by='brundolf', descendants=None, kids=None, score=None, time=1610759869, title=None, item_type='comment', url=None, parent=25798008, text='A few points:<p>&gt; Once your code is compiled, everything’s amazing! But in my case, this basic API - which wasn’t even feature-complete and was by no means a complex system - took more than ten minutes to compile...Caching helps as long as you don’t have to rebuild cached dependencies.<p>The author glossed over that last part, but at least from a workflow perspective, the build cache makes a <i>huge</i> difference. In my experiments developing a web server in Rust, I used cargo-watch (<a href="https:&#x2F;&#x2F;github.com&#x2F;passcod&#x2F;cargo-watch" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;passcod&#x2F;cargo-watch</a>) to automatically rebuild each time I made a change. The turnaround time was usually 1-2 seconds - nearly as fast as restarting a Node server, and about the same amount of time it takes me to alt-tab and test the change. I was using Serde, a high-level HTTP framework, and several other crates. It didn&#x27;t matter, because they never had to be rebuilt. My own code was small, but still.<p>&gt; Rust makes you think about dimensions of your code that matter tremendously for systems programming...It makes you think about real but unlikely corner cases and make sure that they’re handled...These are all valid concerns. But for most web applications, they’re not the most important concerns.<p>I disagree strongly (at least about corner cases). Maybe you don&#x27;t want to bother with this stuff when you&#x27;re still in the prototyping phase, but once a service is fairly well established, it&#x27;s definitely beneficial to be forced to think about corner-cases (both in libraries&#x2F;IO, and in your own business logic that you&#x27;ve hopefully modeled with Rust&#x27;s powerful type system). Not only is your API usually the authoritative source of truth for your application&#x2F;service, it&#x27;s exposed to the whole internet by design, just begging to be prodded for logic holes. This IMO is one of Rust&#x27;s main benefits; it&#x27;s been called &quot;the practical Haskell&quot; before, and while its ecosystem isn&#x27;t yet the most practical one for web servers, it is still much more so than Haskell&#x27;s.<p>&gt; Lots of missing pieces<p>This is the strongest point, in my opinion. Rust&#x27;s web ecosystem is definitely still in the early days, and this is partly because Rust&#x27;s benefits aren&#x27;t nearly as extreme in this usecase as they are in other usecases. There is for sure a chicken-and-egg problem as not enough companies are using Rust for web servers, which means not as much time is getting invested in the relevant libraries. I hope this changes; I don&#x27;t know for sure that it will. It feels like it is, but very slowly. That said:<p>&gt; Unfortunately, a lot of the incredibly exciting work in the Rust ecosystem has nothing to do with web application servers. There are some promising web frameworks - even a somewhat higher-level framework - but they’re undoubtedly in a niche. Even Actix, the main web framework, has a very top-heavy set of contributors.<p>The author failed to mention or wasn&#x27;t aware of Rocket (<a href="https:&#x2F;&#x2F;rocket.rs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rocket.rs&#x2F;</a>), an up-and-coming Rust web framework that&#x27;s <i>extremely</i> exciting and provides a programming experience strikingly similar to that of Flask or Express. It&#x27;s still in 0.X releases, the current release doesn&#x27;t build on stable rustc (though the master branch does!), you&#x27;re still going to have a hard time finding SDKs for auth and payment and cloud, etc.<p>But the important thing is that it shows what&#x27;s possible. Web servers <i>can</i> be ergonomic to write in Rust, benefiting from its wonderful type system and performance, with very few sacrifices. We just need the ecosystem to catch up. Hopefully enough companies will realize the opportunity and that will happen.<p>In summary: Yeah. Rust is a hard way to make a web API right now. But I don&#x27;t think it has to be.')