Item(by='Blikkentrekker', descendants=None, kids=[25891971, 25892921], score=None, time=1611494786, title=None, item_type='comment', url=None, parent=25891726, text='&gt; <i>Nothing in py2 returns bytes. They all return strings. That is the issue.</i><p>No, that is not an issue, that is semantics.<p>What one calls it does not change the behavior. And aside that the system could perfectly well be designed that this pragma changes that `str` is synonymous with either `bytes` or `unicode` depending on it&#x27;s state.<p><i>What about subclasses or type wrappers? What about functions that return bytes or utf8 strings? How would you handle code that then calls “.startswith()” on a returned string&#x2F;bytes value?</i><p>You would now which is which by using the pragma or not.<p>Not using the pragma defaults to the old behavior, as said, one only receives the new, breaking behavior, when one opts in.<p><i>Python</i> could even support always opting in by a configuration file option for those that really want it and don&#x27;t want to add the pragma at the top of every file.<p>&gt; <i>A language pragma that fundamentally alters a built in type across all the code you have in a program is never going to work and pushes the burden onto library authors to support a large matrix of different behaviours and types.</i><p>Opposed to the burden they already had of maintaining a 2 and 3 version?<p>Any new code can of course always return `unicode` rather than `str` which in this scheme is normally `bytes` but becomes `unicode` with the pragma.<p>It would make the already ridiculous py2 str&#x2F;bytes situation even more ridiculous.<p>&gt; <i>Having two almost separate object models in the same language is rather silly.</i><p>Yes, it is, and you will find that most languages are full of such legacy things that no new code uses but are simply for legacy purposes.<p>“<i>It is silly.</i>” turns out to be a rather small price to pay to achieve. “<i>We have not broken backwards compatibility.</i>”.')