Item(by='thu2111', descendants=None, kids=[25212278], score=None, time=1606322394, title=None, item_type='comment', url=None, parent=25205588, text='Ridiculous that you&#x27;re downvoted. There are a lot of people posting here who haven&#x27;t worked on memory management subsystems.<p>GC vs RC is not a trivial comparison to make, but overall there are good reasons new systems hardly use RC (Objective-C dating back to the 90s isn&#x27;t new). Where RC can help is where you have a massive performance cliff on page access, i.e. if you&#x27;re swapped to disk. Then GC is terrible because it&#x27;ll try and page huge sections of the heap at once where as RC is way more minimal in what it touches.<p>But in most other scenarios GC will win a straight up fight with an RC based system, especially when multi-threading gets involved. RC programs just spend huge amounts of time atomically incrementing and decrementing things, and rummaging through the heap structures, whereas the GC app is flying along in the L1 cache and allocations are just incrementing a pointer in a register. The work of cleaning up is meanwhile punted to those spare cores you probably aren&#x27;t using anyway (on desktop&#x2F;mobile). It&#x27;s tough to beat that by hand with RC, again, unless you start hitting swap.<p>If M1 is faster at memory ops than x86 it&#x27;s because they massively increased memory bandwidth. In fact I&#x27;d go as far as saying the CPU design is probably not responsible for most of the performance increase users are seeing. Memory bandwidth is the bottleneck for a lot of desktop tasks. If M1 core is say 10% faster than x86 but you have more of them and memory bandwidth is really 3x-4x larger, and the core can keep far more memory ops in flight simultaneously, that&#x27;ll explain the difference all by itself.')