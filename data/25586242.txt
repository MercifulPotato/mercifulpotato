Item(by='dragontamer', descendants=None, kids=[25587006], score=None, time=1609363161, title=None, item_type='comment', url=None, parent=25585509, text='I&#x27;m curious: what&#x27;s wrong with myFunc(List&lt;BaseClass * &gt;) ??<p>EDIT: Remember, in C++, &quot;BaseClass&quot; cannot polymorph, only &quot;BaseClass * &quot; can. (BaseClass is where the data is stored precisely. If its 20 bytes of RAM, then DerivedClass might be 24 bytes of RAM, and therefore can&#x27;t fit. But both BaseClass * and DerivedClass * are compatible with each other, and may convert into each other, as long as you know the pointer goes to the right kind of class)<p>And if that&#x27;s not sufficient, then a static_assert over the type information is probably what you need. Ex:<p><pre><code>   template&lt;class T&gt;\n   void myFunc(List&lt;T&gt; list){\n      static_assert(std::is_nothrow_convertible(T, BaseClass)); &#x2F;&#x2F; I haven&#x27;t tried, but this probably works\n   }\n</code></pre>\nThat&#x27;s what I mean about C++ templates: they&#x27;re a meta-language. You can add if-statements &#x2F; else statements over type information at compile-time in C++.<p>In this case, we&#x27;ve created a static_assert (aka: a compile-time error will pop up) if T does not convert into BaseClass (note: T may have a CopyConstructor(BaseClass), so maybe its not exactly tthe same concept as what you&#x27;re trying to do... but this gives you an idea of C++isms...)')