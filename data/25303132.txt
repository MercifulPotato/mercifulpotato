Item(by='zerkten', descendants=None, kids=[25304453], score=None, time=1607094978, title=None, item_type='comment', url=None, parent=25302555, text='&gt;&gt; So, in reality, the right solution is probably: use UUIDs for keys, and donâ€™t ever expose them.<p>&gt; Can someone shed light on this?<p>Some of the answers over at <a href="https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;218306&#x2F;why-not-expose-a-primary-key" rel="nofollow">https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;2183...</a> cover the reasoning that I had been taught in the mid-nineties: it&#x27;s an implementation detail and there are better choices to expose outside the database.<p>When it comes to UUIDs, these often have a usability penalty when exposed to users. There may be something better to expose to users depending on the context, but not always. It&#x27;s never an absolute. Since few people now start by building their database first with relatively rigorous modeling, it&#x27;s hard to avoid the outside exposure.<p>You should consider the situation though. In the early-2000s, there was a raft of web apps built in the .NET space that exposed GUIDs just because they were cool (I&#x27;ve literally heard them described as that), or devs didn&#x27;t think about the implications. As with many ASP.NET abstractions at the time, these were problematic in the contexts used: Web Forms relied on POSTing everything and now your URLs weren&#x27;t &quot;hackable&quot;.<p>Retrofitting UUIDs is possible if you are using other keys. If you are merging databases you can introduce these to get the data merged, as long as you are OK with some level of fix-ups to the original (integer?) primary key that you&#x27;ve exposed to the application. Ultimately, it becomes an application problem if you have collisions in the original IDs.')