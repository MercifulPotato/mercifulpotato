Item(by='exogen', descendants=None, kids=[24674708], score=None, time=1601756429, title=None, item_type='comment', url=None, parent=24670252, text='Advice on the &quot;A Broken DOM&quot; section: it sounds exactly like a hydration mismatch. Hydration is the process of React correlating existing DOM nodes from server-rendered HTML (SSR) with the initial render of the React app on the browser-side. (As opposed to what happens without SSR, which is almost always the app being rendered into an empty DOM node – no content exists yet.)<p>Satisfying hydration constraints is by far the hardest part of doing React server-side rendering. The basic requirement is: whatever HTML you rendered on the server, the initial render of the browser app MUST output that exact same DOM structure. Otherwise, it won&#x27;t be able to correlate them correctly, and will get confused about which DOM nodes to update. You can seriously mangle your entire page this way – but usually, it looks like nearby content stuck in the wrong place, or incorrect updates.<p>Some things that lead to hydration mismatches:<p>- Time-based rendering. Time passes between when the server rendered the HTML and the browser initializes the app. So any component using `new Date` to make decisions can potentially have a hydration mismatch.<p>- Randomization. Let&#x27;s say you wanna choose a random promo image to show. The `Math.random()` result is going to be different on the server and client.<p>- Anything involving browser APIs, like the browser window size, or checking `typeof window`, etc. The server has no access to this info, so it either needs to skip rendering that content, or fallback to a default.<p>Once in the browser, here&#x27;s the important part: you need the app&#x27;s components to make all the same rendering decisions that they made on the server, <i>on the first pass</i> specifically (when hydration occurs). Then, using the component lifecycle, you can make them update to take the latest client-side info into account.<p>In other words, it&#x27;s not enough to simply detect `typeof window` and render different content – you&#x27;re only &quot;allowed&quot; to render that different content <i>after</i> the app has done its initial mount.<p>The somewhat-reassuring aspect of all this is that it&#x27;s almost certainly your components at fault, not Gatsby or React, so it can always be fixed without too much effort. But it&#x27;s an annoying foot-gun to have to worry about nonetheless.')