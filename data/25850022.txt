Item(by='ledauphin', descendants=None, kids=[25850443, 25850530, 25872315], score=None, time=1611167340, title=None, item_type='comment', url=None, parent=25848542, text='I don&#x27;t mean to derail the conversation, but this really does remind me of the game Factorio, though sort of in reverse.<p>In Factorio, you build a larger and larger factory out of pre-established functional components (assemblers, labs, chemical plants, etc) that take in a limited set of inputs and produce (usually) a single output. Your challenge is not to define the functional core processes, but instead to wire together those functional components by connecting their inputs and outputs in ever-more-automated fashion, starting by hand, then using simple belts (pipes) that eventually allow arbitrary load-balancing via &quot;splitters&quot;, and eventually through to trains (the forking and load balancing happening via backpressure in the train system) and robots (where everything is managed essentially as a single state database of requests, and backpressure is provided by output limitations, usually per functional component).<p>Naively, I think that someday a decent chunk of programming might actually look like this, and parts even be represented visually (though in my opinion likely still defined formally as text). Only I think programmers will continue to write the functional components themselves, unlike in Factorio. They&#x27;ll just live on different levels of the &quot;codebase&quot;, and the &quot;pipes&quot; level will likely be a lot more abstracted than it is in Factorio.<p>As a software developer, I find this paradigm to map very well to serverless architectures, because you generally want to think a level higher than the per-machine basis. It does require a willingness to forgo handy and well-established tools like the filesystem and Unix pipes in favor of higher level abstractions around transfer and storage of data.')