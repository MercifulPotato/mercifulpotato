Item(by='Silhouette', descendants=None, kids=[25807359], score=None, time=1610847268, title=None, item_type='comment', url=None, parent=25805402, text='FWIW, everything I wrote before was intended to refer to JS and TS as they are today. I would certainly agree that today&#x27;s JS is much better than the JS of the pre-ES6 era, but the JS of the pre-ES6 era was objectively one of the worst programming languages ever to gain significant adoption, so that&#x27;s not exactly a high bar to clear.<p>Unfortunately, even with the useful additions to the language, a lot of the historical baggage is here to stay. The dynamic nature of the language means everything is nullable by default, except with JS there are two distinct null-like values. The type coercion rules have all kinds of strange consequences. It can&#x27;t make up its mind whether to make standard library tools standalone functions or methods called on something and the two don&#x27;t compose well with JS syntax, which is never great but particularly annoying if you&#x27;re trying to write code in more of a FP style. Everything is mutable by default and side effects are totally uncontrolled, with the same observation. Idiomatic JS relies on magical global variables, which differ depending on the platform it&#x27;s running on. It has exceptions but limited tools for using them systematically, particularly in larger programs.<p>Obviously vanilla JS is also missing all the benefits of a more expressive and static type system, which is where TS comes in and why TS has rapidly become the preferred option for many front-end developers as they have more code to work on. However, the TS type system is still ultimately dealing with the underlying JS types and the tools JS provides for working with them, which means it&#x27;s not entirely sound. Even with the TS additions, you still don&#x27;t get the kinds of algebraic data types and pattern matching that are entry-level features for languages with good static type systems these days.<p>The standard library is still weak. Yes, it&#x27;s true that there are many utility libraries you can readily include in your project dependencies to help with that, but that is part of the problem. The benefit of a comprehensive <i>standard</i> library is that everyone has the same version of that functionality available with no extra code required. No need for maybe dozens of extra indirect dependencies in your project because each library you depend on directly has its own preferences for which utilities to use. No need to worry about whether the utility library you picked plays nicely with optimisations like tree-shaking or you&#x27;ve just added extra bloat to your bundle. No need to worry about whether different utility libraries have compatible representations for structured data or follow the same conventions for parameter orders. Lodash and friends are great and they do reduce the problem, but they shouldn&#x27;t need to exist in the first place.<p>And all of this has consequences for the whole ecosystem, from the capabilities and performance of the tools we use to work with JS&#x2F;TS code every day to the dependency hell problem, and also for the general programming knowledge and skill of developers who have primarily or only worked in JS and TS. I don&#x27;t know your own background, so I don&#x27;t know how to interpret your feeling that you are highly productive in JS. All I can tell you is that as someone who has also programmed in many other languages and in many contexts away from web development, much of the JS ecosystem is very far behind the state of the art.<p>I am hopeful that this will improve in time, even if we do get stuck with JS and derivatives compiled down to it. TS is at least trying to improve one aspect, with a better type system overlaid on top. There are build tools now that Just Work for everyday tasks instead of requiring endless tweaking of configuration files and installation of plugins. There is at least one build tool in development that isn&#x27;t several orders of magnitude slower than it needs to be, unlike every major bundler&#x2F;optimiser currently in widespread use within the JS ecosystem.<p>But these incremental improvements, welcome as they are, can only go far as long as the JS heritage underpins everything. The one thing that could improve the performance of the web development community dramatically and across the board, far more than any single new tool or library, is a language designed to do the job properly and taking advantage of everything we&#x27;ve now learned about programming, programming languages and programming for web development.')