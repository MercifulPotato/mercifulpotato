Item(by='mjevans', descendants=None, kids=None, score=None, time=1610002915, title=None, item_type='comment', url=None, parent=25667703, text='Think about how CPUs access RAM, Random Access Memory.<p>Now think about how you would store and process the ECC (checksum &#x2F; parity data) without the optimally dispersed bits.<p>This is very much like RAID-5,6,Z or like the addition of integrity codes in other media.  CDs and DVDs have the ECC protected data as the default layer and also expose the raw blocks to the OS.<p>Random seeks in a CD &#x2F; DVD were possible because the device could start reading from anywhere and get back a full stream of data.<p>With RAM used the same way the first question is: Where is the ECC decision drawn?  Is it per bus word (E.G. 128 or 256 bits), an OS page (often 4KByte for common OSes), some other unit?  Next is where is the ECC data stored?<p>If you&#x27;re keeping this efficient smaller reads are better, and the 4KByte OS page is a common multiple for lots of things so at the moment that&#x27;s about where I&#x27;d draw the line.  Dedicating silicon to calculate the parity on a page that large is probably way more expensive than gates for a couple extra bits per native word (and designs that might also match parity used for internal cache too and thus could be reused), but would be a logical maximum for doing something the hard way.<p>Virtual page alignment would also be a performance issue, and the cache would have an effectively fixed blocksize and read-ahead granularity.<p>Or everyone could just use the one already developed industry standard that was optimized by engineers not thinking on the back of a napkin.')