Item(by='akra', descendants=None, kids=None, score=None, time=1604874045, title=None, item_type='comment', url=None, parent=25017841, text='Not quite. There is an advantage to being &quot;chatty&quot; that GraphQL proponents don&#x27;t often mention IMO. You can load balance each of those join requests, cache those GET requests even if they make up only a part of the overall query, shard the storage to multiple servers, rate limit, etc. Spreading requests is usually a good thing; with HTTP&#x2F;2 the overhead of those extra requests is extremely low as well. It allows sharded processing with approx equal load between nodes at the backend.<p>Its much easier to define SLA&#x27;s and manage your traffic profile&#x2F;platform when the load of each &quot;query&quot; is definitely quantifiable and granular - unlike a GraphQL query.<p>Then people come to me and say - well you can pre-can your GraphQL queries so that you know which queries are going to be run therefore you have known performance. At which point I say - why not just make a specialised REST endpoint with that query inside it?<p>I see it as a good backend-for-frontend adapter technology where a bulk query can be sharded into individual smaller ones using core backend services for large use-case specific views. If a query uses too much resources then the GraphQL server and&#x2F;or a client ID can be rate limited by the backend servers, etc. Which is why I think its mainly a JS thing to date IMO - it doesn&#x27;t solve many core problems for most backends - it solves typical front-ender dev&#x27;s issues who can&#x27;t&#x2F;don&#x27;t want to write server side code.')