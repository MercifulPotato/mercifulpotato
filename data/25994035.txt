Item(by='ncmncm', descendants=None, kids=[25994728, 25994225], score=None, time=1612214006, title=None, item_type='comment', url=None, parent=25990585, text='This is about runtime binding vs static binding, not static objects or static members. There is still a &quot;this&quot;, but the code that will run is known up front -- &quot;ahead of time&quot;.<p>C++ went through this 25+ years ago: runtime binding, what in C++ is virtual functions, is a <i>niche technique</i>. Most C++ programs don&#x27;t use it at all, or use it in only one or two spots. When it is the right thing, it makes the work convenient, but it really is just a dance with function pointers. In C++, templates do the heavy lifting.<p>Java never offered any other support for organizing programs, so inheritance and virtual functions have been your go-to for everything, no matter how bad the fit. In a static call there is only one bit of code to run, and it never changes over the life of the program. Just like <i>almost everything</i>, really, except here your runtime knows up front.<p>It was always a dumb choice to make member functions default to virtual semantics, when they almost always don&#x27;t need it, and it just costs performance to no purpose. That is what comes out of treating language design as a marketing exercise: Java&#x27;s designers really (and openly) cared less than nothing about object-oriented programming. They thought people really ought to be coding Lisp. Forcing runtime binding was a way to sneak in something a little bit lispy, and maybe get people used to production code running no faster than Lisp.')