Item(by='aldanor', descendants=None, kids=[24653671], score=None, time=1601554758, title=None, item_type='comment', url=None, parent=24649747, text='The difference here is that, C++ templates are closer to just &quot;string replacement&quot;, as they&#x27;re not validated (basic syntax aside) until you instantiate them. As such, in C++, your generic type T can be whatever the user decides to stick in there (you can&#x27;t prevent them doing that), and so you typically have a chance of disabling&#x2F;enabling certain bits of code by checking various type traits and using hacks like sfinae etc (e.g., &quot;if T is an enum - please use this version of this method; otherwise - substitute this version of the same method&quot;, this would be quite typical and idiomatic in C++).<p>In Rust, generic code is fully validated as it should be, with all trait bounds being matched where need be. So you would rarely end up with needing to figure (at compile time) whether generic type T is an enum or not - because it wouldn&#x27;t allow you to do anything extra with it out of the box. In Rust, an idiomatic way of adding different behaviours based on the kind of the generic type would be using traits still - e.g., you can have multiple impl blocks on your generic type, each one having different trait bounds on the generic parameter, like - if T: Copy, then implement these extra methods; standard library has tons of examples like this. The only exception that comes to mind is proc macros - when you deal with Rust code in AST form and generate new code at pre-compile-time phase, but that&#x27;s a completely different story and not really related.')