Item(by='simias', descendants=None, kids=[25387032], score=None, time=1607698896, title=None, item_type='comment', url=None, parent=25385782, text='I feel like we&#x27;re kind of mixing up a bunch of things here, or maybe I am.<p>The reason you don&#x27;t need to mess with GRUB or you BIOS when you change your\nhardware is that modern hardware interfaces have built-in discovery and resource\nallocation features. Before that you had to deal with pesky low level details\nlike IRQ allocations and the like (which was a thing on PC not that long ago).<p>That&#x27;s not really a feature of &quot;PC&quot; per se, it&#x27;s a feature of USB, PCI etc...\nThat stuff works exactly the same on ARM or anywhere else.<p>The things that need to be described in the device tree are generally internal\ncomponents of the SoC and motherboard, things like IO expanders, SPI interfaces,\nserial interfaces, and of course the USB&#x2F;PCI&#x2F;... controllers themselves.<p>I think there maybe some confusion because of the term &quot;bootloader&quot;. It&#x27;s true\nthat both u-boot and GRUB are bootloaders, but bootloaders in the ARM world have\na lot more to do than PC bootloaders, they&#x27;re effectively the equivalent of UEFI\n+ GRUB, not just GRUB. You can write a simplistic boot sector loader for PC in a few hundred ASM opcodes, that would be a lot more difficult for the average ARM bootloader because there&#x27;s a lot more to do before you can just call into Linux. In general you won&#x27;t even have RAM or caches available when u-boot begins executing.<p>And I think it&#x27;s actually a better design, because it means that proprietary\nbuilt-in firmware crap is usually kept to a minimum on ARM: the BOOTROM usually\njust initializes the bare minimum to be able to load u-boot (or some other\nloader) into on-chip SRAM and then it&#x27;s over. Of course that means that the loader is\nsignificantly more complex, but that complexity has to be some place or an\nother.')