Item(by='spiffytech', descendants=None, kids=[25799099, 25798833], score=None, time=1610754266, title=None, item_type='comment', url=None, parent=25797624, text='I&#x27;ve been building some projects with Crank.js and Mithril, both of which require an explicit function call to rerender the application after changing state.<p>In theory, that sounds terrible; I don&#x27;t want to keep track of when my app needs to rerender, or worry about a stale DOM because I forgot to rerender after some event.<p>In practice, it&#x27;s a breath of fresh air compared to my work with React&#x2F;Vue&#x2F;Svelte. Everything is just so <i>simple</i>; I can use vanilla JS data structures and code organization patterns. I can architect my frontend state and logic in the way that makes the most sense for my domain, instead of ceding control flow to a heavy, footgun-y, limited-expressivity framework that demands to know everything my app does so it can decide on its own when to rerender.<p>I&#x27;m tired of debugging confusing bugs because React hooks mix asynchronous control flow inside the render loop and my app has to have correct rendering and logic for every intermediate state of a chained sequence of useCallback&#x2F;setState hooks. Tired of telling my team we have to put off a feature because it&#x27;ll take a week to do something that feels like a 3-hour task because refactoring around a framework&#x27;s control structures is harder than refactoring ordinary JS features. Tired of magic reactive compilers that create buggy renders and template languages that are only nice to work with if you use the One True Blessed VS Code Plugin, and tired of frameworks that need CLI scaffolding tools because they&#x27;re more complicated than anyone wants to initialize with a blank editor.<p>Crank.js, Mithril, and (at a preliminary glance) Forgo are very compelling to me. They offer the declarative, self-contained nature of components that I love from React&#x2F;Vue&#x2F;Svelte and the type safety of TypeScript for view code instead of template strings. My whole project scaffolding is just installing esbuild and generating a tsconfig.json. Maybe toss in browser-sync and watchexec if I&#x27;m feeling fancy. I don&#x27;t need to make major architectural decisions based on the preferred state management tool, because these frameworks couldn&#x27;t care less about how state is managed. And if I <i>really want</i> automatic rerenders, it&#x27;s 10 LOC to write a reusable ES6 Proxy that returns an object I can dump state values into that will auto refresh if I reassign a property.<p>And these frameworks still feel like a state machine in the same way React does - view code is declaratively rendered from application state. There is synchronization of state to DOM, but only in the sense that you have to explicitly invoke the declarative engine, and not in the sense that you have to manually synchronize like you would using jQuery to find and change DOM nodes.<p>Keeping up with manual refreshes feels so simple and easy compared to all the hoops I&#x27;ve jumped though with the household name frameworks.')