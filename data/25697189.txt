Item(by='peter_d_sherman', descendants=None, kids=None, score=None, time=1610167826, title=None, item_type='comment', url=None, parent=25697163, text='&gt;&quot;ELVM is similar to LLVM but dedicated to Esoteric Languages. This project consists of two components - frontend and backend. Currently, the only frontend we have is a modified version of 8cc. The modified 8cc translates C code to an internal representation format called ELVM IR (EIR). Unlike LLVM bitcode, EIR is designed to be extremely simple, so there&#x27;s more chance we can write a translator from EIR to an esoteric language.<p>Currently, there are 48 backends:<p>Awk (by @dubek)<p>Bash<p>Befunge<p>Brainfuck<p>C<p>C++14 constexpr (compile-time) (by @kw-udon)<p>C++ Template Metaprogramming (compile-time) (by @kw-udon) (WIP)<p>C# (by @masaedw)<p>C-INTERCAL<p>CMake (by @ooxi)<p>CommonLisp (by @youz)<p>Crystal (compile-time) (by @MakeNowJust)<p>Emacs Lisp<p>F# (by @masaedw)<p>Forth (by @dubek)<p>Fortran (by @samcoppini)<p>Go (by @shogo82148)<p>HeLL (by @esoteric-programmer)<p>J (by @dubek)<p>Java<p>JavaScript<p>Kinx (by @Kray-G)<p>LLVM IR (by @retrage)<p>LOLCODE (by @gamerk)<p>Lua (by @retrage)<p>Octave (by @inaniwa3)<p>Perl5 (by @mackee)<p>PHP (by @zonuexe)<p>Piet<p>Python<p>Ruby<p>Scheme syntax-rules (by @zeptometer)<p>Scratch3.0 (by @algon-320)<p>SQLite3 (by @youz)<p>Swift (by @kwakasa)<p>Tcl (by @dubek)<p>TeX (by @hak7a3)<p>TensorFlow (WIP)<p>Turing machine (by @ND-CSE-30151)<p>Unlambda (by @irori)<p>Vim script (by @rhysd)<p>WebAssembly (by @dubek)<p>WebAssembly System Interface (by @sanemat)<p>Whirl by (@samcoppini)<p>W-Machine by (@jcande)<p>Whitespace<p>arm-linux (by @irori)<p>i386-linux<p>sed<p>The above list contains languages which are known to be difficult to program in, but with ELVM, you can create programs in such languages. You can easily create Brainfuck programs by writing C code for example. One of interesting testcases ELVM has is a tiny Lisp interpreter. The all above language backends are passing the test, which means you can run Lisp on the above languages.<p>Moreover, 8cc and ELVM themselves are written in C. So we can run a C compiler written in the above languages to compile the ELVM&#x27;s compiler toolchain itself, though such compilation takes long time in some esoteric languages.&quot;<p>[...]<p>&gt;&quot;ELVM internals<p>ELVM IR<p>Harvard architecture, not Neumann (allowing self-modifying code is hard)<p>6 registers: A, B, C, D, SP, and BP<p>Ops: mov, add, sub, load, store, setcc, jcc, putc, getc, and exit<p>Psuedo ops: .text, .data, .long, and .string\nmul&#x2F;div&#x2F;mod are implemented by _builtin*<p>No bit operations<p>No floating point arithmetic<p>sizeof(char) == sizeof(int) == sizeof(void*) == 1<p>The word-size is backend dependent, but most backend uses 24bit words<p>A single programming counter may contain multiple operations&quot;')