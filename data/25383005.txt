Item(by='ashtonkem', descendants=None, kids=None, score=None, time=1607668508, title=None, item_type='comment', url=None, parent=25377928, text='&gt; That sounds more like an indictment of functional programming rather than Clojure specifically.<p>I&#x27;d say that it&#x27;s a problem (not indictment!) of Lisp style[0] functional programming, where there&#x27;s a pretty hard wall between how you organize your data and your functions[1]. If we&#x27;d been using Haskell, we could have at least declared a type class for our shared behavior and used that to handle the different parts of behavior in the pipeline.<p>I say problem with some reservations, because your mileage will vary depending on the domain in question. My current team could use Clojure quite effectively since the domain is much more amenable to how Clojure approaches these problems. My position is less &quot;this doesn&#x27;t work&quot; and much more &quot;this has some tradebacks you should be aware of&quot;.<p>&gt; I’m not a seasoned functional programmer but I often read glowing praise from others about the use of pattern matching in their code.<p>Pattern matching is superior to if&#x2F;else&#x2F;else if trees, full stop. If you <i>have</i> to have a bunch of if&#x2F;else trees, you&#x27;d rather use pattern matching.<p>The problem comes when you start repeating the same if&#x2F;else conditions (not behavior) in multiple places. In a language like Java, you would naturally start wondering if you should make a class or interface to factor this out somehow. In a language like Clojure you don&#x27;t have nearly as many tools laying around to collect common behavior into shared locations. You can do it, but you&#x27;ll be happier the less you have to use multi-methods and defrecords.<p>&gt; I thought that multi-methods were supposed to be the solution to the expression problem<p>Multi methods are ... ok. There are a few footguns laying around with them, since using them suddenly makes imports side-effectful, but I can and have used them successfully.<p>The issue is that multi-methods inherently give you one function, and there&#x27;s no real way to tie several of them together at all. That&#x27;s great if your domain is organized in such a way that you can use a single multi-method in one spot to break up the dispatch tree. It&#x27;s less great if you need to use multi-methods multiple times during processing to specialize based on similar traits of the data. You <i>can</i> do it, but it&#x27;s error prone and you&#x27;ll end up with a nagging feeling that you&#x27;re just making a really bad object system using multi-methods.<p>&gt; It was my understanding that multi-methods are supposed to allow open extension of behaviour without having to do what you just described; track down every instance, and cover every case.<p>Yes, and it&#x27;s this open-ended nature that kind of screws you in some cases. If I have four multi-methods that all need to cover the same cases (with different behavior), it&#x27;s real easy for me to forget one when modifying my code. That same flexibility in adding instances means that there&#x27;s nothing preventing me from forgetting one too.<p>&gt; couldn’t you just co-locate the method implementations next to the data they are supposed to operate on<p>Well, the data came from Bloomberg, so there was nowhere we could put them that would be &quot;next to&quot; the data. We could put them all in one namespace, but that starts getting unwieldy fast. We could separate them out into different namespaces for clarity, but now it&#x27;s even easier to miss that you&#x27;ve forgotten things. It&#x27;s a tough trade-off.<p>Oh, and multi-methods really messed with our dev tools at the time. Hopefully they&#x27;ve fixed it since then, but a lot of the time Cursive Clojure wouldn&#x27;t refresh them properly, resulting in dozens of REPL restarts for those of us that preferred Cursive. That got old fast.<p>0 - As long as you pretend CLOS isn&#x27;t a thing. This isn&#x27;t a big deal, since lots of people like to pretend that CLOS isn&#x27;t a thing.<p>1 - Yes yes, I know &quot;functions are data too&quot;, that indeed was a neat trick ... half a century ago. In Lisps the hard wall is in organization; there typically is very little binding the data to functions like you get with objects[0] or even Haskell style typeclasses. Getting the right data into the right function is entirely driven by how functions are called, rather than by the data itself.')