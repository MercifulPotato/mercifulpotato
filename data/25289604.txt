Item(by='CydeWeys', descendants=None, kids=[25297375, 25293222], score=None, time=1607008659, title=None, item_type='comment', url=None, parent=25289292, text='It&#x27;s worth pointing out that several of the concerns mentioned here are specific to the Bitcoin protocol (e.g. SHA256^2 hashing) and aren&#x27;t relevant to the use of Base58 as a general encoding scheme.  The main issues that are non-Bitcoin-specific are: compatibility with QR encoding schemes, difficulty reading out loud mixed case strings, and higher efficiency encoding to Base32 (you can do it all with CPU-friendly bitwise operators).<p>So if you care about either of those things, then a Base32 encoding may well be good for you.  But personally, my use of encodings like these tends to be for GUIDs and such, which I want to encode as a string, take up as little space as possible in URLs, and be maximally compatible with URL parameters and such.  Base58 works great for that, and indeed I&#x27;ve been using it for that purpose for almost a decade now.  There are some pretty serious efficiency losses from stepping down to Base32 that I don&#x27;t want to incur (you&#x27;re almost halving the size of your alphabet, so every byte you want to encode requires nearly another entire bit).<p>And, crucially, I&#x27;m not actually ever even decoding&#x2F;encoding these strings back to their numeric value because the string itself then becomes the unique identifier (as it&#x27;s way easier to work with in the fullstack from DB all the way on up through front-end than a byte or GUID type would be), so the encoding efficiency improvements that are salient for Bitcoin when you have thousands of these to decode in each block you want to validate just don&#x27;t matter.')