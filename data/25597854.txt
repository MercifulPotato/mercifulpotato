Item(by='svat', descendants=None, kids=None, score=None, time=1609453303, title=None, item_type='comment', url=None, parent=25597842, text='So with that understanding in the comment above, a case study of the ADVENTURE program (<a href="http:&#x2F;&#x2F;literateprogramming.com&#x2F;adventure.pdf" rel="nofollow">http:&#x2F;&#x2F;literateprogramming.com&#x2F;adventure.pdf</a> or download from <a href="https:&#x2F;&#x2F;github.com&#x2F;shreevatsa&#x2F;knuth-literate-programs&#x2F;blob&#x2F;master&#x2F;programs&#x2F;advent.pdf" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;shreevatsa&#x2F;knuth-literate-programs&#x2F;blob&#x2F;m...</a> for working hyperlinks). I think that even though the program was written in the order it&#x27;s written (and he thinks best read that way), the following is the structure of the ADVENT program (and one is supposed to glean that first). The whole program is divided into numbered sections, grouped into what I&#x27;ll call &quot;chapters&quot;. They are:<p>- In &quot;Introduction&quot; (sections 1–3), the program&#x27;s overall outline is given,<p>- In &quot;The Vocabulary&quot; (sections 4–17), we have data structures for storing words (the hash table), how they map to motions and objects and other responses from the program,<p>- In &quot;Cave Data&quot; (sections 18–20) there are the 100+ locations one can be in during the game,<p>- In &quot;Cave Connections&quot; (sections 21–62) there&#x27;s the game&#x27;s &quot;map&quot; data: how you get around, what messages you get, etc,<p>- In &quot;Data structures for objects&quot; (sections 63–68), there&#x27;s data structures for the list of (game) objects at a given location, for groups of objects, and object properties (like its name and in-game note),<p>- In &quot;Object data&quot; (sections 69–70) these are populated,<p>- &quot;Low-level input&quot; (sections 71–73), is just asking yes&#x2F;no questions and taking in commands,<p>- The next chapter, &quot;The main control loop&quot; (sections 74–91) begins with some comments very revealing about the author&#x27;s programming style &#x2F; thinking:<p>&gt; <i>Now we’ve got enough low-level mechanisms in place to start thinking of the program from the top down, and to specify the high-level control. […] Here is our overall strategy for administering the game. […] The execution consists of two nested loops: There are “minor cycles” inside of “major cycles.” Actions define minor cycles in which you stay in the same place and we tell you the result of your action. Motions define major cycles in which you move and we tell you what you can see at the new place.</i><p>etc. And this chapter, in turn using many of the following ones, is what populates one of the main sections that were mentioned in the outline of the program on Page 2. There&#x27;s parsing of the user&#x27;s input, dealing with edge cases, until we figure out where to `goto`.<p>- The next chapter, &quot;Simple verbs&quot; (sections 92–103) starts with <i>“Let’s get experience implementing the actions by dispensing with the easy cases first”</i> i.e. it&#x27;s the start of several chapters implementing the action procedures we invoke (or to which we &quot;goto&quot;) from the previously mentioned main control loop.<p>- The next chapter, &quot;Liquid assets&quot; (sections 104–115) starts with something that I also find revealing: <i>&quot;Readers of this program will already have noticed that the BOTTLE is a rather complicated object, since it can be empty or filled with either water or oil&quot;</i> (so he expects that your reading will have noticed this already?)<p>- Then &quot;The other actions&quot; (sections 116–139) is what you&#x27;d expect: &quot;Now that we understand how to write action routines, we’re ready to complete the set&quot; (must say, this whole game looks a lot of fun! Thanks Crowther and Woods!)<p>- Then &quot;Motions&quot; (sections 140–153) (filling out a section referred to in the main control loop above), &quot;Random Numbers&quot; (sections 154–158, half a page), &quot;Dwarf stuff&quot; (sections 159–176), &quot;Closing the Cave&quot; (177–182), and &quot;Death and Resurrection&quot; (183–192), &quot;Scoring&quot; (193–199), and &quot;Launching the program&quot; (section 200).<p>Well, with my hard-won familiarity with WEB&#x2F;CWEB conventions of font choice and numbering and so on (I bet you didn&#x27;t expect the table of contents to be on the <i>last</i> page!) and with Knuth&#x27;s style (one can often expect a main control loop branching off to various action procedures), the above is what I understand of the overall structure of the program after a quick reading taking about a second or two per page, maybe a bit more here and there, less than five minutes overall. <i>After</i> that, I feel oriented enough that I can now start reading the program, and I think literate programming (though I haven&#x27;t even started actually reading it!) makes it easier to understand than if it had been written in &quot;for the compiler&quot; order with the same soup of functions and gotos. But to reiterate, LP in this case is about better presentation of programs written in straightforward old-style &quot;just tell the computer what to do&quot; idiom. It is conceivable that with modern programming conventions, with just the right abstractions and objects and whatnot, one could produce something more readable, and which did not have so many global variables and so on. But that&#x27;s not the relevant comparison here, I think (and besides maybe <i>that</i> program too could be reordered, written literately?)<p>Now, the main question that arises is: why not just write out this outline at the beginning? Why is the heart of how the program works, the main control loop, described neither at the beginning nor the end but in the middle of the book, section 74 of 200? Is it fair to the reader to have so many conventions that are not explained in the program itself? Well, I have no end of frustrations with trying to read Knuth&#x27;s literate programs (see my complaints and jokes in the page I linked above and in the slides), but still I think the answer would be: (1) Every house style has its conventions that must be learned (like: &quot;variables ending with an underscore are private member variables in this codebase&quot;), (2) It would be extra work for the programmer to write this all out when the reader can just skim and find out. And for Knuth, literate programming (and programming in general) is supposed to be fun, not drudgery. So while I think Knuth-style literate programming has problems, I think there are more interesting problems  than the surface-level ones. (For example, someone&#x27;s observation that there are approximately as many LP systems as programmers practising LP: no one is comfortable using others&#x27; tools and ultimately wants to write their own tool.)')