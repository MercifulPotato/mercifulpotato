Item(by='AaronFriel', descendants=None, kids=[25180891], score=None, time=1606070928, title=None, item_type='comment', url=None, parent=25179116, text='A properly done effects system with type-level annotation of the &quot;color&quot; of functions helps this, rather than hurts as you might surmise.<p>Take for example logging or tracing - we almost always in a modern backend application want an ambient trace or span ID and a log destination. What we don&#x27;t want is to have to add those as parameters to _every function_.<p>So we want to paint these functions with the &quot;logger&quot; and &quot;traced&quot; colors, which respectively allow a function to send messages to an ambient logger via log(message: str) and to get the current trace context via getTraceContext() each with no other arguments.<p>The compiler will tell us if we call these functions from an unlogged, untraced function, so at a very high level - say at the RPC request level, we paint them early on. In Haskell we might even be able to do something like<p><pre><code>    handleReq req = \n      withTraceSpan (...)\n      . withLogging (...)\n      $ handleReqInner req\n</code></pre>\nWhere handleReqInner requires these &quot;colors&quot;.<p>Having too many effect handlers is never a problem either - you can always call an untraced function from a traced function. The &quot;trace&quot; effect handler just falls off at that call. Or in other words: you can always call a function whose colors are a subset of the call-site&#x27;s.<p>This is somewhat a foreign concept to people who haven&#x27;t worked with type systems like this and whose only concept of the color of function is purely binary - either async or not. In a good typed effect system, the compiler will assist you in knowing where you&#x27;re missing an effect handler, and it will be easy to add those effect handlers sufficiently far from the business logic that you won&#x27;t have to think about it.')