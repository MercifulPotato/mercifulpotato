Item(by='rocqua', descendants=None, kids=None, score=None, time=1611826322, title=None, item_type='comment', url=None, parent=25935766, text='The function system doesn&#x27;t hold &#x27;global&#x27; state. It holds the state in arguments given to functions. If you want a client, you still have a bit of client &#x27;data&#x27; and you pass that around your functions.<p>If you wanna do stuff to the client, you call functions with the client as an argument. If you want polymorphic clients, you define a client typeclass &#x2F; trait &#x2F; interface called Client, and then your functions take a generic Client bit of data.<p>In some sense, this approach is a lot like replacing foo.bar() with foo(bar). Which doesn&#x27;t do much to change your program. The interesting difference in FP is how you &#x27;change the state&#x27; of your client.<p>In FP, if you want your client to e.g. count its connections you would do something like `nextClient = connect(oldClient)` instead of the OOP `client.connect()`. This means that you are a lot more explicit about your state changes. This has a lot of advantages that can be hard to wrap your head around. It also comes with some disadvantages.<p>As a result though, all of your state is carried very &#x27;locally&#x27; in your functions scopes.')