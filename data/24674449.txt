Item(by='btschaegg', descendants=None, kids=[24674579, 24674510], score=None, time=1601756809, title=None, item_type='comment', url=None, parent=24674183, text='On 1.:<p>As others already noted, Git has a GC-mechanism, which means that objects can still linger around in any copy of your repo for a while. And if you need to version binary files, you&#x27;d better use git-lfs or git-annex. Obviously, if you don&#x27;t need them, just nuking them outright with BFG or `git filter-branch` is fine, too.<p>If you&#x27;d like to try git-lfs: It also includes tooling to retroactively migrate your Repository[1], but that&#x27;ll re-write your history (although BFG obviously does that, too).<p>If GCing your repo will not reduce its size, you&#x27;ll probably have to hunt down any remnant branch and&#x2F;or tag that might reference the old history and thus &quot;keep it alive&quot;.<p>On 2.:<p>I&#x27;m not entirely certain I understand you correctly. Which commits were duplicated? The resulting merge commits?<p>Assuming that, if you wanted to, you could probably build some shell script to get rid of them (or use something like `git checkout prod; git rebase -ir &lt;first_commit&gt;` and remove the duplicated merges yourself).<p>But from a repo perspective, this shouldn&#x27;t cause too much trouble (i.e. the additional space required will be negligible), and doing so would, again, mean that you&#x27;ll rewrite history, potentially causing issues for others who still have local copies referencing your old commits.<p>Also: If you try to go the rebase route: Make sure you understand the log Git will create for you. Using `-r`, it will preserve merges, but how they are represented is not very intuitive and you&#x27;ll have to wrap your head around that first.<p>You could also try to achieve the same result with `git filter-branch` and `--commit-filter`. In this case, you&#x27;d probably want to write a script that only performs the `git commit-tree` command if the tree ID passed to the filter is not the same tree as the first parent commit was referencing already (this should weed out all commits that don&#x27;t change anything).<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;git-lfs&#x2F;git-lfs&#x2F;blob&#x2F;master&#x2F;docs&#x2F;man&#x2F;git-lfs-migrate.1.ronn" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;git-lfs&#x2F;git-lfs&#x2F;blob&#x2F;master&#x2F;docs&#x2F;man&#x2F;git-...</a><p>Edit: As an idea for 2.:<p>Describing issues in commit histories as prose text is tricky :). If your problem looks different than I assumed, you could try to create a bogus Git repo that showcases the pattern in its history and put it on GitHub as a reference.<p>You can create &quot;empty&quot; commits for that via `git commit --allow-empty`.')