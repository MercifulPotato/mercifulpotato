Item(by='nendroid', descendants=None, kids=None, score=None, time=1602292694, title=None, item_type='comment', url=None, parent=24735868, text='&gt;Hence why i say why there is a data model mismatch.<p>There is no data mismatch if the data model is richer, than it can cover it. Unless you&#x27;re saying SQL is not rich enough to cover the PL.<p>Well you can implement a database that does that, it just wouldn&#x27;t be table based data storage anymore. Postgresql supports JSON and enums if you want it but the minute you use these types things become less predictable in terms of performance.<p>&gt;ORMs are notorious for being a leaky abstraction. Largely because the object and relational data model dont entirely match.<p>Wrong ORMs are notoriously leaky because the query translation is extra indirection. You need to compile to SQL and the SQL needs to compile to a query plan. This is why ORMS are bad.<p>As for the data types, Objects easily mimic types in SQL. You basically rarely ever encounter problems with incompatible type systems.<p>&gt;When was the last time you wrote a 500 line sql query? A thousand line? My point is that sql queries are short enough, that further abstraction is not really missed. That doesn&#x27;t mean you should put 0 logic in your query.<p>When did you last write a 500 line function? When did you last write a 100 line function? You shouldn&#x27;t be doing that if you are. Case in point, the total lines of SQL written in any source code usually well exceed over 500 and that is a case for composability. T<p>This is no different than regular source code. If you&#x27;re writing 500 line functions in your source code than you&#x27;re not even taking advantage of modularity in programming languages outside of SQL so of course for you it doesn&#x27;t matter. Because composition doesn&#x27;t matter for you period.<p>&gt;This is a strawman.<p>No it&#x27;s a statement written in the english language. A strawman is something that doesn&#x27;t EXIST, because men are made out of flesh not straw.<p>It&#x27;s sort of similar to the non-existence of what was suppose to be written in response to my statement: an actual counterpoint or an argument. But then how can you write such a thing if it doesn&#x27;t exist?<p>&gt;I disagree. At scale you have data that has mixed cardinality. The indirection allows the db to chose the best algorithm given the size of underlying data at runtime. Sometimes that doesn&#x27;t work properly, but the vast majority of time it is a significant benefit. Its sort of like how sometimes compilers dont work properly and you need to hand optimize, but in practise that is rare and you wouldn&#x27;t throw out the compiler because the other 95% of time its better and lower effort than if you had to always do it by hand.<p>Sure but when it comes time to hand optimize SQL is extremely bad and you need to hand optimize SQL all the time. Not necessarily most of the time, but enough times that it&#x27;s a real problem. That is the point and that is what I said. It&#x27;s basically the biggest headache with SQL. If you&#x27;ve ever done analytics you&#x27;d know this is a huge problem.<p>It&#x27;s better to have a language that allows explicit decorators that allow the programmer to choose optimization procedures when needed. Instead in SQL often optimizations come in the form of hacks. Case in point: SELECT * FROM A is worse then SELECT A.column1 FROM A. The later optimization comes in the form of a language hack and not explicit syntax.<p>Not saying the alternative mentioned in the article would solve this problem nor am I saying a solution exists... but if there&#x27;s any big problem with SQL today it&#x27;s hand optimization for sure.')