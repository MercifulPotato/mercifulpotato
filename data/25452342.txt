Item(by='mikewarot', descendants=None, kids=None, score=None, time=1608178084, title=None, item_type='comment', url=None, parent=25439629, text='I think that there are other directions to pursue. (Some overlap, sorry)<p>1. Bidirectional Compilers --  code --&gt; ast --&gt; code, at a bare minimum. All the way to executable and back, if possible.  Except for Macros... it should be fairly easy to ingest any valid program in one language, and output the exact equivalent in another (however clunky). This allows refactoring while staying in a given language with far more flexibility that any IDE trying to guess.<p>2. Time Travel Debugging - if you have something go awry, you should be able to scroll back and forth across its execution until you find where it deviates from expectations.<p>3. Using traditional flow based execution alongside declarative code (I hope I got that term right).  You should be able to do traditional a:= b; (assignment) statements... alongside a different type of form.. the equation   c :== d;  in which ANY change to d is immediately and ALWAYS propagated to c, regardless of what&#x27;s going on in the flow of control.  Verilog and other languages for programming FPGA and other systems handle hardware that executes all instructions in a circuit.<p>4. Imperative, Declarative, Functional, Object Oriented, Concatenative programming all in one box... with support for infix, prefix, and postfix functions all at the same time. (After all, they are just transformations of each other)<p>5. Hard and soft&#x2F;no type systems that let the user slide between the ends of the scale.  If you&#x27;re just prototyping something, who cares what the types are, as it gets used, start to lock it down, as the user permits.<p>6. Rich text source... like ColorForth, where you can just tell the computer that X is a string literal, variable, function, or whatever attributes you care to assign to it, and the users preferences then indicate to them what it is. Last resort would be to spit it all out in text.<p>7. Notebooks - The idea of using notebooks like Jupyter instead of IDE or a REPL allows prototyping and eases the discovery of solutions by lowering the cost of trying an idea out, and making the stack of ideas required to implement an idea smaller.<p>8. Parallel processing, en mass, as we move to 50+ core processors, and programmable hardware, the idea of a single control flow running the show becomes absurd. Even low end embedded devices are starting to have FPGA peripherals.<p>9. Least privilege &#x2F; Multilevel Secure Systems - Eventually, the admins of the world will realize the folly of using Unix like systems where everything is based on the users level of access, and migrate to systems which allow no access by default. In those environments, code needs to handle the IO it is given, instead of just driving everything. This is the next step in evolution from interactive command line apps --&gt; windows apps that deal with events --&gt; apps that only get given IO<p>10. We can make things better, but we have to stop making them worse first... peak usability happened with Hypercard, VB6, Delphi, and it&#x27;s gone downhill since.')