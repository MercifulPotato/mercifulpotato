Item(by='skissane', descendants=None, kids=None, score=None, time=1606699299, title=None, item_type='comment', url=None, parent=25249756, text='&gt; There are tons of programs that do not go through &quot;the&quot; libc under Linux<p>I agree with you there. This is a big problem with using the classic environment subsystem model.<p>&gt; Plus you still want all the fine semantics of Linux (mmap, cow or at least cow-like, etc.) and for tons of calls the libc is a trivial layer anyway, so you are not gaining much.<p>One potential advantage to the environment subsystem model â€“ it might have pushed them to enhance the NT API to be closer in feature parity to the Linux API, which could then have benefited Win32.<p>&gt; I doubt they would have been able to follow the upstream quickly enough, at least not without a pretty big dedicated team, and it seems difficult to justify.<p>Well, one relevant difference is that Linux is much more of a moving target than POSIX or OS&#x2F;2 are. POSIX is a formal standard, and changes in formal standards are <i>slow</i>, they take years.<p>Back in the 1990s, OS&#x2F;2 was a moving target, with IBM coming out with new versions with new features (2.x, 3.x, 4.x). But, Microsoft had decided they only wanted to support OS&#x2F;2 1.x, and to ignore all new features in OS&#x2F;2 2.x and higher, which made Microsoft&#x27;s task much simpler. And even back when IBM was actively developing OS&#x2F;2, they couldn&#x27;t attain anywhere near the pace of change which is happening with Linux. Linux has far more people working on it than IBM ever had working on OS&#x2F;2; and IBM, certainly back then (I don&#x27;t know whether it is still true today), was notorious for slow, cumbersome and overly bureaucratic development practices, which was another limit on OS&#x2F;2&#x27;s velocity.')