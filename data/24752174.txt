Item(by='zozbot234', descendants=None, kids=[24752423], score=None, time=1602487317, title=None, item_type='comment', url=None, parent=24752097, text='Memory safety errors are a far bigger &quot;annoyance&quot; to the profession than dealing with a slightly more complex (but still quite elegant) syntax or understanding borrowck diagnostics (&quot;fighting with the borrow checker&quot;). It&#x27;s not even close.<p>The problem with unsafe programming in the traditional C style (with its heavy reliance on shared, mutable, possibly aliased pointers) is that it&#x27;s inherently non-compositional: proving safety or correctness of such a piece of code is a &#x27;global&#x27; problem that cannot be meaningfully decomposed or modularized. That&#x27;s why Rust&#x27;s choice of explicitly restricting these features to &quot;unsafe&quot; blocks feels intuitively right - the &quot;safe&quot; part of Rust is essentially the part that can be worked with in a highly modular way, where safety is checked &#x27;locally&#x27; via a type system. Future versions of Rust may well make some currently-unsafe features slightly easier to use, perhaps even more idiomatic in a way that might appeal to C developers, but some inherent constraints will remain.')