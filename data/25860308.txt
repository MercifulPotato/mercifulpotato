Item(by='dwohnitmok', descendants=None, kids=[25861602], score=None, time=1611245129, title=None, item_type='comment', url=None, parent=25856976, text='&gt; I think this is a wrong use of the term &quot;dependent types&quot;.<p>The operative term here is &quot;a certain amount.&quot; `typeof` in Typescript is definitely a dependent type operator (it takes a runtime value and extracts its type which can then be used as a type signature for other types).<p>You don&#x27;t have full-spectrum dependent types a la Idris, but you do have some amount of dependent typing. See for example<p><pre><code>    type MyResult&lt;T extends boolean&gt; =\n        T extends true ? { tag: &#x27;a&#x27; } : { tag: &#x27;b&#x27; }\n\n    function outputTypeDependsOnInputValue(\n        value: boolean\n    ): MyResult&lt;typeof value&gt; {\n        if (value) {\n            &#x2F;&#x2F; replacing &#x27;a&#x27; with &#x27;b&#x27; is a type error\n            const result: MyResult&lt;typeof value&gt; = { tag: &#x27;a&#x27; };\n            return result;\n        } else {\n            &#x2F;&#x2F; replacing &#x27;b&#x27; with &#x27;a&#x27; is a type error\n            const result: MyResult&lt;typeof value&gt; = { tag: &#x27;b&#x27; };\n            return result;\n        }\n    }\n</code></pre>\nNow there&#x27;s a good deal of limitations and hackiness here in how you call this function (in particular you need some weird overloadedness to preserve the types at call sites), but it is really some measure of dependent types! I&#x27;ll include a full example at the end of this post.<p>&gt; Dependent type systems are complex because they also want to be sound.<p>Dependent Haskell, if it lands, will not be sound (TypeInType). Idris 2.0 currently also is explicitly not sound. In the case of Idris that&#x27;s mostly a matter of prioritization, but it&#x27;s enough to demonstrate that soundness is, perhaps surprisingly, not a huge priority for even all full-spectrum dependently typed languages.<p>Full TS example:<p><pre><code>    type MyResult&lt;T extends boolean&gt; =\n        T extends true ? { tag: &#x27;a&#x27; } : { tag: &#x27;b&#x27; }\n\n    function outputTypeDependsOnInputValue&lt;T extends boolean&gt;(\n        value: boolean\n    ): MyResult&lt;T&gt;\n\n    function outputTypeDependsOnInputValue(\n        value: boolean\n    ): MyResult&lt;typeof value&gt; {\n        if (value) {\n            const result: MyResult&lt;typeof value&gt; = { tag: &#x27;a&#x27; };\n            return result;\n        } else {\n            const result: MyResult&lt;typeof value&gt; = { tag: &#x27;b&#x27; };\n            return result;\n        }\n    }\n\n    function worksWithA(a: &#x27;a&#x27;): void {}\n\n    function worksWithB(b: &#x27;b&#x27;): void {}\n\n    function useOurFunction(value: boolean): void {\n        if (value) {\n            const result = outputTypeDependsOnInputValue&lt;typeof value&gt;(value);\n            worksWithA(result.tag);\n            &#x2F;&#x2F; worksWithB(result.tag) is a type error\n        } else {\n            const result = outputTypeDependsOnInputValue&lt;typeof value&gt;(value);\n            worksWithB(result.tag);\n            &#x2F;&#x2F; worksWithA(result.tag) is a type error\n        }\n    }</code></pre>')