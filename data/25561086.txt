Item(by='mumblemumble', descendants=None, kids=[25561762, 25567874], score=None, time=1609176667, title=None, item_type='comment', url=None, parent=25560633, text='The only really stable, standardized, well-supported ABI out there is the C ABI. Communicating across it is a chore. On the side of the language publishing the API, you need to write a C-friendly façade that translates everything your language has that C doesn&#x27;t into a much more Spartan semantic space. You&#x27;ll be losing or having to re-implement pretty much everything you like about that language: any sort of dynamic dispatch, memory management semantics, exceptions, etc. And then, on the client language side, you probably want to write another façade in order to, to the extent that it&#x27;s feasible, restore all those sorts of niceties.<p>Direct FFIs are possible, but generally don&#x27;t happen except in exceptional cases because of the cost involved in writing a new FFI (and accompanying set of gotchas) for every possible language whose packages you might want to consume. The best and worst thing about the C ABI is that it&#x27;s pretty much the least common denominator.<p>Even in platforms like Java and .NET that theoretically smooth over these problems, we find that it never works out that well in practice. Scala and F# users end up having to write compatibility layers in order to preset Java and C# friendly APIs, and they end up writing their own versions of just about every possible library in order to have packages that don&#x27;t feel awkward to use in their language of choice. The only real exception I know of to that pattern on the JVM or the CLR is between C# and Visual Basic, and that is only because Microsoft was very careful to ensure that the two languages&#x27; semantics were similar enough to virtually guarantee no cross-language friction.')