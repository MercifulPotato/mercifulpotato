Item(by='mci', descendants=None, kids=[25266317, 25264344, 25264286], score=None, time=1606810643, title=None, item_type='comment', url=None, parent=25257209, text='If you do not care about speed, you can get not <i>arbitrary-precision</i> (static number of significant digits, set upfront) but <i>exact</i> (dynamic number of significant digits, as large as you wish) results. Under the hood, your expressions will be directed acyclic graphs of lazy generators, each generator coresponding to a mathematical operation or function.<p>Here is a Python library that employs continued fractions to this end: [0]. You can pull successive partial quotients of the result from the root node of the dag. Whenever any node needs more precise input to deliver more precise output, it pulls a partial quotient from its argument(s).<p>Full disclosure: I wrote the original version of the library 13.5 years ago. Here are the slides from my talk about it: [1].<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;AdamPrzybyla&#x2F;python-cf" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;AdamPrzybyla&#x2F;python-cf</a><p>[1] <a href="https:&#x2F;&#x2F;marcinciura.files.wordpress.com&#x2F;2019&#x2F;10&#x2F;cf-slides.pdf" rel="nofollow">https:&#x2F;&#x2F;marcinciura.files.wordpress.com&#x2F;2019&#x2F;10&#x2F;cf-slides.pd...</a>')