Item(by='socialdemocrat', descendants=None, kids=[25485617], score=None, time=1608458088, title=None, item_type='comment', url=None, parent=25484251, text='I don&#x27;t see how an ISA doesn&#x27;t matter. While not a chip architect like you, I do work as a developer and I know that the interface you make to something affects what kind of performance you can build in the backend.<p>In principle whether you are using Python or C++ doesn&#x27;t matter. It is just an interface. The compiler or interpreter in the back decides the actual performance. Yet it is pretty obvious that the specifications of C++ syntax makes it much easier to create a high performance compiler than the specification for Python.<p>I have been quite involved with Julia. It is a dynamic language like Python, but specific language syntax choices has made it possible to create a JIT that rivals Fortran and C in performance.<p>Likewise we have seen from Nvidia slides when the went with e.g. RISC-V over ARM, that the simple and smaller instruction-set of RISC-V allowed them to make much cores consuming much smaller silicon, better fitting their silicon budget.<p>When you worked as a chip architect didn&#x27;t the ISA affect in any way how hard or easy it would be for you to make an optimization&#x2F;improvement in silicon?<p>I mean if one ISA requires memory writes to happen in order, or have variable length, or left too little space for encoding register targets etc. All that kind of stuff is going to make your job as a chip architect harder isn&#x27;t it?<p>Also I don&#x27;t quite get your argument about modeling the M1 around Mac workloads. We know the M1 is having great performance on Geekbench and other benchmarks which have not been specifically designed for Mac workloads.<p>Only things I can see with M1 which is specific to Mac is:<p>1) They do the code needed for automatic reference counting faster. Big deal on Mac since more software is Objective-C or Swift which uses automatic reference counting.<p>2) They prioritized faster single cores over multiple cores. Hence optimizing more for a desktop type workload than a server workload.<p>3) A number of coprocessors&#x2F;accelerators for tasks popular on Macs such as image processing and video encoding. But that is orthogonal to the design of the Firestorm cores.<p>I don&#x27;t claim to know this remotely as well as you. I am just trying to reason based on what you said and what I know. Would be interested in hearing your thoughts&#x2F;response. Thanks.')