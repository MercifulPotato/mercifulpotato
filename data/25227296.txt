Item(by='danidiaz', descendants=None, kids=[25227888], score=None, time=1606472457, title=None, item_type='comment', url=None, parent=25218601, text='One neat and practical application of existential types if for defining &quot;collectors&quot; for streaming sources. The internal state of the collector is hidden and it can be different form what the collector ultimately returns. For example, a collector that returns the average of its inputs can store sum and count separately as its internal state. This also makes it easier to combine collectors.<p>In Haskell, using GADTSyntax, it would be something like<p><pre><code>    data Collector a b where\n        MakeCollector :: (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; Collector a b\n</code></pre>\nThat is: to construct a collector that ingests as and returns a single b, you need to supply a step function, the initial state of type x, and a &quot;tally&quot; function that calculates the result b from the final state. The type of the state (&quot;x&quot;) is <i>not</i> present in the type &quot;Collector a b&quot;; it is an &quot;existential&quot;.<p>In the Java Collectors framework, this is (roughly) analogous to<p><pre><code>    Collector.of (Supplier&lt;A&gt; supplier, BiConsumer&lt;A, T&gt; accumulator, BinaryOperator&lt;A&gt; combiner, Function&lt;A, R&gt; finisher, Collector.Characteristics... characteristics)\n</code></pre>\nAnd the type parameter that corresponds to the existential in Haskell is:<p><pre><code>    A - the mutable accumulation type of the reduction operation (often hidden as an implementation detail)</code></pre>')