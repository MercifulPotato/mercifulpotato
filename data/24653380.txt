Item(by='geofft', descendants=None, kids=[24656341], score=None, time=1601571747, title=None, item_type='comment', url=None, parent=24649371, text='The way you&#x27;d do this in Python is something like<p><pre><code>    @contextlib.contextmanager\n    def get_a_locked_thing():\n        with lock:\n            yield thing\n</code></pre>\nand then<p><pre><code>    with get_a_locked_thing() as thing:\n        do_stuff_with(thing)\n</code></pre>\nExiting this &quot;with&quot; block causes get_a_locked_thing to resume at its yield statement, which exits that &quot;with&quot; block, which releases the lock. Throwing an exception also exits the context managers.<p>If you were to try omitting the &quot;with&quot; statement and running, say, &quot;thing = get_a_locked_thing()&quot;, the function hasn&#x27;t executed yet (because you haven&#x27;t entered the context manager), meaning that not only is &#x27;thing&#x27; the wrong object, you also haven&#x27;t even gotten the lock yet. So you won&#x27;t deadlock&#x2F;leak the lock, and you will notice in the most basic of tests that your code isn&#x27;t doing the right thing.<p>I do agree that this is nowhere near as nice as having an object in a local variable, because &quot;with&quot; adds an extra layer of indentation, and that&#x27;s an advantage of C++&#x2F;D&#x2F;Rust-style RAII. But it&#x27;s definitely doable in Python and pretty idiomatic.')