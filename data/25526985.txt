Item(by='skohan', descendants=None, kids=None, score=None, time=1608813645, title=None, item_type='comment', url=None, parent=25526588, text='I don&#x27;t have a ton of experience writing async rust programs, but I can imagine some types of problems which might come up:<p>- So what if I am implementing a high-throughput, performance critical system which makes heavy use of async, and under certain circumstances the runtime I&#x27;m using falls off a performance cliff.  It&#x27;s going to be difficult to diagnose and solve this problem, because the critical path of my program actually winds through a library which is essentially a black box to me.<p>- What if I have two dependencies, and each one internally depends on a separate async runtime.  And what if each of these runtimes is designed with the assumption that it is the main owner of system resources, like threads.  There may be conflicts which are very difficult to understand but have effects on the performance of my program.<p>I think fundamentally, an issue with this type of &quot;middleware&quot; is that by its nature, an async runtime, like Tokio for example, has to be implemented with a lot of assumptions about how &quot;the generic program&quot; should optimally handle async.  It may work great for the vast majority of use-cases, but fundamentally whenever you design a super general, abstract system like this you have to make tradeoffs.<p>In some ways Rust has taken probably the best possible approach to this, by making it modular and allowing you to bring your own runtime, but I think in practice, if the use of async continues to become pervasive in Rust and certain libraries get locked into certain ecosystems, it will not be so easy in practice to take advantage of that modularity.')