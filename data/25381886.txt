Item(by='KMag', descendants=None, kids=[25383220], score=None, time=1607656857, title=None, item_type='comment', url=None, parent=25379075, text='&quot;Executable&quot; configuration languages (most &quot;non-executable&quot; configuration language parsers are push down automatons that execute the configuration) are handy, but without strong coding standards and good discipline, the line between business logic and configuration tends to blur over time.<p>Cartesian product, map, and reduce operations over finite sets and lists are really handy in configuration.  (&quot;For each server in SetA look at each path in SetB and ...&quot;) \nBut, if you find yourself starting to write general loops (as opposed to loops implementing map, reduce, and Cartesian product in languages that don&#x27;t have them built-in), it&#x27;s a sign you&#x27;re starting to blur the line between configuration and business logic.<p>Unit-testing configurations is difficult, especially if they can be non-deterministic (depend on data&#x2F;time&#x2F;random()) and aren&#x27;t modular.<p>In some sense, all programs with configuration files are really interpreters for the language of their configuration files.  (As mentioned before, many of these abstract machines are just push down automata.)  Taken too far, the configuration becomes the real program.<p>I&#x27;ve seen a (now retired) automated trading system with a powerful XML-based configuration language where a few times people got themselves into trouble (and caused trading losses) when their complex tower of configuration fell over.  Part of the problem was there existed a few people who weren&#x27;t trusted to write application logic, but who were trusted to &quot;just update configurations&quot;.  When the only tool  some of your people are allowed to use is a hammer, hammer marks start mysteriously showing up everywhere.  Additionally, this was over 10 years ago, and prior to these trading losses, configuration underwent less stringent review.  I don&#x27;t think my experience was atypical.<p>I&#x27;ve also seen configuration loading get stuck because someone added some code to the config to hit a REST endpoint in the middle of the configuration file.  Ideally, you&#x27;d leave any I&#x2F;O to the main program logic, where it&#x27;s easier to perform the I&#x2F;O asynchronously, or otherwise non-blocking.<p>Deterministic non-Turing-complete immutable &quot;executable&quot; configuration languages (or at least ones where it&#x27;s difficult to get unbounded recursion) tend to be a happy medium.  Also, declarative rather than imperative configuration languages tend to be easier to read.<p>Back when I was a developer in web search infra at Google, I vaguely remember once or twice using a language (maybe Borg&#x27;s config language, borgconfig) that completely lacked mutability and essentially used object prototyping (A is created as a copy of B, with differences specified at object creation time.)')