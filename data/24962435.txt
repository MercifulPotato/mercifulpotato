Item(by='jeff-davis', descendants=None, kids=None, score=None, time=1604264101, title=None, item_type='comment', url=None, parent=24961481, text='Consider a hash table. Access is basically random, so if 25% fits in memory and 75% is paged-out at any given time, then 75% of the lookups will be a page fault and require a page-in. Very costly.<p>Compare that to a Grace HashJoin (<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Hash_join" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Hash_join</a>) which partitions both sides (lookup side and hash table side) into matching partition pairs. The partitioning step and reading the partitions from disk are both sequential access. Then, pick up and process one pair of partitions at a time, which will only require a small hash table in memory.<p>Note that this is still way more efficient even when on an SSD, because an SSD is still block-oriented, and paging entire blocks in&#x2F;out for a single lookup is still inefficient.<p>It even helps when the data fits into memory sometimes, because you can size the partitions small enough to fit in cache, which will make lookups even faster.<p>You can say &quot;don&#x27;t use hash tables&quot;, but that&#x27;s not a great amswer for a low-level high-performance language like Rust.')