Item(by='StefanKarpinski', descendants=None, kids=None, score=None, time=1603294244, title=None, item_type='comment', url=None, parent=24845444, text='That C code is 39% faster than the Julia version, so faster but not massively so. You can optimize the Julia code to be as fast as the C code by using in-place operations, but it&#x27;s probably not worth if for such a small speedup unless the code is a real bottleneck. By comparison, the Python version (using NumPy, of course) is 25x slower than C, which is a whole different situation.<p>Most the speed advantage of the C here is due to reusing the same memory over and over, which you can do pretty easily in Julia as well. Here&#x27;s the Julia code using in-place operations and it&#x27;s still quite a bit more readable than the C version: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;StefanKarpinski&#x2F;e57f5a36b7890b261a0d42db4eb1324c" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;StefanKarpinski&#x2F;e57f5a36b7890b261a0d...</a>. I timed this and it&#x27;s the same speed as the C version. When developing this, it follows the same general outline as the C version, but you have several benefits: (1) You can use asserts to compare to the easy version; (2) There are niceties like bounds checks and array indexing. In C you can&#x27;t do (1) because there is on easy version to compare with. And doing the array index computations in C is kind of a nightmareâ€”it&#x27;s so easy to accidentally screw them up.')