Item(by='Mindless2112', descendants=None, kids=[25205032], score=None, time=1606256581, title=None, item_type='comment', url=None, parent=25201269, text='From Joe Duffy&#x27;s series of blog posts on Midori[1]:<p>&gt; <i>Error codes fail the test of “zero overhead for common cases; pay for play for uncommon cases”:</i><p>&gt; <i>There is calling convention impact. You now have two values to return (for non-void returning functions): the actual return value and the possible error. This burns more registers and&#x2F;or stack space, making calls less efficient. Inlining can of course help to recover this for the subset of calls that can be inlined.</i><p>&gt; <i>There are branches injected into callsites anywhere a callee can fail. I call costs like this “peanut butter,” because the checks are smeared across the code, making it difficult to measure the impact directly. In Midori we were able to experiment and measure, and confirm that yes, indeed, the cost here is nontrivial. There is also a secondary effect which is, because functions contain more branches, there is more risk of confusing the optimizer.</i><p>&gt; <i>This might be surprising to some people, since undoubtedly everyone has heard that “exceptions are slow.” It turns out that they don’t have to be. And, when done right, they get error handling code and data off hot paths which increases I-cache and TLB performance, compared to the overheads above, which obviously decreases them.</i><p>[1] <a href="http:&#x2F;&#x2F;joeduffyblog.com&#x2F;2016&#x2F;02&#x2F;07&#x2F;the-error-model&#x2F;" rel="nofollow">http:&#x2F;&#x2F;joeduffyblog.com&#x2F;2016&#x2F;02&#x2F;07&#x2F;the-error-model&#x2F;</a>')