Item(by='valand', descendants=None, kids=None, score=None, time=1611409220, title=None, item_type='comment', url=None, parent=25874105, text='<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25874105" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25874105</a><p>The article pictures conflicts from different programming cultures. There isn&#x27;t any attempt of acculturation mentioned in the article. Acculturation is important to keep everyone in the same page on what&#x27;s the added value of React. You don&#x27;t need people from .NET to get culture conflict, frontend dev that haven&#x27;t got any previous experience with React and the likes, those who operates with jquery and left frontend world, for example, will also introduce culture conflict.<p>In the near beginning, &quot;Where is the dependency injection? What do you mean by ‘There is no need for one?&#x27;&quot;.<p>The React developers seem to also not aware what&#x27;s the significance of dependency injection, therefore the culture acknowledgement goes both way. While the term came from heavy-OOP environment, dependency injection can take a different form.<p>In React&#x27;s world, it can utilize context or types from common module. Dependency injection is crucial in flattening deep components surfaces, which in turn makes them testable. And it&#x27;s not exclusively for the React part. Testable code (with actual tests at STRATEGIC PLACES) makes it easy to increment on, because validating if the added code takes less effort. (Although automated tests at NON STRATEGIC places can make it worse).<p>“Why is the development slowing down?”.<p>I can imagine the author&#x27;s frustration when &quot;They want to use the .NET guidelines and design patterns in React&quot;. I&#x27;ve been in and out some cultures, React, NodeJS, Java, C#, C++, Golang, Android, Game development, Game Engine, Ecommerce, Identity management, Crypto, LL&#x2F;system programming, infra. I can say that without running around and having enough persistence to break and remake cultures while avoiding ineffective compromises, things will not work.<p>CTO losing his temper and blaming for what&#x27;s decided 2 years prior seems like either things have gotten a bit out of control or the environment is a bit toxic. That is if the story is told accurately. Maybe CTO has been constantly reminding the author along the way but only the climax is told because it is peak emotional. Either way, observability and control over the project is lacking. Also the added values of React and other dependencies being included in the project as the main UI library is not communicated well.<p>There are a lot of &quot;should we use [x] lib&quot; going on. The easiest principle is if a module changes a lot, don&#x27;t depend on any lib that locks it in.<p>&quot;Redux-Forms, Formiq, or Final-Form?&quot; This smells, just because without delving deep into the library, Redux-forms seems to tightly couple redux state with, well, forms, which is, in React environment, usually closer to the UI side rather than the core logic side, and you want UI and logic layers to be able to change a lot relative to each other even if they don&#x27;t.<p>On Redux:<p>Redux itself was a weird long-running phenomenon. Its placement relative to other components is a big misunderstanding. It&#x27;s supposed to be a state container that can be either local or global, but the default `connect` API stamps it as a god object permanently in the eyes of the ecosystem. Not to mention countless of medium articles that encourage the pattern.<p>Its &quot;middlewares&quot; such as thunk makes stories hard to write as a single top-to-bottom functions. In one project we identified the risk of misunderstanding as a problem early in the project, therefore redux is removed. We didn&#x27;t even got to touch redux-saga. We had to find a replacement, which is unstated and custom typed event emitter.<p>This buys us code explicitness, loose-coupling, less processes on increments, more accurate types (redux doesn&#x27;t play nice with typescript&#x27;s type system), but we had to pay with writing a lot of types (we are using typescript). It teaches us the concept of message passing ala kafka&#x2F;rabbitMQ, as well as the importance of immutability, which is the core of redux, without redux API bureaucracy.<p>On React hooks:<p>React hooks was a departure to a more (a bit forced) functional programming. Some concept introduced is good as it encourage us to write in automata-based programming style.<p>Automata-based programming <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Automata-based_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Automata-based_programming</a><p>But it has bad API design too. For example `use*` can&#x27;t be written inside `if`. So are custom hooks. We have to be very careful to not place any hooks inside `if`. Writing with hooks needs either: 1.) experienced hooks developers, 2.) linter. You can install&#x2F;write the latter as long as you become the former, which is a paradox. Had it introduced hooks as below things would be a bit better.<p>```\nconst SomeComponent = makeComponent(\n  ({ context, props }) =&gt; {\n    &#x2F;&#x2F; context supplies useState and useEffect like APIs\n    return (\n      &lt;ChildComp &#x2F;&gt;\n    )\n  },\n  { [stateName]: defaultValue } &#x2F;&#x2F; the default state\n)\n```<p>The worse part of hooks introduction is that React&#x27;s culture diverge, and so its users. A company can have people with and against hooks.<p>About the title, it should be &quot;Using React the wrong way created roadblocks in our enterprise app&quot;.')