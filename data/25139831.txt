Item(by='Const-me', descendants=None, kids=[25140206], score=None, time=1605721692, title=None, item_type='comment', url=None, parent=25139427, text='&gt; to prevent reodering of instructions<p>GPUs don’t reorder, their EUs are way too simple for that. Are you certain GPU drivers reorder instructions while recompiling DXBC into their microcode?<p>&gt; HLSL is bit better at controlling this than GLSL is.<p>BTW, if you compile acos() in HLSL and disassemble the output DXBC, you’ll see a really strange sequence of 10 instructions (mad, mad, mad, add, lt, sqrt, mul, mad, and, mad) . The precision is indeed lost that way. Still, if you really need that, you can implement full-precision stuff on top of what’s available.<p>&gt; Using workgroup shared memory is now a thing<p>Was always there. CUDA 1.0 was released in 2007, D3D 11 in 2008.<p>&gt; But oh boy those are pain to program in compared to OpenCL or Cuda.<p>D3D 12 is a pain to program in general, too low level. But for GPGPU, I personally never needed command queues, I’m quite happy with old-school D3D 11. Despite the API is mostly single threaded, with some care you can do stuff in parallel. Things like ID3D11DeviceContext::CopyResource are asynchronous, you can go quite far with deeply pipelined commands without doing it manually like you have to in D3D12.')