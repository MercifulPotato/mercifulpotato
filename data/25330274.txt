Item(by='akkartik', descendants=None, kids=None, score=None, time=1607329030, title=None, item_type='comment', url=None, parent=25322656, text='I buy the thesis as stated; there&#x27;s a common attitude among researchers of, &quot;why don&#x27;t we have this <i>already</i>?&quot; that seems counter-productive.<p>However, there&#x27;s an adjacent thesis that&#x27;s also worth stating: fundamentally improving programming is hard, but still worth attempting. There&#x27;s just too much risk with the current status quo. We&#x27;ve built up our world atop a brittle, insecure, unstable tower of software, and it doesn&#x27;t feel unreasonable to ask if it might lose capability over time[1].<p>The good news: you don&#x27;t have to give it all up all at once and return to the stone age to try something new, as OP says. There&#x27;s nothing stopping us from using the present as we like to build the future. The key, it seems to me, is to prevent the prospective future from <i>inter-operating</i> with the present.<p>You won&#x27;t get lots of users this way, but I think jettisoning the accumulated compatibility baggage of 50+ years of mainstream software might free us up to try new things. Even if the world doesn&#x27;t switch to it <i>en masse</i>, it seems useful to diversify our eggs into multiple baskets.<p>Here&#x27;s what I work on: <a href="https:&#x2F;&#x2F;github.com&#x2F;akkartik&#x2F;mu" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;akkartik&#x2F;mu</a>. It&#x27;s a computer built up from machine code, designed to be unportable and run on a single processor family. It uses C early on, but it tries to escape it as quickly as possible. Mu programs can bootstrap up from C, but they can also build entirely without C, generating identical binaries either way[2]. (They do still need Linux at the moment. Just a kernel, nothing more like libc.)<p>I call this ethos &quot;barbarian programming&quot;, inspired by Veblen&#x27;s use of the term[3]. I rely on artifacts (my computer, my build tools, my browser, my community support system, the list is long) from the surrounding &quot;settled&quot; mainstream, but I try to not limit myself to its norms (compatibility, social discouragement of forking, etc.). I&#x27;m researching a new, better, more anti-fragile way to collaborate with others.<p>Here&#x27;s a 2-minute video I just recorded, experimenting with a new kind of live-updating, purely-text-mode shell built atop the Mu computer: <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;akkartik-2min-2020-12-06" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;akkartik-2min-2020-12-06</a>. The shell is implemented in a memory-safe programming language that is translated almost 1:1 to 32-bit x86 machine code. Without any intervening libraries or dependencies except (a handful of syscalls from) a Linux kernel.<p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=pW-SOdj4Kkk" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=pW-SOdj4Kkk</a><p>[2] <a href="http:&#x2F;&#x2F;akkartik.name&#x2F;akkartik-convivial-20200607.pdf" rel="nofollow">http:&#x2F;&#x2F;akkartik.name&#x2F;akkartik-convivial-20200607.pdf</a><p>[3] <a href="https:&#x2F;&#x2F;www.ribbonfarm.com&#x2F;2011&#x2F;03&#x2F;10&#x2F;the-return-of-the-barbarian" rel="nofollow">https:&#x2F;&#x2F;www.ribbonfarm.com&#x2F;2011&#x2F;03&#x2F;10&#x2F;the-return-of-the-barb...</a>')