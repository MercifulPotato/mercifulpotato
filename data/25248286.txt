Item(by='derefr', descendants=None, kids=None, score=None, time=1606685605, title=None, item_type='comment', url=None, parent=25238794, text='&gt; You can&#x27;t ignore any file that may be interesting to someone, which is basically all of them.<p>ripgrep already <i>does</i> ignore certain files! Specifically, it ignores binary and hidden files, and files in your .gitignore. This is part of what makes ripgrep&#x27;s default output so much more &quot;readable&quot; than GNU grep&#x27;s default output: its few default filters mean that it&#x27;s not matching from  e.g. the contents of your .git&#x2F; directory, whereas GNU grep <i>does</i> show those matches by default.<p>&gt; Could the_mitsuhiko, the creator of flask, provide such a list for flask?<p>That wasn&#x27;t what I was suggesting. I&#x27;m saying that each repo owner should be maintaining such a list <i>for their own repo</i>, custom-tailored to it. Just like every repo owner manages their repo&#x27;s .gitignore, .gitattributes, .dockerignore, etc.<p>And specifically, that list shouldn&#x27;t be a set of things that are <i>always</i> filtered out of <i>all</i> searches, but rather a set of patterns that apply abstract purpose-type tags to files, ala .gitattributes, such that it makes them much easier (or even &quot;default&quot;) to filter them in&#x2F;out of your searches.<p>Given a patterns file that would look like:<p><pre><code>    *.test.js purpose=test\n    tests&#x2F;**  purpose=test\n    apps&#x2F;*&#x2F;tests&#x2F;** purpose=test\n</code></pre>\n...ripgrep and other search tools could then see those files as having that purpose-tag &quot;test&quot; attached; and you&#x27;d be able to filter files in&#x2F;out by their purpose-tag, just like you can filter files in&#x2F;out by their filetype with ripgrep&#x27;s -t&#x2F;-T switches.<p>(You could go wild from there, if you like, and let this patterns-file match not just files but lines <i>inside</i> files. For example, doc-comments lines [=~ lines with syntax X in files of type Y] could be tagged as having purpose=docs.)<p>And I would then propose, <i>on top</i> of that, some higher-level behavior — not necessarily implemented in rg(1) itself — that could look at a file of &quot;filter-context specifications&quot; like this:<p><pre><code>    default: code\n    code: +purpose=impl -purpose=test -purpose=examples -purpose=docs\n</code></pre>\n...and then, when you do a search, it would use that `default` search-scope if not otherwise specified; or use another scope if you name it. So given the config above, by default you&#x27;d be searching only code; but you could instead search your docs scope, or your examples scope, or an implicit &quot;all&quot; scope.<p>The big win with those purpose-tags and scopes, would be if they had conventional or formal (e.g. URNs in an RDF namespace) names, such that different repos could agree on their usage.<p>Then tools that do code-search across many different repos, like Github, could layer UI on top of these purpose-tags and search-scopes discovered from the repo, to enable the repo to be searched using this explicitly-encoded abstract understanding of the purpose&#x2F;function of the different parts of the repo. (Picture the Github search autocomplete for a search &#x27;foo&#x27; giving several drop-down options like &quot;Search &#x27;foo&#x27; in [code] of this repo&quot;, &quot;Search &#x27;foo&#x27; in [docs] of this repo&quot;, etc. Then, after you get to the search page, a set of checkboxes to refine your search from the original scope, into a custom scope, by including&#x2F;excluding arbitrary purpose-tags.)')