Item(by='patrec', descendants=None, kids=[25201316], score=None, time=1606120433, title=None, item_type='comment', url=None, parent=25183075, text='Again this is not fundamentally tied to whether functions and variables share a namespace, in clojure they do and yet your example above does not cause a problem. Watch:<p>Let&#x27;s start out with a function:<p><pre><code>   user=&gt; (defn enlist [x] (if (list? x) x (list x)))\n   #&#x27;user&#x2F;enlist\n   user=&gt; (let [list 1] (enlist list))\n   (1)\n</code></pre>\nCreate a (pointless) equivalent macro:<p><pre><code>   user=&gt; (defmacro enlist&#x27; [x] `(let [y# ~x] (if (list? y#) y# (list y#))))   \n   user=&gt; (let [list 1] (enlist&#x27; list))\n   (1)\n</code></pre>\nNo hygiene and yet it works!<p>How? The secret is that backquote is automatically namespace qualifying:<p><pre><code>    user=&gt; &#x27;(list 1 2 3)\n    (list 1 2 3)\n    user=&gt; `(list 1 2 3)\n    (clojure.core&#x2F;list 1 2 3)\n</code></pre>\nIn practice this + convenient gensym syntax (also demonstrated above) seems to be enough, just like in practice Common Lisp&#x27;s approach of separate value and function cells for symbols + prohibition of rebinding function cells of symbols in the standard COMMON-LISP namespace is. Scheme has no cl style namespaces and no prohibition on redefining standard bindings and thus came up with a much more complex macro approach, at the gain of stronger hygiene guarantees (but see article above!) and the cost of an ugly design of considerable complexity that has a completely different sublanguage (non-orthogonally) baked in.<p>As far as purely hygiene is concerned that&#x27;s IMO not a good trade-off at all; I could rattle off a long list of major usability gripes with both cl and clojure but problems caused by lack of macro hygiene wouldn&#x27;t be on it.<p>Racket, which is basically several iterations beyond R*RS macros, OTOH is interesting because it&#x27;s more principled approach gives you something qualitatively different to what you can do with clojure (no read-syntax control; bad error messages) and common lisp (readtables suck and break tooling; bad error messages).')