Item(by='yellowapple', descendants=None, kids=[25010793], score=None, time=1604690641, title=None, item_type='comment', url=None, parent=25008584, text='I&#x27;d imagine that in this context (i.e. one where a 1-arity function initializes a tail-recursive 2-arity function) the 1-arity function is the only one that&#x27;d be exposed outside of the module, in which case you can know with reasonable certainty that only things within the current module will ever call it.<p>If you really do need to export the 2-arity version, you could always do a meaningless addition to force it to typecheck to a number, like so:<p><pre><code>    count([], C) -&gt; C+0;\n    count([_|T], C) -&gt; count(T, C+1);\n</code></pre>\nWhich should then result in the following:<p><pre><code>    erl&gt; c(test_count).\n    {ok,test_count}\n    erl&gt; test_count:count([], bang).\n    ** exception error: an error occurred when evaluating an arithmetic expression\n         in function  test_count:count&#x2F;2 (test_count.erl, line 8)\n</code></pre>\nOr alternately, use guards (though in the context of BEAM-level introspection I haven&#x27;t the slightest idea if this would produce an equivalent check):<p><pre><code>    count([],    C) when is_integer(C) -&gt; C;\n    count([_|T], C) when is_integer(C) -&gt; count(T, C+1);\n</code></pre>\nWhich then gets you a somewhat clearer error message:<p><pre><code>    10&gt; c(test_count).\n    {ok,test_count}\n    11&gt; test_count:count([], bang).\n    ** exception error: no function clause matching test_count:count([],bang) (test_count.erl, line 8)</code></pre>')