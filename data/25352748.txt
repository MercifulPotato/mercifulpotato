Item(by='dunham', descendants=None, kids=None, score=None, time=1607468515, title=None, item_type='comment', url=None, parent=25350094, text='Yeah, I tried to mention that near the end, but it can be hard to explain.<p>It is &quot;t&quot; applied to &quot;e&quot; - so it would be t(e) in javascript notation. This could be nonsensical, but because of lazy evaluation it never gets expanded&#x2F;evaluated. (K doesn&#x27;t use its second argument.)<p>The SKI stuff is defined as applying those replacement rules from the outside in, so:<p><pre><code>    K e (t e) ... -&gt;  e ...\n</code></pre>\nyou take that whole expression from the front (K and the next two expressions) and replace it with the expression that was in the first argument&#x27;s location. But (t e) here is dropped without ever being expanded &#x2F; evaluated.<p>Most languages fully evaluate arguments before passing them to functions, but a few rare languages like Haskell don&#x27;t evaluate the arguments until they&#x27;re needed. So for<p><pre><code>    K e (t e)\n</code></pre>\nit will assign the whole tree (t e) wherever y occurs in the function definition, and just keep passing it along until something needs its value (if you use apply it to something like a function, use it in a case statement, or pass it to a primitive function like plus).<p>The miranda language (whose source was recently published) is also lazy, and works by compiling your code down to SKI combinators and then evaluating them. So this actually has been used in practice.')