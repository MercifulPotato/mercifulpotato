Item(by='nendroid', descendants=None, kids=[24974757], score=None, time=1604357349, title=None, item_type='comment', url=None, parent=24973909, text='&gt;The stdout buffer.<p>The stdout buffer is not part of the haskell language, it is part of the OS. The haskell runtime reads the haskell language and accesses the buffer. Neither the runtime or the buffer is part of the haskell language, get it? That&#x27;s why haskell is called &quot;pure&quot; Category Hask: <a href="https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Hask#:~:text=Hask%20is%20the%20category%20of,%3E%20f%20(g%20x)%20" rel="nofollow">https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Hask#:~:text=Hask%20is%20the%20cate...</a>.<p>&gt;Just because mutation isn&#x27;t explicit doesn&#x27;t mean it isn&#x27;t there.<p>So? I never said it wasn&#x27;t there. I&#x27;m basically saying as far as the programmer is concerned when operating within the haskell language no haskell language primitive is mutating. stdout buffer is not a haskell primitive... it is an OS primitive.<p>&gt;That&#x27;s completely untrue. Imperative languages can be implemented as a subset of functional ones[1] and vice versa.<p>This is true theoretically, but physically but you can&#x27;t actually build a functional machine. Lisp isn&#x27;t actually a functional language and you&#x27;ll see from the instruction primitives that the lisp machine is more or less a turing machine that mutates memory.<p>&gt;No language can do anything if it isn&#x27;t implemented in a machine.<p>So? Never said this wasn&#x27;t true.<p>&gt;A machine isn&#x27;t &quot;imperative&quot;[2], it&#x27;s a pile of atoms that do what atoms do, without paradigm or instruction.<p>The machine you build is limited by what you build it with. You have a limited set of atoms. Therefore you can only build a machine with limited amount of state. In order to use the state efficiently the state must be mutable. Mutable state means imperative instructions. You can imitate functional programming with such a machine and you can sort of solve the memory problem with garbage collection. But with what paradigm do you implement the garbage collector? Imperative primitives.<p>&gt; The reason nobody has, is because it doesn&#x27;t matter: any Turing complete language can be used to implement any other language[3].<p>No the real reason is also because it&#x27;s physically impossible. A physical translation of a actual lambda machine cannot be realized. What they can make is register based machine that are more efficient at compiling certain functional languages that&#x27;s it. All machines we build have some sort of state that changes.<p>&gt;Don&#x27;t assert it, Prove it. Show me one computable function that cannot be computed using boolean algebra.<p>Sure I can prove what I said. But you&#x27;re changing the problem from IO and ST to a computable function which I assume is algebraic. So of course all of algebra can be used to create all algebraic functions. I&#x27;ll just prove what I said rather than what you changed it to.<p>Assuming mutation is an axiomatic operation that cannot be built from immutable operations, you will see that no mutation operation exists in algebra indicating that mutation cannot ever exist in any theorem of algebra:<p><a href="https:&#x2F;&#x2F;www.wikiwand.com&#x2F;en&#x2F;Algebraic_operation#:~:text=In%20mathematics%2C%20a%20basic%20algebraic,taking%20roots%20(fractional%20power)" rel="nofollow">https:&#x2F;&#x2F;www.wikiwand.com&#x2F;en&#x2F;Algebraic_operation#:~:text=In%2...</a>.<p>You will see that no algebraic operation involving mutation exists in the above document.<p>&gt;Try to implement `volatile` in C without using another language. Does that mean C fails to model real hardware? No, because it has `volatile` to get volatile semantics! Just like Haskell has IO to get I&#x2F;O side-effects. Or ST to get mutation semantics.<p>No but I can implement volatile with imperative primitives from other languages. All I am saying is you cannot implement ST and IO with functional primitives.')