Item(by='User23', descendants=None, kids=[24967250], score=None, time=1604270011, title=None, item_type='comment', url=None, parent=24962464, text='&gt; And I am saying that since this has never been achieved in practice for systems of considerable scale, this is a rather hypothetical use of the word &quot;easier.&quot; Is it possible that one day this will actually be easier? Sure. Is this the case now? I don&#x27;t think so.<p>Respectfully, I recommend that you read Dijkstra&#x27;s A Discipline of Programming that I linked above. I think you&#x27;ll find it interesting at the very least and possibly even enlightening. I assume you are a product of the American educational system, where these concepts are rarely taught. There are exceptions though, for example the great Leslie Lamport has also done notable work[1] in this area. You&#x27;ll find that out of necessity on some level we all have to reason about state spaces and the possible coordinates in those spaces to write software. Using formal mathematical reasoning is strictly better than the sloppy approach generally used. I&#x27;m not claiming that it&#x27;s a magic bullet though. Even mathematicians make errors after all.<p>There are various middle grounds too. Done properly, TDD and its cousins amount to an implied specification and &quot;ensure&quot; that the program written will satisfy the tested subset of said implied specification. The primary practical limitation of this approach is that testing can never show the absence of errors, only their presence.<p>&gt; The human act of painting your ceiling is exactly the same as painting the Sistine Chapel and the human act done by a first-year student taking a calculus exam is exactly the same as a Field medalist writing a proof in a paper.<p>You&#x27;ve lost me here, I don&#x27;t at all understand how these analogies have anything to do with the kind of reasoning a human can do about programs vs the kind of &quot;reasoning&quot; programs can do about programs.<p>The point is that it doesn&#x27;t matter what language a program is written in. The program text is always a mathematical object describing a state space (usually reasoned about as a set of state spaces like structs or objects) and transformations in those state spaces. Granted, some languages, like Perl, have ill-defined semantics that make reasoning about correctness impracticable, but often it&#x27;s possible to restrict oneself to a subset of the language that can be reasoned about. For what it&#x27;s worth I&#x27;ve applied these techniques quite successfully in my professional life. I hate getting paged and I hate debugging, so I&#x27;ve found it useful to learn to write correct software. I seriously doubt that I&#x27;m the only one, but as I&#x27;ve said before there is some kind of bizarre phobia American programmers have about being told that what they are doing is math that makes it very hard to talk about with most of them.<p>[1] <a href="https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;pubs&#x2F;lamport-win.pdf" rel="nofollow">https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;pubs&#x2F;lamport-win.pdf</a>')