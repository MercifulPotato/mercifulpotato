Item(by='tejasv', descendants=None, kids=[25316308, 25312951], score=None, time=1607152530, title=None, item_type='comment', url=None, parent=25309848, text='Here&#x27;s is a simplistic example of a state machine:<p><pre><code>  let transition (state: State) (action: Action) : State option =\n     match (state, action) with\n     | (StateA, ActionA) -&gt; Some StateB\n     | (StateA, ActionB) -&gt; Some StateC\n     | (StateB, ActionA) -&gt; Some StateB\n     | _ -&gt; None\n</code></pre>\nIf you get the quoted representation of the transition function, it can be visualized as a tree data structure (like code-as-data in LISP). You can analyze that tree to understand that if current state is StateB, only ActionA can be applied on it.<p>Couple this with another realization: &quot;Any sufficiently complicated model class contains an ad hoc, informally specified, bug-ridden, slow implementation of half of a state machine.&quot; (not sure where I read this quote).<p>This means all the entity framework&#x2F;ORM crap work that we do can actually be neatly represented as transforms on a F# state machine, which suddenly makes the application more powerful if you give it this structure.<p>We use this technique to auto-generate admin panels.')