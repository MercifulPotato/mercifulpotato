Item(by='jillesvangurp', descendants=None, kids=[25304741, 25302451], score=None, time=1607091104, title=None, item_type='comment', url=None, parent=25301549, text='It&#x27;s more than that. Java developers are switching to Kotlin; notably on Android and Spring code bases (well over 50% of backend Java projects at this point apparently).<p>This is an article about structured concurrency and how Loom implements something that Kotlin has shipped that both Android and Spring heavily integrate with already.<p>So, there&#x27;s more than a casual relation between Kotlin co-routines and Loom. I&#x27;d go as far that they apparently took a really good look at it and somehow ended up with something that essentially implements almost 1 to 1 the same kind of things.<p>Roman Elizarov (tech lead for co-routines, and recently the whole language) has been talking about structured concurrency a lot. I don&#x27;t think he invented the notion but it definitely is what co-routines is designed to do.<p>So, when I see an article talking about how great Loom and structured concurrency is mentioning several languages but yet somehow glossing over Kotlin, I call it out as lame. Oracle no doubt has good reasons to not want to talk about Kotlin. But to me it is clear they consider it a threat. It&#x27;s not the first time that they celebrate a few features new to Java where they mention other languages as influence and yet not mention Kotlin. Recent introduction of Records is a good example.<p>The Threading APIs date back to the late nineties and are full of complex stuff that you need to be aware of if you go near them if you care about avoiding all sorts of interesting categories of bugs, issues, and  pitfalls. So much that I&#x27;d  treat the occurrence of import java.lang.Thread as a giant red  flag in a code review. Typically, it&#x27;s a rookie mistake to use that. You shouldn&#x27;t have to; there are better APIs.<p>Kotlin, btw. treats threads just as a special case of co-routines. You can have co-routine dispatchers that represent a particular executor. This is how you separate slow blocking IO things  from e.g. CPU heavy stuff, or UI event handling. So, there is no API split in Kotlin. Some co-routines use a threadpool, some don&#x27;t.')