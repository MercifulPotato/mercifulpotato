Item(by='Tainnor', descendants=None, kids=None, score=None, time=1605637864, title=None, item_type='comment', url=None, parent=25123796, text='Thanks, I do know some Haskell, but I never dug deep enough into it to fully understand some of the concepts such as Reader. It seems to at least approximate the concept quite well.<p>Still - I don&#x27;t know whether it&#x27;s just due to unfamiliarity, but it seems to me that the simplicity and readability of the &quot;OOP&quot; equivalent (not requiring you to understand the semantics of &quot;map&quot; and &quot;join&quot; in the context of Reader), are a bit better. Also - OOP languages allow for dynamic dispatch and if I&#x27;m not totally mistaken (but I might), Haskell at least doesn&#x27;t allow that unless you start adding language extensions, so you can&#x27;t even make something like `Logger` a type class. I guess that would work in Scala, though, but then again, Scala also supports my original &quot;OOP&quot; approach anyway.<p>The ad-hoc polymorphism idea doesn&#x27;t really solve the issue, I think, because even if you bundle up all the values into an &quot;Environment&quot; variable, you still have to pass it around from function to function.<p>Others have mentioned closures, too. I&#x27;m not sure if they mean something like:<p><pre><code>   data UserRepository = Repository { load :: UserID -&gt; IO User, save :: User -&gt; IO () }\n\n   mkUserRepository :: Directory -&gt; Logger -&gt; UserRepository\n   mkUserRepository baseDir logger = UserRepository { load = load, save = save }\n       where load = ...\n             save = ...\n</code></pre>\nI mean, I guess that works somehow, but now we&#x27;ve made it possible to create user repositories with weird semantics (I know you hide the default data type constructor from other modules etc., but still). It also makes the implementation weirdly separated from the data type. And it makes me wonder... where would I even add the documentation for what the functions do. Having top-level functions certainly seems preferable to me.<p>My point is, I think nothing would stop a PFP language from theoretically allowing to have some sort of &quot;module scope&quot; where we pass some dependencies to the module that can then be re-used internally. The module could even be represented internally as a data type + a constructor function, but it would allow you to use top-level functions that can use those arguments. It shouldn&#x27;t break any of the correctness &#x2F; purity guarantees.<p>E.g. (just a quick sketch):<p><pre><code>  -- UserRepository is simultaneously a module, a constructor function and a data type\n  module (logger :: Logger, baseDir :: File) =&gt; UserRepository where\n\n  -- ad-hoc syntax to show that UserRepository is\n  -- an argument to the function at call-site, but\n  -- it&#x27;s looked up &quot;implicitly&quot; from the context\n  -- within the definition\n  load :: (UserRepository) =&gt; ID -&gt; IO User\n  load id = loadFrom baseDir id\n      where loadFrom = ...\n  \n  save :: (UserRepository) =&gt; User -&gt; IO ()\n  save = ...\n</code></pre>\nand then<p><pre><code>  import UserRepository (load, save)\n  \n  main = do\n    let baseDir = File &quot;&#x2F;some&#x2F;Directory&quot;\n    let logger = Logger &quot;&#x2F;some&#x2F;Directory&#x2F;logfile.log&quot;\n    let repo = UserRepository baseDir logger\n    user &lt;- load repo 1\n    ...\n</code></pre>\nMaybe PFP-ers wouldn&#x27;t find that useful, but I think I would find it very readable while essentially only amounting to &quot;syntactic sugar&quot; without having to break language semantics. I don&#x27;t want to claim that Haskell should do this, though. :)<p>I also didn&#x27;t want to claim that languages like Haskell don&#x27;t have any way of doing this, just that, from a readability &#x2F; simplicity point of view I find this &quot;OOP&quot; feature to be very useful and I haven&#x27;t yet seen anything in the Haskell world that seems comparable _to me_ ergonomics-wise.')