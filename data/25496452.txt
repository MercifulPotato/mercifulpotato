Item(by='dragontamer', descendants=None, kids=None, score=None, time=1608568492, title=None, item_type='comment', url=None, parent=25496170, text='I dunno if its just &quot;how I learned it&quot;, but experiments over the GF(5) prime field, followed by the GF(2) then GF(2^x) extension fields has always made the most sense in my brain.<p>GF(5) is a prime field and is much easier to think about. You have 0, 1, 2, 3, 4 as your numbers (and they&#x27;re &quot;true numbers&quot;, not yet polynomials).<p>The most natural generator is 2.<p>* 2^0 == 1 mod 5<p>* 2^1 == 2 mod 5<p>* 2^2 == 4 mod 5<p>* 2^3 == 8 mod 5 == 3<p>* 2^4 == 2^3 * 2 == 3 * 2 == 6 mod 5 == 1 == 2^0<p>Because 2^4 == 2^0 == 1, you have your loop. All non-zero elements are created by this sequence (because 2 is an appropriate generator). Define multiplication to be consistent with these numbers (and it happens to line up with normal multiplication).<p>For example:<p>* 2^4 * 2^3 ==  1 * 3 == 2^7 == 2^4 * 2^3 == 2^0 * 2^3 == 3.<p>-------<p>Extend the cycle over the negative numbers, and you remain consistent:<p>* 2^0 == 1 mod 5<p>* 2^-1 == 3 mod 5<p>* 2^-2 == 4 mod 5<p>* 2^-3 == 2 mod 5<p>* 2^-4 == 1 mod 5 == 2^0<p>By extending into the negative exponents, we&#x27;ve invented division that&#x27;s 100% consistent with all other math. Notice that 2^-1 == 3, which is 2&#x27;s inverse.<p>2^2 == 2^-2, which is its own inverse. Notice that 4 * 4 == 2^2 * 2^2 == 2^4 == 1. Any number times 4 twice equals itself.<p>Remember, GF(5) is just simple mod-5 arithmetic. We&#x27;ve redefined multiplication to the above attributes, but it works out how you&#x27;d expect. Lets take some random examples of multiplicative inverses &#x2F; division in GF(5), but &quot;extended&quot; over normal integers outside of the modular space to show you this really is amazing and it works.<p>* 3 * 2 == 6 mod 5 == 1.<p>* 4 * 2 * 3 == 24 mod 5 == 4 (notice: 2 * 3 is 1, so when 4 * 1 == 4)<p>* 4 * 4 == 16 mod 5 == 1<p>* 2 * 4 * 4 == 32 mod 5 == 2 (notice: 4 is equal to 1&#x2F;4. So 2 * 4&#x2F;4 == 2 * 4 * 4 == 2)<p>-----<p>A similar exercise can be done over addition. Then a similar exercise can be done over distributive property and even polynomials &#x2F; quadratic equation &#x2F; cubics and more!<p>Logarithms, Square Roots. Everything. All the math you ever learned: shrunk down into the exact space of {0, 1, 2, 3, 4} numbers.<p>--------<p>GF(5) is awkward for computers however. To make this &quot;reasonable&quot; for computers, we need to convert it into bits and bytes. Shrink the space down to GF(2) (0 and 1), then extend the space into GF(2^8). Extension fields (taking a &quot;power&quot; of the prime) are... complicated. Very complicated.<p>An extension field is the GF-version of &quot;complex numbers&quot;. You invent a polynomial over &quot;x&quot; (or some indeterminate variable). Complex numbers call it &quot;i&quot;, electrical engineers call it &quot;j&quot;. In the Complex world, i^4 == 1 (the 4th root of 1 is i). But in GF-version, the variable depends on the size of your field. A GF(2^8) will have x^255 == 1... so you have a much larger &quot;loop&quot; so to speak, but otherwise functions very similar to the Complex i.<p>But hopefully the experiments in GF(5) show why cryptographers love to use GF() fields in general. Its very useful to have all numbers &quot;loop&quot; back into themselves.')