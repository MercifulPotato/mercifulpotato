Item(by='spinningslate', descendants=None, kids=[24947382], score=None, time=1604095605, title=None, item_type='comment', url=None, parent=24947001, text='OK, OP was somewhat remiss in saying &quot;no-one&quot;.  But you have, I think, missed his point.<p>Instead, substitute &quot;few mainstream language designers&quot; and it stands up.  By mainstream I mean Java, Javascript&#x2F;Typescript, C#, C, C++, Python and such.  Most have introduced async&#x2F;await.  None has meaningfully gone beyond that as far as I&#x27;m aware.  Working with Erlang&#x27;s concurrency model is a refreshingly simple, consistent mental model compared to the mismash of concurrency features provided by the mainstream.  In Erlang, it&#x27;s as simple as:<p>1. Do these things need to happen concurrently?<p>No: regular functions.\nYes: spawn regular functions.<p>Compare that to the mainstream:<p>1. Do these things need to run concurrently?<p>No: regular functions.\nYes: are there only a few, and&#x2F;or do I need strong isolation?<p>Yes: use OS-level processes\nNo: do I want the OS to take care of scheduling &#x2F; preemption?<p>Yes: use threads\nNo: use async&#x2F;await<p>Is there a chance that my async operations will be scheduled across multiple OS threads?<p>No: get speed boost from no scheduling overhead, but remember to yield if there&#x27;s any long-running actions.\nYes: build my own likely-buggy, half-baked scheduler<p>Oh, and as a bonus: run back up the entire call stack to make all functions that call mine async.<p>And that&#x27;s before we get to error handling.  I&#x27;d take Erlang supervision trees _every day_ over trying to figure out which nested async callback function generated an exception.')