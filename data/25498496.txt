Item(by='PoignardAzur', descendants=None, kids=[25510829, 25510450], score=None, time=1608579257, title=None, item_type='comment', url=None, parent=25488214, text='&gt; Plus D is adding Rust&#x27;s ownership and borrowing<p>Saying that &quot;@live&quot; feature is &quot;adding Rust&#x27;s ownership and borrowing&quot; is technically accurate, but in reality I&#x27;d be surprised if it were used in production in major systems in the next 5 years.<p>The @live feature has multiple problems:<p>- The author wants it to be implementable incrementally (eg some code uses @live, some doesn&#x27;t), but doing so isn&#x27;t really feasible in safe code. From the moment you disable GC, you either need your entire program to respect some strict memory model (in which case you basically have a new programming language, and no incrementality), or your program won&#x27;t be any safer than C++. This is not hyperbole: Rust-with-unsafe and D-with-@system is safer than C++, because you only need to audit an annotated subset of your codebase. D-with-@live (or more accurately, D-with-@trusted-@live) is not safer, because a memory error can come from anywhere in your program.<p>- Speaking of a memory model, D doesn&#x27;t have one. Rust has Stacked Borrows, which gives library developers a framework to know whether their unsafe code might lead to undefined behavior. D doesn&#x27;t seem to have nailed down semantics as to how @live might create&#x2F;affect undefined behavior (which means the semantics will probably be &quot;whatever the DMD&#x2F;LLVM&#x2F;GCC backend wants&quot;).<p>- Rust has Non-Lexical-Lifetimes (and soon Polonius). D&#x27;s documentation is very sparse about how lifetimes in @live will be determined, but I think it&#x27;s safe to assume that it will be scope-based at first. This means that, <i>eventually</i>, when @live ships, it will be roughly equivalent to Rust as it was in 2015. Not great.<p>And, finally, saying that Rust will decline because another language will add OB misses what makes Rust great.<p>The strength of Rust is that things <i>work by default</i>.<p>A quick search through D&#x27;s forums will raise dozens of instances of people complaining about edge cases in the language, things that don&#x27;t work exactly as expected or produce undefined behavior (autodecoding and uninitialized variables come to mind).<p>Rust has very few problems like that. If your Rust code compiles, it will <i>work</i>. You will never have a bug that happens on a coworker&#x27;s machine but not on yours, or a crash that happens because you used two niche features that weren&#x27;t designed to be used together.<p>If your code crashes, it will be in a predictable, reproducible way, with an error message and a stack trace to tell you what to fix.<p>Rust isn&#x27;t perfect, but it&#x27;s infinitely less fragile over time than D.')