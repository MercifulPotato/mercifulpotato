Item(by='BatmanAoD', descendants=None, kids=None, score=None, time=1609615871, title=None, item_type='comment', url=None, parent=25612155, text='&gt; I&#x27;d add a recommendation at the top of this to have a Rust compiler handy.<p>If you haven&#x27;t already, check out the Playground: <a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;</a><p>It&#x27;s reasonably full-featured for a web IDE (much more so than the Go playground), and it includes many commonly used packages.<p>&gt; Because on my screen in non-dark mode...<p>The little sun icon in the lower left corner of the page turns on dark mode! Hopefully that helps.<p>&gt; I don&#x27;t understand why b=a; c=a; &lt;-- doesn&#x27;t work because a is &quot;used up&quot;???<p>This is something called &quot;linear typing&quot;, and it&#x27;s admittedly pretty unusual in a mainstream language.<p>The core idea is that the assignment operator _only ever_ creates a &quot;shallow&quot; (bitwise) copy of data; it never invokes anything like C++&#x27;s copy assignment operator. For types that are &quot;plain old data&quot; (like primitives), the old and the new values are fully independent, so the assignment works the same way it would in most languages, i.e., `a` is not &quot;used up&quot;. This is what other commentors mean when they say that primitives &quot;implement `Copy`&quot;. But if the old value has pointers or references, then the two values are not independent: after the bitwise copy, they both have pointers to the same data. Since data can only ever be shared explicitly in Rust, and the assignment operator never performs a deep copy, the old value, `a`, is considered invalid and cannot be re-used.<p>If you&#x27;re familiar with C++11 or later, one way to think of it is that `=` in Rust always behaves somewhat like `std::move` in C++:<p>`b = std::move(a);`<p>The details are substantially different (this will call `a`&#x27;s move-assignment operator if one exists, which has no equivalent in Rust, and C++ offers no support for ensuring that `a` is no longer used if its move-assignment operator invalidates it). But the general idea that &quot;move semantics are on by default&quot; is essentially accurate.')