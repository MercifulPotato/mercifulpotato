Item(by='Barrin92', descendants=None, kids=None, score=None, time=1611182826, title=None, item_type='comment', url=None, parent=25849862, text='Strange piece. Nobody claimed that dynamic type systems are simpler, they&#x27;re just... well, dynamic. Type system complexity and dynamism are orthogonal. What the dynamic and static distinction is about is when the program decides to look at what your types actually are. At runtime or compile time, nothing more.<p>This has some implications for simplicity but not in the sense that the article tries to argue about. The real benefit from dynamic languages is not that you don&#x27;t have types, it&#x27;s that your program becomes more flexible at runtime. This is riskier by definition, but it also has the advantage of not eliminating countless of valid programs that a static language eliminates, or only makes possible through fairly complicated constructs.<p>&gt;<i>&quot;[...]One day you open that module which you havenâ€™t touched in six months, and you see a function call where the third argument is null. You need to remember what kinds of variables you can pass to that third argument[...]&quot;</i><p>You don&#x27;t need to remember that at all. The issue here is that the author applies the static mindset to the dynamic paradigm. The correct behaviour here is to not &#x27;expect&#x27; or take for granted any particular input, but for the object&#x2F;function in question to on its own deal with whatever input it gets. In Smalltalk style OO you would say it&#x27;s the object that is solely responsible for the message it receives. That&#x27;s not surprising but the very essence of late-binding.')