Item(by='chrismorgan', descendants=None, kids=[24690961, 24690477], score=None, time=1601920407, title=None, item_type='comment', url=None, parent=24688233, text='Further to this: transmute is really pretty dangerous, and you’ve got to be <i>very</i> careful if you use it, or you’ll invoke undefined behaviour. And I believe the transmutes in the original article <i>do</i> invoke undefined behaviour, since the layout of the struct is undefined (you’d need to use something like `#[repr(C)]` on the struct to make it be defined). In practice, <i>these particular</i> examples are at least 99.9999% sure to do the right thing in all versions of Rust ever, but you just shouldn’t ever do this—you’re playing with delayed-action napalm. With his background, I feel that Will should have known better than to use unsafe here in this way: because it’s <i>wrong</i>.<p>Admittedly the SecureVec example is more understandable: because the generic is passed through to Item as well, you’ll need to convert the Vec&lt;Item&lt;T, ItemLevel&gt;&gt; to a Vec&lt;Item&lt;T, MaxLevel&lt;ItemLevel, VecLevel&gt;&gt;&gt;, which… well, it can be done readily enough without unsafe code, by consuming the Vec, mapping each item and collecting to a new vec, but short of a kind of specialisation magic that I don’t <i>think</i> will kick in in this case, that’s going to entail allocating a new vector, so that I <i>would</i> be inclined to use unsafe code here for efficiency; but care should still be taken that it doesn’t invoke undefined behaviour.<p>But one more word in defence of the transmutes: it makes it obvious that it’s either zero-cost or just a copy, whereas more involved things can become subject to compiler optimisations, so that you don’t <i>know</i> that the whole supposedly-noop transformation will be being optimised out of existence. That confidence and clearly-stated intent <i>is</i> valuable.')