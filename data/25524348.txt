Item(by='lmm', descendants=None, kids=None, score=None, time=1608774244, title=None, item_type='comment', url=None, parent=25518189, text='&gt; But if a fn takes an input stream as an arg, and if given input streams that yield the same bytes the fn always yields the same result, then why consider it an impure fn? The input stream is just a fancy data structure for bytes.<p>Hmm. It&#x27;s impossible to create a value that&#x27;s equivalent to reading from the input stream, because reading from the input stream has operational effects. But that logic doesn&#x27;t apply to an array if your access to the array is unobservable. (One could argue that reading from an array creates temporal relationships, but I don&#x27;t think that really holds up). So I think you&#x27;re right, and a function that accepts a mutable datastructure can still be pure (in a vacuous sense really, since a mutable datastructure can&#x27;t ever be equivalent to a value - it&#x27;s not even equivalent to itself at a different time), though given that that purity can&#x27;t ever be useful to you I don&#x27;t think it&#x27;s particularly important.<p>&gt; And though I guess it would be possible to have the `Mut*` collections use value equality instead of reference equality, that&#x27;d probably conflict with the performance goals of the mutable variant.<p>It&#x27;s not about the implementation of .equals(), it&#x27;s about semantic equivalence. Two different arrays with the same members behave quite differently than two references to the same array (as the program continues and other code mutates them), regardless of whether they compared equal at the start.')