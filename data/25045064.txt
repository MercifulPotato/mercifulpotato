Item(by='jgraham', descendants=None, kids=[25045678], score=None, time=1605010207, title=None, item_type='comment', url=None, parent=25044921, text='If you have tooling to support it, rebase-and-ff-merge is perhaps an even better workflow. In this model every commit on the main branch has a first parent that&#x27;s the previous merge, and a second parent that&#x27;s a linear set of the commits that were landed together, with the parent of the first commit being the previous state of master. This has the following advantages:<p>* It&#x27;s clear which states master has actually been in, without having to resort to squashing each merge into a single commit. This means that you know which commits actually passed CI and are therefore good rebase targets. People often claim that when merging multiple commits each commit should individually pass CI, but that&#x27;s almost impossible to achieve in practice.<p>* Development can split single features into multiple commits for easier review and understanding later. This can be particuarly important if the changes depend on each other, but different people need to review different parts of the overall change. That&#x27;s another thing that most tooling is really bad at.<p>* The history is basically linear. The merge commits are all empty, and there is one linear history for all the states of master (the first parent of each merge commit) and one linear history for all the individual commits (the second parent of each merge commit and only parent of each non-merge commit).<p>Of course this approach isn&#x27;t well supported by mainstream tooling (e.g. GitHub) and probably requires a custom bot to do all the rebase-and-merge operations. It <i>is</i> pretty well supported by git itself, however.')