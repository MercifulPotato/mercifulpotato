Item(by='jiggawatts', descendants=None, kids=None, score=None, time=1611148008, title=None, item_type='comment', url=None, parent=25843032, text='&gt; Honestly I prefer the bash way of $yaml | yaml2json(.exe) | convert-fromjson<p>I always prefer native support, but that&#x27;s just me. I recently even wrote a converter for DNS bind zone files because they&#x27;re such a pain to deal with as &quot;text&quot; files.<p>&gt; Why do I need to type .SYNOPSIS above here, and yes that extra line is too many<p>Because there are other sections as well.<p>Consider yourself lucky! If you&#x27;re writing binary modules in C#, the automatic help generation is missing. Instead, you have to use a hideous legacy XML-based help system nobody asked for. There are thankfully generators available now that plug into the Visual Studio build system, but in the past you literally had to author these by hand.<p>&gt; I wish there was a version of powershell that was static checked like typescript for javascript.<p>Don&#x27;t we all?<p>Set-StrictMode adds some static checks (not enough IMHO), and there are also linters available. If using VS Code, you get a bunch by default.<p>Fundamentally, once I start getting too frustrated by the weak typing, I realise that I&#x27;m writing <i>software</i>, not <i>scripts</i>. I simply crack open Visual Studio and start writing C#...<p>&gt; Why this is not the default behavior<p>PowerShell conceptually is nearly perfect at a high level. It was originally called the &quot;monad shell&quot;, and that design pedigree still shines through.<p>Unfortunately the implementation has many gaps that are as yet unresolved.<p>I was hoping PowerShell Core would fix everything, but it only fixed a few things (parallel foreach finally!) while leaving simple things like break-on-exception on the table.<p>Nonetheless, having worked with both Bash and PowerShell, I hugely prefer the latter because of that purity of vision.')