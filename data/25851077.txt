Item(by='megameter', descendants=None, kids=None, score=None, time=1611172234, title=None, item_type='comment', url=None, parent=25849539, text='Having studied and implemented FBP systems in the past, one major takeaway I&#x27;ve gleaned is that most automation problems start off as a linear sequence of processes, and so the branching-graph of FBP looks unwieldy and superfluous. But this is deceptive; you probably don&#x27;t want to have a huge number of branches in the design, but you will want them as an optimization step or a way to combine inputs.<p>So it&#x27;s useful to design with FBP in mind but with a linear interface as the entry point.<p>Another aspect of this is that FBP graphs are static but you may have a need to reconfigure them frequently; that is, you may want to have a graph compilation step drawn from a source language, rather than manually wiring it up.<p>A way of making that graph compilation more than a syntax is to include a formal constraint solver: Excel, for example, flows the data after determining a solution for how cells relate to each other. The power of the spreadsheet paradigm really lies in these combinations of concepts.<p>Lastly, there isn&#x27;t really magic in the algorithmic&#x2F;implementation aspects of FBP. It grew out of 1960&#x27;s mainframe types of problems, and so it can be implemented in a low level way with static pools of memory and pieces of assembly code. But it remains conceptually just as relevant to today&#x27;s massive distributed systems.')