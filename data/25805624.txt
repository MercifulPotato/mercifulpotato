Item(by='jrockway', descendants=None, kids=None, score=None, time=1610832074, title=None, item_type='comment', url=None, parent=25805469, text='I think it&#x27;s necessary to leak the details of the mutex until you have some sort of transaction object to abstract that away.  In a concurrent workload, these two things are different:<p><pre><code>   store.Lock()\n   store.WriteKey(&quot;foo&quot;, &quot;bar&quot;)\n   x := store.ReadKey(&quot;foo&quot;)\n   store.Unlock()\n   &#x2F;&#x2F; x is always &quot;bar&quot;\n</code></pre>\nAnd:<p><pre><code>   store.Lock()\n   store.WriteKey(&quot;foo&quot;, &quot;bar&quot;)\n   store.Unlock()\n\n   store.Lock()\n   x := store.ReadKey(&quot;foo&quot;)\n   store.Unlock()\n   &#x2F;&#x2F; x could be whatever another goroutine set &quot;foo&quot; to, not the &quot;bar&quot; that you just wrote.\n</code></pre>\nIn a more complicated app, you&#x27;ll have library that acts as the datastore, with transaction objects that abstract away the actual mutex (which will be something more complicated):<p><pre><code>   var x string\n   err := db.DoTx(func(tx *Tx) {\n     tx.Write(&quot;foo&quot;, &quot;bar&quot;)\n     x = tx.Read(&quot;foo&quot;)\n   })\n   if err != nil { ... }\n   &#x2F;&#x2F; what x is depends on the details of your database; maybe you&#x27;re running at &quot;read uncommitted&quot;, maybe you&#x27;re running at &quot;serializable&quot;.\n</code></pre>\nBut, even in the simple examples, it&#x27;s worth thinking about the difference between lock { write; read } and lock { write }; lock { read }.')