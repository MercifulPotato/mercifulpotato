Item(by='jpegqs', descendants=9, kids=[25329973, 25329773, 25329711], score=1, time=1607319148, title='Ask HN: “undefined behavior” or “target machine behavior”?', item_type='story', url=None, parent=None, text='I have encountered a bug in GCC that can lead to security vulnerabilities in software, but the GCC developers refuse to consider this a bug.<p>So I ask for your opinion on this matter.<p>Here&#x27;s the URL: https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=98168<p>Copied the text below.<p>Here GCC thinks that if both signed integers are positive, then the sum of these integers is also positive. And removes the next bounds check for the negative values (it could be written different, but this is the common way).<p><pre><code>  int test(int a, int b, int *buf) {\n    if (a &gt;= 0 &amp;&amp; b &gt;= 0) {\n      a += b;\n      &#x2F;&#x2F; let&#x27;s check that we are not reading outside the buffer\n      if (a &gt;= 0 &amp;&amp; a &lt; 8) return buf[a];\n    }\n    return -1;\n  }\n</code></pre>\nSo this code supposed to read the element A+B from a buffer of 8 values. And if the sum is out of the buffer, then return -1. But when compiling with GCC -O2&#x2F;O3 on x86&#x2F;x86_64 (and possibly others), you can pass A=0x7fffffff, B=0x7fffffff and access buf[-2] (as with any negative value except -1).<p>Thus, optimizations that falsely assume that the target machine is performing signed integer saturation when it is not - should be considered dangerous.<p>In my opinion, UB in C has a different purpose, it exists because C is a low-level language and in most cases can use a single machine instruction for a general operation. So for compilers it should be &quot;target machine behavior&quot;, not &quot;we can do anything&quot;. And compilers must maintain this behavior while removing some operations when optimizing the code.')