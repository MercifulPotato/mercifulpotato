Item(by='chriswarbo', descendants=None, kids=None, score=None, time=1608510705, title=None, item_type='comment', url=None, parent=25482956, text='&gt; Putting randrange as an argument creates deeply worse complexity issues and externalizes a needless burden on your user who must carry around their rand function and must understand what type of return value format the passed-in function has to give in order to be usable in the internals of findBias. It’s shocking to me you think this is somehow simpler or that the testability is somehow better.<p>It gives users the <i>option</i> to do that, but doesn&#x27;t burden them. This can be an implementation detail, whilst the public API provides a default like `bias = lambda: findBias(random.randrange)`. Since it&#x27;s Python we could also use a default argument, e.g.<p><pre><code>    import random\n\n    def findBias(randrange=random.randrange):\n      heads = tails = 0\n      for i in range(n):\n        if randrange(100) &lt; 100*p:\n          heads += 1\n        else:\n          tails += 1\n      return heads&#x2F;tails\n</code></pre>\n&gt; This is how nasty convoluted API get created. Now other functions up the call stack will also have to have a randrange param if they have to pass it forward.<p>This is overly-simplistic and disingenuous:<p>If other functions don&#x27;t care about this parameter, then they don&#x27;t need to use it, since it&#x27;s just an implementation detail; they&#x27;ll call the public API, which will use the default random.randrange, and these callers don&#x27;t even have to know that the parameter exists. This scenario is strictly an improvement to what you describe; heck, we could even mock &#x27;randrange&#x27; like you describe and it would work in exactly the same way! (except we don&#x27;t <i>need</i> to, since we can just do normal dependency injection via function arguments instead)<p>If other functions <i>do</i> care about this parameter, e.g. because they want to pass along a parameter from their own callers, then that&#x27;s <i>solving a different problem</i>. In this case it&#x27;s even <i>better</i> to be passing around parameters: mocking is a last-resort crutch when we&#x27;re unable to refactor legacy code, but even in those cases it should only be used during testing. It&#x27;s a <i>very</i> bad idea to be monkey-patching the standard library during the normal course of a program run; especially when it&#x27;s just to avoid adding an extra parameter to a function we control.<p>&gt; Your change is strictly more confusing, has strictly worse coupling and has a strictly worse API and even after all that, the test is not simpler and isn’t even less code than a one-liner mocker.patch in pytest.<p>I know a lot of this is subjective, but I&#x27;d like to point out that the mocking solution essentially works using mutable global variables. If we override the name &quot;random.randrange&quot;, we don&#x27;t actually know what else we might be affecting; for all we know, our bias-calculator could invoke a bunch of helper libraries which happen to rely on certain behaviour from random.randrange, which mocking will break in unexpected ways. In contrast, changing which value we pass as a function argument will not break arbitrary other code far-away which just-so-happens to be using the previous value. That&#x27;s the fundamental problem with mocking, and why it should be avoided except as a last resort: it forces us to make big, inappropriate assumptions about not only the code we&#x27;re testing, but also everything else it might ever interact with. The way pytest implements that mocking (by mutating globals like &#x27;random.randint&#x27;) just makes this even worse.')