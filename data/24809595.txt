Item(by='roca', descendants=None, kids=None, score=None, time=1602939258, title=None, item_type='comment', url=None, parent=24805717, text='The code for that blog post is fragile in an interesting way. Its safety and security depend on a subtle invariant: that the &#x27;word_regex&#x27; does not match a string containing any non-ASCII character. If requirements changed so the regex could match a non-ASCII character, then one of the &#x27;c&#x27; chars could have a negative value other than -1. <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;string&#x2F;byte&#x2F;tolower" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;string&#x2F;byte&#x2F;tolower</a> says &quot;If the value of ch is not representable as unsigned char and does not equal EOF, the behavior is undefined&quot;, so executing std::tolower(c) would trigger undefined behavior, i.e. a safety and security bug.<p>This fragility is not at all obvious in the code. It is easy to imagine someone making that kind of change to word_regex and introducing a theoretical security bug that no compiler or static checker is going to pick up (AFAIK). Of course the severity of the bug in practice depends on what std::tolower does in that undefined-behavior situation (which may depend on the run-time locale setting).<p>I think the author&#x27;s example actually illustrates the C++ safety problem pretty well. You write a program that looks safe and actually is safe, but slightly different code which looks just as safe is not. You&#x27;re tiptoeing through a minefield.')