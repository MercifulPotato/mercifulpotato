Item(by='quietbritishjim', descendants=None, kids=[25466891, 25466621], score=None, time=1608287624, title=None, item_type='comment', url=None, parent=25465196, text='Thanks for posting that link, it was a very interesting read. I&#x27;m a big fan of Rust, but that article really convinced me that C is the best language for SQLite. A couple of highlights IMO:<p>&gt; 2. Safe programming languages solve the easy problems: memory leaks, use-after-free errors, array overruns, etc. Safe languages provide no help beyond ordinary C code in solving the rather more difficult problem of computing a correct answer to an SQL statement.<p>(My commentary) So SQLite development is at such a different level to normal application that the memory safety errors that are a concern for us mortals are the &quot;easy&quot; problems for SQLite developers!<p>&gt; 5. Safe languages insert additional machine branches to do things like verify that array accesses are in-bounds. In correct code, those branches are never taken. That means that the machine code cannot be 100% branch tested, which is an important component of SQLite&#x27;s quality strategy.<p>(My commentary) I don&#x27;t really agree with this one: If a branch cannot possibly be taken then I don&#x27;t think it counts towards your coverage percentage... just like, if you&#x27;re careful never to dereference null pointers, you don&#x27;t include dereferencing null pointers as a missing part of your test coverage. Still, I thought it was very interesting, especially since it&#x27;s not quite the argument I was expecting (that those checks are wasted CPU time and binary bloat because they&#x27;re not needed). (Edit: What&#x27;s more, exactly this situation applies with SQLite&#x27;s own ALWAYS() and NEVER() macros [1])<p>[1] <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;assert.html#different_behaviors_according_to_build_type" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;assert.html#different_behaviors_according...</a>')