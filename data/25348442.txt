Item(by='munificent', descendants=None, kids=None, score=None, time=1607448494, title=None, item_type='comment', url=None, parent=25341476, text='<i>&gt; You can map, filter, reduce, chain, compose functions that all work with optionals, and lift functions that work on numbers (or any other type) to be functions that work on Optional&lt;number&gt; but none of that is even mentioned in this piece (likely cause then its harder to justify picking nullable types instead)</i><p>Maybe I&#x27;m missing something, but I don&#x27;t see how that&#x27;s special to option types. Here&#x27;s a set of extension methods in Dart that provide the operations you describe:<p><pre><code>    extension NullableExtensions&lt;T&gt; on T? {\n      R? map&lt;R&gt;(R Function(T) transform) =&gt; this == null ? null : transform(this);\n\n      T? filter(bool Function(T) predicate) {\n        if (this == null) return null;\n        if (predicate(this)) return this;\n        return null;\n      }\n    }\n\n    extension FunctionExtensions&lt;T, R&gt; on R Function(T) {\n      R? Function(T?) lift() =&gt; (T? param) =&gt; param == null ? null : this(param);\n    }\n\n    extension NullableIterableExtensions&lt;T&gt; on Iterable&lt;T?&gt; {\n      Iterable&lt;R?&gt; map&lt;R&gt;(R Function(T) transform) =&gt;\n          this.map((e) =&gt; e == null ? null : transform(e));\n\n      Iterable&lt;T?&gt; filter(bool Function(T) predicate) =&gt;\n          where((e) =&gt; e == null || predicate(e));\n    }\n</code></pre>\nChaining has built-in syntax:<p><pre><code>    int? maybeInt = ...\n    print(maybeInt?.isEven.toString());\n</code></pre>\nI&#x27;m not sure what you mean by &quot;compose&quot;.<p>Of course, this is not entirely as expressive as option types because of the inability to nest, but the article is pretty clear that nesting is the major advantage of option types.')