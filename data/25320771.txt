Item(by='bhk', descendants=None, kids=[25321722, 25320894], score=None, time=1607225439, title=None, item_type='comment', url=None, parent=25316933, text='This article presents as a language flaw what is really an operating system flaw.  Exposing system functionality through dynamically-linked C libraries, and using C features that do not guarantee ABI compatibility, results in an OS interface that does not provide backwards compatibility.<p>When I ran into similar problems trying to distribute a binary for Linux users, I thought &quot;Screw it, I&#x27;ll just statically link <i>everything</i>.&quot;  But the older statically linked C libraries would crash on newer kernels, and the newer static C libraries would refuse to run on older kernels.  (Or do I have that backwards?  Anyway, I ended up concluding that Linux doesn&#x27;t really have a stable ABI.)<p>Now, if you think &quot;operating system&quot; == &quot;kernel&quot;, then, yes this is a language problem.  And yes, people who write in x86 assembly and directly invoke the Linux kernel don&#x27;t have all of these worries.  They have much more manageable backwards compatibility issues.  But for most of us, &quot;programming to Linux&quot; means using the APIs defined in man pages.<p>Perhaps the actual &quot;OS API&quot; should be more completely divorced from C library issues.  The kernel should define its <i>own</i> contract in some kind of IDL from which one can generate APIs for any language (including all of the variants of C that differ by implementation choices).  Yes, it should map to C without any impedance mismatch, and the C folks can deal with how exactly it maps to different implementations of C, but other language runtimes shouldn&#x27;t have to go <i>through</i> C and re-live all its problems.')