Item(by='logicchains', descendants=None, kids=[24915484], score=None, time=1603860517, title=None, item_type='comment', url=None, parent=24913404, text='Theorem provers using constructive logic have the nice property that proofs are programs; if you have a proof that A implies B, and you have an A, you can produce a B. Classical mathematics is usually based on set theory plus the axiom of choice (implying law of excluded middle), which allows non-constructive proofs (which don&#x27;t compute). If the computer knows &quot;not not X&quot; implies &quot;X&quot; due to the law of the excluded middle, it can&#x27;t necessarily produce an &quot;X&quot; from an &quot;not not X&quot;.<p>The most popular theorem provers (at least among computer scientists) are based on some form of Martin-LÃ¶f type theory. In these theories, some very helpful proof techniques (often used in classical mathematics) like function extensionality and quotients don&#x27;t compute. While they can be added as axioms, this breaks the computational property of the proof. What HOTT brings is a type theory with an improved notion of equality in which such things do compute, based on the notion of transport along equivalences.<p>If have two types<p><pre><code>    Inductive nat : Set :=\n      | O : nat\n      | S : nat -&gt; nat.\n\n    Inductive natural_number : Set :=\n      | Zero : natural_number\n      | Successor : natural_number -&gt; natural_number.\n</code></pre>\nAnd I have proved something about nat, HOTT allows me to automatically convert that proof into a proof about natural_number (after showing nat is isomorphic to natural_number).')