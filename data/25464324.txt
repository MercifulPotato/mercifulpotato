Item(by='ReactiveJelly', descendants=None, kids=[25464776], score=None, time=1608271228, title=None, item_type='comment', url=None, parent=25463443, text='&gt; But if you manually delete the journal, or otherwise separate it from its database, you get data corruption.<p>I didn&#x27;t believe you, but you&#x27;re right.<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;wal.html" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;wal.html</a><p>&gt; If a database file is separated from its WAL file, then transactions that were previously committed to the database might be lost, or the database file might become corrupted. The only safe way to remove a WAL file is to open the database file using one of the sqlite3_open() interfaces then immediately close the database using sqlite3_close().<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;lockingv3.html" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;lockingv3.html</a><p>&gt; If a crash or power failure occurs and results in a hot journal but that journal is deleted, the next process to open the database will not know that it contains changes that need to be rolled back. The rollback will not occur and the database will be left in an inconsistent state.<p>It&#x27;s a bummer that SQLite is a &quot;database in one file&quot; but many operations actually require a 2nd or 3rd file.<p>What&#x27;s the reason that it can&#x27;t act like a filesystem image, and keep everything in one file? If I mounted an ext4 image in userspace and modified it a bunch, it wouldn&#x27;t be corrupt, right? Is that just because SQL has stronger atomicity requirements than a filesystem?')