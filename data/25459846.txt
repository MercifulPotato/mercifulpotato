Item(by='hardwaregeek', descendants=None, kids=[25460948, 25460384, 25460273, 25462306, 25464913, 25465227, 25463426, 25462922, 25467685, 25461033, 25471947, 25460980, 25462373, 25464122, 25460106, 25463218, 25460974], score=None, time=1608236329, title=None, item_type='comment', url=None, parent=25458777, text='I&#x27;m a huge fan of strictNullChecks but it is remarkable how much language features contribute towards making non-nullable types ergonomic. For instance Rust has a lot of primitives on Option a lot nicer.<p>One that I love is `Option::ok_or` (or `Option::ok_or_else` if you like). It takes an Option and converts it to an error. With the try macro (?) it makes Option a lot easier to use. Compare:<p><pre><code>   function parseFile(file: File | null) {\n     if (file === null) {\n       throw new Error(&quot;File must exist&quot;);\n     }\n     &#x2F;&#x2F; TS now infers as File\n   }\n</code></pre>\nto:<p><pre><code>   fn parse_file(file: Option&lt;File&gt;) {\n      let file = file.ok_or(Error::new(&quot;File must exist&quot;))?;\n   }\n</code></pre>\nLikewise if you want to apply a function to an Option if it is Some and pass along None otherwise, you can use `Option::map`:<p><pre><code>   fn parse_file(file: Option&lt;File&gt;) {\n      let parse_result = file.map(|f| parse(f));\n   }\n\n</code></pre>\nIndeed it&#x27;s a little interesting how libraries have adopted paradigms beyond the language. React is extremely expression based, but that makes for a clunky combo with JS&#x27; primarily statement based control flow. You see this in React developers&#x27; reliance on ternary operators and short circuiting for control flow in JSX.<p>Of course this just JavaScript being a classical imperative language. Not much to do about that.')