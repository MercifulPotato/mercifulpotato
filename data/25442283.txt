Item(by='harperlee', descendants=None, kids=[25442380], score=None, time=1608125661, title=None, item_type='comment', url=None, parent=25442210, text='Through an atom (<a href="https:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;atom" rel="nofollow">https:&#x2F;&#x2F;clojuredocs.org&#x2F;clojure.core&#x2F;atom</a>). The idea of accesing a closure that is mutable is as follows:<p><pre><code>  (let [temp (atom 0)]\n    (defn getter [] @temp)\n    (defn setter [val] (reset! temp val)))\n</code></pre>\nTo implement an object, you would do something more like:<p><pre><code>  (defn new-object [init-val]\n    (let [temp (atom init-val)]\n       {:getter (fn [] @temp)\n        :setter (fn [val] (reset! temp val))}))\n\n  (def obj (new-object 0))\n  ((:setter obj) 12)\n</code></pre>\nTo define interfaces, you could check whether the map&#x2F;object conforms to a spec, etc.<p>But obviously all this is not very idiomatic; in clojure you would keep those functions first-class through defn instead of tying them to the object &#x2F; map, and would pass state as an argument. Something like:<p><pre><code>  (defn getter [obj] @obj)\n  (defn setter [obj val] (reset! obj val))\n\n  (def obj (atom 0)) ; This gives you the ability (and need) \n                     ; to explicitly track the list of \n                     ; existing objects in use lest they are garbage collected.\n\n  (setter obj 12)\n</code></pre>\nIf obj has structure (e.g. it is a map such as {:type :my.personal&#x2F;type :val 12}) you can identify its type through the type keyval and can check conformance to a spec, etc.<p>As it was said in the previous post, it&#x27;s equivalent. It&#x27;s a matter of how to organize code.')