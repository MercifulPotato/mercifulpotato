Item(by='klodolph', descendants=None, kids=[24690259, 24689241, 24690254, 24689587, 24691874], score=None, time=1601911577, title=None, item_type='comment', url=None, parent=24687031, text='The with-baffle is interesting (and call-with-exit).<p>My personal take on Scheme is that call&#x2F;cc is elegant and powerful in the same way that assembly language is elegant and powerful—and just like it’s hard to reason about programs that make creative use of assembly language constructs, it’s hard to reason about programs that make creative use of call&#x2F;cc. Just like you can implement nearly any control structure in assembly, you can implement many with call&#x2F;cc. I was once working on a Scheme compiler but abandoned the efforts once I realized the enormous negative impact that call&#x2F;cc has on writing compilers, interpreters, and library code.<p>Do you want to write a reasonably fast and general mapcar? Do you want to do some basic escape analysis to see if you can allocate a value on the stack? Better have a good, long think about things. The withering gaze of call&#x2F;cc will make your face melt.<p>So, years ago, I was hopeful that there would be an officially sanctioned Scheme without call&#x2F;cc. Call it what you will. It never materialized.<p>You can think of it as two sides of the same coin—just like objects are a poor substitute for closures and closures are a poor substitute for objects, call&#x2F;cc is a poor substitute for exception handling, and exception handling is a poor substitute for call&#x2F;cc. R7RS adds SRFI-34, but you still see stuff like with-baffle and call-with-exit precisely because call&#x2F;cc is like a stick of dynamite that you can put in your code, and there’s no way it can work across any kind of FFI boundary without severe restrictions.')