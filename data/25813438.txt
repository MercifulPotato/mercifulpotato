Item(by='jpeloquin', descendants=None, kids=[25813705], score=None, time=1610908484, title=None, item_type='comment', url=None, parent=25812553, text='This is what sold me on magit:<p>1. In the magit status buffer (equivalent of git status), you can selectively stage changes by highlighting the relevant lines and pressing &quot;a&quot;.  Basically an interactive git add -p.  There&#x27;s also line-specific unstage and discard.  This makes it easy to tidy up before committing.<p>2. If the cursor is on a commit, commands (show, interactive rebase, push) will take that commit ID as a default argument.  It feels like you&#x27;re interacting with the commits directly, which makes it easier to reason through an interactive rebase or partial push.  Simple rebases like reordering or squashing recent commits take only a few seconds.<p>3. It seems to mostly rely on calling the core git commands and parsing their text output.  The core git commands are reliable.  Many git clients will hang on large (&gt; 200 GB) repos; magit doesn&#x27;t.  An exception is diff colorization, but if colorization is taking too long on a big diff, Ctrl-g will make magit fall back instantly to the plain diff.<p>4. Has decent submodule support, in that submodules can be interacted with much like commits in the parent repo.<p>5. Has git annex support.  (Technically, I think this is provided by another package that extends magit.)<p>It&#x27;s not really tailored to any particular git workflow as far as I can tell.  The design intent seems to be that every displayed entity should be interactive, regardless of where it is displayed.')