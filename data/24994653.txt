Item(by='curryst', descendants=None, kids=None, score=None, time=1604537499, title=None, item_type='comment', url=None, parent=24987183, text='&gt; And Go let&#x27;s you communicate by copying. That&#x27;s what a Channel is. Pass a struct and that is copied. Pass a pointer and the pointer is copied. The thing it points to isn&#x27;t copied for glaringly obvious reasons.<p>Copying large structs is not ideal, but passing a pointer to the channel means the other side of the channel can mutate that data.  If Go had immutable types, you could pass a constant pointer, allowing the other end of the channel to read from the pointer but not modify it.<p>&gt; And what would you suggest is a good alternative for returning multiple parameters. Currently this basically forces you to handle any possible errors and results in software you can very easily reason about.<p>What he&#x27;s talking about is returning a union type.  You have a single return value, it&#x27;s type is either a valid result (i.e. a string) or an error.  The compiler expects you to do runtime type checks (basically) to assert whether your return value is actually a value or not.<p>The explicit return values get clunky in some situations.  If I have a function that processes an array of items, where each item can fail individually, in Go the cleanest way to handle that is to make a struct that holds a pointer to a value (so you can check if it&#x27;s nil) and an error.  And you return an array of those structs.  In languages with Options, you can simply return an Option object, and let the upstream caller figure out what to do if it&#x27;s an error.<p>Javascript&#x2F;Typescript Promises are a similar, though less featureful, implementation of the same kind of idea.<p>Not sure what you mean about human reviewers needing to check errors.')