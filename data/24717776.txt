Item(by='q3k', descendants=None, kids=[24717838, 24717975], score=None, time=1602152914, title=None, item_type='comment', url=None, parent=24716525, text='Agreed. I have a strong background in &#x27;bad&#x27; programming languages like Go, Python, C. Half a year ago I had a short stint at a Haskell shop and was thoroughly disillusioned.<p>That particular &#x27;writing against the compiler&#x27; approach lended itself to write-once, over complex type juggling code. Because why make it readable - if it compiles, it works, and if it works, there won&#x27;t be any need to read it, right? Well, except you still get bugs, and then debugging anything is like making sense of brainfuck. Maybe smarter people than me can juggle a handful of types and operators simultaneously in their head - I can&#x27;t.<p>My favourite example of &#x27;just because it compiles it doesn&#x27;t mean it works is&#x27; Maybe [a]. I&#x27;ve had a colleague scratch their head for hours over something like this:<p><pre><code>    userCount :: Foo -&gt; Int\n    userCount f = length $ getUsers f\n</code></pre>\nThis compiled, but always returned 1. Why? Well, because turns out `getUsers` returned `Maybe [User]`, and not `[User]` as the programmer expected, and somewhat asserted in their mind with types. And it also turns out that in Haskell, `length` takes a `Foldable`, and `Maybe` is a `Foldable`. Thus, a `length` of a Maybe will gladly return 0 or 1, which makes perfect sense from the point of view of the type system, but zero sense when it comes to humans. Whoops.')