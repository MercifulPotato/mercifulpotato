Item(by='nsajko', descendants=None, kids=[25221823, 25221619], score=None, time=1606408536, title=None, item_type='comment', url=None, parent=25220734, text='&gt; PEG in Python is the latest, [...]<p>The popularity of PEG baffles me. I guess it ties in nicely with the wider and older pattern of rejecting good formal language and parsing theory, but PEG seems like an all around bad technology; like, is there even a single benefit to using PEG?<p>The difference between PEG and the usual grammars is that PEG introduces special meaning to the &quot;choice&quot; grammar operation so as to define away ambiguity. But defining away ambiguity actually just &quot;hides&quot; language constructions that will be ambiguous to users. Although PEG notation may be indistinguishable from those used to define CFGs, PEG sucks as a language specification tool as it is unclear what language a PEG defines (unlike with CFGs). From the perspective of implementation, PEG parsers backtrack, meaning either exponential run-time or additional linear memory requirements.<p>Also some Jeffrey Kegler quotes:<p>&gt; With PEG, what you see in the extended BNF is not what you get. PEG parsing has been called &quot;precise&quot;, apparently based on the idea that PEG parsing is in a certain sense unambiguous. In this case &quot;precise&quot; is taken as synonymous with &quot;unique&quot;. That is, PEG parsing is precise in exactly the same sense that Jimmy Hoffa&#x27;s body is at a precise location. There is (presumably) exactly one such place, but we are hard put to be any more specific about the matter.<p>and<p>&gt; When you do not know the language your parser is parsing, you of course have the problem that your parser might not parse all the strings in your language. That can be dealt with by fixing the parser to accept the correct input, as you encounter problems.<p>&gt; A second, more serious, problem is often forgotten. Your PEG parser might accept strings that are not in your language. At worst, this creates a security loophole. At best, it leaves with a choice: break compatiblity, or leave the problem unfixed.\nand<p>&gt; PEG is not unambiguous in any helpful sense of that word. BNF allows you to specify ambiguous grammars, and that feature is tied to its power and flexibility and often useful in itself. PEG will only deliver one of those parses. But without an easy way of knowing which parse, the underlying ambiguity is not addressed -- it is just ignored.')