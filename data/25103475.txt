Item(by='grose', descendants=None, kids=[25107049], score=None, time=1605465285, title=None, item_type='comment', url=None, parent=25100397, text='I like using the “serverless monolith” architecture. You use a catch-all API gateway hooked up to a single lambda. You write it the same as any standard HTTP server and let an adapter handle the lambda bits[1]. During development you run it as a regular HTTP server and connect directly to localhost. To deploy it all you need is a shell script that zips and uploads your binary to lambda. All state is stored in DynamoDB. One log stream for everything.<p>The downside is dealing with AWS events. There’s a few ways to handle it. You can write it into your monolith, toggling behavior with say an environment variable. You can sometimes work around it, for example avoiding the S3 file uploaded event by having clients ping your HTTP API on upload completion. Of course, there are trade offs for all the techniques. You can easily reconfigure a lambda to retry on failure but you’d have to manually implement that client-side. You can also always just add another lambda if you’re ready.<p>To put it another way: you probably don’t need to write that record to a queue which gets written to DynamoDB, whose stream calls another lambda etc etc. Just do that stuff within a regular old HTTP handler until the fanciness is absolutely necessary.<p>For personal projects, I appreciate how serverless scales to zero. I don’t have to worry about axing projects with minimal usage.<p>[1] for example <a href="https:&#x2F;&#x2F;github.com&#x2F;akrylysov&#x2F;algnhsa" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;akrylysov&#x2F;algnhsa</a> or <a href="https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;aws-lambda-go-api-proxy" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;aws-lambda-go-api-proxy</a>')