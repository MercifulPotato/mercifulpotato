Item(by='KMag', descendants=None, kids=None, score=None, time=1610692542, title=None, item_type='comment', url=None, parent=25787332, text='The direct uses would be either very specialized portions of the kernel or C&#x2F;C++ runtime (mutexes, etc.) or performance-critical code, where you&#x27;d typically look at C&#x2F;C++ compiler output, tweak it by hand, and then insert your modifications into the C&#x2F;C++ code as inline assembly.<p>Though, a small amount of assembly and a small understanding of processor design and implementation (I highly recommend MIT 6.004) go a long way into having a better mental model of what Java&#x2F;JavaScript&#x2F;C&#x2F;C++ are actually doing under the covers and what&#x27;s going on.<p>I was working on a project where I looked at the Philox4x32 random number generator specification and implemented it in Java.  A colleague was trying to speed things up by porting it to C++ and so he just used the liberally licensed reference C++ implementation.  He couldn&#x27;t figure out why my Java implementation was significantly faster than the C++.  I had a look, at the C++ implementation, and they missed an optimization to save one register in the inner loop.  I didn&#x27;t disassemble the native binary or have the JVM dissassemble JIT&#x27;d code, but I guessed that a register spill (32-bit x86 is pretty register starved) in the inner loop was the problem.  Just by applying my optimization, he got the C++ implementation faster than the Java implementation.')