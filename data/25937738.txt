Item(by='scaramanga', descendants=None, kids=None, score=None, time=1611804011, title=None, item_type='comment', url=None, parent=25931223, text='&gt; Someone has to learn compiler engineering and then design and implement a &#x27;safe&#x27; ABI. Unlike learning Rust, this is probably worthy of a research paper.<p>Yes, all good points. What I&#x27;m getting at is that it seems like nobody has yet re-written sudo in this safe way. And it&#x27;s not just a matter of re-writing it. If (when) someone comes along with this re-write there&#x27;s &quot;if this person goes away, will we find someone else to maintain it?&quot; and all those other very conservative social forces at play.<p>I think any new programming language community has these sorts of adoption hurdles to face. And I&#x27;m sure the rust community is working hard to build up that pool of developers and I think that&#x27;s all really positive so I don&#x27;t want to sound like I&#x27;m subtracting from it at all. I&#x27;m just also an interested spectator of PL and systems programming research&#x2F;new directions :)<p>&gt; If you use unsafe, then you take some of the responsibility for maintaining memory safety. However, you can audit the unsafe parts of the code, and it will compose with the compiler-provided guarantees for the rest of the code. Besides, one can easily avoid unsafe code for safety-critical tools like these.<p>Thanks, yep. That&#x27;s why I think that generally Rust is a good idea, and rewriting the TCB in it is a worthwhile project. In regards to safety it looks like a step in the right direction. We&#x27;re just quibbling about the cost&#x2F;benefit analysis of how big of a step it is compared to above-mentioned issues that all new programming languages face. Personally, I&#x27;ve no doubt that even with all that factored in, it&#x27;s still a net positive.<p>&gt; Miri does not support most interaction with the outside world [1]. It is focused more on detecting UB in unsafe code when it is exercised by tests, than on having your code running in production through Miri. Moreover, I wouldn&#x27;t call a thousand-fold slowdown [2] &quot;relatively lightweight&quot;<p>Thanks for the clarifications, you&#x27;re definitely more up to speed on that project than I am! But yeah, what I meant there was not that the implementation of miri was something to use as-is, more that it&#x27;s an interesting direction in PL&#x2F;systems programming research (imo). And some of the ideas there, especially where runtime cost _in principle_ can be made to be relatively lightweight are interesting. I&#x27;ve seen some other research where C implementations with bounds-checking have been implemented part-statically and where the remaining checks are done at run-time with fat-pointers.<p>OK, bounds checking isn&#x27;t memory safety, but the paper was a while ago. Maybe it was this one <a href="https:&#x2F;&#x2F;www.comp.nus.edu.sg&#x2F;~ryap&#x2F;Projects&#x2F;LowFat&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.comp.nus.edu.sg&#x2F;~ryap&#x2F;Projects&#x2F;LowFat&#x2F;</a> ?<p>So I mean, it sounds like you might be able to get to a place where you can use some bits of unsafe in rust, but maybe the program overall could still be safe because the compiler can have a mode where run-time checks (which can be statically eliminated in a lot of cases) are included.<p>But hey, I&#x27;m just a relatively amateur outside-observer of all this, maybe that&#x27;s a totally impossible pipe dream? :)')