Item(by='bsder', descendants=None, kids=[25767629], score=None, time=1610565285, title=None, item_type='comment', url=None, parent=25766362, text='&gt; It doesn&#x27;t have the same ecosystem. Which is half the point of the rpi to start with.<p>Now <i>that&#x27;s</i> a valid argument.  And I would argue it&#x27;s way more than half.<p>If you want a one-off <i>mumblesomething</i> and can stay at the Linux OS level (ie. Web application, USB peripherals or maybe the most basic of GPIOs), the RPi ecosystem is going to let you get there <i>much faster</i> even though it will crash and burn occasionally.  If that&#x27;s &quot;good enough&quot; ... Douzou! ...  Ganbatte! ... get moving and get going.<p>I have the same comment about Arduino.  It ain&#x27;t real reliable (but, to be fair, it&#x27;s quite a bit more reliable than the RPis), but the ecosystem is awesome.<p>However, when you start asking something like &quot;Gee, how do I send a single address byte over the I2C subsystem?&quot; or &quot;That signal needs a response in 50 nanoseconds, can I make that work?&quot; you will thank the TI folks for producing that 5000 page (not joking or exaggerating) Technical Reference Manual.<p>One other thing that people who live in the RPi system always overlook in the Beagle ecosystem are the PRU cores.  You can do <i>HARD</i> real-time work on those and still live in the Linux world.  That&#x27;s something that the RPi series just simply cannot do no matter how much you hack at them.  And it often means the difference between a design which needs an FPGA and one that doesn&#x27;t.<p>However, yes, you are going to live in that Technical Reference Manual for the Beagle series.  If you&#x27;re not comfortable doing that, then the Beagle stuff probably isn&#x27;t for you.<p>There are really good reasons to use and love RPi&#x27;s--ease of use is huge.  But the whole &quot;It&#x27;s cheaper&quot; thing just chaps my hide.')