Item(by='shepardrtc', descendants=None, kids=None, score=None, time=1605102801, title=None, item_type='comment', url=None, parent=25058088, text='I&#x27;ve been building a program that heavily uses multiprocessing for the past few months.  It works quite well, but it did take me a little bit to figure out the best way to work with it.<p>&gt; - Threads can&#x27;t be used efficiently because of the GIL<p>Python&#x27;s &quot;threads&quot; are actually fibers.  Once you shift your thought process toward that then its easy enough to work with them.  Async is a better solution, though, because &quot;threads&quot; aren&#x27;t smart when switching between themselves.  Async makes concurrency smart.<p>But if you want to use real threads, multiprocessing&#x27;s &quot;processes&quot;  are actually system threads.<p>&gt; - multiprocesses has to serialize everything in a single thread often killing performance. (Unless you use shared memory space techniques, but that&#x27;s less than ideal compared to threads)<p>I&#x27;m not quite sure what you mean.  Multiprocessing&#x27;s processes have their own GIL and are &quot;single-threaded&quot;, but you can still spawn fibers and more processes from them, as well as use async.<p>Or are you talking about using the Manager and namespaces to communicate between processes?  That is a little slow, yes.  High speed code should probably use something else.  Most programs will be fine with it, but it is way slower than rolling your own solution.  However, it does work easily, so that&#x27;s something to be said about it.  Shared memory space techniques do work, too, but they are a little obtuse.  Personally, I rolled my own data structures using the multiprocessing primitives.  You have to set them up ahead of time, but they&#x27;re insanely fast.  Or you can use redis pubsub for IPC.  Or write to a memory-mapped file.<p>- You can&#x27;t use multiprocess while inside a multiprocess executor.  This makes building things on top of frameworks&#x2F;libs that use multiprocess a nightmare...  e.g try to use a web server like over something like Keras...<p>I&#x27;m not sure what you mean.  Multiprocessing simply spawns other Python processes.  You can spawn processes from processes, so I don&#x27;t know why you would have issues.  Perhaps communication is an issue?<p>&gt; - The dependency ecosystem is a pita<p>Yes, absolutely.')