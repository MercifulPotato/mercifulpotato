Item(by='pietroppeter', descendants=None, kids=[24801511], score=None, time=1602860608, title=None, item_type='comment', url=None, parent=24801408, text='From this nice interview with Araq (language creator): <a href="http:&#x2F;&#x2F;157.245.209.254&#x2F;andreas-rumpf-on-creating-and-growing-nim&#x2F;" rel="nofollow">http:&#x2F;&#x2F;157.245.209.254&#x2F;andreas-rumpf-on-creating-and-growing...</a><p>&gt; I started the Nim project after an unsuccessful search for a good systems programming language. Back then (2006) there were essentially two lines of systems programming languages:<p>&gt; The C (C, C++, Objective C) family of languages.<p>&gt; The Pascal (Pascal, Modula 2, Modula 3, Ada, Oberon) family of languages.<p>&gt; The C-family of languages has quirky syntax, grossly unsafe semantics and slow compilers but is overall quite flexible to use. This is mostly thanks to its meta-programming features like the preprocessor and, in C++&#x27;s case, to templates.<p>&gt; The Pascal family of languages has an unpleasant, overly verbose syntax but fast compilers. It also has stronger type systems and extensive runtime checks make it far safer to use. However, it lacks most of the metaprogramming capabilities that I wanted to see in a language.<p>&gt; For some reason, neither family looked at Lisp to take inspiration from its macro system, which is a very nice fit for systems programming as a macro system pushes complexity from runtime to compile-time.<p>&gt; And neither family looked much at the upcoming scripting languages like Python or Ruby which focussed on usability and making programmers more productive. Back then these attributes were ascribed to their usage of dynamic typing, but if you looked closely, most of their nice attributes were independent of dynamic typing.<p>&gt; So that&#x27;s why I had to create Nim; there was a hole in the programming language landscape for a systems programming language that took Ada&#x27;s strong type system and safety aspects, Lisp&#x27;s metaprogramming system so that the Nim programmer can operate on the level of abstraction that suits the problem domain and a language that uses Python&#x27;s readable but concise syntax.')