Item(by='ihumanable', descendants=None, kids=[24702004], score=None, time=1602014963, title=None, item_type='comment', url=None, parent=24700508, text='I work in Elixir most of the time but can read and write Erlang reasonably well, here&#x27;s my two cents.<p>Elixir&#x27;s syntax was inspired by ruby and so if you&#x27;ve used ruby or look at ruby code and think, &quot;yea, I get what&#x27;s going on here&quot; then you will likely find working with Elixir&#x27;s syntax preferable to Erlang.  Erlang&#x27;s syntax was based off of Prolog and so it will be less familiar, unless you have done a bunch of Prolog programming.<p>Elixir layers on a bunch of things that are very nice to have at a language level, the ability to rebind names is probably the one that most impacts code.  In Erlang you can&#x27;t rebind a variable, so Erlang code ends up either using lots of very small functions of having variables like `n` `n2` `n3`.  It&#x27;s not that you can&#x27;t write good, clean, easy to reason about code in Erlang, but if you are coming from a language with mutability and variable rebinding, it&#x27;s a bit of a culture shock.  I find that Elixir hits a nice medium ground to allow you to wrap your head around immutable data structures, functional programming, actor model, OTP without ALSO having to climb the hills of unfamiliar syntax and some limitations (like variable rebinding) that aren&#x27;t strictly necessary.<p>From a tooling standpoint, I find Elixir to be a bit more pleasant than Erlang.  Mix (build tool) is great, ExUnit (unit testing) is great, ExDocs (docs generation) is great, Hex (package management) is great.  The Elixir community has somehow stayed pretty unified when it comes to tools and for the most part they work really well.<p>From an interoperability standpoint, you really don&#x27;t leave anything behind choosing to use Elixir over Erlang.  Erlang dependencies work just fine, and the interop is so easy, here, I&#x27;ll give you an example.<p>Want to use an Erlang module directly from your Elixir code, here&#x27;s an example of how to use the timer module.<p><pre><code>  :timer.seconds(1)\n</code></pre>\nThat&#x27;s it, that&#x27;s the interop, you don&#x27;t have to import anything weird, you don&#x27;t have to fence off your code, you don&#x27;t have to juggle types from Elixir types into Erlang types and back again.  Want your Erlang interop to look more like elixir, two lines of code.<p><pre><code>  alias :timer, as: Timer\n  Timer.seconds(1)\n</code></pre>\nOverall the Erlang and Elixir communities are friends (and Gleam, LFE, and all the other BEAM Languages). It&#x27;s a very positive community all working to build great functionality on top of the really cool piece of tech that is the BEAM VM.')