Item(by='KMag', descendants=None, kids=None, score=None, time=1609922281, title=None, item_type='comment', url=None, parent=25655644, text='&gt; One concern with logic programming is cost of computation,<p>Right, but the client executes the contract, keeping a trace of what needs to be computed by the verifier.  The verifier doesn&#x27;t actually execute the full contract, just verifies that the trace was faithfully executed.  If we have<p><pre><code>  let R = (A() || B() || C() || D()) &amp;&amp; ! E();\n  R().\n</code></pre>\nIf A is costly, but true 99% of the time, but this transaction is one of the 0.001% of the cases where D() is true, the contract verification trace says to execute D(), and the verifier never checks A, B, or C.  See my nearby comment for a worked out example of a compact trace representation for a deeper disjunction decision tree.<p>Effectively, because declarative languages don&#x27;t dictate order, the client is free to re-order the contract execution order to be optimal for this particular execution, without altering semantics.  Declarative semantics, are by definition, independent of execution order.  This makes efficient compilation and execution more difficult, but makes verification faster (if the verifier is provided with an execution trace).<p>Now, you could potentially do similar optimizations with Solidity contracts, with a suitably modified EVM definition, but if the execution order is up to the runtime&#x2F;compiler instead of dictated by the source code, then you&#x27;ve by definition changed the language to be declarative.')