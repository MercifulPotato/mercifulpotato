Item(by='labawi', descendants=None, kids=None, score=None, time=1610404833, title=None, item_type='comment', url=None, parent=25727169, text='&gt; As a mostly C++ programmer making sure that I get compiler errors as often as possible by encoding most preconditions in the type system ..<p>When selecting a language for a recent project, that needed to run correctly, without extensive debugging that would be hard to simulate (too many states and interactions), I had a couple of important criteria:<p>0) checked static typing<p>1) ADTs (that are reasonably easy to use, read and write)<p>2) pattern matching (no way I&#x27;ll get all the if&#x2F;else right)<p>3) reasonably easy to write static const (pure functional) code<p>4) memory-safe<p>I&#x27;ve considered rust, but settled on haskell, as I needed it fast and I know haskell. While technically any Turing-complete language would work, I don&#x27;t think C++ would be a fit for must-work code, even disregarding (4).<p>While I haven&#x27;t used C++ in a while, it seems to me, encoding the constraints would be 3-10x as much code, or even more, with many checks&#x2F;cracks left, and a lot of readability gone.<p>Clean and correct functional haskell code took a bit longer to write than say happy-path imperative python, but after fixing 2 or so bugs that manifested on pretty much the first (partial) use (like incorrect &quot;&lt;&quot; vs. &quot;&gt;&quot; and a bad constant), it has been running happily ever since. I didn&#x27;t even bother simulating a full system configuration before a real-world customer acceptance test, because components worked on 1-2 inputs I tried, setting up a system would take a couple of hours and I couldn&#x27;t think of reasonable failure scenarios. I haven&#x27;t experienced similar correctness in other languages.')