Item(by='kazinator', descendants=None, kids=[25686166, 25684959], score=None, time=1610099761, title=None, item_type='comment', url=None, parent=25681362, text='Inspired by my observation that tail calls can be seen as &quot;goto with arguments&quot;[1], in 2013 I wrote a Common Lisp macro called <i>argtags</i> which is like <i>tags&#x2F;prog</i>, but with labels that have parameters. Giving them arguments causes the corresponding variables to be assigned as the transfer takes place. It compiles to <i>tagbody</i>.<p>Then, I used <i>argtags</i> as the basis for <i>tlet</i>: a macro that looks like it is defining local functions using syntax similar to <i>labels</i> or <i>flet</i>, but actually compiles to <i>argtags</i>, so everything ends up as a <i>tagbody</i>.<p>The calls are always tail calls, whether or not in tail position. You cannot accidentally blow the stack, but you can accidentally expect a call to return, which it won&#x27;t!<p>This is all found here:<p><a href="http:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;lisp-snippets&#x2F;tree&#x2F;tail-recursion.lisp" rel="nofollow">http:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;lisp-snippets&#x2F;tree&#x2F;tail-recursio...</a><p>There is a complementary cross-module tail calling system in here which provides a <i>defun</i>-like construct <i>deftail</i> for defining tail calling functions. That&#x27;s based on a trampoline dispatch loop: tail calls unwind up to the loop, passing their arguments to it, along with the next function to be called.<p>[1] Later I found out that Steele also offered the viewpoint back in the 1970&#x27;s that tail calls can be seen as goto with arguments.')