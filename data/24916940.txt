Item(by='std_badalloc', descendants=None, kids=[24918620], score=None, time=1603878200, title=None, item_type='comment', url=None, parent=24915497, text='I don&#x27;t think the example here is the best. There&#x27;s a case to be made for extracting pure functions and organizing them like this, but I don&#x27;t think this code makes it. The benefit of pure functions IMO is primarily in that the code becomes easy to reason about if it doesn&#x27;t depend on state. But any app that does anything will have state, and the question is how you manage that. One guideline could be that individual code units should reduce the amount of state you need to worry about at higher levels of abstraction.<p>In the example, there is hardly any code that does anything different depending on state. There&#x27;s no state being managed, so there isn&#x27;t actually any architectural problem being solved here. Should the API go down or change its format, the code breaks. The pure pluck_definition() will still fail to parse the JSON if the format changes. The pure build_url() will stop working if the API changes its URL format. They will pass unit tests, but fail in practice.<p>An actual problem to be solved here is to abstract away the details of the REST API, formatting and network errors. One way to do this is to pack that into a component with a well defined interface. You can still do this stateful&#x2F;non-stateful split within the component if you want, but on the application level you need to apply that heuristic recursively at different levels of abstraction.')