Item(by='typedef_union', descendants=None, kids=[25629597], score=None, time=1609749914, title=None, item_type='comment', url=None, parent=25626227, text='&gt;The reason that C programs often don’t perform as well as an equivalent rust program[1] is that it’s so incredibly hard to do anything at all in C (especially something reliable) that one can usually only do the simplest thing possible and this typically means simple data structures, simple algorithms and arrays<p>Reliability is very often the name of the game with C, and part of the reason you might see it written in such a simplistic fashion. In embedded systems, we often follow very strict code convention that has strict requirements on how a C program is to be written. This includes everything from how memory is to be allocated, the maximum number of local variables, the maximum number of the arguments, various limits on a function, constraints to handle errors, etc. We do this because it minimizes potential hazards especially when working with limited memory and system resources.<p>C is an unforgiving language in that mistakes can occur silently and on mission critical hardware these mistakes can cost more than just your project milestones. These programs are very specialized and often have complex algorithms associated with them. Most of the systems I&#x27;ve worked with include various kinds of feedback control systems, and accompanying algorithms. If you&#x27;re familiar with control systems, you&#x27;ll know these algorithms are certainly not trivial by any means.<p>The challenge with C is more as a developer your C code needs to be perfect. Bugs just aren&#x27;t an option like they are in other environments. Once a specialized piece of hardware ships it needs to work as intended under a myriad of conditions without powering off for the next 30 years (not always the case but more often than you might think). Sometimes this kind of software is going to be put a position it may have never been designed for. The best we can do is try to add various check&#x2F;support mechanisms both in software and in hardware, and maintain as safe and hazard free software as possible.<p>In terms of performance, again coming from an embedded environment, there is almost always a spec we are aiming for. It needs to do X tasks in N time for example. Of course high level design questions like whether to poll or wait for interrupt, or how to broker data from shared resources is decided long before you get to the question of how should I, or if I even should, compare two strings. It is nevertheless advised to go with a trivial solution if the ends satisfy the needs.<p>Is C time-consuming to write? Is C a &quot;hard&quot; language? These are subjective and depend on the nature of the project. I would certainly never use C with only libc to write a webserver that&#x27;s going to be serving SaaS Co&#x27;s backend API.')