Item(by='jstimpfle', descendants=None, kids=[25644380], score=None, time=1609840515, title=None, item_type='comment', url=None, parent=25639811, text='&gt; Why the heck am I writing timeInMs or timeInSeconds still?<p>Because &quot;keeping track of types&quot; is much more complicated than one would think at first. How many languages are there that can do something like (3A * 4V == 12VA), (12VA &#x2F; 3A == 4A)? What if you want to use a generic routine that is just about the integers? It will lose track of all the types. I claim that there is still no nice way to do this stuff except scripting languages (dynamic types).<p>One of the languages that go a little more into types than mainstream languages but still are somewhat close to mainstream is Haskell. Have you ever tried to use it? You get quickly sucked down into a sea of language and type extensions that you have to use, and that are often mutually incompatible, most of them probably the result of a PhD thesis. And you never quite get at what you want (if you want sth slightly differend the card house tumbles and you have to pick a different set of extensions). That is unless you&#x27;re very, very smart, and have so much investment into Haskell that you know the current limits, so you&#x27;re able to choose a model that is still within the bounds of representability in the language.<p>For all of us mere mortals and practitioners, we use simple integers and get our job done.<p>For everyone still clinging on the idea of types, I strongly believe the type system vs runtime values dichotomy is a dead end. Sometimes you <i>need</i> dynamic computations with types - sometimes types of expressions are known statically, but sometimess not. That&#x27;s why most mainstream type systems keep it simple and provide escape hooks (like void-pointers or RTTI).')