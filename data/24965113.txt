Item(by='zmix', descendants=None, kids=[24965513], score=None, time=1604296168, title=None, item_type='comment', url=None, parent=24941663, text='I don&#x27;t know what XPath 3.1 implementation you use, but the two major implementations, I have at hand, SaxonEE and BaseX, both do not understand your code. You write:<p><pre><code>  for-each(normalize-unicode(upper-case(json-doc(&#x27;x.json&#x27;))) =&gt; tokenize(&quot;\\s+&quot;),\n    function($a) {\n      let $a := $a * 10\n      load-xquery-module(&#x27;abc&#x27;):some-func(\n        function-lookup($a, 1)(array:map($a, function($b) {\n          let $c := unparsed-text-lines($b)\n          trace($c)\n          if ($c) {\n            return xml-to-json($b)\n          } else {\n            error(&#x27;This is an error&#x27;)\n          }\n        })) \n      }\n  )\n</code></pre>\n1. fn:json-doc(), by default and typically, returns either an XPath map or array datatype. Therefore fn:tokenize() can not be used with it. Just as fn:normalize-unicode() and fn:upper-case() can not (both take a string as input) The error is: [FOTY0013] Items of type map(*) cannot be atomized.<p>2. in your anonymous function &#x27;function($a) {...&#x27; you use a &#x27;let&#x27; expression without &#x27;return&#x27;. This is illegal.<p>3. As is the use of a colon &#x27;:&#x27; after fn:load-xquery-module(). The colon seperates prefixes from namespaces. Did you mean the question-mark &#x27;?&#x27;? That would make sense, since fn:load-xquery-module() returns a map. But then &#x27;some-func(...&#x27; would not work out, since the returned map has two keys: &quot;variables&quot; and &quot;functions&quot; and &#x27;some-func()&#x27; would be referenced in another map, which is the value of the &#x27;functions&#x27; key.<p>4. Calling fn:function-lookup() (as the parameter to some-func()) with a value, that must be a string ($a), which you then multiply with an integer (10)) will already have errored out (multiply string with integer is not possible), but even if this would be possible, the next error would arise since the first parameter to this function must be an xs:QName type, which a number (or string), clearly, is not.<p>5. The function, you look up in the external module takes an array:map() function as first parameter. Such a function does not exist in the XPath 3.1 standard (see <a href="https:&#x2F;&#x2F;maxtoroq.github.io&#x2F;xpath-ref" rel="nofollow">https:&#x2F;&#x2F;maxtoroq.github.io&#x2F;xpath-ref</a>). You may have studied a version of the specification, which was written, before the array functions have been finalized, which was in 2017. That could mean, that what you wanted to express, would now be array:fold-left(), which is how a map() function is being called in XPath. However, that function takes three parameters.<p>6. Again, this is not valid XPath grammar:<p><pre><code>    let $c := unparsed-text-lines($b)\n    trace($c)\n    if ($c) {\n      return xml-to-json($b)\n    } else {\n      error(&#x27;This is an error&#x27;)\n    }\n</code></pre>\nIt would need to be:<p><pre><code>    let $c := unparsed-text-lines($b)\n    return (\n             trace($c)\n           , if ($c)\n             then xml-to-json($b)\n             else error(&#x27;This is an error&#x27;)\n           )\n</code></pre>\nAlso, $c can not evaluate to a boolean ([FORG0006] Effective boolean value not defined for xs:string+), since it is a sequence of strings. Of course, such things could be implementation dependent...<p>I don&#x27;t want to go any further, since I can not totally recapitulate, what your code is supposed to do. It may be some &#x27;blackhattish&#x27; dark magic, that fucks up some engines, but the engines I use do not even go through with compilation, due to the invalid XPath code. As is, your code does not make much sense. At least, if we talk about XPath 3.1.<p>Your bashing of XPath 3.1 (and also 2.1) makes no sense either, since you seem to use a completely non-standard processor, with a different syntax and functions, that behave very differently from XPath 3.1, or, even worse, did not understand the language.<p>Many of the changes to XPath, starting with version 2.1, stem from the fact, that XPath became a subset to XQuery, a fully functional and declarative programming language, that satisfies the need, to query XML documents as they would be databases. This was done in order to satisfy the needs of non-programmers, like in the digital humanities, the publishing industry, etc.<p>XQuery 3.1, as a superset of XPath 3.1, is a language made in heaven! Nowhere is it that simple, to work with (X)HTML, JSON and XML documents as here! A fully functional, declarative language, that has templating (think handlebars, moustache) built in as an integral part of the language, where you can just intermix you XML code with program code, with easy error tracing (stateless!), quick &quot;to production&quot; development cycles and a painless approach to anything XML!<p>XML is one of the most misunderstood technologies in our industry and the only solid document technology, I know of. Sadly, also based on this misunderstanding, a whole generation of developers has evolved, which listened to those, who jumped the hypetrain of XML, just to realize, that a document format may not be the best tool for the job (RPC, \nconfiguration files, etc.). And instead of admitting to themselves, that they were wrong, they accuse the technology, they abused, teaching the kids to make their lifes more difficult. And these kids now are in charge of browser development, etc. And adding to that, your lightheaded comments do not really help the issue.')