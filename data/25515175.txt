Item(by='josephg', descendants=None, kids=None, score=None, time=1608706700, title=None, item_type='comment', url=None, parent=25514483, text='&gt; Meh. I&#x27;ve think Option is just null with extra steps.<p>Yeah, but those extra steps are worth it. I&#x27;ve written a fair bit of typescript and javascript, and I feel like I need to be always careful about nullable values in javascript. Like, I agree that Option is null with extra steps - but those extra steps make it harder for bugs to creep into my code.<p>In JS its all too easy to accidentally write getNullableVal().doStuff(). Or doStuffWith(nullableVal) and inside the function accidentally forget that the value can be null. In typescript the compiler forces me to consider the nullable case for nullable values, and as a result my code ends up better. And when I pass a nullable value into a method, its clear from the type signature whats going on. I still make bad assumptions sometimes and unwrap when I shouldn&#x27;t, but when crashes happen they happen closer to the bug in the code.<p>My favorite syntax for all this is Swift, which understands nullable types at a language level. (Rather than at the type level in rust &#x2F; haskell). It means the language can coerce X -&gt; Just(X), so making function arguments nullable doesn&#x27;t break callers. And let myVal: SomeType? &#x2F; myVal!.foo() syntax seems strictly better than rust&#x27;s let myVal: Option&lt;SomeType&gt; &#x2F; myVal.unwrap().foo().')