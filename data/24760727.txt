Item(by='dllthomas', descendants=None, kids=[24761088], score=None, time=1602545639, title=None, item_type='comment', url=None, parent=24760007, text='&gt; I realized that there is no way to take a value out of an IO purely, that is, you cannot have a function IO a -&gt; a.  It is not because IO is a Monad and Monads are special cased magic, but simply because the constructor of IO is not exported out of its module.<p>That&#x27;s not really why.  Even if you could unwrap the IO constructor, there is no `a` inside it!<p>As it turns out, with you <i>can</i> unwrap the IO constructor if you import GHC.Types from ghc-prim:<p><pre><code>    Prelude&gt; import GHC.Types\n    Prelude GHC.Types&gt; :set -XUnboxedTuples \n    Prelude GHC.Types&gt; let (IO f) = getChar\n    Prelude GHC.Types&gt; :t f\n    f :: GHC.Prim.State# GHC.Prim.RealWorld\n         -&gt; (# GHC.Prim.State# GHC.Prim.RealWorld, Char #)\n</code></pre>\nWhat&#x27;s inside is a function.  You can&#x27;t get the return value out of a function without running it.  You can, of course, run it.  `unsafePerformIO` will give you a thunk that, when forced, will do just that.')