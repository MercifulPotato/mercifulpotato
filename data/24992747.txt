Item(by='steveklabnik', descendants=None, kids=[24994177], score=None, time=1604521732, title=None, item_type='comment', url=None, parent=24992537, text='Here&#x27;s an example. You want to do some computations on an array of values:<p><pre><code>    fn main() {\n        let mut v = vec![1, 2, 3];\n        \n        for i in &amp;mut v {\n            *i += 1;\n        }\n        \n        println!(&quot;v: {:?}&quot;, v);\n    }\n</code></pre>\nThey want to speed this up with threads. So they ask &quot;how do I do threads in Rust&quot; and get pointed to std::thread. So they write this code:<p><pre><code>    use std::thread;\n\n    fn main() {\n        let mut v = vec![1, 2, 3];\n        \n        for i in &amp;mut v {\n            thread::spawn(move ||{\n                *i += 1;\n            });\n        }\n        \n        println!(&quot;v: {:?}&quot;, v);\n    }\n</code></pre>\nand they get this error message:<p><pre><code>    error[E0597]: `v` does not live long enough\n      --&gt; src&#x2F;main.rs:6:18\n       |\n    6  |         for i in &amp;mut v {\n       |                  ^^^^^^\n       |                  |\n       |                  borrowed value does not live long enough\n       |                  argument requires that `v` is borrowed for `&#x27;static`\n    ...\n    13 |     }\n       |     - `v` dropped here while still borrowed\n</code></pre>\n(there&#x27;s more to the error message but I&#x27;m cutting it to the start)<p>So they ask &quot;hey how do I make v live for &#x27;static&quot; and someone says &quot;you use Arc&quot; so they write this:<p><pre><code>    use std::thread;\n    use std::sync::Arc;\n\n    fn main() {\n        let v = Arc::new(vec![1, 2, 3]);\n        \n        for i in v.iter_mut() {\n            thread::spawn(move ||{\n                *i += 1;\n            });\n        }\n        \n        println!(&quot;v: {:?}&quot;, v);\n    }\n</code></pre>\nand get this error:<p><pre><code>    error[E0596]: cannot borrow data in an `Arc` as mutable\n     --&gt; src&#x2F;main.rs:7:18\n      |\n    7 |         for i in v.iter_mut() {\n      |                  ^ cannot borrow as mutable\n      |\n      = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::sync::Arc&lt;std::vec::Vec&lt;i32&gt;&gt;`\n</code></pre>\nSo then they ask &quot;hey I have an arc, but I want to mutate things inside of it, how do I do that?&quot; and the answer is &quot;use a mutex&quot;, so they write this:<p><pre><code>    use std::thread;\n    use std::sync::{Arc, Mutex};\n\n    fn main() {\n        let v = Arc::new(Mutex::new(vec![1, 2, 3]));\n        \n        for i in v.lock().unwrap().iter_mut() {\n            thread::spawn(move ||{\n                *i += 1;\n            });\n        }\n        \n        println!(&quot;v: {:?}&quot;, v);\n    }\n</code></pre>\nbut this <i>still</i> doesn&#x27;t work, because the lock is held during multiple threads of execution. So they figure out that they can do this:<p><pre><code>    use std::thread;\n    use std::sync::{Arc, Mutex};\n\n    fn main() {\n        let v = Arc::new(Mutex::new(vec![1, 2, 3]));\n        let mut joins = Vec::new();\n        \n        for i in 0..3 {\n            let v = v.clone();\n            \n            let handle = thread::spawn(move ||{\n                v.lock().unwrap()[i] += 1;  \n            });\n            \n            joins.push(handle);\n        }\n        \n        for handle in joins {\n            handle.join().unwrap();\n        }\n        \n        println!(&quot;v: {:?}&quot;, v);\n    }\n</code></pre>\nI&#x27;ve skipped a few iterations here because this comment is <i>already</i> too large. The point is, they&#x27;ve now accomplished the task, but the boilerplate is <i>way way way</i> out of control.<p>A more experienced Rust person would see this pattern and go &quot;oh, hey, these threads don&#x27;t actually live forever, because we want to join them all, but the compiler doesn&#x27;t know that with thread::spawn because it&#x27;s so general. What we want is scoped threads&quot; and writes this:<p><pre><code>    use scoped_threadpool::Pool;\n\n    fn main() {\n        let mut pool = Pool::new(3);\n        let mut v = vec![1, 2, 3];\n        \n        pool.scoped(|scope| {\n            for i in &amp;mut v {\n                scope.execute(move ||{\n                    *i += 1;       \n                });\n            }\n        });\n        \n        println!(&quot;v: {:?}&quot;, v);\n    }\n</code></pre>\nand moves on with life. Way more efficient, way easier to write, extremely hard for a new person to realize that this is what they should be doing.')