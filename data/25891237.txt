Item(by='gutensearch', descendants=None, kids=None, score=None, time=1611488221, title=None, item_type='comment', url=None, parent=25891090, text='Thanks for the suggestions! I will try them next.<p>&gt; Looking at your where clause, did you index language and textsearchable_index_col together ? If not, you are giving the planner the opportunity to skip your full text index.<p>Here is the index:<p><pre><code>  update gutenberg.paragraphs\n  set textsearchable_index_col = to_tsvector(b.cfgname::regconfig, coalesce(paragraph, &#x27; &#x27;))\n  from\n  gutenberg.all_data a \n  inner join pg_ts_config b on lower(a.language) = b.cfgname \n  where gutenberg.paragraphs.num = a.num;\n  create index textsearch_paragraph_idx on gutenberg.paragraphs using gin (textsearchable_index_col);\n</code></pre>\n&gt; if you order by ts_rank_cd then the query will sort all rows, including those that don&#x27;t match. A better pattern is to take the ranking score as a column and then sort it in a subquery. [1] from stack overlfow has an example. (As an aside, from pg2, CTEs are no longer an optimization fence, so you can write the query out more cleanly with a CTE and still get the desired performance).<p>Ranking was already done as a column in a CTE and ranked further down:<p><pre><code>  with paragraphs as (\n                select \n                num\n                , paragraph\n                , ts_rank_cd(textsearchable_index_col, phraseto_tsquery(%s::regconfig, %s), 32) as rank \n                , ts_headline(%s, paragraph, phraseto_tsquery(%s::regconfig, %s), &#x27;MaxFragments=1000, StartSel=**, StopSel=**&#x27;) as highlighted_result \n                from gutenberg.paragraphs \n                where language = %s::regconfig and textsearchable_index_col @@ phraseto_tsquery(%s::regconfig, %s)\n            ) \n</code></pre>\nI did rewrite the query as per your [1] but EXPLAIN ANALYZE found no difference.<p>Pagination is a tricky one. I was in a rush and hit an issue where building large Dash tables was very expensive and prone to crashing. I initially set up pagination as per the Dash examples, but that didn&#x27;t play nice with markdown which I needed for the URLs and highlighting (giving these up for plain text tables made in HN-fast, but it confused my trial users). So the quick and dirty solution &quot;to ship now&quot; was to set up custom pagination in the SQL and show the results.<p>I think that if there is enough interest in this project, the front end will have to move off Dash.')