Item(by='013a', descendants=None, kids=[25020386, 25023504], score=None, time=1604787918, title=None, item_type='comment', url=None, parent=25019707, text='No, its still an issue. If you have QueryA which requests User { firstName } and QueryB which requests User { lastName }, those queries both have to request their data in order for both fields to be cached.<p>If, instead, you have QueryC which does User { firstName, lastName }, but two usages of it (QueryC1&#x2F;QueryC2), after QueryC1 requests, QueryC2 can use the cached results. This works whether you&#x27;re doing Query&#x2F;Operation level caching or Field&#x2F;ID level caching. The former example works in neither. And QueryC is trivially faster than QueryA+QueryB because of network overhead.<p>This isn&#x27;t necessarily an issue with GraphQL (and, I thought I was clear about this, but: I&#x27;m not against GraphQL). Its a behavior of both typical REST implementations and GraphQL. And, to be clear, GraphQL&#x27;s out-of-box caching story is more powerful than any REST implementation I&#x27;ve seen short of hyper-engineered FAANG companies, because it enables really powerful field&#x2F;ID level caching across multiple queries. But it doesn&#x27;t work in this case.<p>The point is that its still very immature. Even the thought leaders (Apollo being the biggest one and worst offender) write these blog posts filled with Best Practices and Recommendations that often convey horrible advice and flat-out misrepresent GraphQL&#x27;s actual advantages compared to REST. GraphQL solves a lot of REST&#x27;s problems; it does NOT solve REST&#x27;s &quot;god-object&quot; class of problems, like the grandparent comment suggests; and it introduces many new classes of problems that remain unsolved in the ecosystem because of how immature it is (one great example is OSI L7 inspection in many tertiary tools a typical SaaS app has. Many products like Datadog, CloudFront, AWS ALB, etc are capable of doing some really cool and powerful stuff out-of-the-box just by inspecting standard HTTP headers. REST is basically just standard HTTP; your resource is in the path, query parameters, http headers, its very standard. GraphQL is not, so many of these tools don&#x27;t work out-of-box with GraphQL. People are catching up, but again, its immature).')