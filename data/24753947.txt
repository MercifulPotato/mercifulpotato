Item(by='nsajko', descendants=None, kids=None, score=None, time=1602507774, title=None, item_type='comment', url=None, parent=24753793, text='I used the following C code earlier this year (use at your own peril): <a href="https:&#x2F;&#x2F;github.com&#x2F;nsajko&#x2F;numericcompfricas&#x2F;blob&#x2F;master&#x2F;check&#x2F;checker.c#L234" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;nsajko&#x2F;numericcompfricas&#x2F;blob&#x2F;master&#x2F;chec...</a><p>Distance between 0.0 and -0.0 is taken to be 0. If x or y are NaN, the distance is taken to be the greatest positive value of the return type.<p>Replace mfloat_t with double. Replace int64 with long or similar.<p><pre><code>  int64\n  ud(mfloat_t x, mfloat_t y) {\n          &#x2F;&#x2F; Handle NaNs.\n          if (x != x || y != y) {\n                  return (int64)(~0UL &gt;&gt; 1);\n          }\n\n          union {mfloat_t X; uint64 a;} u1;\n          union {mfloat_t Y; uint64 b;} u2;\n          u1.X = x;\n          u2.Y = y;\n          uint64 a = u1.a, b = u2.b;\n\n          if ((a &amp; (1UL &lt;&lt; 63)) == (b &amp; (1UL &lt;&lt; 63))) {\n                  &#x2F;&#x2F; a and b are of the same sign.\n                  a = a - b;\n                  if ((a &amp; (1UL &lt;&lt; 63))) {\n                          return -a;\n                  }\n                  return a;\n          }\n          return (int64)(a - (1UL &lt;&lt; 63) + b);\n  }\n</code></pre>\nUsing memcpy could be more portable than using unions, but I think it doesn&#x27;t really matter.<p>EDIT: The Musl libc, for example, also uses unions instead of memcpy: <a href="https:&#x2F;&#x2F;git.musl-libc.org&#x2F;cgit&#x2F;musl&#x2F;tree&#x2F;src&#x2F;math&#x2F;nextafterf.c" rel="nofollow">https:&#x2F;&#x2F;git.musl-libc.org&#x2F;cgit&#x2F;musl&#x2F;tree&#x2F;src&#x2F;math&#x2F;nextafterf...</a>')