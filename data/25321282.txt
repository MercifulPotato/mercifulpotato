Item(by='enriquto', descendants=None, kids=[25321751], score=None, time=1607232023, title=None, item_type='comment', url=None, parent=25320523, text='Putting VLA in the stack is just an implementation choice.  A conforming implementation could allocate all VLA in the heap (and freeing the memory upon scope loss), or do not even use a stack&#x2F;heap system at all.  In that sense, VLA are a crucial language feature to allow a RAII-style for C code.  Essentially, you could replace this<p><pre><code>    void f(int n, ...)\n    {\n            float *t = malloc(n * sizeof*t);\n            &#x2F;&#x2F; do stuff with t[i]\n            free (t);\n    }\n</code></pre>\nwith the following semantically equivalent code<p><pre><code>    void f(int n, ...)\n    {\n            float t[n];\n            &#x2F;&#x2F; do stuff with t[i]\n    }\n</code></pre>\nToday, this is not a good idea for large arrays because, unfortunately, many C implementations put VLA in the stack.  I hope that by keeping VLA in the standard language, future C implementations will get to favor this usage.<p>Notice that VLA are not more dangerous or risky than recursion.  The exact same argument that you use against VLA can be used against recursion.  Are you against recursive functions in C?  Of course, you wouldn&#x27;t traverse a long array using recursion, but if you are careful that the depth of recursion is logarithmic with the array size (e.g. as in binary search), then it is perfectly safe and reasonable to use recursion.  The same thing with VLA.  If you are sure that n is 2,3 or at most 4 there&#x27;s no reason to avoid VLA due to stack scare, and they may make your code much simpler, clearer and better.<p>On the other hand, VLA are useful even if you do not use them to allocate memory.  Pointers to vla can be used for many things, for example accessing a one-dimensional array (allocated by a single call to malloc) using two indices as if it was a 2d array.')