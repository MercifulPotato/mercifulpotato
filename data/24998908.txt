Item(by='iainctduncan', descendants=None, kids=[24999039, 24999219, 25000789, 25000267, 24999497, 24999052, 24999884, 24999771, 25001594, 24999075, 25001884, 25001002, 25000297, 25000643, 25000885, 24999010, 25001529, 24999785, 24999957, 24999443, 25001595, 25000163, 25000396, 25007583, 24999910, 25002618, 25002172, 25000021, 25004549, 25003041, 24999132, 24998975, 25002078, 24999280, 25001667, 25000124, 24999045], score=None, time=1604589263, title=None, item_type='comment', url=None, parent=24997496, text='I was a total raving Python evangelist for the first 12 years of my coding career, and then got a job as the CTO for a Python based startup that had been running absent a technical leader for 5 years, with relatively junior coders making all the decisions. I still love Python, but I now have a completely different attitude to hyper-dynamic languages (like Python, Ruby, Clojure, Elixir, etc). In my <i>new</i> opinion, they are great for anyone making small projects, and good for disciplined, experienced teams making larger projects, but are really double-edged swords in large projects. If your team really knows what they&#x27;re doing and can take advantage of the flexibility without creating a mess, they can let you move really fast and make elegant DSLs and so on. But if you let a team of juniors do whatever seems like a good idea, with nobody calling the shots who understands tech debt and the large-scale architecture problems, the mess that can be made is staggering. I never thought I&#x27;d say this before, but I would have been happier stepping into C++. :-&#x2F;<p>Sure, this is a problem of people, not language. But there is something to the argument that absent discipline and experience, these can be dangerous. One can detangle a dog&#x27;s breakfast in Java Spring a lot more easily.<p>(ever seen &quot;import gc&quot; in a Python program? yes, that means what you think it means..)')