Item(by='pbowyer', descendants=None, kids=[24909651, 24909961, 24910306, 24909756, 24909486, 24909514], score=None, time=1603818528, title=None, item_type='comment', url=None, parent=24908729, text='&gt; Nowadays users browse the web using their phones, tablets, and laptops, yet images are still as a one size fits all. For example: sites load a 2000 by 2000 pixel image, but phones are only displaying it as 100 by 100 pixels.<p>That&#x27;s what srcset &amp; &lt;source&gt; were invented for.<p>&gt; Furthermore, 30% of images on web pages are outside of the initial viewport, meaning the browser loads images that a user does not see until they scroll further down the page.<p>That&#x27;s why we now have a loading=lazy HTML attribute<p>&gt; When using the next&#x2F;image component, images are automatically lazy-loaded, meaning they&#x27;re only rendered when the user is close to seeing the image. This prevents loading that 30% of images outside of the initial viewport.<p>This has been done many times before. For images outside the viewport it&#x27;s great; for images which are in the viewport, the browser isn&#x27;t able to discover the image until the JS has loaded and decided which image size to fetch. In my experience this slows down the overall rendering of the page.<p>I see the Google Chrome team was involved in creating this component so I&#x27;d like to know what&#x27;s different this time, because they have the data.<p>&gt; Developers can mark images that are in the initial viewport, allowing Next.js to automatically preload these images. Preloading images in the initial viewport has shown improvements to the Largest Contentful Paint by up to 50%.<p>How can smart preloading work when the image size isn&#x27;t known until the JS component runs? If we&#x27;re back to loading the 2000px image then we&#x27;re losing a lot of optimization.<p>If they&#x27;re relying on client hints [1] then we can get as far as an image as wide as the browser window width, but no more - at the price of poor browser compatibility.<p>Preloading also has its own costs, as it messes with the browser&#x27;s prioritization of page content. I&#x27;ve found it easy to prioritize something you know is essential and unintentionally increase load time metrics.<p>1. <a href="https:&#x2F;&#x2F;caniuse.com&#x2F;client-hints-dpr-width-viewport" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;client-hints-dpr-width-viewport</a>')