Item(by='pizza234', descendants=None, kids=[24836522, 24836593, 24836389, 24836777, 24837094, 24836419, 24836359, 24838092, 24836323], score=None, time=1603194729, title=None, item_type='comment', url=None, parent=24835357, text='I think this an argument like the following is not really meaningful:<p>&gt;  Most of this difference is not related to lifetimes. Rust has patterns, traits, dyn, modules, declarative macros, procedural macros, derive, associated types, annotations, cfg, cargo features, turbofish, autoderefencing, deref coercion etc<p>Nobody forces beginners to write macros. Beginners are only macros _users_. With time and experience, the need for macros emerges by itself, then learning them is a natural part of the process. But even then, nobody is forced to write any.<p>Dyn is also a very obvious concept to anybody who knows a bit of OO-programming in lower-level languages (e.g. C++). The choice to make dynamic dispatching explicit is arguable, but ultimately, although making it explicit is (AFAIK) Rust-specific, the concept itself isn&#x27;t.<p>Complaining on pattern matching? C&#x27;mon :-) It&#x27;s a bit like a Python programmer complaining that Golang has a switch&#x2F;case.<p>I don&#x27;t argue that Rust is hard or not, but it seems to me that the author was overwhelmed, and complained about everything, even simple things.<p>In my experience, in the Rust learning process (and programming experience), all the concepts above are dwarfed by the headaches induced by the borrow checker.<p>&gt; Zig has it&#x27;s own implementation of standard OS APIs which means that linking libc is completely optional. Among other things, this means that zig can generate very small binaries which might give it an edge for wasm where download&#x2F;startup times matter a lot.<p>I&#x27;m curious about the details of this. Rust has `no_std`, however, it seems that in Zig, this is more (in a way) granular?')