Item(by='Cthulhu_', descendants=None, kids=[24775197, 24776313], score=None, time=1602663630, title=None, item_type='comment', url=None, parent=24773555, text='I&#x27;ve worked with two major (well, relatively) microservices architectures and honestly it made things many times more complicated and expensive than they should have.<p>In the one, I came in after a year and a half and they still had nothing to show for other than some marketing (this was fairly straightforward e-commerce). They tried to bolt Java applications together using Amazon Kinesis (which isn&#x27;t intended as a service bus) and we quickly ran into issues because the stock &#x2F; inventory service was separate from the order processing service, so any incoming order would have to do a weird round trip to confirm stock before it could confirm the order to the end-user. To name but one example.<p>The other was for a shipping company, where every &#x27;model&#x27; (users, addresses, shipments, etc) was put in its own microservice. That one started out with NodeJS services before - for some reason, probably political &#x2F; hiring related) migrating to Scala, only adding to the complexity of what, in essence, was a CRUD application where the heavy lifting was still being done in the legacy back-end &#x2F; mainframe systems.<p>I don&#x27;t get it. Glad I&#x27;m working on a project right now where I have full control over things, it&#x27;s also a CRUD project but I can build it as a straight monolith.<p>One other anecdote I have is where we built a serverless application. It too was e-commerce, but the heavy lifting was done by as-a-services; we used Commercetools as e-commerce back-end as as service, Contentful as CMS-as-a-service, Adyen for payment processing, and we used a heap (about 30) &#x27;serverless&#x27; functions deployed in Netlify as the glue. Seemed to work all right, better than the microservices attempt (because the individual functions didn&#x27;t have to talk to one another; they responded to either user &#x2F; client requests, or events generated from one of the services doing the heavy lifting).<p>Anyway if I had to do ALL of those again (and if I actually had a say in it, lol) I&#x27;d just write them as plain old Java monoliths.<p>The reason that&#x27;s not being considered an option much is because it&#x27;s boring, and highly paid software engineers don&#x27;t want to do boring stuff. Second reason is that if you have boring code, you get mediocre developers. That&#x27;s why in some projects I&#x27;ve seen them push for Scala instead of plain Java (which would&#x27;ve done just fine), because if you pick Scala you weed out a good 95% or so percentile of developers - that is, the reasoning being that one already has to be a good developer to start to comprehend Scala.<p>Of course, it backfired because these developers are so &#x27;good&#x27; that they&#x27;re also stubborn and will do things their own way, which may not be the same way as other devs. That may have just been my limited experience though, IDK.')