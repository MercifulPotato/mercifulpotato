Item(by='cesarb', descendants=None, kids=None, score=None, time=1607976061, title=None, item_type='comment', url=None, parent=25421680, text='I&#x27;ve been thinking about the instruction cache of the M1 lately.<p>Another difference between x86 and ARM is that, for historical reasons, on x86 there is no need to invalidate the instruction cache explicitly when writing instructions to memory. That is, on x86, when a core writes to memory, the corresponding line in the instruction cache has to be invalidated. Since the instruction cache is usually VIPT for performance reasons, it has to be indexed only by bits which don&#x27;t change in the virtual to physical mapping, otherwise there&#x27;s a risk of cache aliases. For an instruction cache, an alias should not be a problem (it just wastes space with duplicated data), except that all aliases have to be flushed when invalidating by physical address.<p>IIRC, in 64-bit ARM user space (EL0) the only available instruction to invalidate the instruction cache is an &quot;invalidate by virtual address&quot; instruction. Since calling that instruction (after calling an instruction to flush the data cache to the point of unification) is required on ARM, there&#x27;s no need to be able to invalidate all aliases of a physical address, like would be required on x86. That means it would be easier on ARM to have much larger instruction caches than on x86.')