Item(by='jbackus', descendants=None, kids=None, score=None, time=1608052553, title=None, item_type='comment', url=None, parent=25429493, text='Another cool way you could do this: Ruby methods can ask for their caller_locations. They work like this:<p><pre><code>    # Source\n\n    $ cat example_for_hn.rb\n    def foo\n      bar\n    end\n\n    def bar\n      baz\n    end\n\n    def baz\n      (c1, c2) = caller_locations.first(2)\n      puts &quot;Parent caller:      &#x27;#{c1.label}&#x27; in &#x27;#{c1.path}&#x27;&quot;\n      puts &quot;Grandparent caller: &#x27;#{c2.label}&#x27; in &#x27;#{c2.path}&#x27;&quot;\n    end\n\n    foo\n\n    # Demo\n\n    $ ruby example_for_hn.rb\n    Parent caller:      &#x27;bar&#x27; in &#x27;example_for_hn.rb&#x27;\n    Grandparent caller: &#x27;foo&#x27; in &#x27;example_for_hn.rb&#x27;\n</code></pre>\nSo, you could define a method decorating class method like so:<p><pre><code>    module Shitlist\n      def shitlist(method_name, whitelist)\n        original_method = instance_method(method_name)\n        undef_method(method_name)\n\n        define_method(method_name) do |*args, &amp;block|\n          call = caller_locations.first\n          passes_whitelist = whitelist.any? do |label, file_pattern|\n            call.label == label &amp;&amp; call.absolute_path.end_with?(file_pattern)\n          end\n\n          unless passes_whitelist\n            fail &quot;Shitlisted method! Permitted callers: #{whitelist}&quot;\n          end\n\n          original_method.bind(self).call(*args, &amp;block)\n        end\n      end\n    end\n</code></pre>\nand then extend classes with it to use the decorator:<p><pre><code>    class Example\n      extend Shitlist\n\n      def not_on_shitlist\n        qux\n      end\n\n      def baz\n        qux\n      end\n\n      def qux\n        puts &#x27;Only some methods can call me :)&#x27;\n      end\n      shitlist :qux, &#x27;baz&#x27; =&gt; &#x27;shitlist.rb&#x27;\n    end\n</code></pre>\nIf I run this example (full source: <a href="https:&#x2F;&#x2F;git.io&#x2F;JLOdV" rel="nofollow">https:&#x2F;&#x2F;git.io&#x2F;JLOdV</a>), the non-whitelisted caller throws an error:<p><pre><code>    $ ruby shitlist.rb\n    Only some methods can call me :)\n    Traceback (most recent call last):\n      2: from shitlist.rb:44:in `&lt;main&gt;&#x27;\n      1: from shitlist.rb:25:in `not_on_shitlist&#x27;\n    shitlist.rb:13:in `block in shitlist&#x27;: Shitlisted method! Permitted callers: {&quot;baz&quot;=&gt;&quot;shitlist.rb&quot;} (RuntimeError)\n\n</code></pre>\n---<p>Of course, you might not want this hijacked method with tracing inside something performance critical. You could always configure the implementation to be a no-op in production.')