Item(by='Twisol', descendants=None, kids=None, score=None, time=1609276933, title=None, item_type='comment', url=None, parent=25571693, text='Oh, I see! Yes, the &quot;continuation&quot; I&#x27;m referring to is the &quot;remaining reduction&quot;. I like to think of FP programs proceeding by reduction, so there&#x27;s no need to introduce any auxiliary state just to describe the computation -- it&#x27;s always present in the program itself.<p>In a traditional imperative program, the &quot;continuation&quot; is the call stack + heap, both of which need to be introduced and managed separately from the &quot;remaining reduction&quot;. In formal semantics, you usually have to introduce a reduction on &quot;environments&quot;, which is a tuple of the remaining reduction and the separately-managed forms of state. This, specifically, is why I think of state in imperative languages as &quot;explicit&quot; -- it&#x27;s a separate entity in the operational semantics.<p>I think the confusion may be that I&#x27;m thinking very much in terms of semantics, and almost not at all in terms of syntax. If you&#x27;re an interpreter in the middle of executing a program, what information do you need to do your job? (We execute code mentally to understand and grasp it, after all.) In the imperative case, the program text (reduced up to this point) is &quot;not enough&quot; to tell what work remains. In the functional case, you need nothing else. State is a real, additional, explicit thing in the one case, and an illusory, implicit thing in the other.')