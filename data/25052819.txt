Item(by='dragontamer', descendants=None, kids=None, score=None, time=1605046747, title=None, item_type='comment', url=None, parent=25050501, text='&gt; I think you have a good point about sorts, in that case mutation is almost always faster, but it seems to me that a large contributor, is that often much data doesn&#x27;t need to be moved. So clearly no work is better than some work.<p>I disagree. Even for a simple situation:<p>[9 1 2 3 4 5 6 7 8] -&gt; [1 2 3 4 5 6 7 8 9]<p>All 9 elements have to move to a different memory location!! In fact, assuming a randomly shuffled array with all different values, I&#x27;d assume that the most common situation is all elements being forced to move somewhere else. But I don&#x27;t feel like doing the rigorous math to prove it. I&#x27;ll so something simpler:<p>If there are N locations in an array, the probability that a random element is in the right spot is 1&#x2F;N (I think anyway). With N elements, that would be an average of 1-element in the correct spot (assuming uniform random arrays). There is only one-sorted array, but factorial(n-1) array without any element in the correct spot.<p>&gt; I haven&#x27;t considered shuffles specifically. But getting into the rut of complexity evaluation alone dismisses important aspects of the machine and the data you are actually operating on, and can lead you very far from the fastest solution for the problem you are actually trying to solve.<p>Sure. But Knuth shuffle uses nothing aside from &quot;Swap&quot; instructions and a 32-bit (or 64-bit) RNG. Its really simple and fast. That&#x27;s why that algorithm has stood the test of ~40 or 50 years of use, its probably the optimal algorithm for shuffling on a single-thread.')