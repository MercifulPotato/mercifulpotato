Item(by='johnisgood', descendants=None, kids=[24836890], score=None, time=1603193629, title=None, item_type='comment', url=None, parent=24835942, text='&gt; The comptime feature is probably the most exciting thing I&#x27;ve seen in a while<p>Just please do not make the mistake of believing that it is unique to Zig. Factor brings the best of Forth and Lisp together, so meta-programming or extending the language is possible quite easily, for example. You could extend the syntax or add constructs pretty easily, and so forth. Anyways, an example can be found here: <a href="https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Compile-time_calculation#Factor" rel="nofollow">https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Compile-time_calculation#Factor</a> but this barely scratches the surface. It does not mention `&lt;&lt; ... &gt;&gt;` which evaluates some code at parse time. You can execute code before the words in a source file are compiled.<p><a href="https:&#x2F;&#x2F;docs.factorcode.org&#x2F;content&#x2F;article-literals.html" rel="nofollow">https:&#x2F;&#x2F;docs.factorcode.org&#x2F;content&#x2F;article-literals.html</a><p><a href="https:&#x2F;&#x2F;docs.factorcode.org&#x2F;content&#x2F;article-syntax-literals.html" rel="nofollow">https:&#x2F;&#x2F;docs.factorcode.org&#x2F;content&#x2F;article-syntax-literals....</a><p><a href="https:&#x2F;&#x2F;docs.factorcode.org&#x2F;content&#x2F;article-syntax-immediate.html" rel="nofollow">https:&#x2F;&#x2F;docs.factorcode.org&#x2F;content&#x2F;article-syntax-immediate...</a><p><a href="https:&#x2F;&#x2F;docs.factorcode.org&#x2F;content&#x2F;word-flags{,literals.html" rel="nofollow">https:&#x2F;&#x2F;docs.factorcode.org&#x2F;content&#x2F;word-flags{,literals.htm...</a><p>I remember when I did something like:<p><pre><code>  SYMBOL: aligned-16-char\n\n  &lt;&lt;\n  : 16-byte-alignment ( c-type -- c-type )\n      16 &gt;&gt;align 16 &gt;&gt;align-first ;\n\n  char lookup-c-type clone 16-byte-alignment \\ aligned-16-char typedef\n  &gt;&gt;\n</code></pre>\nwhen I was working on some binding.<p>You could use it in a struct like:<p><pre><code>  STRUCT: foo\n    { bar aligned-16-char[16] } ;\n</code></pre>\nOr something like this is pretty typical (when writing bindings&#x2F;ffi):<p><pre><code>  &lt;&lt; &quot;libotr&quot; {\n      { [ os windows? ] [ &quot;libotr.dll&quot; ] }\n      { [ os macosx? ] [ &quot;libotr.dylib&quot; ] }\n      { [ os unix? ] [ &quot;libotr.so&quot; ] }\n  } cond cdecl add-library &gt;&gt;\n</code></pre>\nThose are just some examples, but it is pretty powerful. It supports (and encourages) interactive development. Profiling and debugging is a breeze and highly detailed and useful, you can easily disassemble words (functions), you can get a list of how many times malloc has been called in some circumstances, there is runtime code reloading (a vocabulary that implements automatic reloading of changed source files[1]), and so on. And on top of all this, <i>you can compile your stuff to an executable that is less than 4 MB!</i><p>And of course you do not have to do stack shuffling at all, you can easily use locals which is useful for math equations and whatnot. Plus did you know that the Factor compiler supports advanced compiler optimizations that take advantage of the type information it can glean from source code? The typed <i>vocabulary</i> (yes, it is not part of the language, but implemented as a vocab) provides syntax that allows words to provide checked type information about their inputs and outputs and improve the performance of compiled code.<p>I would like to repeat because if this was not the case, I would have never bothered with it: you can create a single executable file that is less than 4 MB of size if you wish so! Of course it encourages interactive development, but still, it is great to have an optimizing compiler that can do all this easily. And mind you, this part is also written in Factor itself and is available as a vocabulary (vocab).<p>[1] There is a vocabulary named <i>io.monitors</i> and loaded source files across all vocabulary roots are monitored for changes. You can read more about it here: <a href="https:&#x2F;&#x2F;docs.factorcode.org&#x2F;content&#x2F;article-vocabs.refresh.html" rel="nofollow">https:&#x2F;&#x2F;docs.factorcode.org&#x2F;content&#x2F;article-vocabs.refresh.h...</a><p>---<p>So all in all, I think Factor is great. I was shocked at how modern (and how many) libraries it has, especially considering only a handful of people have been working on it. <i>Slava Pestov</i> created the language, and some people joined him later on. If you want to learn more about it, start here: <a href="https:&#x2F;&#x2F;concatenative.org&#x2F;wiki&#x2F;view&#x2F;Factor" rel="nofollow">https:&#x2F;&#x2F;concatenative.org&#x2F;wiki&#x2F;view&#x2F;Factor</a>. There are videos, there are papers, there are lots of resources to get started. :) The language misses a couple of things, but it is being worked on.')