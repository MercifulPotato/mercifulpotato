Item(by='vvillena', descendants=None, kids=[25065642], score=None, time=1605111959, title=None, item_type='comment', url=None, parent=25054702, text='Although the silly &quot;Expected &#x27;:&#x27;&quot; is still there, the newer SBT versions show better output, there&#x27;s even a &quot;did you mean&quot; feature.<p>Regarding &quot;discovering which submodule you&#x27;re supposed to run commands in&quot;: this is a non-issue. Commands are either run under the obvious subproject (e.g. &quot;api&#x2F;run&quot;, &quot;business-logic&#x2F;test&quot;), or are run as top-level commands. This is true 99% of the time. I have a fairly complex project open right now, and I just run &quot;docker:publishLocal&quot; to create two separate Docker images, one for each subproject that includes the appropriate plugin. I think this is better than overloading a single command. SBT projects usually have a small readme describing what is the command for any specific task you&#x27;re supposed to do. In Maven, you know the commands, but you need to read to ensure what they do (does &quot;deploy&quot; push to an artifact repository, does it create a container image, does it create a deb package, or does it create a standalone jar?).<p>The use case where a multimodule project becomes multiple projects is more gradual in Maven, I fully agree on this. The problem, as I said, lies in that child Maven projects are not self-contained. They usually depend on information declared in the parent builds. This breaks the assumption that people can work on a project without worrying about the parent project.<p>Finally, source dependencies are explicit in SBT save for the base case &quot;test depends on main&quot;. Everything else must be specified, so it&#x27;s either there in the build file, or added as part of a build plugin. It can also be checked from the REPL. And building from the IDE is a dumb mistake if the IDE doesn&#x27;t use the correct build tool underneath: the build is there for a reason and the IDE shouldn&#x27;t bypass it.')