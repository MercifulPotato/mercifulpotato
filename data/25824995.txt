Item(by='hisham_hm', descendants=None, kids=None, score=None, time=1610995359, title=None, item_type='comment', url=None, parent=25800937, text='&gt; Sure, that was my point: s:sub(#s-2,#s-1) != s:sub(-2,-1) â€” if # works on s at all :)<p>And why would they ever be the same? Writing &quot;#s-2&quot; you&#x27;re treating -2 as a relative _offset_, not an index.<p>&gt; Basically, some things are more &quot;natural&quot; with 1-based counting, but some aren&#x27;t.<p>Yes, offsets are naturally zero-based, and indices (everywhere other than languages derived from the C tradition) are naturally 1-based. The reason why C and its descendants use zero-based indexes is because C mixes indexes with offsets (since offsets are the low-level primitive in machine language), so that given a pointer p, we have that p[i] and p+i are the same.<p>If instead C had not done that and used 1-based indexing like everyone else back then, I&#x27;m sure people today would be claiming how C is superior for providing both 1-based indexing with [] and 0-based offsets with +, since there are always scenarios where one leads to more natural expressions that the other, and how people mixing them up were clearly not suited for the subtleties of low-level programming in C, and should be instead using simpler languages with garbage collection and without pointer arithmetic. :)')