Item(by='segfaultbuserr', descendants=None, kids=[25539027], score=None, time=1608909797, title=None, item_type='comment', url=None, parent=25536537, text='It&#x27;s also important to see that the SSL&#x2F;TLS system does not allow you to revoke a certificate with 100% certainty, the revocation mechanism is flawed - it&#x27;s often <i>practically impossible</i> to reliably revoke a certificate after someone has compromised your private key. The only feasible workaround is early expiration to reduce the window of vulnerability.<p>* <i>CRL</i> is a list of revoked certificates, it must be downloaded and manually applied to all clients, which only occurs once in a while as a new update, and many hate system updates. The huge lists of revoked certificate have size, performance and scalability problems, currently they are considered obsolete and mainly replaced by OCSP.<p>* In <i>OCSP</i>, clients ask a CA&#x27;s OCSP server to determine the validity of a certificate. It operates out-of-band from the main TLS connection, and networks and CA servers are not reliable, especially in the early days. Timed out OCSP requests were common. If you are a web browser, you don&#x27;t want a failed OCSP request to block&#x2F;DoS HTTPS, thus OCSP becomes essentially &quot;optional&quot;. Browsers reject bad certificates when the connection goes through, but if it times out, nothing happens. An attacker can simply block the OCSP server to bypass the revocation check. There&#x27;s also the problem of privacy - you have to send the name of every website you visit to third party servers.<p>* In <i>OCSP Stapling</i>, the webserver acts like a proxy - it hosts a cached copy of the OCSP response for itself (it cannot be forged because it&#x27;s signed by the CA) and sends it to clients in-band, via normal TLS channel. Because now the client no longer asks CA&#x27;s OCSP servers for a response, but instead simply asks the webserver itself, it eliminates the problem of third-party OCSP servers, solves the reliability and privacy issues. However, there&#x27;s nothing to prevent an attacker to run a server with a compromised certificate with OCSP Stapling turned off.<p>* In <i>OCSP Must-Staple</i>, you can get a certificate from a CA that says &quot;you must use OCSP Stapling, otherwise this certificate is null and void.&quot; Hence, if a browser sees a certificate with &quot;OCSP Must-Staple&quot; enabled, it must see whether the webserver supports OCSP Stapling, and via OCSP Stapling, the certificate&#x27;s validity will be determined. If OCSP Stapling is not supported by the webserver, the connection is rejected. Thus, an attacker who uses a compromised certificate has to either disable OCSP Stapling and be rejected, or to enable OCSP Stapling and gets caught. Finally the problem of reliable revocation is solved. But this is an optional feature and is only used by a tiny percentage of sysadmins. Also, it&#x27;s only supported by webservers and browsers, other TLS-based applications like VPN, FTPS, SMTP, IMAP, XMPP, IRC servers&#x2F;clients, etc, usually don&#x27;t support OCSP Stapling at all.<p>Thus, it&#x27;s often <i>practically impossible</i> to reliably revoke a certificate in SSL&#x2F;TLS after someone has compromised your private key. The only feasible workaround is early expiration to reduce the window of vulnerability, an unrevokable certificate that expires within 90 days is less dangerous than a zombie certificate that lasts two years.')