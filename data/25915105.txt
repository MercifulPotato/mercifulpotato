Item(by='ojnabieoot', descendants=None, kids=None, score=None, time=1611664451, title=None, item_type='comment', url=None, parent=25913979, text='&gt; As far as memory safety goes, never rely on null terminated strings, allways copy the exact amount of data to a statically defined max, and make the buffer that holds data have the length max+1 with an extra byte that is allways set to null for every copy into the buffer. For malloc&#x2F;free, design your code so that malloc and free are in the same function at the beggining and end, and allways run memcheck and valgrind before deploying to production.<p>Aren’t you just proving the author’s point here? Even your fairly simple heuristic that works in most cases is easy to screw up due to a typo &#x2F; brain fart, and it’s quite likely that even experienced developers will write code that memcheck&#x2F;valgrind complains about (which is why the tools exist!)<p>So writing memory-safe code in C&#x2F;C++ is brittle and not easy to do <i>consistently</i> without additional tools and checks. The author’s point wasn’t that it’s impossible or conceptually deep, but that it’s tricky and painstaking work which is easy to mess up.')