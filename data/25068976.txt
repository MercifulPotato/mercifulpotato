Item(by='spacechild1', descendants=None, kids=[25081164], score=None, time=1605183234, title=None, item_type='comment', url=None, parent=25068672, text='To elaborate why sandboxing itself can&#x27;t help performance, let&#x27;s assume you have an FX chain A -&gt; B -&gt; C and &quot;B&quot; is sandboxed. After you&#x27;ve computed &quot;A&quot;, you take the output and pass it to &quot;B&quot;. You then have to wait for &quot;B&quot; to finish before you can go on and compute &quot;C&quot;. So while the subprocess for &quot;B&quot; might run in another thread, the main audio thread has to go to sleep. See how there&#x27;s actually no parallelism at play? In fact, you lose performance because context switches and thread synchronization (especially wake up from sleep) takes time.<p>I think jBridge might actually collect the result of the subprocess in the <i>next</i> DSP tick. This means that the thread can go on to compute &quot;C&quot; because it can take the result of &quot;B&quot; from the <i>previous</i> DSP tick. Now you indeed have things run in parallel. However, this adds additional latency of 1 audio block. If you have several of such sandboxed plugins in a row, this can easily add up.<p>This is technique is sometimes called the &quot;pipelining&quot; (see &quot;2.3&quot; in <a href="https:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;Diplomarbeiten&#x2F;blechmann11.pdf" rel="nofollow">https:&#x2F;&#x2F;www.complang.tuwien.ac.at&#x2F;Diplomarbeiten&#x2F;blechmann11...</a>). Note that you don&#x27;t need sandboxing for this. You can just as well dispatch items to a thread pool, so everything stays within the same process.<p>So I think the speed up you observe with jBridge has nothing to do with sandboxing per-se, but is just a side effect of its implementation. I can&#x27;t prove this because I can&#x27;t look at the source code, but for me this is the most likely explanation.')