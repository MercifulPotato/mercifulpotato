Item(by='vvillena', descendants=None, kids=None, score=None, time=1604491766, title=None, item_type='comment', url=None, parent=24988133, text='Scala is more strict than D for this use case. In Scala, if you want a function to be available to a certain type as if it was a method call, you need to be explicit about it. You have to declare an &quot;implicit class&quot; that takes the base type as an argument, and define the function as a method of the implicit class. You also need to ensure the implicit class is in scope. Once these conditions are met, you can use it as a method.<p><pre><code>    val t1 = MyType()\n    def fun(t: MyType, argument: Int) = argument\n\n    &#x2F;&#x2F; can&#x27;t do this yet\n    &#x2F;&#x2F; t1.fun(42)\n    \n    &#x2F;&#x2F; In Scala 2 you use an implicit class to add methods to a type\n    implicit class MyEnrichedType(t: MyType) {\n      def fun(argument: Int) = fun(t, argument)\n    }\n\n    &#x2F;&#x2F; In Scala 3 you use an extension\n    extension (t: MyType)\n      def fun(argument: Int) = fun(t, argument)\n    \n    &#x2F;&#x2F; now it can be done\n    t.fun(42)\n</code></pre>\nRegarding your question about the stdlib methods being able to be chained: they are not special. They are defined for the type the methods return, so they can be used.<p>Rejecting all kinds of implicits and then complaining about Scala missing features is a bit unfair. &quot;Implicit&quot;is a single keyword, but not a single feature. Implicit arguments, implicit conversions and implicit classes are not the same thing. Fortunately, Scala 3 will clear this misunderstanding.')