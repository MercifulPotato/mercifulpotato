Item(by='nendroid', descendants=None, kids=[24733705], score=None, time=1602271554, title=None, item_type='comment', url=None, parent=24730713, text='The article talks about how SQL lacks composability. I would like to know everyones thoughts about this.<p>This is a huge issue with programming in general not exclusive to SQL. Everyone would like to build programs that are modular and reusable but programming paradigms have been traveling in directions that prevent this from happening. Many people turn to design patterns or microservices to try to deal with this organizational issue but they fail to see that the lower level programming paradigm itself is the precursor to the problem.<p>In SQL the problem occurs in the statement itself. The WHERE clause or the SELECT clause cannot be reused anywhere else. I can&#x27;t modularize a where clause and put it in another SQL statement. I have to rewrite the entire clause to reuse it.<p>In OOP the same issue occurs. In OOP your class tends to contain methods that are not combinators, or in other words methods that modify a free variable. Due to this like the SQL expression, Objects cannot be decomposed either. I cannot reuse a setter in another class or anywhere else outside of the context of the free variable it modifies.<p>In both cases there comes a time in the future of an application where programmers realize that similar logic could be reused but structural problems are preventing the reuse from happening so they have to implement a hack to get around it.<p>The issue is that everyone is unaware of this trend at a low level. They are unaware that SQL lacks composability just like how they are unaware that OOP lacks composability as well. But they are aware of this issue at a higher level and they tend to call it &quot;technical debt&quot; or some high level design problem.<p>Case in point: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24732789" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24732789</a><p>Most commenters above talk about minor syntactical issues and fail to address what is not only IMO the main issue, but the main issue that the article itself is addressing. Likely because they&#x27;re all unaware of the true nature of the composability issue and just didn&#x27;t completely understand what the article was saying.<p>Also note that when I talk about composition in OOP I am not talking about &quot;object composition.&quot; These are completely different usages of the word.')