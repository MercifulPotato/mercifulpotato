Item(by='nickjj', descendants=None, kids=None, score=None, time=1611862527, title=None, item_type='comment', url=None, parent=25947583, text='&gt; I&#x27;d be interested in the &quot;how&quot; if you&#x27;d consider creating a blog on using Hotwire with Phoenix.<p>Technically it doesn&#x27;t involve adding or changing even 1 line of code on the back-end to make Turbo Drive and Frames work with any tech stack.<p>It works out of the box by following Turbo&#x27;s docs and using the HTML tags they mention along with bringing in the Turbo JS library.<p>But for Frames you can optionally do what Rails does and add some server side code that says &quot;hey, if this request is coming from a Turbo Frame only send the partial template as a response instead of the whole layout&quot;. That logic for Rails is here: <a href="https:&#x2F;&#x2F;github.com&#x2F;hotwired&#x2F;turbo-rails&#x2F;blob&#x2F;main&#x2F;app&#x2F;controllers&#x2F;turbo&#x2F;frames&#x2F;frame_request.rb" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;hotwired&#x2F;turbo-rails&#x2F;blob&#x2F;main&#x2F;app&#x2F;contro...</a>. It&#x27;s a nice to have optimization that will reduce your frame&#x27;s HTML payload size but it still works without doing this.<p>It can be ported to Phoenix or any back-end language by using a plug &#x2F; middleware to not render the layout if a specific header exists in the request. The ETag stuff could be ported over too if your web framework&#x27;s web server sets an ETag header.<p>Streams are a bit more tricky to get working in other tech stacks since it may involve Websockets. Hopefully we start to see more examples in the future. But I believe it should be possible to pull off in a production ready way with any back-end language that has a good library or built in support for Websockets at the framework level. That means Flask, Django, Laravel and Phoenix are all good to go in this regard (probably others too but I&#x27;m not familiar enough with their ecosystems to say for sure).')