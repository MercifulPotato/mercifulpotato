Item(by='AnIdiotOnTheNet', descendants=None, kids=[25861852], score=None, time=1611249894, title=None, item_type='comment', url=None, parent=25861131, text='I was going to give you the benefit of the doubt and actually try this so I could show you that you are wrong, but I couldn&#x27;t even get that far because dpkg always complains it is unable to access the dpkg status area. So clearly this is not as trivial as you make it out to be. I suspect because it expects a full filesystem in $HOME with its status file in the appropriate place. In other words, it is expecting a whole separate installation to be under $HOME.<p>Regardless, lets assume it did work. Here&#x27;s what it would do: unpack the package replacing &#x27;&#x2F;&#x27; with &#x27;$HOME&#x27; in the destination paths. That&#x27;s it. That software will not magically be able to find its associated libraries and configurations without the user mucking with environment variables at best, or chrooting or sandboxing such that $HOME appears to it to be a wholly separate installation.<p>That&#x27;s not how sane systems do this sort of thing. I have been trying to do this sort of thing in Linux for pretty much as long as I have been using Linux because I <i>loathe</i> the way Linux installs software, and in 20 years it has <i>never</i> been straight forward. AppImage is a close as we get and software needs to be carefully built and packaged for that.<p>&gt; If what you&#x27;re saying were true, unmodified software wouldn&#x27;t work in a Docker container, either.<p>&gt; [...] or using namespacing and chroot to build it a sandbox wherein its baked-in paths actually work.')