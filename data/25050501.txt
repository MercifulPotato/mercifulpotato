Item(by='Arelius', descendants=None, kids=[25052819, 25051159], score=None, time=1605036621, title=None, item_type='comment', url=None, parent=25043476, text='I think you have a good point about sorts, in that case mutation is almost always faster, but it seems to me that a large contributor, is that often much data doesn&#x27;t need to be moved. So clearly no work is better than some work.<p>Having said that, I hardly see a sort being the majority of time spent in real-world code.<p>&gt; Because thread-barriers are no-ops on a SIMD computer<p>My understanding is that only holds true across the SIMD lane, and the algorithm doesn&#x27;t hold up so generally to general purpose concurrency. But agreed, a sort is something I&#x27;d likely try to optimize on a single core, and express program concurrency outside that specific operation.<p>&gt; What algorithms are you thinking of where copying is faster than mutating? At best, a copy ties mutation in speed.<p>My main point is it&#x27;s actually the case that a copy ties mutation in speed quite often if you structure the flow of your data correctly. If you&#x27;re operating on a value, writing it somewhere else is often close to free.<p>Having said that as an example, I&#x27;ve seen filtering a list run faster doing a move, highly dependent on the details of the cache of course.<p>&gt; that can beat the Knuth Shuffle&#x27;s O(n) computation complexity.<p>I haven&#x27;t considered shuffles specifically. But getting into the rut of complexity evaluation alone dismisses important aspects of the machine and the data you are actually operating on, and can lead you very far from the fastest solution for the problem you are actually trying to solve.')