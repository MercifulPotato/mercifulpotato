Item(by='crazygringo', descendants=None, kids=[25990058], score=None, time=1612196452, title=None, item_type='comment', url=None, parent=25989220, text='As long as you&#x27;ve got primary keys on the huge table, there&#x27;s a hacky solution -- create a second table with columns for just the first table&#x27;s primary key and the columns you&#x27;re indexing and your desired index, and ensure you always write&#x2F;update&#x2F;delete both tables simultaneously using transactions. Then when needed, use the index on the second table and join it to your first with the primary key.<p>Annoying, but it should work for most queries I&#x27;d expect without too much SQL.<p>I&#x27;ve definitely &quot;rolled my own indexing&quot; like this in the past, though it&#x27;s more often been duplicating strings into a custom &quot;collation&quot; or other transformations.<p>Another solution is simply to split your table in two, with the same columns in both, and the index only on one of the tables. But of course that really depends on your business logic -- queries that need to retrieve data from both tables together can get pretty hairy&#x2F;slow, and if you&#x27;ve got auto-incrementing PKEY&#x27;s then avoiding collisions between the two tables can be tricky on its own. So this is definitely the less general solution.<p>Of coure it certainly would be nicer if MySQL supported partial indexes. It seems so useful, I&#x27;m surprised it didn&#x27;t happen long ago.')