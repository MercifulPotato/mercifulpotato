Item(by='eesmith', descendants=None, kids=[24853430], score=None, time=1603312887, title=None, item_type='comment', url=None, parent=24850044, text='Which compiled language adds 680564733841876926926749214863536422912 and 35370553733215749514562618584237555997034634776827523327290883 in one instruction?<p>FWIW, here&#x27;s the relevant dispatch code in Python&#x27;s ceval.c where you see it uses a very generic dispatching at that level, which eventually, deeper down, gets down to the &quot;oh, it&#x27;s an integer!&quot;<p><pre><code>        case TARGET(BINARY_ADD): {\n            PyObject *right = POP();\n            PyObject *left = TOP();\n            PyObject *sum;\n            &#x2F;* NOTE(haypo): Please don&#x27;t try to micro-optimize int+int on\n               CPython using bytecode, it is simply worthless.\n               See http:&#x2F;&#x2F;bugs.python.org&#x2F;issue21955 and\n               http:&#x2F;&#x2F;bugs.python.org&#x2F;issue10044 for the discussion. In short,\n               no patch shown any impact on a realistic benchmark, only a minor\n               speedup on microbenchmarks. *&#x2F;\n            if (PyUnicode_CheckExact(left) &amp;&amp;\n                     PyUnicode_CheckExact(right)) {\n                sum = unicode_concatenate(tstate, left, right, f, next_instr);\n                &#x2F;* unicode_concatenate consumed the ref to left *&#x2F;\n            }\n            else {\n                sum = PyNumber_Add(left, right);\n                Py_DECREF(left);\n            }\n            Py_DECREF(right);\n            SET_TOP(sum);\n            if (sum == NULL)\n                goto error;\n            DISPATCH();\n        }\n</code></pre>\nPython code can be made more high performance if there&#x27;s some way to tell the implementation the types, either explicitly or by inference or tracing. That&#x27;s how several of those listed projects get their performance.')