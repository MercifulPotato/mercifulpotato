Item(by='laumars', descendants=None, kids=None, score=None, time=1602370246, title=None, item_type='comment', url=None, parent=24741886, text='&gt; FAT32 isn&#x27;t often included these days in Linux FS benchmarks [0]<p>Running sqlite3 on a USB stick isn&#x27;t really the same as one time sequential read from a virtual hard disk though. Even FAT32 on Windows 98 could handle sequential reads just fine. In fact if you look at the other benchmarks in that link you supplied -- the ones that are doing tasks more equivalent to a compiler -- FAT32 actually comes out pretty fast.<p>&gt; <i>but some older benchmarks [1] also show noticeable performance differences, especially when the workload is more meaningful than copy files.</i><p>But the workload in question <i>isn&#x27;t</i> more meaningful. A compiler is &quot;just&quot; reading a few files and then writing a few new files. It&#x27;s going to be more CPU and memory intensive than disk heavy.<p>&gt; <i>Lack of features does not imply efficient design.</i><p>I&#x27;m never suggested it does. However for <i>simple</i> workloads like a sequential read and write from a virtual hard drive where your host has already abstracted away the problems of physical hardware with optimised drivers, a lack of features on the guest operating system could conceivably be a more efficient design. It&#x27;s not that far fetched a comment given that&#x27;s the principle behind unikernels.<p>&gt; <i>Caching was optional with Windows 98 and sometimes was turned off by default</i><p>It&#x27;s optional in every OS (even now) but is rarely ever turned off by default under normal operating conditions -- this is as true for Windows 98 as it is for Linux.<p>&gt; <i>The referenced Linux benchmarks probably limit the variability here since I think Linux tends to follow the same code paths, independent of the partition types.</i><p>There&#x27;s a few things to consider when looking at these file system benchmarks:<p>1. They are all running on Linux so none of them actually demonstrate the FAT32 driver in question<p>2. They&#x27;re writing direct to physic media (which isn&#x27;t the case with the Delphi 2 benchmark).<p>3. The workload you&#x27;re demonstrating isn&#x27;t equivalent to the workload of a compiler. I wasn&#x27;t suggesting people should run databases on FAT32 (tbh I wasn&#x27;t suggesting people should run FAT32 at all).<p>I would be interested in the same Delphi 2 benchmark but with Delphi running bare metal in WINE')