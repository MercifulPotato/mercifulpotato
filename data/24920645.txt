Item(by='kentonv', descendants=None, kids=[24922503, 24921078], score=None, time=1603902203, title=None, item_type='comment', url=None, parent=24920216, text='&gt; The idea is that optionals allow you to pass optional data by value.<p>Yes, and kj::Maybe was doing the same before std::optional was standardized.<p>It&#x27;s disappointing that the committee chose only to solve this problem while not also solving the problem of forgetting to check for null -- often called &quot;the billion-dollar mistake&quot;.<p>&gt; Dereferencing null optionals is UB for consistency with dereferencing pointers. All uses of operator* should have the same semantics<p>My argument is that `std::optional` should not have an operator* at all. `kj::Maybe` does not have operator* nor `operator-&gt;`.<p>&gt; If you want to dereference an optional that may be null, use the .value_or() method. For the times when you absolutely know the optional has a value use operator*.<p>This is putting a lot of cognitive load on the developer. They must remember which of their variables are optionals, in order to remember whether they need to check for nullness. The fact that they use the same syntax to dereference makes it very easy to get wrong. This is especilaly true in modern IDEs where developers may be relying on auto-complete. If I don&#x27;t remember the type of `foo`, I&#x27;m likely to write `foo-&gt;` and look at the list of auto-complete options, then choose one, without ever realizing that `foo` is an optional that needs to be checked for null.<p>In KJ, you MUST write:<p><pre><code>    KJ_IF_MAYBE(value, maybeValue) {\n      use(value);\n    } else {\n      handleNull();\n    }\n</code></pre>\nOr if you&#x27;re really sure the maybe is non-null, you can write:<p><pre><code>    use(KJ_ASSERT_NONNULL(maybeValue));\n</code></pre>\nThis does a runtime check and throws an exception if the value is null. But more importantly, it makes it really clear to both the writer and the reader that as assumption is being made.')