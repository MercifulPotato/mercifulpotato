Item(by='jrockway', descendants=None, kids=None, score=None, time=1606687805, title=None, item_type='comment', url=None, parent=25244167, text='I completely agree with you.  To give the build system the understanding it needs, you have to give up the generality.<p>For me, I&#x27;ve found that the results are best when you use a build system and you use it exactly the way the author intends.  For example, Go&#x27;s built-in build system is so good that you don&#x27;t even notice it&#x27;s there.  It automatically updates its configuration as you write code.  It does a perfect incremental build every time, including tests.  The developer experience is basically perfect, because it has a complete understanding of the mapping between source files, dependencies, and outputs.  But, it is not extendable, so you&#x27;re screwed when your Go project also needs to webpack some frontend code, or you need to generate protocol buffers (which involves a C++ binary that runs a Go binary), etc.  So, people bolt those features on, and the build system becomes more general, but not quite as good.  (Then there&#x27;s make, which is as good or as bad as you want it to be.)<p>I think super small projects often do get their Makefiles right.  But you can manually build small projects with something like &quot;gcc foo.c bar.c -o foobar -lbaz&quot;, and so you don&#x27;t really benefit from any improvement over the bare essentials.  (Nothing wrong with keeping your projects tiny in scope, of course!)<p>But, sometimes you don&#x27;t have the luxury of a super small project, and the Makefiles become quickly unfixable.  Like I said, I am most scarred by a buildroot project I worked on (that&#x27;s embedded Linux, basically).  It never built what I expected it to build, and to test anything reliably I either had to yolo my own incremental build or wait a while for a full build.  My productivity was minimal.  I could switch between client-side and server-side tasks on that project, and so I really only touched the client if it was absolutely necessary.  I would never be productive enough to undertake a major project that truly added value with that kind of build system, so I let others that didn&#x27;t have the server-side experience write the client-side stuff.  In that case, the poor build system silently cost our team productivity in terms of artificially splitting the team between people who could tolerate a shitty developer experience and those who couldn&#x27;t.<p>I don&#x27;t think anyone has fixed the buildroot problem, either.  If you want to build a Linux image today, you are stuck with these problems.  Nothing else is general enough to build Linux and the associated random C binaries that you&#x27;re going to want to run.')