Item(by='derefr', descendants=None, kids=None, score=None, time=1609354697, title=None, item_type='comment', url=None, parent=25584002, text='&gt; would require some very tricky state synchronization<p>Games for these older consoles — any generation while games were either still unikernels, or still ran on RTOSes — are already 100% deterministic in terms of what the game will do on a given frame, given a fixed history of per-frame inputs. (That might be surprising, but devs would strive to keep this property, as it makes reproducing bugs far easier.) So you don’t have to do much, other than execute the game faithfully and ship button-presses back and forth, to ensure synchronization.<p>Of course, shipping these button-presses around to achieve state-consensus <i>synchronously</i> would be slow — but there’s no need to do it synchronously. All modern emulators are built not in terms of a single mutable virtual-machine state, but rather in terms of a functional-persistent <i>chain</i> of VM states (think a HAMT.) This is what enables “rewind” support in emulators — and more recently, “run-ahead” latency reduction (basically a type of speculative execution of VM states.)<p>Thus, with any emulator constructed this way, it’s actually very easy to ship+receive+resolve network inputs <i>asynchronously</i>: i.e. to receive inputs “about” frame N while rendering frame N+M, and then to go back and re-compute the correct VM state for frames N..N+M, such that frame N+M+1 will inherit from the recomputed frame N+M. (Remember, you don’t need to run any of the IO-emulation logic for the recomputed frames, so they’re actually quite cheap to recompute!)<p>It’s actually oddly similar to what blockchain nodes do to “reorg” when they discover a fork — just done in real-time, between 16.7ms frames.')