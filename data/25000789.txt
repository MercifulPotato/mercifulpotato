Item(by='iainctduncan', descendants=None, kids=None, score=None, time=1604602180, title=None, item_type='comment', url=None, parent=24998908, text='Some interesting responses here, thanks. Not surprisingly lots of people are saying &quot;types would have saved you&quot;. I&#x27;m sure they would have helped, though I personally think they do introduce a high cost too, and I&#x27;m a lisp-head nowadays not a Haskeller.<p>The real culprits, thinking about it since my post, were <i>side effects and mutability</i>. Python lets you create incredibly difficult to trace chains of side effects and mutations, and has basically no decent ways to prevent this. In Scheme, my code is still super small and I can dynamically create all kinds of object like things, but if I want private, I can make it god-damned private. In Python, anything can be changed by anything (&quot;we&#x27;re all consenting adults&quot;) and using side effects in weird ways is actually part of the idiom. I don&#x27;t know how many times in Python literature I&#x27;ve seen some variant of &quot;you don&#x27;t need those baroque patterns because we can use &#x27;import&#x27; as a singleton, running class initialization as the constructor&quot;. And so all the frameworks have crazy thread-local magic happening from bloody import statements!!! Do that too much and you have no idea what&#x27;s happening where and why, and something as trivial as changing the order of imports can kill your app. Where I was, this had gotten so bad that the app couldn&#x27;t even be turned on and tested in the normal way, and none of my predecessors had been willing to go through the pain of figuring out what the chain of imports were doing to bugger it up. (Because that didn&#x27;t look like doing anything productive, I&#x27;m sure you all know the drill...)<p>If I were doing it again, personally, I&#x27;d use Clojure and Spec, and worry more about mutability and side-effects than anything else. Just my two cents Canadian.')