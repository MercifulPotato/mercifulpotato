Item(by='derefr', descendants=None, kids=None, score=None, time=1607667312, title=None, item_type='comment', url=None, parent=25382421, text='But the third-party tool frequently <i>isn’t</i> intended to (only) consume machine-generated config. It’s usually built to consume a format that <i>could equally be</i> machine-generated <i>or</i> hand-authored. Usually with an emphasis on hand-authoring, where machine-generation is an automation over hand-authoring that will only need to happen as one scales; and so high-complexity machine-generation will only be relevant to the most enterprise-y of integrators.<p>Other examples of formats like this, that are hand-authored in the small but generated in the large: RSS, SQL, CSV.<p>Again, Kubernetes is a prime example of this. K8s config YAML is <i>designed</i> with the intention of being hand-authored and hand-edited. It’s only when devs or their tools need to auto-generate entire k8s cluster definitions, that you begin needing to machine-generate this YAML. This generated YAML is expected to still be audited by eye and patched by hand after insertion, though, so it still needs to be in a format amenable to those cases, rather than in a format optimal for machine consumption.<p>&gt; if we&#x27;re generating this config with code then we don&#x27;t want to diff or edit the generated config<p>Look more into GitOps. The idea behind it is that whatever tooling you’re using to generate config is run and the resulting config is committed to a “deployment” repo as a PR; ops staff (who don’t necessarily trust the tooling that generated the config) can then audit the PR, and the <i>low-level</i> changes it describes, before accepting it as the new converged system state. It puts a human veto in the pipeline between machine-generated config and continuous deployment; and allows for debugging when upstream tweaks aren’t having the low-level side-effects on system state one would expect.')