Item(by='Rochus', descendants=None, kids=[24992206, 24991851], score=None, time=1604514758, title=None, item_type='comment', url=None, parent=24989682, text='Interesting. Here is also a podcast about the topic: <a href="https:&#x2F;&#x2F;thinkingelixir.com&#x2F;podcast-episodes&#x2F;017-jit-compiler-for-beam-with-lukas-larsson-and-john-hogberg&#x2F;" rel="nofollow">https:&#x2F;&#x2F;thinkingelixir.com&#x2F;podcast-episodes&#x2F;017-jit-compiler...</a><p>Had a brief look at asmjit; as it seems it only supports x86 and x86_64 and is not really an abstraction (i.e. a platform independent IR). I will try to find out why they didn&#x27;t use e.g. LLVM or sljit.<p>EDIT: according to this article (<a href="https:&#x2F;&#x2F;www.erlang-solutions.com&#x2F;blog&#x2F;performance-testing-the-jit-compiler-for-the-beam-vm.html" rel="nofollow">https:&#x2F;&#x2F;www.erlang-solutions.com&#x2F;blog&#x2F;performance-testing-th...</a>) the speed-up factor caused by the JIT is about 1.3 to 2.3 (as a comparison the speed-up between the PUC Lua 5.1 interpreter and LuaJIT 2.0 is about factor 15 in geometric mean over all benchmarks, see <a href="http:&#x2F;&#x2F;luajit.org&#x2F;performance_x86.html" rel="nofollow">http:&#x2F;&#x2F;luajit.org&#x2F;performance_x86.html</a>).')