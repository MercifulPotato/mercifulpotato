Item(by='lambda', descendants=None, kids=None, score=None, time=1609713354, title=None, item_type='comment', url=None, parent=25624314, text='Here is an example which, while trivial, demonstrates some of the optimization issues you can run into in C and C++ but not in Rust, even with noalias currently only applying to &amp;T.<p>C++: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;dTPsbh" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;dTPsbh</a>\nRust: <a href="https:&#x2F;&#x2F;rust.godbolt.org&#x2F;z&#x2F;Mdx87h" rel="nofollow">https:&#x2F;&#x2F;rust.godbolt.org&#x2F;z&#x2F;Mdx87h</a><p>In C and C++, compilers are allowed to infer &quot;noalias&quot; based on pointer types; two pointers of different type are not allowed to alias. This is known as type-based alias analysis. But char * is given special treatment, because of its use as a generic pointer type; so if one of your arguments is char * or even signed char * , that disables any optimizations which were relying on type-based alias analysis.<p>This provides both for performance and undefined-behavior footguns. If you ever try to use some pointer type other than char * or signed char * to refer to data of another type, you may inadvertently cause type-based alias analysis to kick in, causing invalid optimizations and miscompilation. On the other hand, if you have a function which takes both a char * and another pointer, the compiler may not apply optimizations that it otherwise could because char * is allowed to alias anything.<p>In Rust, there is no such undefined behavior footgun. Because of the LLVM bug, noalias isn&#x27;t applied to &amp;mut pointers so there are still some cases which could be better optimized, though it sounds like there is some progress being made on the LLVM front so it should be fixed at some point, and there are already places where the compiler can do better optimizations with better safety due to the stronger semantics of &amp;T.')