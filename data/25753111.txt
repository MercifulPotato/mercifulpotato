Item(by='TheDong', descendants=None, kids=[25753380], score=None, time=1610483449, title=None, item_type='comment', url=None, parent=25752450, text='Can you give examples of specific language features of go that prevent you from making questionable design choices, that require you to &quot;get the design right up front&quot;?<p>When I hear that, the first things that come to mind are things like haskell&#x27;s IO monad, which forces you to model IO better than go or most other languages, or haskell&#x27;s other state monads which similarly force you to model state more explicitly.<p>I think of rust&#x27;s lifetime and ownership system, which forces you to correctly model the ownership of types and prevents quite a few bad design patterns (which I see constantly in go btw; the number of times I&#x27;ve seen races due to multiple goroutines writing to a struct is large, the number of times I&#x27;ve seen incorrect synchronization that rust would have prevented is large).<p>I can&#x27;t think of anything in go that pushes you towards designing your code well in go, especially when compared to languages with more complete type-systems.')