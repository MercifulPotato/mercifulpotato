Item(by='rleigh', descendants=None, kids=None, score=None, time=1611486902, title=None, item_type='comment', url=None, parent=25888882, text='2to3 does 95% of the job.  The other 5% requires manually fixing up all the bits it missed, and until you do that, your codebase will be subtly (not not so subtly) broken.  The most common problem I saw was relating to iterating over dictionary keys.<p>That 5% that requires manually fixing up is the sticking point.  You still need to audit every line of the codebase, and each line that gets missed is a guaranteed bug introduced to your codebase by the conversion.  This is not much of an issue for small scripts or tiny programs.  It is an issue for big applications.  This migration really highlights (yet again), the dangers of using interpreted languages at scale.  With no compiler to pick up errors, no typechecking by default etc., identifying all of the remaining faults is a huge task.<p>Like it or not, this is a huge risk to a business.  There is a risk of introducing vast quantities of bugs, and there a huge developer cost to performing the migration.<p>For the record, I have migrated several medium-sized codebases with 2to3 and python-modernize.  Because these were internal tools with defined inputs and outputs, it was trivial to validate that the behaviour was unchanged after the conversion.  But for most projects this will not be the case.<p>The 2 to 3 conversion will be a textbook case of what not to do for many decades to come.  For the many billions it will cost for worldwide migration efforts, the interpreter could have retained two string types and handled interpreting both old and new scripts.  The cost would have been several orders of magnitude less.')