Item(by='segfaultbuserr', descendants=None, kids=[25737992], score=None, time=1610402203, title=None, item_type='comment', url=None, parent=25735474, text='&gt; <i>seems like such a system could avoid this failure mode in systemd, video[1], slides[2]</i><p>Yes and no.<p>Yes, OpenBSD is not vulnerable to this failure mode. But no, it&#x27;s only because OpenBSD made assumptions that systemd couldn&#x27;t.<p>The problem is not how well the random system performs once it started, but simply <i>what to do when it&#x27;s not initialized yet during early boot</i>. From <i>Page 20: Kernel initialization from boot</i>, OpenBSD&#x27;s initialization sequence is:<p>1. If available, use rdrand to generate random seeds.<p>2. Read random seed file from the disk, saved from the previous boots or installation, very early by the bootloader.<p>3. Read the Stack Protector cookie from the kernel binary, by the bootloader.<p>4. Mix them together. The pool is initialized at this point.<p>5. Keep collecting entropy from various sources of randomness, such as interrupts.<p>Nice, it ensures that you always get a initialized entropy pool, and hides all complexity away from the userspace. But do note that (2) and (3) provides no security during the first early boot if the same OS image is replicated across many machines.<p>---<p>Now what about Linux?<p>1. If available...<p>- use rdrand to generate random seeds. It&#x27;s optional and can be disabled by the user.<p>- use hardware random number generators and TPMs, but only if they&#x27;re compiled into the kernel (or loaded early enough) and trusted by the user.<p>- use the in-kernel jitter entropy collector, &quot;a modern out-of-order CPU, even quite simple loops show a fair amount of hard-to-predict timing variability.&quot; But only available since Linux 5.3 released in 2019.<p>2. Read random seed file from the disk, saved from the previous boots. But it&#x27;s the responsibility of the userspace to do that, this is problematic for systemd.<p>- systemd needs a source of randomness at an earlier time, before the entropy pool is seeded by the file. How did OpenBSD solve it? Instead of loading it after boot in userspace, OpenBSD loads the file early, really early, via the bootloader.<p>- systemd doesn&#x27;t trust the file. The file is read, but by default, its entropy is not credited, because systemd doesn&#x27;t want to take the responsibility if someone accidentally replicated the random file across millions of machines via a system image (OpenBSD seems to be okay with the lack of protection of image replication, but systemd is more cautious, probably because it has zero control over the rest of the system). As a result, the system may block at step 4 (entropy collection) during boot for a long time.<p>3. If Latent Entropy GCC plugin is used, Linux kernel can use entropy embedded in the kernel binary. It&#x27;s a creative innovation by PaX&#x2F;grsec, it uses a random seed inserted at build time, but also inserts local variables in every marked function, so that different runtime code paths and control flows create different entropy seeds. But it&#x27;s only an optional feature and almost nobody uses it - PaX&#x2F;grsec ideas are too radical to most people ;-)<p>- Note that it&#x27;s security properties can still be seriously weakened by a replicated kernel binary. Also, it&#x27;s entropy is seeded to the pool, but it&#x27;s also not trusted and credited, since it&#x27;s considered a workaround, not a solution.<p>4. Keep collecting entropy from various sources of randomness, such as interrupts.<p>As you can see, it&#x27;s actually really similar to OpenBSD (I meant the concepts, not the implementation), the only difference is that almost everything is optional and nothing is guaranteed to work.<p>---<p>So as a tradeoff, systemd uses the following logic instead.<p>1. If available, bypass the kernel, use rdrand directly for non-crypto randomness.<p>2. For everything else (no rdrand machines &amp; crypto), use the system&#x27;s entropy pool, it may block for a long time before the pool is initialized, even with a random seed file or Latent Entropy, because their entropy is uncredited.<p>I think this is a reasonable tradeoff, but if rdrand is broken, everything breaks down.<p>I think the differences between OpenBSD and Linux is basically due to how much control you have over the operating system.<p>OpenBSD has the advantage you have when you&#x27;re building an entire operating system, not just a kernel.<p>---<p>Update: As pointed out by the comment, systemd supports bootloader entropy too, but only uses it via systemd-boot on EFI systems since it&#x27;s not vulnerable to the image replication problem. With UEFI, it can combine the seed file with a machine-specific EFI variable (&quot;system token&quot;) in UEFI&#x27;s NVRAM generated during system installation.<p>Systemd also criticizes NetBSD&#x27;s bootloader entropy for being vulnerable to the image replication problem, see <a href="https:&#x2F;&#x2F;systemd.io&#x2F;RANDOM_SEEDS&#x2F;" rel="nofollow">https:&#x2F;&#x2F;systemd.io&#x2F;RANDOM_SEEDS&#x2F;</a><p>&gt; This is boring: NetBSD had boot loader entropy seed support since ages!<p>&gt; Yes, NetBSD has that, and the above is inspired by that (note though: this article is about a lot more than that). NetBSD’s support is not really safe, since it neither updates the random seed before using it, nor has any safeguards against replicating the same disk image with its random seed on multiple machines (which the ‘system token’ mentioned above is supposed to address). This means reuse of the same random seed by the boot loader is much more likely.<p>Update 2: Rewrite the comment entirely.')