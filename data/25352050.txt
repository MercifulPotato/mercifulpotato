Item(by='didibus', descendants=None, kids=None, score=None, time=1607465277, title=None, item_type='comment', url=None, parent=25350681, text='&gt; and, in all likelihood, with a few modifications make it respect the ANSI specification and have it run in 2020<p>&gt; Granted I also have some implementation-specific code and code that would suffer in efficiency and that would hit implementation limits.<p>That&#x27;s my point. I mean that the Spec make you think it&#x27;s always 100% compatible, but there are actually some small differences, and it&#x27;s not always compatible or performing similarly.<p>Clojure just makes that reality explicit. Here are alternate implementations, here&#x27;s what they support and where they differ, and don&#x27;t trust that any implementation details might be exactly the same.<p>And for CL, a lot of choosing an alternate implementation is about finding one that supports the platform you target. But in Clojure, that&#x27;s already handled by an intermediate host, like JVM, JS, or CLR. And so a lot of the meaningful differences between CL implementations arn&#x27;t meaningful in Clojure, instead they&#x27;d be lifted to choosing which JVM you want to use, instead of which Clojure implementation you want to use. And it turns out the JVM is incredibly portable across platforms and does have a Spec, and so does indirectly Clojure.<p>So when you take it practically, the choice of implementation for me is about reach. And there are some places where CL reaches further then Clojure for now, specifically around embedded, IOT, lower level and such. There&#x27;s also places where it doesn&#x27;t reach as far as the JVM or JS hosts can give you. And yes, you can use say ABCL, but it&#x27;s not as simple as copy&#x2F;pasting your code to it. Part of wanting the reach of the JVM is to tap into its ecosystem of libraries and frameworks, and as soon as you do that, your ABCL code is stuck to only working on ABCL, and is no longer portable to any other CL host, same as Clojure.<p>I&#x27;d reframe the problem here, instead of saying CL is portable and has a Spec and Clojure doesn&#x27;t. I&#x27;d say what exactly are you trying to achieve?<p>Do you want to run code written for x86 Windows on ARM64 FreeBSD? Well Clojure code is portable on both using the same implementation but a different JVM. And CL code can be portable as well if switching to a different CL compiler implementation with support for ARM64 FreeBSD.<p>Do you want to use JS libraries in a Common Lisp project and target the browser and NodeJS? Well, I&#x27;m actually not sure if CL has any way to do that, but assume it does, great you can do it, but most likely not have it be portable. Similarly with Clojure you have ClojureScript for that.')