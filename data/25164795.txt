Item(by='rng_civ', descendants=None, kids=None, score=None, time=1605905467, title=None, item_type='comment', url=None, parent=25163402, text='I think there&#x27;s a conflict between FFIs in practice and theoretical FFIs. The few papers I&#x27;ve read for sound FFIs between languages A and B rely on the fact that the common interop target is a high-level language whose features subsumes the features of A and B. ABI, calling convention, etc. are merely implementation details.<p>So from this perspective, the interop target should actually not be the lowest common denominator, but the opposite: a target that can describe all possible user languages in a common format.<p>In fact, I would actually argue that the implementation details are NOT that interesting and only a distraction: that we need an abstract way of declaring compatibility. For instance, one can imagine a high-level FFI target where function types are parameterized by their calling convention i.e.:<p>`foo: (VOID&lt;C&gt;-&gt;VOID&lt;C&gt;)&lt;C&gt;`<p>`bar: (UNIT&lt;Rust&gt; -&gt; UNIT&lt;RUST&gt;)&lt;RUST&gt;`<p>and attempting to call `bar` from `foo` involves a compiler intrinsic like `RUST_CALL(bar)()` to convert the type (and the calling convention) appropriately.')