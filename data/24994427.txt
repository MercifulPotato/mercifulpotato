Item(by='kannanvijayan', descendants=None, kids=None, score=None, time=1604535001, title=None, item_type='comment', url=None, parent=24991577, text='&gt; Some might mention that V8 moved away from the always-JIT<p>They did, but their always-JIT was a bit heavyweight.  They generated full method-jit code on first invocation at first.  This was a massive improvement over the existing state of the art, but it was also relatively early in the whole development of the &quot;fast JS&quot; ecosystem we live in now.<p>The _size_ of JS grew, and the size of functions grew, and the complexity of logic grew.  The amount of cold and run-once code grew.<p>That issue was brought into focus by the growth of the webapp space and the size of the payloads.<p>In this case (erlang folks) - they&#x27;re going about the whole thing in a very good way.  Their &quot;jit-everything&quot; is actually &quot;jit one instruction at a time&quot;, which is _amazingly_ perceptive of the challenges people in other JIT teams have faced (e.g. JS JIT teams).  What they&#x27;re doing is tightly scoped, easy to bootstrap and test with fallbacks to VM-calls into the VM for slowpaths or complicated stuff.<p>That&#x27;s a solid base you can slowly layer with higher tiers later if it matters.  They&#x27;re keeping their abstraction layers strong by having a well-specified bytecode system, and hopefully they will strive to keep it relatively independent of the runtime, and avoid leakages of runtime semantics into instructions.<p>I was personally very impressed by their description of their approach and motivation behind each decision.')