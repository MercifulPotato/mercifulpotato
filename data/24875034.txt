Item(by='krytarowski', descendants=None, kids=[24875484, 24875176], score=None, time=1603492426, title=None, item_type='comment', url=None, parent=24874568, text='Thank you for your feedback.<p>&gt; The real issue with debuggers is that ptrace is a pretty broken API.<p>Please note that this article focuses on NetBSD and FreeBSD first.<p>As your comment describes only one OS (Linux) please do not generalize as your comment seems to use truth sparingly.<p>The ptrace(2)&#x2F;NetBSD API design and implementation is free from all of the difficulties you mentioned in your post.<p>&gt; Supporting things like spawning threads, forking processes, fork+exec, etc. is difficult, and full of race conditions that are difficult to code correctly.<p>The difficulty of catching LWP creation events:<p>ptrace_event_t event = {};\nevent.pe_set_event = PTRACE_LWP_CREATE;\nptrace(PT_SET_EVENT_MASK, child, &amp;event, sizeof(event))<p>Then whenever a debuggee creates a child, it&#x27;s fully stopped (so called all-stop mode from GDB) and reported to the debugger by sending a signal that is wait(2)ed.<p>Then, investigate the debuggee event through checking the signal passed (SIGTRAP) and investigating siginfo_t that contains new thread identifier.<p>Then, you can resume the whole process with a single PT_CONTINUE.<p>&gt; forking processes<p>Same for forking, use PT_SET_EVENT_MASK+PTRACE_FORK. Fork events are reported for the forking parent and forked child. As you poll on events on a single PID only (for all events for all threads within a process), you have the deterministic order of reporting the forked parent first always, followed by polling for the forked child (you know its PID from SIGTRAP + siginfo_t submitted to the parent).<p>&gt; fork+exec<p>This is a matter of catching EXEC and FORK events separately. All exec() events are reported as SIGTRAP + siginfo_t specifying TRAP_EXEC. No big deal.<p>&gt; is difficult, and full of race conditions that are difficult to code correctly<p>I push this comment to the free market of opinions of the readers.<p>&gt; Attaching to running multithreaded processes is another challenge.<p>It&#x27;s 1-liner always:<p>ptrace(PT_ATTACH, pid, NULL, 0);<p>No matter whether this is a single-threaded or multi-threaded process.<p>&gt; Writing a debugger that can correctly handle multithreaded applications is challenging,<p>Again, I defer this question to the free market of opinions.<p>&gt; the documentation gives you zero insight into what the potential pitfalls are,<p>Please list the pitfails so we can improve the documentation!<p>&gt; and almost all examples are similarly uninformative, being too complex for their use case.<p>There are a few hundreds of ptrace programs in NetBSD executing each small feature in minimal code. This is embedded into the regression test framework (ATF). This code can be reused (good license + simple) in 3rd party software.<p>For external examples, I recommend the most minimal event tracker of debuggers, that I wrote here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;krytarowski&#x2F;picotrace" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;krytarowski&#x2F;picotrace</a><p>In particular, you can trace all events possible in all types of programs (at least in the current version of ptrace(2)) in around 300 LOC, as noted here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;krytarowski&#x2F;picotrace&#x2F;blob&#x2F;master&#x2F;common&#x2F;trace.c" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;krytarowski&#x2F;picotrace&#x2F;blob&#x2F;master&#x2F;common&#x2F;...</a><p>FreeBSD has a distinct ptrace(2) API, but not far from NetBSD and is relatively comparable and quickly portable from one BSD to another.<p>If you have got any more questions or comments, do not hesitate to ask!')