Item(by='SassyGrapefruit', descendants=None, kids=[24776919], score=None, time=1602685231, title=None, item_type='comment', url=None, parent=24770954, text='I watch more people overcomplicate their lives when it comes to unit testing. The problem discussed in this article is not one of mock vs. fake its actually about how this individual chose to engineer their application.<p>First I&#x27;ll introduce some axioms...<p>1. Mixing unit and integration testing is not ideal. If you are doing unit testing focus on verifying the code paths within the unit. When considering the collaborators focus on the finite number of states that are most likely to occur.<p>2. (I know this is contentions) Design your code so that it is easy to unit test. It&#x27;ll be ok I promise. In almost all cases code designed for easy unit testing is synonymous with well engineered code<p>Imagine this python...<p>```<p>def get_a_file_and_do some_stuff(path):<p><pre><code>    d = dict()    \n\n    with open(path, &#x27;r&#x27;) as file:\n\n      for line in file:\n\n          d[line] = d.get(line, 0) + 1\n\n    # a bunch of code that does something with this dictionary\n\n    return result</code></pre>\n```<p>The above is miserable to test with mocks. You end up trying to man handle the file object. Its not fun.<p>```<p>def get_a_file_and_do some_stuff(path):<p><pre><code>    d = convert_path_to_dictionary(path)\n\n    # a bunch of code that does something with this dictionary\n\n    return result\n</code></pre>\n```<p>With the simple flick of the wrist I can now trivially mock out &quot;convert_path_to_dictionary(path)&quot; and I only ever have to work with dictionaries.<p>So you might say &quot;but but what about the file dictionary code. are you going to test that?&quot; Probably not and if experience is any indicator I&#x27;ll never have an issue with it. The edge cases and regressions will all lie in the custom business logic executed on the dictionary.<p>I see engineers make their lives enormously difficult to live up to some unachievable standard. Often that standard yields very little value in excess of a much simpler approximation')