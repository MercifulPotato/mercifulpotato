Item(by='aequitas', descendants=None, kids=None, score=None, time=1601899292, title=None, item_type='comment', url=None, parent=24686698, text='Depends on the Git craftmanship of the team is my experience. If they commit every small fix with a useless commit message, history becomes messy real quick. Squashing can be seen as a solution here. Until you learn proper rewriting of history as in (interactive) rebasing. After which you can put you code changes in every commit you want and order them around as you see fit. But that also depends on the Git workflow that is used and how much branches are shared amongst team members.<p>I had one job in the past that used Gerrit[0] as Git tool. One of it&#x27;s features is that it creates a &quot;pullrequest&quot; for every commit in the branch you push. Which needs to be reviewed individually. This is really anoying if you&#x27;re used to organising your work in lot of commits to record each step of your developerment. But from a project&#x27;s Git history perspective it makes a lot of sense. As every commit is 1 change, one feature, one contained unit, that is added to the main branch. So instead of the main branch now containing countless commits with each developers complete history on a specific feature (where code is added in one commit to be removed in the next) it contains the features as distict commits, making them easy to bisect and revert if needed. This looks a lot like squashing but because you do it before you push your code you learn to put much more thought into that single commit and the commit message.<p>[0] <a href="https:&#x2F;&#x2F;www.gerritcodereview.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.gerritcodereview.com&#x2F;</a>')