Item(by='acoard', descendants=None, kids=None, score=None, time=1605889406, title=None, item_type='comment', url=None, parent=25161600, text='&gt;However, unit tests are usually written to assert assumptions.<p>As you say, types are a more declarative (rather than procedural) way of asserting  assumptions.<p>&gt;In practice, this means that you sometimes get &quot;surprised&quot; by some unit tests that are failing after a refactor. That&#x27;s good because it sheds light where you&#x27;ve made mistakes when changing your code.<p>&gt;To some degree, of course, this is true for types. E.g. they will always help you to point out when two APIs mismatch. However, a test usually is contained within a unit with a clear description motivating its existence. It&#x27;s so much harder to accidenitally changing a test for the worse than it is to change a typed function signature for the worse.<p>I&#x27;d argue it&#x27;s just as true for types as it is for unit  tests, if  not more so.  You can get &quot;surprised&quot; by the compiler when refactoring methods in just the same way.  I&#x27;d argue you get more information with types, because it hooks into the LSP and identifies everywhere in your code that now fails.  In contrast, a unit test only tells you that unit test failed.  It is still up to you to find the actual locations in the code. In this way, unit tests can be thought of as a parallel program.  This isn&#x27;t true of types, which are directly embedded into the program.  Put concretely, if you removed a property on a type then the LSP and tsc would tell you every single place that property is missing.<p>That&#x27;s the crux of my argument.  Types have better tooling, which helps with both the &quot;delclarative unit test&quot; part and equally importantly with refactoring.  You can check for more things with types, like whether your `switch` statement exhaustively goes over every option or is missing any. Your tools also understand the types (like the LSP), which helps with refactoring.<p>I&#x27;d also argue that types are usually easier to understand than tests. While good unit tests can provide good examples on how to use an API, types exhaustively tell you what a thing is and what it is capable of.<p>&gt;Lastly, very often functions are crucially dependent on input values and not their types. So even if, in a dynamic language, you get b=0 input into div(a, b) return a&#x2F;b and it&#x27;s a valid type, you should test for values as in this case as you can&#x27;t divide by 0.<p>That&#x27;s a great point. There&#x27;s absolutely still a place for tests.  Types are not a like-for-like replacement, and each have their strengths, but there is significant overlap.  If one wanted to exhaustively enumerate in options in a `switch` statement, and ensure division by 0 issues, then they would need both.')