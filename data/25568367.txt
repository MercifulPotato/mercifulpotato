Item(by='jcelerier', descendants=None, kids=None, score=None, time=1609236271, title=None, item_type='comment', url=None, parent=25564624, text='&gt; So the big win with functional programming is easier testibility and fewer hazards when trying to multi-thread your code.<p>To give you my experience: during my phd, I developed <a href="https:&#x2F;&#x2F;ossia.io" rel="nofollow">https:&#x2F;&#x2F;ossia.io</a> in C++. For the manuscript redaction, I rewrote all the core algorithms in pure functional OCaml. When I did some tests, performance was slower than -O0 C++ (so it&#x27;s not even a given that multithreaded OCaml would outperform single-thread C++), the tests weren&#x27;t meaningfully simpler to write, and it would be pretty much impossible to have an average comp. sci. student contribute to the code.<p>My experience multi-threading C++ code is, &quot;slap cpp-taskflow, TBB, RaftLib&quot; or any kind of threaded task system and enjoy arbitrary scaling. Hardly the pain it is made to be unless you have a need to go down to std::thread level, but even then using something like <a href="https:&#x2F;&#x2F;github.com&#x2F;cameron314&#x2F;concurrentqueue" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;cameron314&#x2F;concurrentqueue</a> to communicate between threads makes things extremely painless.')