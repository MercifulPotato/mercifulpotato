Item(by='6gvONxR4sf7o', descendants=None, kids=[25041800], score=None, time=1604961838, title=None, item_type='comment', url=None, parent=25039676, text='I&#x27;m just butting into this conversation, but I think you&#x27;re setting the bar to high.<p>&gt; Program analysis, (assuming &quot;FSMification&quot;, of course, to avoid undecidability), was proven in 2005 to not be FPT.<p>I think your using &quot;program analysis&quot; in a different way than I&#x27;m used to. I thought program analysis was just the attempts to infer&#x2F;check properties of the program. A property like termination and a property like &quot;the type of this variable&quot; are very different, obviously. What specifically are you referring to?<p>&gt; I&#x27;m claiming that analogous code to that which would be feasibly checkable in a restricted language would also be feasibly checkable in a non-restricted language, and that both are subject to the same difficulties.<p>I mean, you&#x27;re correct here, but missing the point. Consider a type checker, or Rusts borrow checker, or a side effect checker. The static analysis is going to be the same if you just translate the code to Python, for example. Nonetheless, the differences matter to people. I have a completely different confidence in my program&#x27;s properties using somebody&#x27;s pure function in Haskell than I do using some random Python function. If I looked at the source code, yeah I could reason through either of them in the same way, But in one, I don&#x27;t have to.<p>&gt; Right, but that doesn&#x27;t mean that a specific empirical claim should be assumed true until proven false, rather than the opposite, which is the scientific norm.<p>A specific empirical claim should be suspected in whichever direction you personally think, given the arguments and incomplete evidence, held in a state of uncertainty until proven definitely one way or the other. The scientific norm is decidedly NOT assuming one way or another prior to evidence&#x2F;proof.')