Item(by='mehrdadn', descendants=None, kids=[25427005], score=None, time=1608001828, title=None, item_type='comment', url=None, parent=25426477, text='Comparing pointers derived from entirely different objects (or arrays) isn&#x27;t legit. See here: <a href="https:&#x2F;&#x2F;www.viva64.com&#x2F;en&#x2F;b&#x2F;0576&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.viva64.com&#x2F;en&#x2F;b&#x2F;0576&#x2F;</a><p><i>&quot;Pointer arithmetic is only defined for pointers pointing into array objects or one past the last element. Comparing pointers for equality is defined if both pointers are derived from the same (multidimensional) array object. Thus, if two pointers point to different array objects, then these array objects must be subaggregates of the same multidimensional array object in order to compare them. Otherwise this leads to undefined behavior.&quot;</i><p>For the purpose of comparisons, C++ lets you partially work around this via std::less et al, which are nevertheless guaranteed to implemented in such a way as to give you a total ordering among all pointers. Even then, I don&#x27;t think you can freely interchange pointers that compare &quot;equal&quot; in that sense; the same object may have pointers with different representations, all of which compare &quot;equal&quot; for ordering purposes but which don&#x27;t have an identical representation. (See segmented memory models, for instance.) I also don&#x27;t recall if C has a similar workaround (it might not).')