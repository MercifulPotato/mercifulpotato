Item(by='mrkeen', descendants=None, kids=[24969204], score=None, time=1604325243, title=None, item_type='comment', url=None, parent=24959057, text='Glad you asked!<p>synchronized locks <i>code</i>, atomically locks <i>data</i>.<p>It maps to my thinking better, because what I&#x27;m interested in is manipulating two or more resources <i>at the same time</i>.  I&#x27;m not interested in making sure two threads aren&#x27;t in the same region of code at the same time.<p>&gt; What error does it protect you against compared to synchronising on list?\nSynchronized is perfectly fine for my example.  I should have picked a better example of two resources (instead of list and size of list), because synchronized gets trickier once you start combining different pieces.<p>For example, I have two bounded lists, and I want to transfer an element from one to the other.  I&#x27;ve already written synchronized versions of remove and insert, so let&#x27;s try with them:<p><pre><code>    transfer(otherlist) {\n        x = otherlist.synchronizedRemove();\n        this.synchronizedInsert(x);\n    }\n</code></pre>\nThere will be a moment in time where the outside world can&#x27;t see x in either list.  Maybe I crash and x is gone for good.  Or maybe the destination list becomes full and I&#x27;m left holding the x with nowhere to put it.  So what is to be done?  I could synchronize transfer but that still wouldn&#x27;t fix the vanishing x, or the destination filling up.  So I paid the performance cost of taking two&#x2F;three locks and I&#x27;ve still ended up buggy.<p>I think the fix here is to lock each list, then no-one else can access them and it should fix the vanishing x:<p><pre><code>    transfer(otherlist) {\n        synchronized(this) {\n            synchronized(otherlist) {\n                x = otherlist.synchronizedRemove();\n                this.synchronizedInsert(x);\n            }\n        }\n    }\n</code></pre>\nI think that&#x27;s correct?  But now I have taken too many locks - I only needed remove and insert not synchronizedRemove and synchronizedInsert.  And now I&#x27;ve introduced deadlock possibility - if two transfers are attempted in opposite directions.<p>I can fix the too many locks problem, by exposing non-synchronized remove and insert and have transfer call them instead.  But then callers and I will accidentally call the wrong one.  I break any pretence of encapsulation by exposing unsafe and safe versions of a method.  The deadlock is harder to fix.  I&#x27;d need to synchronize the lists in some agreed order (and have everyone else obey that ordering in their other methods too!).<p>Instead, I want my implementation to look something like:<p><pre><code>    BoundedList {\n\n        transactional Int sz;\n        transactional List list;\n\n        transactional insert(x) {\n            if (sz &lt; 4) {\n            list.insert(x);\n            sz++;\n            }\n        }\n\n        transactional remove() {...}\n\n        transactional transfer(otherlist) {\n            x = otherlist.remove();\n            this.insert(x);\n        }\n    }\n</code></pre>\n&gt; What happens if .insert() also uses atomically{} somehow?<p>A good implementation would throw a compile-time error.  A bad implementation could throw a runtime error.<p>In order to do this, transactional actions would need to be marked as such - to prevent mixing them up.  atomically by definition is a non-transactional action (because it&#x27;s the thing that commits all the steps to the outside world) so if you find an atomically inside a transaction, it&#x27;s a type error.<p>You&#x27;ve already used a system like this if you&#x27;ve worked with any decent SQL implementation:<p><pre><code>    BEGIN TRANSACTION\n\n    UPDATE accounts\n    SET money = money - 50\n    WHERE accountId = &#x27;src&#x27;\n\n    UPDATE accounts\n    SET money = money + 50\n    WHERE accountId = &#x27;dest&#x27;\n\n    COMMIT TRANSACTION\n</code></pre>\nI didn&#x27;t take any &#x27;locks&#x27;.  I just wrapped two perfectly good individual actions and said &#x27;run them both or not at all&#x27;.  Though to be fair I am getting a lot of grief in another thread by suggesting that even novices could wrap up their SQL like that without getting it wrong.')