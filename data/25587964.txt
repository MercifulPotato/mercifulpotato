Item(by='yold__', descendants=None, kids=[25588018, 25589152, 25588487, 25591497, 25590770, 25592861, 25589785, 25588976, 25588257, 25591669, 25590609, 25589215, 25588049, 25593086, 25591301, 25591267, 25589524, 25590575, 25588014, 25588032, 25591107, 25588110], score=None, time=1609373575, title=None, item_type='comment', url=None, parent=25586063, text='I&#x27;m a research actuary working in reinsurance.  Here is why I think Python creates more problems than it solves from the standpoint of most insurance business users:<p>1.) Environment management.  There are many solutions for managing python dependencies, my favorite is Docker + pip.  Good luck getting actuaries and underwriters to write Dockerfiles etc, and good luck getting I.T. to support Docker on Windows desktops.  Like it or not, the best &quot;feature&quot; of Excel is that it is mostly the same on every corporate Windows machine.<p>2.) Unless you are using numpy &#x2F; numba, Python isn&#x27;t that much faster than VBA (if at all).  Both are &quot;compiled&quot; to interpreter bytecode.<p>3.) Speed of development and traceability.  Excel takes a lot of getting used to, but if you know the purpose of the spreadsheet (e.g. a reserve calculation), it&#x27;s relatively easy to figure out what a mangled and convoluted formula is doing (Excel has a &quot;debugger&quot; that allows you to evaluate formulas by highlighting pieces).<p>4.) LAST BUT NOT LEAST.  Many financial and actuarial (insurance) calculations are inherently recursive.  Excel has built-in memoization (in the dynamic programming sense).  It also has a reactive programming model.  Good luck implementing that in Python without tripping up on the huge amount of function call overhead, even if you use a memoization decorator.')