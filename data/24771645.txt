Item(by='to11mtm', descendants=None, kids=None, score=None, time=1602632673, title=None, item_type='comment', url=None, parent=24770900, text='&gt; I&#x27;m starting to think the biggest selling point for Java and dotNET platforms is, not platform-independence, but code obfuscation.<p>I wouldn&#x27;t agree for that in the case of .NET Framework.<p>On one hand, the safety of both languages does make it easier for obfuscators to pull certain tricks i.e. swapping out direct calls for Delegates (memory safe pointers for those unfamiliar with .NET terms) or throwing a bunch of indirect method calls, etc etc because in most cases object lifetime is something you don&#x27;t think about in LOB .NET.<p>On the other hand, the problem is that almost any IL can be pulled back into a representation that may not be -fully- comprehensible, but again there are tools to even help with that b&#x2F;c the C# language spec is well defined enough you know what you need to strip that isn&#x27;t truly needed for a decompile.<p>Java&#x2F;C# got big because of (1) hype, (2) somewhat-filled promises of xplat, (3) somewhat filled promises of better productivity because you don&#x27;t have to think about most object lifetimes.<p>We&#x27;re seeing a shift back to Go&#x2F;C&#x2F;Rust&#x2F;Etc because people are realizing as data grows that a lot of their C#&#x2F;Java code suddenly isn&#x27;t so great at huge scale when a GC is churning all the time.<p>Both C# and Java are working on this in their own way of course; Java is doing a lot of work on their GC, .NET is doing a lot of work to make sure that their IO pipelines for things like sockets are better handled; after that it&#x27;s up to the dev to decide if they want to go struct-happy.')