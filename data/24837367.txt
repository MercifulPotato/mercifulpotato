Item(by='oefrha', descendants=None, kids=[24840027, 24838025], score=None, time=1603202438, title=None, item_type='comment', url=None, parent=24836833, text='&gt; \nThe standard Python profilers profile and cProfile show you a big list of functions, ordered by the time spent in each function. This is great, but it can be difficult to interpret why those functions are getting called. It&#x27;s more helpful to know why those functions are called, and which parts of user code were involved.<p>Note that you can use something like gprof2dot to convert pstats dump from cProfile to a visual callgraph: <a href="https:&#x2F;&#x2F;github.com&#x2F;jrfonseca&#x2F;gprof2dot#python-cprofile-formerly-known-as-lsprof" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;jrfonseca&#x2F;gprof2dot#python-cprofile-forme...</a><p>Not saying that solution’s better than pyinstrument — I haven’t use this one before so I’ll have to evaluate. Also, the lower overhead is undeniable.<p>---<p>Edit: Another thing I noticed in &quot;How is it different to profile or cProfile?&quot;:<p>&gt; &#x27;Wall-clock&#x27; time (not CPU time)<p>&gt; Pyinstrument records duration using &#x27;wall-clock&#x27; time. ...<p>Seems misleading as cProfile uses time.perf_counter unless you supply your own timer, and time.perf_counter does measure wall clock time. See<p><a href="https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;ec42789e6e14f6b6ac13569aeadc13798d7173a8&#x2F;Modules&#x2F;_lsprof.c#L106-L115" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;ec42789e6e14f6b6ac135...</a><p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;time.html#time.perf_counter" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;time.html#time.perf_counte...</a>')