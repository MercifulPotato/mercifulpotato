Item(by='Ericson2314', descendants=None, kids=[25222525, 25222233], score=None, time=1606413462, title=None, item_type='comment', url=None, parent=25220892, text='From the author&#x27;s previous piece: <a href="https:&#x2F;&#x2F;www.scylladb.com&#x2F;2020&#x2F;05&#x2F;05&#x2F;how-io_uring-and-ebpf-will-revolutionize-programming-in-linux&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.scylladb.com&#x2F;2020&#x2F;05&#x2F;05&#x2F;how-io_uring-and-ebpf-wi...</a><p>&gt; Our CTO, Avi Kivity, made the case for async at the Core C++ 2019 event. The bottom line is this; in modern multicore, multi-CPU devices, the CPU itself is now basically a network, the intercommunication between all the CPUs is another network, and calls to disk I&#x2F;O are effectively another. There are good reasons why network programming is done asynchronously, and you should consider that for your own application development too.\n&gt;\n&gt; It fundamentally changes the way Linux applications are to be designed: Instead of a flow of code that issues syscalls when needed, that have to think about whether or not a file is ready, they naturally become an event-loop that constantly add things to a shared buffer, deals with the previous entries that completed, rinse, repeat.<p>As someone that&#x27;s been working on FRP related things for a while now, this feels very vindicating. :)<p>I few like as recently as a few years ago, the systems world was content with it&#x27;s incremental hacks, but now the gap between the traditional interfaces and hardware realities has become too much, and bigger redesigning is afoot.<p>Excited for what emerges!')