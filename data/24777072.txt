Item(by='chriswarbo', descendants=None, kids=[24786504], score=None, time=1602686724, title=None, item_type='comment', url=None, parent=24775446, text='Function composition doesn&#x27;t spring to mind when I think fakes&#x2F;mocks&#x2F;testing. As a long-time functional programmer, the things I&#x27;d reach for are:<p>Higher-order functions: rather than taking a &#x27;service object&#x27; as an argument, and calling one or two of its methods, we can accept the methods&#x2F;functions we need as arguments. Tests can pass in their own functions, which looks a lot like mocking but doesn&#x27;t need any tricks or frameworks. This is the easiest approach for simple cases, but incurs lots of boilerplate as it&#x27;s used more and more.<p>Records: these are name&#x2F;value collections (think &#x27;{foo: bar, ...}&#x27; in JS). Since the values can be functions, they&#x27;re pretty much objects; but we can swap out these values without having to define classes, etc. We can use these just like &#x27;service objects&#x27; in OOP.<p>Type classes&#x2F;interfaces: these define certain operations&#x2F;methods that can be performed on a given type, even if that type&#x27;s generic. They&#x27;re essentially records like above, but chosen by the compiler based on the type; some languages (e.g. Agda, Idris, Scala) also allow overrides to be taken from the current scope.<p>Domain-specific languages: we treat the methods&#x2F;operations of our API as if they&#x27;re builtin-functionality of some &#x27;embedded&#x27; language. When we use such functionality, the result is a program for that embedded language. We can run these programs by defining an &quot;interpreter&quot; (a function which implements each of these operations); we can define a &#x27;real&#x27; interpreter and a test interpreter. This is the most hardcore, and usually benefits from some framework for doing the necessary plumbing. I wouldn&#x27;t recommend it as a first step, but I&#x27;ve had success doing this with Haskell&#x27;s Polysemy library; another popular library is Haskell&#x27;s &#x27;Monad Transformer Library&#x27; but I&#x27;ve not used that myself.')