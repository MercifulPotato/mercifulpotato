Item(by='geofft', descendants=None, kids=[25531372, 25531835], score=None, time=1608842468, title=None, item_type='comment', url=None, parent=25530159, text='&gt; <i>I have no idea how anyone lives with it for anything except writing extremely repetitive, formulaic, and superficial code, because having to dig into its guts feels like a nightmare.</i><p>This is sort of why I <i>like</i> Python: it prioritizes getting something working today and trades off being able to build a complex system over several years. Java is a great language if you&#x27;re going to build a large-scale application and want a bunch of developers across time and space to productively contribute to it. But business requirements change, and if you can get what you want done by using a series of applications that live for a few weeks or months, why wouldn&#x27;t you do that?<p>Another commenter mentioned scientific computing, which is a good example. When you&#x27;re evaluating hypotheses, it&#x27;s important to be able to write <i>new</i> code with high throughput. That means you need enough power of abstraction to be able to have libraries like NumPy etc., but you don&#x27;t want <i>so much</i> structure that it&#x27;s hard to write 10 lines of code and validate or falsify your gut feeling and then move on. Python was built around a REPL; Java only grew JShell fairly recently, and Jupyter was built for Python, not Java.<p>And even when you&#x27;re trying to reproduce old work, it&#x27;s a lot more scientifically valuable to have someone be able to look at the paper (the spec) and write a new implementation than to say &quot;Start with this 100 kloc Java codebase which we wrote for Java 1.2 but still works today.&quot; There are of course useful applications for that capability and it&#x27;s great that Java supports it, but this isn&#x27;t one of those applications.<p>I don&#x27;t do scientific Python myself, but I support users who do and I do a lot of infrastructure work. For that, it&#x27;s still much more valuable to be able to write new code and get rid of it than to work within an old and well-built system. If I want to answer questions of, say, what our storage use patterns look like so the business can figure out what to invest in, it&#x27;s a lot more valuable to be able to take that problem statement and produce an <i>answer</i> quickly than to build a long-lasting application that can keep producing answers to variants of that question, because the next question isn&#x27;t likely to look too similar in terms of implementation.<p>Or maybe put it this way - if you&#x27;re the IRS, and you&#x27;re writing code to process and verify people&#x27;s tax returns, Java sounds great. You&#x27;re going to want to keep the tax code from N years ago still working, and you&#x27;re going to want this application to live many years. But for me, I have a little program to do the math for me to fill out my taxes, and that program is in Python, because <i>I</i> have no need to keep maintaining the script when the tax code changes (or when I move states), and I&#x27;m the only author. I make a copy of the Python file each year and I drop anything irrelevant. The ability for me to read the entire script top to bottom and be convinced &quot;OK, this solves this one task accurately&quot; is far more valuable than the program being able to solve hundreds of tasks it needed to solve in the past.')