Item(by='lmm', descendants=None, kids=[25344159], score=None, time=1607422594, title=None, item_type='comment', url=None, parent=25343335, text='&gt; That&#x27;s a problem that is solved by CRDTs and the like, not any form of data store.<p>But once you accept that you have to use CRDTs or similar, traditional-RDBMS ACID becomes pointless, and you can and should use a datastore that makes better tradeoffs.<p>&gt; But it&#x27;s just one use of web frontends. Banking doesn&#x27;t use that, neither does a large chunk of the world&#x27;s applications.<p>Banking doesn&#x27;t do that, but it doesn&#x27;t do RDBMS-level transactions either. People cargo-cult the idea that you should use an ACID database, but I&#x27;m not sure I&#x27;ve ever seen a web application that actually made use of the database&#x27;s transaction support, and fundamentally I think it&#x27;s probably impossible - people say things like &quot;if you get a deadlock, just retry&quot;, but if it&#x27;s something you can retry then it didn&#x27;t need to be a transaction in the first place.<p>&gt; Studies have shown that programmers can&#x27;t work out what the race conditions and locking requirements are.<p>Which is exactly the problem with using RDBMS transactions! It&#x27;s hard enough to figure out deadlocks when you can see the lock statements in the code - it&#x27;s impossible when you don&#x27;t even have tooling that can tell you which locks will be held by which parts of the code before you run it.<p>&gt; But your definition of &quot;web-based&quot; architectures seems to be picked to be the CRDT related stream of changes.<p>The thing about the web is that it makes everything a distributed system. Even if you only have one server, the fact that your clients are accessing it over a network means you have all the problems of distributed systems and are better off using a system that&#x27;s designed to deal with them.<p>&gt; Which, by the way, could be implemented in an RDBMS by writing the CRDTs as transactions and enforcing the ordering with the appropriate rollbacks and commits.<p>You wouldn&#x27;t want to do a DB-level rollback or commit, the whole point of using a CRDT is that even when two writes conflict you can still commit them to durable storage straight away and resolve the conflict asynchronously. So the DB-level transactions don&#x27;t help you.<p>You can implement a perfectly good event sourcing architecture on top of an RDBMS by effectively using the tables as queues - I worked on a system that did exactly that back in 2010, and it worked very well. But at that point you&#x27;re not really getting much value from the database - its transaction support only gives you ways to shoot yourself in the foot, its flexible query system likewise, its schema support is better than nothing but not by much. There&#x27;s a lot of really impressive engineering under the hood, but the parts that would be useful to you aren&#x27;t actually exposed where you can use them (e.g. the MVCC implementation could be really useful, but your database will go to great lengths to pretend that it isn&#x27;t there and there&#x27;s only ever one version of your table at a time. E.g. the indexing implementation is often very good, but you don&#x27;t have enough control over which indices get built when). There are better options these days.')