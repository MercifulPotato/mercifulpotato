Item(by='carapace', descendants=None, kids=None, score=None, time=1610901829, title=None, item_type='comment', url=None, parent=25807699, text='&gt; Joy was the inspiration for min :)<p>Right on!<p>&gt; min is actually mainly an interpreted language, BUT it can actually as of recently be transpiled to Nim (which in turns generates C code which can be compiled), so you can actually create executable files from min, which is pretty cool.<p>That <i>is</i> pretty cool.  I just started learning Nim and I really like it so far.<p>&gt; ...the following Nim code gets generated. As you can see, it&#x27;s mostly just pushing items on the stack :)<p>It looks like you&#x27;re sort of compiling the interpretation?<p>The last couple of days I&#x27;ve circled back and got some work done on compiling Joy code.  (I&#x27;m using Python as the target language.  I&#x27;d like to use Nim, but I don&#x27;t want to learn that at the same time as I&#x27;m trying to write a compiler; with Python I have a lot of experience and the surprise factor is low.  I know where I&#x27;m at with it.)  I&#x27;ve just now got it to the point where I can compile (integer) math, binary Boolean logic, and loops and branches.<p>Example:<p><pre><code>    á… ?- compile_function(&quot;gcd&quot;, `true [tuck % dup 0 &gt;] loop pop`).\n\n    def gcd(stack, expression, dictionary):\n        stack = True, stack\n        tos, stack = stack\n        while tos:\n            (v1, (v2, stack)) = stack\n            stack = ((v2 % v1), ((v2 % v1), (v1, stack)))\n            stack = 0, stack\n            (v3, (v4, stack)) = stack\n            stack = ((v4 &gt; v3), stack)\n            tos, stack = stack\n        (v5, stack) = stack\n        stack = stack\n        return stack, expression, dictionary\n\n    true.\n\n</code></pre>\nAs you can see, the generated Python good is not good.  (E.g., it calculates &quot;v2 % v1&quot; twice for no good reason.)  But it has the qualities of being correct and I-didn&#x27;t-have-to-write-it! :)<p>(The compiler code is written in Prolog.  It turns out that Prolog is so good for writing compilers that it&#x27;s faster and easier to learn Prolog and then write a compiler in it than to try to write a compiler in some language you already know!)<p>This is messy work-in-progress code at this point, but if you&#x27;re interested...<p>My notes start at line 697:<p><a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~sforman&#x2F;Thun&#x2F;tree&#x2F;3b96f60f61f0a34928b9ee764c2083c0a793ee16&#x2F;item&#x2F;source&#x2F;thun.pl#L697" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~sforman&#x2F;Thun&#x2F;tree&#x2F;3b96f60f61f0a34928b9ee7...</a><p>THe code starts at line 995<p><a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~sforman&#x2F;Thun&#x2F;tree&#x2F;3b96f60f61f0a34928b9ee764c2083c0a793ee16&#x2F;item&#x2F;source&#x2F;thun.pl#L995" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~sforman&#x2F;Thun&#x2F;tree&#x2F;3b96f60f61f0a34928b9ee7...</a><p>ANyway, still to do includes: better connections from step to step so the Python code isn&#x27;t packing and unpacking the stack variable like crazy.  Reuse &quot;free&quot; variable names (right now it just generates new vars as-needed, which is fine, but it keeps the values around until the end of the function call.  Maybe they could be GC&#x27;d earlier, I dunno.)<p>That&#x27;s all pretty straightforward, the tricky bit is handling all the meta-programming: as you no doubt know, a lot of Joy functions work by combining args with function fragments to make new functions which are then evaluated.  For example, consider this (kinda silly) function:<p><pre><code>    [dup] cons i\n</code></pre>\nIt&#x27;s silly because it&#x27;s equivalent to just &quot;dup&quot;, but it illustrates the problem: how do you compile this function (or less-silly ones that work with the same meta-programming style)?<p>I suspect that you just have to include the interpreter and make &quot;dynamic&quot; calls to it from the compiled function (or include the compiler and JIT compile.)  What do you think?<p>Cheers!')