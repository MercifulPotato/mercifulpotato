Item(by='quicklime', descendants=None, kids=[24720742], score=None, time=1602174153, title=None, item_type='comment', url=None, parent=24719525, text='I won&#x27;t try to be exhaustive here, but I think it&#x27;s worth mentioning a few things:<p>One con is that most open source (as well as publicly available but proprietary) tooling is geared towards the non-monorepo approach. So if you want to use a monorepo, you&#x27;re going to have to fight a bit of an uphill battle because most tools and processes assume you have lots of little repos. For example, build triggers in a lot of CI&#x2F;CD tools operate on a per-repo basis.<p>There are some random benefits - it&#x27;s easier to make everything public-by-default, which encourages people to look at source code written by other teams, and creates a culture of transparency and internal openness.<p>But the big thing in my opinion isn&#x27;t directly the monorepo itself, but what&#x27;s known inside Google as the &quot;One Version Rule&quot;[1]. Basically this means that only a single version of any package should be in the repo at a time. There are exceptions, but that requires going to extra effort to exempt your package from this rule.<p>I guess Chrome and Android are examples of this - they are made up of lots of little Git repos that are stitched together, but they generally follow the One Version Rule. On the other hand, if you just stick a lot of npm modules in there and every single one has a separate package.json file, then it&#x27;s technically a &quot;monorepo&quot; but it&#x27;s not following the One Version Rule.<p>You also need good test coverage. Not just in terms of line coverage or some other artificial metric, but to the point where you could say &quot;I feel reasonably comfortable that a random change will be caught by my tests&quot;. This lets people in <i>other teams</i> catch regressions without having to have a detailed understanding of your team&#x27;s codebase.<p>So once you&#x27;ve got these three things - 1) a monorepo 2) with everyone following the One Version Rule and 3) lots of tests - it means that dependency owners can update all of their consumers at once without much effort. They just make a change to their base library, and the build system will walk the dependency tree and figure out all the consumers that could possibly break, and runs all the appropriate regression tests.<p>This is the inverse of how it normally works at large companies, where each team pulls in their dependencies and pins them to a specific version. At most companies, updates require extra effort, so the default is to let everything go stale. This is especially problematic when security vulnerabilities are released (e.g. to an ancient version of jQuery) but teams can&#x27;t update until they migrate off of an old API. It also means that library owners regularly have to maintain multiple old branches for months or even years after the initial release, because everyone&#x27;s too afraid to update.<p>I personally think it&#x27;s a myth that you need to be &quot;Google scale&quot; to benefit from a monorepo. In my opinion, you only need a few tens of repos before all the different combinations of semvers get unweildy. For me, going from Google&#x27;s monorepo to a company that is built around lots of little repos in GitHub Enterprise felt like going back to the CVS&#x2F;RCS days, where every single file had a separate revision number and changes weren&#x27;t made atomically.<p>[1]: <a href="https:&#x2F;&#x2F;opensource.google&#x2F;docs&#x2F;thirdparty&#x2F;oneversion&#x2F;" rel="nofollow">https:&#x2F;&#x2F;opensource.google&#x2F;docs&#x2F;thirdparty&#x2F;oneversion&#x2F;</a>')