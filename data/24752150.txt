Item(by='jasonwatkinspdx', descendants=None, kids=[24752808, 24752214], score=None, time=1602486923, title=None, item_type='comment', url=None, parent=24751953, text='The article and the links it references do a good job of explaining the arguments. A short summary:<p>* Rust&#x27;s no_std means you can run bare metal with less memory overhead than even newlib based c<p>* no_std also makes it easier to port to new platforms, as nonportable parts are isolated out of the std lib<p>* algebraic data types and in particular enums that can carry disjoint associated data reduce the number of error prone magic constants and casts in your code, as well as catching all missing switch cases<p>* unsafe makes it very easy for you to audit where data races or memory errors are possible, instead of needing to audit an entire c codebase<p>* The borrow check makes you work more, but in many cases this is justified by it leading you to a less brittle design<p>The examples, particularly on cliff&#x27;s blog post, make pretty convincing arguments oo these points imo.<p>I also wouldn&#x27;t discount EEs so much. There&#x27;s plenty of complexity to Verilog and all the other tools they use.')