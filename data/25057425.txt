Item(by='tialaramex', descendants=None, kids=None, score=None, time=1605093656, title=None, item_type='comment', url=None, parent=25057161, text='I have never used &#x27;ykman fido reset&#x27; and didn&#x27;t implement it. However the obvious way to implement this, which I&#x27;d guess is what Yubico did, is very simple:<p>Randomize the secret key that makes your authenticator unique.<p>Doing this has a similar effect (cryptographically at least, it&#x27;s not going to magically remove initials painted on with nail polish or something) to replacing the authenticator with a different one from the same batch.<p>The thing that makes the simplest possible FIDO authenticator work is a single secret symmetric key known to nobody and used only one that one specific authenticator, 256-bit AES would do, we&#x27;ll call the key K.<p>The exact details will be proprietary, obviously there are opportunities to add features&#x2F; cost reduce the product, but basically:<p>When it is asked to enroll somewhere the authenticator generates a completely random elliptic curve key pair, then it signs a blob with the private key from that pair, encrypts the private key using K in AEAD mode and hands over the signed blob, the public key and the encrypted private key which it says is just a neutral opaque identifier, looks random, could be anything.<p>A relying party (remote web site) stores the public key, the opaque identifier (remember that&#x27;s actually the private key encrypted) and some way to relate these to its existing user database.<p>When you use U2F or WebAuthn&#x27;s second factor mode to sign in, the relying party hands back that opaque identifier. Your authenticator takes the opaque identifier and tries to decrypt it with K. AEAD mode means it&#x27;ll be able to verify it minted this identifier with K and if so, get back that private key. So now it can sign a blob with the private key and prove you are still in possession of the authenticator which was enrolled.')