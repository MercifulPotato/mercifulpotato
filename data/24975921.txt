Item(by='ncmncm', descendants=None, kids=None, score=None, time=1604372626, title=None, item_type='comment', url=None, parent=24949882, text='I have looked around and determined that the only Haskell program I have ever used is Pandoc.<p>To first order, Haskell users self-select as uninterested in writing useful programs. Anybody who would like Haskell to be seen as a language that is useful for writing useful programs would better publish programs in Haskell that do useful things than explain what they like about monads.<p>I can confidently advise against choosing to add to the list of IRC clients, window managers or greps, or stuff only Haskell coders use. A program that does something no other program does, as pandoc does, that is badly needed, as pandoc was, would be the best choice.<p>A second course would be to find ways to make Haskell code run fast without need to jump through hoops that corrupt the design of the program. (It might be that it is too late for Haskell to move in this direction.) There appears to be room in the world for slow languages (Python, PHP), so slowness is not deadly, but it does limit a language&#x27;s appeal. Haskell doesn&#x27;t need that. Prima facie, Haskell should not need to be slow.<p>A Haskell program that generates a program in (e.g.) LLVM IR to do a useful thing quickly would serve in lieu of an actually fast program. FFTW is a fast C library for evaluating FFTs generated by an OCaml program that does not need to be very fast.<p>FFTW relies for its speed on a cache-oblivious array traversal order (re-)invented[0] by Todd Veldhuizen for use in a C++ template library Blitz++ that, in effect, generates programs that perform matrix operations. In Veldhuizen&#x27;s library, the program was in (pretty slow) C++ template meta-language that ran during compilation of the user&#x27;s program, but by generating C++ in place it produced a fast program in one step.<p>A Haskell or descendant not dependent on GC could find use in places where present Haskell is not welcome today.<p>[0] Cache-oblivious traversal was, apparently, originally invented in the &#x27;70s to speed database operations where the the storage cached in main memory (&quot;core&quot;) was on disk and tapes, and was then mostly forgotten. It may be re-invented again, in another generation.')