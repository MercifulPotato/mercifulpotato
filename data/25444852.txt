Item(by='xyproto', descendants=None, kids=[25448901], score=None, time=1608137796, title=None, item_type='comment', url=None, parent=25441664, text='If you&#x27;re on Arch Linux, you can install the `lisp` package from AUR, then type `lispi` and then `(+ 1 2)` for adding 1 and 2. Don&#x27;t type in the backtick quotes. Press `ctrl-c` to quit.<p>If you install `clojure` you can start the interpreter with `clj` and also type in similar expressions, like:<p><pre><code>  (* 3 7)\n</code></pre>\nThere are a couple of differences to Common Lisp, though.<p>The fun thing about Lisp is that you can pass any number of parameters to functions, like &quot;+&quot;, so that expressions like this also works fine:<p><pre><code>  (* 1 2 3 4 5 6 7)\n</code></pre>\nThe next thing to know is that the first element within () is interpreted as the function, while the rest are interpreted as parameters. Then how do you represent a list like (1 2 3) without Lisp thinking that &quot;1&quot; is the function, you surely ask? You prefix it with &#x27;, like this: &#x27;(1 2 3). If you type &#x27;(1 2 3) into the `lispi` or `clj` prompt, they will print (1 2 3) right back at you.<p>A fundamental concept in Lisp is to get the first element of a list (the head) or the rest of the elements (the tail). For historical reasons the head is called CAR and the tail is called CDR in lisp. Everyone has just accepted that this is the way of Common Lisp by now. In Clojure, &quot;first&quot; and &quot;rest&quot; are used instead of CAR and CDR, as the heathens they are.<p>Since regular for loops are for wimps and snowflakes, iterating in traditional Lisp mainly centers around how to do the same thing using CAR, CDR and recursion.<p>Before we can do that, let&#x27;s define a function that adds 2 to the given number:<p><pre><code>  (defun addtwo (x) (+ x 2))\n</code></pre>\nNote that &quot;defun&quot; is the function for creating functions that takes, roughly speaking, three parameters: the function name, the function parameters and the function expression.<p>If you type it into &quot;lispi&quot; you can use the function afterwards, and get the result 42:<p><pre><code>  (addtwo 40)\n</code></pre>\nAlso, all lists in lisp are really just the head and the rest, so creating lists can be done by combining a head with the rest of a list, using cons, like this:<p><pre><code>  (cons 1 ())\n</code></pre>\nWhich is equivalent to this (but signifies that quoting was intended):<p><pre><code>  (cons 1 &#x27;())\n</code></pre>\nAnd this:<p><pre><code>  (cons 1 nil)\n</code></pre>\nAll three of the above expressions returns a list with one element (1), which means a head of 1 combined with an empty tail. Lists are constructed by appending heads to existing (or empty) tails.<p>Creating a function that takes apart a list into a head and a tail and then combines them again can be done like this:<p><pre><code>  (defun combine (xs) (cons (car xs) (cdr xs)))\n</code></pre>\n&quot;xs&quot; is the name of the function parameter, which is a list.<p>The combine function can be called like this:<p><pre><code>  (combine &#x27;(1 2 3))\n</code></pre>\nAnd will return:<p><pre><code>  (1 2 3)\n</code></pre>\nIf you wish to edit code in a file instead of interactively, where the arrow keys may not always work, try putting this in a file named &quot;main.lsp&quot;:<p><pre><code>  (defun hello ()\n    (write-line &quot;Hello, World!&quot;))\n</code></pre>\nThen run the desired function with:<p>lisp main.lsp hello<p>Now to create a for-loop replacement in Common Lisp, for people with hair under their arms, using CAR and CDR and recursion. This program will print each number in the given list, with an axe emoji after each number (HN removed it, please insert an appropriate unicode emoji instead of the x):<p><pre><code>  (defun lumberprint (n)\n    (write n)\n    (write-line &quot;x&quot;))\n  \n  (defun f (xs)\n    (unless (null xs)\n      (lumberprint (car xs))\n      (f (cdr xs))))\n  \n  (defun main ()\n    (f &#x27;(1 2 3)))\n</code></pre>\nSave as &quot;main.lsp&quot; and run with &quot;lisp main.lsp&quot;.<p>&quot;unless&quot; takes a condition and a list of statements. &quot;null&quot; checks if a list is empty. &quot;write&quot; outputs the given argument, but not a newline. &quot;write-line&quot; outputs the given argument and also a newline.<p>This should be enough to get you started. Then read SICP and draw the rest of the owl.<p>Best of luck!')