Item(by='59nadir', descendants=None, kids=None, score=None, time=1602663754, title=None, item_type='comment', url=None, parent=24769770, text='&gt; And how do other languages get away with it?<p>General purpose allocators are (basically) never the best for speed, fragmentation, and so on. They can at most be good enough. Basic knowledge about how your memory is going to be used that&#x27;ll inform the use of a few simple custom allocators is likely to give you several times the performance that you&#x27;d see with a general purpose allocator. In the best case you&#x27;ll literally reset an allocation pointer once per loop and just overwrite memory that you know isn&#x27;t used anymore, for example, making allocation a write into an already existing buffer and &quot;free&quot; the resetting of the pointer. This has nothing to do with platforms, but rather is just basic removal of dumb code that shouldn&#x27;t be running. There&#x27;s zero reason a an actual `free`&#x2F;`delete` should be used in those cases and using it is likely to slow down that loop considerably.<p>&gt; And how do other languages get away with it?<p>Much like general purpose allocators are never the best, there is zero evidence to suggest that garbage collection is ever the optimal choice; it can only ever be good enough. There&#x27;s also a lot of lore around garbage collectors being magic and doing lots of great things for you to ensure less fragmentation and nice cache locality but people are usually just amazed at how it&#x27;s &quot;not that bad&quot; in the end.<p>There&#x27;s no silver bullet: Garbage collectors and general purpose allocators aren&#x27;t magic pieces of code written by developers who can conjure up the best code for every use case. Like most general code they&#x27;re &quot;not bad&quot; at everything but not actually very good at anything. Running <i>less</i> code for your allocation and eliminating things based on your knowledge of how things are going to be used is always going to be better.')