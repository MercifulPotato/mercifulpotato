Item(by='dragontamer', descendants=None, kids=None, score=None, time=1606054819, title=None, item_type='comment', url=None, parent=25175687, text='<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependency_graph" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependency_graph</a><p><a href="https:&#x2F;&#x2F;www.threadingbuildingblocks.org&#x2F;docs&#x2F;help&#x2F;tbb_userguide&#x2F;Parallelizing_Flow_Graph.html" rel="nofollow">https:&#x2F;&#x2F;www.threadingbuildingblocks.org&#x2F;docs&#x2F;help&#x2F;tbb_usergu...</a><p>If you can imagine: there is a dependency graph of operations. Lets take a simple example:<p><pre><code>    1: mov rax, [someValueInMemory]\n    2: mov rbx, [OtherValue]\n    3: add rax, rbx\n    4: add rax, 5\n    5: add rax, 10\n</code></pre>\nThe above has the following dependency graph:<p><pre><code>    5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>\nNo instruction level parallelism is available at all. No modern CPU can parallelize it, if an 8-way decoder read all 5 instructions, it&#x27;d have to all go into the reorder buffer (but ultimately still execute sequentially).<p>Now lets cut some dependencies, and execute the following instead:<p><pre><code>    1: mov rax, [someValueInMemory]\n    2: mov rbx, [OtherValue]\n    3: add rax, 5\n    4: add rbx, 10\n    5: add rax, rbx\n</code></pre>\nThe graph is now the following:<p><pre><code>    5 -&gt; 4 -&gt; 2\n    5 -&gt; 3 -&gt; 1\n</code></pre>\nA modern CPU will decode all of the instructions rather quickly, and come up with the following plan:<p><pre><code>    ClockTick1: Execute 1 and 2\n    ClockTick2: Execute 3 and 4\n    ClockTick3: Execute 5\n</code></pre>\nThe dependency chain has been cut to only length 3, which means the 5-instructions can now execute in 3 clock cycles (instead of 5-cycles, like the original instructions).')