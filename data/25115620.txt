Item(by='kmill', descendants=None, kids=[25115900], score=None, time=1605553513, title=None, item_type='comment', url=None, parent=25112907, text='Sometimes the way I explain Mathematica to people is that, where Perl is the Perl of string rewriting, Mathematica is the Perl of tree rewriting.<p>Some comments about the article:<p>Mathematica has two types of rules, Rule and RuleDelayed, given by a -&gt; b and a :&gt; b.  You usually use RuleDelayed unless you want Mathematica to pre-evaluate b.  For example, if you create a rule like x_ -&gt; (Print[x]; 1 + x) it will immediately print the symbol x and then result in the rule x_ -&gt; 1 + x, but x_ :&gt; (Print[x]; x + 1) instead evaluates to itself without that side effect.<p>It might be worth knowing that $Assumptions has a dynamic scope construct (like fluid-let in scheme), where Assuming[a &gt; 0, ...] will temporarily append a &gt; 0 to $Assumptions.<p>The code for Diff is not correct, since it has patterns on the right-hand side of the rules (and also it&#x27;s Power, not Pow).  For idiomatic Mathematica, you would attach these rules to the Diff symbol itself as &quot;DownValues&quot; so that Mathematica will automatically apply them:<p><pre><code>  Diff[f_ g_, x_] := f Diff[g, x] + g Diff[f, x]; \n  Diff[f_ + g_, x_] := Diff[f, x] + Diff[g, x]; \n  Diff[Power[x_, n_Integer], x_] := n*Power[x, n - 1]; \n  Diff[n_?NumericQ, x_] := 0;\n</code></pre>\nThese := operators append a rule to DownValues[Diff], where the rule is exactly from replacing := with :&gt;.<p><pre><code>  In[14]:= DownValues[Diff]\n\n  Out[14]= {HoldPattern[Diff[f_ g_, x_]] :&gt; f Diff[g, x] + g Diff[f, x],\n            HoldPattern[Diff[f_ + g_, x_]] :&gt; Diff[f, x] + Diff[g, x], \n            HoldPattern[Diff[x_^n_Integer, x_]] :&gt; n x^(n - 1), \n            HoldPattern[Diff[n_?NumericQ, x_]] :&gt; 0}\n</code></pre>\nThe HoldPatterns in here are to prevent Mathematica from evaluating the patterns, since Diff has all these rules that really want to activate for those left-hand sides.  (Yes, patterns, too, are subject to evaluation.  It can be helpful in very limited circumstances, like metaprogramming the rules.)<p>It looks like it&#x27;s still missing some rules, though:<p><pre><code>  In[42]:= Diff[x^2 + 2 x + 1, x]\n\n  Out[42]= 2 x + 2 Diff[x, x]\n</code></pre>\nOne fix is to change the power rule to<p><pre><code>  Diff[Power[x_, n_Integer: 1], x_] := n*Power[x, n - 1]\n</code></pre>\nwhich gives n the default value of 1, plugging into a system where Mathematica knows x^1 and x are the same.<p>---<p>Something I use Mathematica for is calculations in things like the Temperley-Lieb algebra (for calculating the Jones polynomial of knots).  The Temperley-Lieb algebra is pretty much a calculus of path composition, but you also take formal linear combinations of these, and closed loops evaluate to some polynomial.  In the following, P[1, 2] would denote a path between points 1 and 2.<p><pre><code>  SetAttributes[P, Orderless];\n  P &#x2F;: P[a_, b_] P[b_, c_] := P[a, c];\n  P &#x2F;: P[a_, b_]^2 := P[a, a];\n  P &#x2F;: P[a_, a_] := -A^2 - A^-2;\n</code></pre>\nFor example, P[1, 2] P[2, 3] P[3, 1] evaluates to -A^2 - A^-2.  (I have a library for these things where the &quot;boxes&quot; it renders to in the Mathematica notebook is a graphical representation of the paths.  The graphical paths <i>are</i> the expressions, which has been very helpful to me.)')