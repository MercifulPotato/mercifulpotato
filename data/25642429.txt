Item(by='yakubin', descendants=None, kids=None, score=None, time=1609824255, title=None, item_type='comment', url=None, parent=25632836, text='<i>&gt; I have at times in the past made the (somewhat joking) observation that &quot;memory leak&quot; and &quot;unintentional liveness&quot; look very similar from afar, but are really quite different beasts.</i><p>Both situations prevent you from reusing memory previously used by other objects, which isn&#x27;t being utilized for anything useful at that point. The distinction is valid formally, but from a practical point of view sounds rather academic.<p><i>&gt; And to prove the difference between &quot;cannot be referenced&quot; (a property that can in principle be checked by consulting a snapshot of RAM at an instant in time) and &quot;will not be referenced&quot; (a larger set, we will never reference things that cannot be referenced, but we may not reference things that are reachable, depending on code) feels like it is requiring solving the halting problem.</i><p>As usual, looking for a general solution to such a problem is probably a fool&#x27;s errand. It&#x27;s much easier to write code simple enough that it&#x27;s obvious where things are referenced. Rust&#x27;s lifetime semantics help with that (if your code isn&#x27;t all that simple, it will be apparent in the overload of punctuation). If not Rust, then at least it would be good if you could check liveness of an object in a debugger. In C you can check whether a particular allocation was undone by a free() or equivalent. I&#x27;m not aware of any debugger for e.g. Java which would let me point at a variable and ask it to notify me when it&#x27;s garbage collected, but it sounds like something that shouldn&#x27;t be too hard to do, if the debugger is integrated with the compiler.')