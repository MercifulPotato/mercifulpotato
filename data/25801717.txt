Item(by='Tehnix', descendants=None, kids=None, score=None, time=1610798512, title=None, item_type='comment', url=None, parent=25800294, text='As both an IC and Manager, I&#x27;ve now been on a lot of teams using monoliths and teams using microservices, and I would always choose microservices going forward.<p>Let&#x27;s be straight, both have pros and cons, but I value the following pros of microservices a lot more than any of the cons:<p>- Enforces separations that are important for:\n- Maximum parallelization of work.\n- Scalability of each service. Never share database.\n- Reusability of the service from other services.<p>The trick is to learn how to cut microservices though. Establish an interface that it exposes, like GraphQL or RPC. Don&#x27;t try to split too fine-grained, but find a balance that works for you.<p>I promise you, when it comes to scalability, you&#x27;ll be glad you don&#x27;t have to scale one massive database just because one part of your application is seeing more activity.<p>This also allows you to pivot quicker to a different database  suddenly, or a different programming language, if requirements change. E.g. Node.js -&gt; Rust if your service is found to be on the hotpath of everything, and you need correctness and performance.<p>I fundamentally view the difference the same way I would choose Rust over Clojure:<p>- Monoliths: Rely on discipline of the team to do it right (like Clojure won&#x27;t catch your dynamic mistakes)\n- Microservices: The most important parts you need are built-in and enforced by the concept itself (like the Rust compiler guides you towards the correct approach).')