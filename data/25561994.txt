Item(by='comex', descendants=None, kids=None, score=None, time=1609181712, title=None, item_type='comment', url=None, parent=25561154, text='x86 isn’t performance competitive either if you’re targeting a CPU that doesn’t run it natively.  In fact, it’s much worse than WebAssembly.<p>Even Apple Rosetta takes roughly a 1.25x-1.50x hit on SPEC compared to native [1], and that’s with ahead-of-time compilation and no software sandboxing, whereas WebAssembly VMs typically use JIT compilation and do provide software sandboxing, both of which come with overhead.  In contrast, inNative [2] is a WebAssembly compiler that has ahead-of-time compilation and no software sandboxing, and it can supposedly reach 95% of native performance (no idea if the benchmarks are cherry-picked though).  This makes sense: WebAssembly is higher-level, closer to a compiler IR, whereas x86 assembly has already decided on low-level details (like register allocation and calling conventions) that are suboptimal to emulate on another architecture.<p>And other x86 emulators will do worse than Rosetta.  For one thing, Rosetta can take advantage of the Total Store Ordering mode added to M1 chips for the specific purpose of emulating x86 faster.  An emulator running on pretty much any other CPU has to emulate a stronger memory model in software on top of a weaker one, which comes with a <i>massive</i> unavoidable penalty for multithreaded workloads.  Also, most x86 emulators are just not as efficient as Rosetta, adding an additional penalty.<p>[1] <a href="https:&#x2F;&#x2F;www.anandtech.com&#x2F;show&#x2F;16252&#x2F;mac-mini-apple-m1-tested&#x2F;6" rel="nofollow">https:&#x2F;&#x2F;www.anandtech.com&#x2F;show&#x2F;16252&#x2F;mac-mini-apple-m1-teste...</a>\n[2] <a href="https:&#x2F;&#x2F;innative.dev&#x2F;news&#x2F;" rel="nofollow">https:&#x2F;&#x2F;innative.dev&#x2F;news&#x2F;</a>')