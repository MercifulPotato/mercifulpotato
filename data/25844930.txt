Item(by='celrod', descendants=None, kids=[25845599], score=None, time=1611140413, title=None, item_type='comment', url=None, parent=25844616, text='It&#x27;s related to 0-based indexing in that if you you want to take&#x2F;iterate over the first `N` elements, `0:N` works with 0-based indexing + close-open, but if you had 1-based and close-open, you&#x27;d need the awkward `1:N+1`.<p>This is why 1-based index languages normally use closed-closed intervals, so that they can use `1:N`.<p>I&#x27;m a die hard Julian (Julia is 1-based), but I do a lot of pointer arithmetic in my packages internally. I&#x27;ve come to prefer 0-based indexing, as it really is more natural there. 0-based plus close-open intervals are also nicer for partitioning an iteration space&#x2F;tiling loops, thanks to the fact the parent commented pointed out on the end of one iteration being the start of the next. This is a nice pattern for partitioning `N` into roughly block_size-sized blocks:<p><pre><code>  iters, rem = divrem(N, block_size)\n  start = 0\n  for i in [0,iters)\n    end = start + block_size + i &lt; rem\n    # operate on [start, end)\n    start = end\n  end\n</code></pre>\nBut that&#x27;s only slightly nicer. To translate this into 1-based indexing and closed-closed intervals, you&#x27;d just substitute the `# operate` line with<p><pre><code>    # operate on [start+1, end]\n</code></pre>\nthe `[0,iters)` with `[1:iters]`, and `i &lt; rem` with `i &lt;= rem`.<p>1- vs 0-based indexing is bike-shedding. A simple question we can all have opinions on that&#x27;s easy to argue about, when it really doesn&#x27;t matter much.<p>Julia uses 1-based indexing, but its pointer arithmetic is (obviously) 0-based, because pointer arithmetic != indexing. Adding 0 still adds 0, and adding 1 and `unsafe_load`ing will give me a different value than if I didn&#x27;t add anything at all. (This is just reemphasizing the final point made by the blog post.)')