Item(by='btschaegg', descendants=None, kids=[24674813], score=None, time=1601759321, title=None, item_type='comment', url=None, parent=24674510, text='No problem. Glad to be of any help :)<p>I&#x27;m sadly still not all that sure I understand you correctly (and I&#x27;m afraid I can&#x27;t tell you <i>exactly</i> what caused your issue), but:<p>If it is the commits that &quot;do the work&quot; that are duplicated (not the merges), I&#x27;d guess there already was someone (or some script&#x2F;tool) that already rewrote history a couple of times and not everybody was aware of that.<p>If your team didn&#x27;t look much at the history structure and try to actively shape it in a certain way, this could just have happened because someone did an innocent `git pull` after the history of the branch had been altered on the server.<p>`git pull` by default equates to `git fetch` and `git merge`, so if your history was altered, the branch would contain copies of the original commits (with totally new IDs), and git would &quot;knit&quot; the two copies together in a new merge. That means that this probably has happened around five times (since you see five copies of the oldest commits).<p>In this case, the hashes of the duplicated commits should be different. If that&#x27;s not the case, I&#x27;d guess you have a client that visualizes the history in a weird way and the problem is something else.<p>Cleaning this up might then be more cumbersome, since the points you&#x27;d need to &quot;adjust&quot; weren&#x27;t committed &quot;back to back&quot;. If you&#x27;re willing to do the work by hand, you could just string together intact pieces of the history into a clean one by using `git rebase` with `-r` and `--onto` (or `git cherry-pick`, but I&#x27;ve never used that one for complex topologies, so I don&#x27;t know how helpful it is there)...')