Item(by='rusk', descendants=None, kids=None, score=None, time=1605631751, title=None, item_type='comment', url=None, parent=25121416, text='Okay finally RTFA and I have this to say:<p>&gt; Oh, I just pushed a change. I really didn’t wanna push that, so how do I undo it?<p>It&#x27;s always possible to reset the head back one. You &quot;really shouldn&#x27;t&quot; because this will cause issues for anyone else downstream if they had already pulled, but this is an issue common to CVS, SVN and probably most other VCS. Arguably the Git approach is best because it actually provides a structured way to do it, and offers your downstreamers an escape hatch should they decide they don&#x27;t like what you&#x27;ve done. As somebody else pointed out, it&#x27;s like trying to unsend an email. I think you&#x27;ve more wiggle-room than with email though since there is a possibility to correct the record, somehow.<p>I&#x27;m not sure how you would do this better, a system of notifications perhaps but arguably this is something for the tools sitting atop git, and is actually &quot;made possible&quot; by git vs other VCS.<p>&gt; How do I delete a branch? &#x2F; Do you wanna delete a local branch &#x2F; delete the remote tracking branch &#x2F; Or delete the remote branch?<p>If they&#x27;re coming to you it&#x27;s almost certainly the remote branch, although the alternatives are so trivial they&#x27;re barely worth mentioning. Most people will approach learning something new in terms of what they already know, and if they&#x27;ve ever used version control software before they&#x27;re almost certainly thinking in terms of the old, centralised model.<p>&gt; A branch is just a single concept in our head that is made complicated<p>I would say it is &quot;clarified&quot; - just like we never needed to worry about quantum effects and the classical model of physics was fine, it does one no harm to update your mental model to accomodate these things when they come to light. In a distributed setting it absolutely makes sense to be more cognisant of the split realities of two nodes in a distributed system. [0]<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fallacies_of_distributed_computing" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fallacies_of_distributed_compu...</a><p>&gt; I have some changes. I wanna share it with Jon and Johnny so they can tell me what they think. And then maybe they can add their ideas. And then we can have a merging of our ideas, and eventually test out if it works, and have it out there and ship it.<p>There&#x27;s a couple of things wrong with this, but the most glaring is that there are many many ways to do this first of all, but secondly it&#x27;s not what git is for. It&#x27;s for version control. To the extent that it supports collaboration it&#x27;s still a version control tool. You can absolutely email your diffs, or put your code on a share, or do demos or exchange design documents but to me at least Git is an improvement on all of these.<p>&gt; But then when we come to physically typing out all those commands… suddenly we need months or sometimes even years of learning this set of tools to become proficient enough with them.<p>Nobody complains about the C compiler command line? You figure out what you want, and you embed it in a Makefile or something, or you learn the commands that you need to know to do 90% of your stuff.<p>&gt; I have really initially resisted the idea of graphical tools for Git, because I was this heavy terminal nerd; I was very much in my terminal bubble of being really proficient with a lot of these things,<p>Ah, here. Let&#x27;s be clear, while I think it&#x27;s important to maintain contact with the command line in these matters, you really, really need to have some good tools or you really are going to be in pain. C compiler analogy again: I can use an IDE to shield myself from these issues. The beauty of Git is it&#x27;s got such widespread support there&#x27;s so many great tools, and I honestly think you would be &quot;mad&quot; to pass them up.<p>&gt; I especially see it when somebody not from my background is approaching this.<p>Like who? Git is a tool for managing code. I think he might be driving at non-programmers who contribute to a project like graphic designers or people providing copy. Fair enough, but that&#x27;s an extension of the brief for software VCS which is primarily designed with managing and versioning text-based software ... it&#x27;s not, historically what they are for. Surely there is software for managing these kinds of assets?<p>&gt; I will get you to think about a directed graph or as \n&gt; No human thinks about that<p>I&#x27;d say a large amount of people on here think like that. All are human. But facile analysis aside, most people that use git don&#x27;t talk like that or describe what they&#x27;re doing like that. The &quot;chain of commits&quot; is a very useful mental model however.<p>&gt; I’m gonna save my work and I’m gonna share it with other people. Then I’m gonna step off this computer and just leave for the day.<p>Yes, you can zip it up and email as an attachment, or export it on Dropbox. But when you need to store your changes <i>&quot;on the record&quot;</i> it will need to go into a version control system at some point.<p>&gt; I feel that version control systems (the next version of them) should not be something that was specifically made for the Linux Kernel community<p>Literally any other existing version control software. Check out mercurial for something that approaches parity with git&#x27;s features [1], it was an early frontrunner but Git ran away with it globally. Nobody was forced to use it, it was just the better tool.<p>[1] <a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2010&#x2F;03&#x2F;17&#x2F;distributed-version-control-is-here-to-stay-baby&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2010&#x2F;03&#x2F;17&#x2F;distributed-versio...</a>')