Item(by='DannyB2', descendants=None, kids=[24801807, 24804758], score=None, time=1602861555, title=None, item_type='comment', url=None, parent=24800161, text='An economic argument for GC instead of ARC&#x2F;ORC.<p>Commercial web application in Java.  Java GC is concurrent, on other cpu cores than the cores processing customer requests.  Modern GCs such as Red Hat&#x27;s Shenandoah or Oracle&#x27;s ZGC have 1 ms or lower pause times on heap sizes of terabytes (TB).  Java 15 increased max heap size from 4 TB to 16 TB of memory.<p>Now the argument.  A thread running on a cpu core which processes an incoming request has to earn enough to pay the economic dollar cost of the other threads that do GC on other cpu cores.  But that thread processing the client request spends ZERO cpu cycles on memory management.  No reference counting.  Malloc is extremely fast as long as memory is available.  (GC on other cores ensures this.)  During or even after that thread has serviced a client request, GC will (later) &quot;dispose&quot; of the garbage that was allocated when servicing the client request.<p>Obviously, just from Java continuously occupying the top 2 or 3 spots for popularity over the last 15 years -- Java&#x27;s approach must be doing something right.<p>That said, I find Nim very interesting, and this is not a rant about Nim.  I am skeptical of an alternative to real GC until it is proven to work, in a heavily multi threaded environment.  And there is that economic argument of servicing client requests with no cpu cycles spent on memory management -- until AFTER the client request was fully serviced.')