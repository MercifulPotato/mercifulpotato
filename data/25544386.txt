Item(by='fsociety', descendants=None, kids=None, score=None, time=1609000218, title=None, item_type='comment', url=None, parent=25525981, text='Yes! Programs can be much more efficient with non-blocking operations and a scheduler. This doesn&#x27;t just benefit high performance web servers.<p>You gain some distinct advantages too by doing this, because you can then just run a single thread in your worker pool and if you ever need to make the program multi-threaded - god forbid - you can add locks to shared resources (or in Rust&#x27;s case the compiler will help you with this) and then bump up the number of threads.<p>CPUs are really really fast today, I think engineers generally underestimate the amount of performance you can get with a single-thread and non-blocking I&#x2F;O.<p>Async language constructs make this process a bit easier. The only issue IMO is that it is awkward to call async functions synchronously, or that it can have hidden costs to do so. I think languages will improve on this.<p>I believe on Linux, using non-blocking system calls on threads can help reduce expensive context switches too... whereas spawning multiple threads and having them use blocking system calls can cause more context switches.<p>I will say though.. I&#x27;ve seen developers just async-ify everything in codebases without thinking about why or if it is beneficial.')