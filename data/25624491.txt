Item(by='bmitc', descendants=None, kids=None, score=None, time=1609702944, title=None, item_type='comment', url=None, parent=25623661, text='Thanks for the link to Clojure&#x27;s polymorphism. I&#x27;ll need to read through it later and in more detail.<p>Isn&#x27;t the open&#x2F;closed principle more of an OOP design concept? In a statically typed language like F#, I <i>want</i> and expect to be notified what functions I need to update when I add a new type constructor to an existing type. This isn&#x27;t a problem and is welcomed. Just because one updates functions doesn&#x27;t make them brittle or inextensible. By only adding a new pattern matching branch, one is able to extend a function without affecting the other branches. However, this is getting into the statically typed nature of F#.<p>I think that link explains the expression problem rather superficially. It says you just need to add a new class, but neglects to mention that that also entails adding the new method overrides. So simply saying the OOP way is easy and functional programming is difficult when adding a new type is not really accurate. Same thing for adding a function in the functional programming paradigm, because it neglects you need to add a branch for all types. In reality, OOP inheritance and functional pattern matching are simply transposes of each other, and I&#x27;d argue that one is not really necessarily better or worse than the other. They&#x27;re simply different organizational methods of how the data and functions on the data are organized.')