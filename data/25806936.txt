Item(by='qayxc', descendants=None, kids=[25807130], score=None, time=1610843609, title=None, item_type='comment', url=None, parent=25806335, text='&gt; The software manufacturing industry could do with some more silicon sympathy.<p>These are still orthogonal concepts. First of all, it&#x27;s all about cost: if the operational costs of running a piece software over the lifetime of said software are significantly lower than the cost of optimisation, there&#x27;s nothing to be gained from doing the latter.<p>Developer time is more expensive than a faster CPU, additional RAM or slightly higher power usage. Back in the day, the iron was expensive and developer time was cheap. Today it&#x27;s the other way around, so saving on development time is more important than optimising for specific hardware.<p>Hardware-level optimisation becomes especially bogus if your deployment target is data centres - you often don&#x27;t even know the deployment target beforehand (could be an ARM CPU, could be an x86 CPU). With many modern SoCs (see the M1), it&#x27;s even impossible to optimise at that level, since you don&#x27;t even get the required hardware specs and simply using Apple&#x27;s libraries will get the best results.<p>So my argument still stands: there&#x27;s litte benefit <i>in general</i> from going into such detail. Feel free to disagree, but developments like the Go language, SoCs, and GPGPU compute seem to point another direction.<p>&gt; It is to learn how to build a computer.<p>And how does that translate to <i>actual</i> hardware then? Very poorly still. The fact is that unless you work with certain embedded systems, you <i>never</i> get close enough to the hardware to benefit from this.<p>This is time better spent on learning how to use your tools and to learn how to benchmark and optimise based on algorithms and data structures instead, because that&#x27;s where the inefficiencies start.<p>Besides, most programming languages are so far removed from the hardware, that there&#x27;s absolutely nothing you can do to optimise (JS, Python, Go, Java, C#, Haskell, LISP, etc.).')