Item(by='uryga', descendants=None, kids=None, score=None, time=1602764331, title=None, item_type='comment', url=None, parent=24782715, text='i actually think both Django and Tensorflow would benefit from macros. in both cases you spend a lot of time writing what&#x27;s really a DSL embedded into Python (defining models using a magic metaclass thingy &#x2F; defining computation graphs, basically writing ASTs by hand).<p>---<p>for another example, consider<p><pre><code>  Foo = namedtuple(&#x27;Foo&#x27;, [&#x27;a&#x27;, &#x27;b&#x27;])\n</code></pre>\nwhere the namedtuple function actually has to hack around the fact that <i>it&#x27;s not a macro</i>: <a href="https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;644e94272a89196801825cb69a56377bf62d256a&#x2F;Lib&#x2F;collections&#x2F;__init__.py#L498" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;644e94272a89196801825...</a><p>tldr: Foo needs to have<p><pre><code>  __module__ = &#x27;yourmodule&#x27;\n  __qualname__ = &#x27;yourmodule.Foo&#x27; \n</code></pre>\nor else stuff like Pickle won&#x27;t work right. so namedtuple has to <i>reach into the caller&#x27;s stackframe to see what module it was called from</i>! this wouldn&#x27;t be an issue if it was a macro and just expanded to a class definition.')