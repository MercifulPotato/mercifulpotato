Item(by='flohofwoe', descendants=None, kids=[24811490], score=None, time=1602941985, title=None, item_type='comment', url=None, parent=24809564, text='&gt; I think LLVM is too low level for accomplishing...<p>What I mean with &quot;LLVM for language interoperability&quot; is not using LLVM itself (although it could be part of the wider LLVM project), but the <i>idea</i> of LLVM. LLVM decoupled language frontends and code-generation backends by defining a common intermediate layer. Suddenly it was possible for individuals to create new languages that automatically run on all CPUs and ABIs supported by LLVM. What&#x27;s missing for those small new languages is the same effect for connecting those languages to all the other languages that already exist. Doing this for each other language is impossible for small teams. Doing this for a single common interface specification on the other hand is fairly trivial.<p>Such an &quot;hourglass shape&quot; would also make sense for language interoperability. But instead of having a common intermediate bytecode representation, have a common intermediate API-definition + ABI specification (somewhat similar to existing IDLs, but without a separate IDL-language that must be manually maintained, but instead automatically derived from the &quot;native&quot;-language interfaces.<p>Also, it doesn&#x27;t need nor should support all sorts of special language idioms, just a basic common set of &quot;interface features&quot;. It would be very close to what we already have with the C API&#x2F;ABI interoperability, just flavoured with additional annotations for some common higher-level concepts that languages have agreed on since C was invented (e.g. different types of references: unrestricted pointer, non-nullable pointer, ranged pointer, ownership annotations, etc...).<p>Once you have such a common set of annotations, languages can create <i>more</i> idiomatic (not <i>perfectly</i> idiomatic) API bindings automatically. It doesn&#x27;t have to be perfect, just an evolution of the current state (basically &quot;rich C-APIs&quot; instead of &quot;plain C-APIs&quot;). And plain old C would still be part of the language mix that&#x27;s supported, it would just ignore most of the high-level annotations.')