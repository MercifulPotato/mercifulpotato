Item(by='SideburnsOfDoom', descendants=None, kids=[24775276], score=None, time=1602665769, title=None, item_type='comment', url=None, parent=24774260, text='&gt;  Mocks work well because you can quickly define them in a given unit test and forget about it.<p>They do, yes. But:<p>* the mock syntax is complex and verbose. e.g. &quot;repo.Setup(x =&gt; x.Method(It.IsAny&lt;string&gt;(), It.IsAny&lt;List&lt;int&gt;&gt;())) .ReturnsAsync(() =&gt; ....&quot; is not the easiest syntax.<p>The syntax for a fake is just regular old &quot;class FakeFoo: IFoo&quot; with trivial method implementations and no library needed to make it work.<p>* the mock syntax does not scale. Your 5 lines of setup in one test does not help you in a different test class. So it gets repeated.<p>Soon you might find that the Fake is easier to read, easier to maintain, and fewer lines of code than all the mocks.<p>As the article says: &quot;their self-contained nature makes them reusable as well, which lends itself to better long-term maintainability.&quot; Not all our code is &quot;do it quickly and forget about it&quot;, especially where you see that same thing or minor variations of it done over and over again in related tests.<p>Mocks win here when you do something different, once only. Fakes win in the opposite cases.<p>&gt; I can see fakes being useful in certain cases,<p>This is true, but it&#x27;s also true that Fakes are _underused_ in general in in the .NET world. People reach for mocking frameworks as if they are the only tool.')