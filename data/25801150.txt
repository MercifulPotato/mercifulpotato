Item(by='pjmlp', descendants=None, kids=None, score=None, time=1610789025, title=None, item_type='comment', url=None, parent=25799499, text='If you already know any JVM or .NET language, the first step would be to understand the full stack, you don&#x27;t need C for that.<p>Many of us were doing systems programming with other languages before C went mainstream.<p>What you need to learn is computer architecture.<p>Getting back to JVM or .NET, you can get hold of JIT Watch, VS debug mode or play online in SharpLab.<p>Get to understand how some code gets translated into MSIL&#x2F;JVM, and how those bytecodes end up being converted into machine code.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;AdoptOpenJDK&#x2F;jitwatch&#x2F;wiki&#x2F;Screenshots" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;AdoptOpenJDK&#x2F;jitwatch&#x2F;wiki&#x2F;Screenshots</a><p><a href="https:&#x2F;&#x2F;sharplab.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sharplab.io&#x2F;</a><p>Languages like F# and C# allow you to leave the high level comfort and also do most of the stuff you would be doing in C.<p>Or just pick D, which provides the same comfort and goes even further in low level capabilities.<p>Use them to write a toy compiler, userspace driver, talking to GPIO pins in a PI, manipulating B-Tree data stuctures directly from inodes, a TCP&#x2F;IP userspace driver.<p>Not advocating not to learn Zig, do it still, the more languages one learns the better.<p>Only advocating what might be an easier transition path into learning about systems programming concepts.')