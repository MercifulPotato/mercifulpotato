Item(by='didibus', descendants=None, kids=[25557464], score=None, time=1609138283, title=None, item_type='comment', url=None, parent=25556958, text='User interactions would be modeled as a stream of events. And your functions would take that stream of events and return the rendered video player as it should be based on the given events.<p>There&#x27;s two way to do it. One that requires keeping the full history of events, and another which only requires keeping the next one (or next few) and the result of applying the last ones.<p>I&#x27;ll start with full history. You&#x27;d have something like:<p><pre><code>    defn button-icon(click-events):\n      if is-even(count(click-events))\n        return paused\n      else\n        return play\n</code></pre>\nWith this, when the program starts, click-events has nothing in it, so when we call button-icon with it, it returns paused, if the user clicks the button, we call button-icon again and now there is one click event in click-events, so we return play. If user clicks again, there are now two click events and so we return paused, and so on.<p>There is still state in the running program, something is remembering all clicks to the button, but your UI logic is pure.<p>Ok, now this is inefficient and requires lots of memory. Basically every new user action we recompute everything from the program start, and remember all prior actions. That&#x27;s why there&#x27;s the second approach. Instead we will do:<p><pre><code>    defn button-icon(current-button click-event):\n      if click-event\n        if (current-button = paused)\n          return play\n        else\n          return paused\n      else\n        return current-button\n</code></pre>\nNow the running program won&#x27;t remember the list of all click events from the program start, instead it&#x27;ll remember the last result from the last call to button-icon and it&#x27;ll pass that last result to button-icon the next time the user takes an action. This can be bootstrapped recursively or using fold.')