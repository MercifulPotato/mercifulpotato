Item(by='rswail', descendants=None, kids=[25343642], score=None, time=1607418691, title=None, item_type='comment', url=None, parent=25343281, text='&gt; The web request&#x2F;response model makes ACID pointless. The whole point of ACID is that if two users try to update something at the same time, you won&#x27;t lose either of their updates. No web app implements that: if user A loads the edit page and then user B loads the edit page and makes an edit, their update is going to be lost when A saves the page. (Or maybe the webapp implements its own locking, but it won&#x27;t - and can&#x27;t - use database transactions for it, because there&#x27;s no way to know whether the user is still editing or has closed the page).<p>That&#x27;s a problem that is solved by CRDTs and the like, not any form of data store. But it&#x27;s just one use of web frontends. Banking doesn&#x27;t use that, neither does a large chunk of the world&#x27;s applications.<p>&gt; Exactly! MySQL did none of the things that &quot;good&quot; databases do, and yet MySQL-based companies were far more successful. Conclusion: the things that &quot;good&quot; databases do aren&#x27;t actually that valuable.<p>Conclusion: Early web startups were successful, irrespective of what data store they had. Irrelevant to today&#x27;s internet. And judging on the wrong criteria. Companies weren&#x27;t &quot;MySQL-Based&quot;, their business model disintermediated and undercut existing models. Correlation is not causation. Companies that ran on SUN&#x2F;Solaris were successful as well.<p>SQL is not intended as a machine-to-machine interface, it&#x27;s a language for expressing relational queries. Prepared statements and caching remove that &quot;3x as long parsing&quot;<p>&gt; Application programmers know to make sure every thread obtains locks in the same order...<p>Evidence suggests the opposite, thus the need for things like Rust&#x27;s borrow checker. Studies have shown that programmers <i>can&#x27;t</i> work out what the race conditions and locking requirements are.<p>&gt; But SQL is a very poor interface, and datbase-level ACID is worse than useless in today&#x27;s (web-based) architectures.<p>SQL is a crap language, agreed. But your definition of &quot;web-based&quot; architectures seems to be picked to be the CRDT related stream of changes. Which, by the way, could be implemented in an RDBMS by writing the CRDTs as transactions and enforcing the ordering with the appropriate rollbacks and commits.')