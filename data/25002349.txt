Item(by='ywei3410', descendants=None, kids=[25003409], score=None, time=1604612685, title=None, item_type='comment', url=None, parent=25001137, text='Sure — for context I’m very comfortable with Haskell, Typescript, Java and Scala, fairly comfortable with Agda, Coq, C and Rust. I don’t prefer\nPython (the reasons of which I can elaborate, if you’re interested), but I do prefer to do my programming in Lisp-like dynamic languages — \neven when not using meta-programming.<p>The reason for this is quite simple. A static type-system, by design is meant to invalidate programs which are incorrect and accept the programs\nwhich are correct. All static type-systems which exist invalidate a certain number of programs which are correct — that is to say, you can\nwrite a perfectly valid program, but the type-system can reject it. What we term to be a more <i>expressive</i> type-system, is one which rejects\nmore programs. The line which one draws in the sand as expressive <i>enough</i> is completely arbitrary and the type-systems we have currently\nheavily rely on the user constructing their programs in a certain way, so the type-system can prove certain properties about it.<p>Here’s an example demonstrating what I mean. Consider a theoretical language which uses <i>:</i> as the type-ascription, \nhas generics&#x2F;kinds and all functions are total. A code-snippet taking the head of a list might look like this:<p>&gt; let num: Option&lt;Number&gt; = head(numberList)<p>Note that the return type of the head will be <i>Option&lt;A&gt;</i>, if the function is total because the list can be empty. Now suppose I have the snippet —\nlocally I can reason that the type of <i>num</i> should be <i>Number</i>  — but I need to prove that to the type-system. In most current type-systems, proving\nthis requires you restructure your code in a particular way.<p>&gt; let numberList = prependList(4, previousList)<p>&gt; let sortedList = sortList(numberList)<p>&gt; let num = head(sortedList)<p>What I’m trying to drive at is that static type-systems are a spectrum and at some point you <i>will</i> run into a case which you’ll either\nneed to use an escape-hatch or restructure your code in a non-trivial way to satisfy the compiler. The boundary of what you determine\nto be correct is also completely arbitrary — you can <i>always</i> encode more properties and restrict your code further; how far you\ngo is ultimately determined by you.')