Item(by='tptacek', descendants=None, kids=None, score=None, time=1607670503, title=None, item_type='comment', url=None, parent=25382508, text='At some point, in most designs, you&#x27;re going to end up with a client and server service where the server does something on behalf of a user. The identities in this design now include [client-identity, server-identity, user-identity].<p>I&#x27;ll stipulate to mTLS resolving client-identity and server-identity. But the client is making requests of the server that pertain to a user. The certificate doesn&#x27;t (and can&#x27;t) attest to a user.<p>In most designs I&#x27;ve actually evaluated, what ends up happening is that the server just trusts the user provided by the client, and the client tries hard not to ask for things for the wrong user. But beyond whether the client has authorized every code path that generates a request, you have an additional problem here, because even after the client authorizes a path that generates a request, a bug in the client can give an attacker influence over the request itself. The server has no way of distinguishing between a corrupted request and a real request, even though you&#x27;re relying on a secure channel.<p>Authenticated requests mitigate this problem: an attacker might be able to corrupt a request, but it&#x27;s not enough to corrupt it; you need to know whatever secret authenticates the request itself.<p>To do this right, you now need two authentication schemes in play: one for the secure channel, and one for the requests themselves. But if you can reliably authenticate requests, why are we rigorously authenticating the secure channel? We&#x27;re spending complexity chits to buy only marginal extra security.<p>I think it can make some sense to mesh up services with mTLS as a &quot;you must be this high to get on the ride&quot; mechanism. But since that&#x27;s all it&#x27;s doing, we don&#x27;t need a lot of complicated mechanism to give precisely the right certificates to services, because even if something gets screwed up, request authentication, not secure channel authentication, should be what&#x27;s protecting your application.<p>Especially when we think about short-lived certificates and ACME and rollover: what is this really buying us in a strong system with request authentication? A WebPKI ACME certificate will live for 90 days. If certificates matter to our design, <i>we can&#x27;t let a compromised cert live for 90 days</i>. Our certificate lifespans have to be much shorter --- the duration in which we&#x27;d be OK having a compromised credential still viable for an attacker. Remember the differing consequences between a WebPKI certificate compromise and an internal credential compromise: one is a second-order flaw that lets attackers with some other vulnerability MITM a subset of users; the other is a game-over flaw. How long would you let a compromised developer prod SSH key live?<p>So now we&#x27;re talking about very short-lived certificates, and you can see, this is a design that spends all the complexity chits asymmetric encryption costs, but is asymptotically approaching the operational resiliency of Kerberos. Yikes.<p>The WebPKI has to assume certificates might be compromised because there are 18 zillion different ways people might mishandle a certificate. But that&#x27;s not at all true for a data center deployment of a microservice ensemble! Certificate keys are as secure in our system as the microservice itself is. If you lose one to an attacker, you lost the microservice too --- even if you rotate the cred, whatever flaw gave the attacker that certificate is just going to give the attacker the next one, too. If you stop trusting a certificate (and, by extension, the instance it was resident on), you zap the whole instance, <i>revoke</i>, and root-cause the flaw that caused the problem. Rotation just isn&#x27;t winning you much.<p>At bottom the issue here is that the WebPKI has a very particular threat model, and it&#x27;s a shitty threat model, and we have built lots of tools for that threat model, and many of them are by necessity shitty because we live in a fallen world. But your microservice ensemble wasn&#x27;t born with original sin! You don&#x27;t need to inherit the complexities (e.g. X.509) and limitations (e.g. X.509 revocation) that the WebPKI has to deal with. Which is a reason some people get itchy when we talk about importing WebPKI technology to things like K8s.<p>I tend to be pretty chill about little islands of mTLS, like &quot;all the Consul clients need a cert&quot;. That, to me, solves a practical problem. I am way less chill about attempts to create coherent PKI namespaces for all the components of an app, tied together with mTLS.<p>People should use Macaroons!')