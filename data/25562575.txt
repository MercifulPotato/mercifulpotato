Item(by='wott', descendants=None, kids=None, score=None, time=1609185364, title=None, item_type='comment', url=None, parent=25560119, text='&gt; Might be a little off topic, but what’s with the ”written in” obsession? From my perspective it’s so irrelevant compared to well tested, design, architectured, community engagement, track record, performance and usability.<p>As far as I am concerned there is one aspect where I think it is relevant for me, as I compile all software that runs on my machine. If it written in C or in C++, there are good chances that I won&#x27;t need to compile an horrible chain of dependencies (or most likely, try and fail at compile that chain).<p>That matters to me, because I try a lot of alternative&#x2F;niche&#x2F;toy languages, and if I consider those published within, say, the last ten years, half of them won&#x27;t even compile. It is a disaster. If it is written in shell + C, I can fix a couple errors easily (if there are more I give up because there is no point in wasting my time on something that claims to be next programming marvel and yet is itself programmed like shit). People want to be fancy and pick up toolchains that are not battle-tested like Autotools+C or CMake+C++, and that&#x27;s the recipe for pain.<p>For example, today I tried to compile two languages written in Ada, and I had to give up. A mess. Each time I tried to build an Ada project which wasn&#x27;t mine, it has been horrible. That&#x27;s antinomic to the image of Ada (clean and strict to the point of being stiff) but that&#x27;s my repeated experience with <i>building</i>.<p>I am not even talking about the anti-feature which is compilers which are written in the very language they aim to compile and do not even provide a bootstrapping minimal compiler written in C or similarly fundamental and widespread language. They&#x27;re generally very proud of their accomplishment :-&#x2F;<p>So yes, a project in C (or C++) offers the best chances of success (for building, which is the point I developed here).<p>Also, considering toy language, I often want to make a dirty hack to add a missing features. If it is written, say, in Haskell, there is zero chance I can do it. Good old imperative languages like C, Python, Pascal, I have a chance and I have already done it.<p>There is also the case of all the languages built over the JVM. There are really many. But even when they look good to me, they are limited by the opinionated choices of the JVM, and I don&#x27;t wanna undergo the multiple programming neuroses of Gosling. Also anything Java based has always been terribly, awfully, painfully, excruciatingly slow on any of my machines; I suppose it not an universal experience, but it has <i>always</i> been mine.<p>------<p>&gt; compared to well tested, design, architectured, community engagement, track record, performance and usability.<p>To each is own: I care about well tested, usability, and depending on the intended use, performance. I also care <i>a lot</i> about proper exhaustive documentation, which is missing from your list and from most programming languages projects.<p>But I don&#x27;t give a damn about its design and architecture, what matters to me is the external features, not the internals. Language designers care way too much about the internals and neglect the outside, which is what matters to the end user. I don&#x27;t care if it make your parser more complicated, it if makes your grammar irregular, if you need more passes, if you need to dirty your hands with context; I want that source code using your language <i>flows</i>, for writing and for reading.<p>Community? I don&#x27;t really care, and I have seen it being detrimental to many projects, which lose their compass by wanting to incorporate every feature request and following the mood of the year; I&#x27;d rather they were developed between closed doors and only published when they reach beta status, to maintain consistency, instead of jumping from an unpolished feature to the next. I am aware that&#x27;s totally against the current trend, where people publish repositories with a README.md before writing the first line of code or documentation :-)')