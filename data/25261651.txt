Item(by='Geminidog', descendants=None, kids=[25264655], score=None, time=1606790100, title=None, item_type='comment', url=None, parent=25259574, text='The analogy I&#x27;m using is too big. It&#x27;s actually a famous quotation but it kind of blinds you to the fundamental issue.<p>Let me put it with a very primitive example.<p><pre><code>   class Jungle:\n      int bananas;\n      int gorrilas;\n\n      removeBananaFromJungle():\n         banana -= 1;\n\n</code></pre>\nLiterally the example above is the most fundamental example of a class you can write. A class with a method that operates on a member variable. You can&#x27;t get any simpler than this. There&#x27;s no alterative pattern here; this isn&#x27;t some overly complex example you can fix with a pattern. This is objects 101, one of the simplest entities in OOP you can ever define and the problem remains:<p>I want a banana but I must initialize the jungle and the gorilla in order to remove a banana.<p>It seems like a good organization scheme because the banana and gorilla live in the jungle. But this is the issue with OOP. We can&#x27;t predict the future and we can&#x27;t predict how requirements will change or the perfect design.<p>So really the best way to program is to assume nothing. Don&#x27;t assume either the gorilla or the banana are in the jungle:<p><pre><code>  int gorrila = ...\n  int banana = ...\n  map&lt;string, int&amp;&gt; jungleStuff = ...\n\n  haveTheGorillaThrowABananaOutOfTheJungle(gorilla, banana, jungleStuff)\n</code></pre>\nWhat if one day I&#x27;m called as a programmer to write a program about Gorillas on the Space station?<p>With the OOP version I have to create the jungle and the banana just to get the gorilla onto the space station. With the regular procedural version I do not. Basically 99% of accidental technical debt is the result of unintended groupings of logic and data promoted by the OOP pattern because people assume gorillas live in the jungle and they can never account for the fact that one day they will be on the space station.<p>I&#x27;m sure you can come up with some crazy OOP pattern that can account for both the regular Jungle case and the SpaceStation... but what if I start throwing all kinds of crazy requirements at you?<p>The spacestation now has to account for Ostritches, Gorillas can now live with ostriches in a house.... anything you can think of I will try to break your design with a new requirement (within reason) until you come up with a set of entities that can anticipate anything...\nYou&#x27;ll find more and more that your classes will become smaller and smaller until basically you have an OOP pattern that can anticipate any requirement I throw at you:<p><pre><code>  class Gorrilla\n    int gorrilas\n\n  class Banana\n    int Bananas\n\n  class Jungle\n    map&lt;string, int&gt; stuffInTheJungle\n\n  class SpaceStation\n    map&lt;string, int&gt; stuffInTheSpaceStation\n\n  class House\n    map&lt;string, int&gt; stuffInTheHouse\n\n  class Ostrich:\n    int ostriches   \n</code></pre>\nWhich is basically equivalent to this:<p><pre><code>    int gorrilas\n    int Bananas\n    map&lt;string, int&gt; stuffInTheJungle\n    map&lt;string, int&gt; stuffInTheSpaceStation\n    map&lt;string, int&gt; stuffInTheHouse\n    int ostriches\n</code></pre>\nIn short, any grouping of logic and variables through the use of free variables or classes reduces the modularity and flexibility of your program pointlessly. There is no reason why you should group logic together and you can never anticipate the future where your grouping will be found to be incorrect. To counter this problem you need to make your groupings smaller and smaller until each class holds one thing. A class that holds one thing is pointless, it&#x27;s the same as just that thing itself without a class wrapped around it.')