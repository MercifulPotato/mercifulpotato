Item(by='tptacek', descendants=None, kids=None, score=None, time=1609016512, title=None, item_type='comment', url=None, parent=25546389, text='This is so great.<p>Assume this fact pattern: an interactive client-server cryptosystem where messages are encrypted under keys derived from passwords, AND (1) the server will reveal whether decryption of a trial message succeeded (super common!) AND (2) the encryption scheme is &quot;non-committing&quot;, meaning roughly that the output of the encryption construction doesn&#x27;t encode the specific key used (this is the norm for mainstream ciphers).<p>Well, now you have a problem. If you can create a message that decrypts properly under 2 different (password-derived) keys, you can &quot;guess&quot; two passwords per query to the system; that&#x27;s obvious. But you&#x27;re not limited to 2. For instance, AES-GCM, the most popular AEAD in the industry, isn&#x27;t key-committing, and you can with a laptop and SageMath create a ciphertext that encrypts validly under (wait for it) 200k different known keys, by solving a system of linear equations. (It&#x27;s about 4M long).<p>In a sort of general attack setting, you can already see how this is going to work: you can iterate over messages that guess 200k passwords at a time. When you get a hit, you do a search, partitioning and re-partitioning the space of possible passwords until you discover the right one.<p>The paper uses this approach to break the Shadowsocks circumvention proxy, which uses GCM, and where condition (1) is met because successful serverside decryption opens a listening UDP socket for 5 minutes that you can just scan for.')