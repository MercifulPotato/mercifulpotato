Item(by='Jweb_Guru', descendants=None, kids=[24793007], score=None, time=1602788778, title=None, item_type='comment', url=None, parent=24792111, text='void is the unit type, which has a single inhabitant, so those functions have a codomain; you can think of the unit type as the set containing the empty set.  Sure, you don&#x27;t explicitly write a return statement in C for `void` functions, but as long as the function still terminates, it can still be thought of as producing a value.  Admittedly, not a very useful one, since all having a value of type void tells you is that whatever function produced it completed, but that mostly reflects the fact that `void` functions generally do other non-functional stuff; there&#x27;s nothing inherently wrong with returning or having such a value, and it can be quite useful for generic code.  For example, a map from keys to unit can be used to implement a set &quot;for free.&quot;<p>Even in non-generic, purely functional code, the unit type is still useful--as the <i>domain</i> for a constant function!  In most C-like languages, this is of course just represented by a function that takes no arguments, but type theoretically it&#x27;s equivalent to taking a single void argument (or any number of void arguments, of course, since the Cartesian product of two sets with one inhabitant produces another set with one inhabitant).  In strict functional languages that insist that everything has a type, you will often use this encoding explicitly, to implement thunks (call-by-name evaluation).<p>In partial languages (aka every language you&#x27;re likely to practically use) or total languages which have the principle of explosion (which covers most of the remaining languages in existence), there is also the bottom type (the empty set) which has no inhabitants; this represents falsity or impossibility, which is computationally meaningful as a (perhaps not terribly informative) type for programs that can&#x27;t return a value; for instance, nonterminating ones, or ones that always throw an exception.  However, since in general you shouldn&#x27;t be able to produce a closed value of that type, it can usually be freely cast to any other type you want, so many languages lack explicit syntax for it.<p>That said, it can still be convenient at times to have a way of explicitly talking about the empty type; for example, in Rust (behind a feature flag currently), if you use a sum type where all but one of the variants includes the bottom type `!`, the compiler will recognize that only one variant is possible, and allow you to directly extract data from the inhabited variant (and can optimize out the tag, or at least that&#x27;s the intent).  This is useful when writing generic code that has to implement an API that returns (for instance) a `Result&lt;T, E&gt;`, but your implementation doesn&#x27;t have an \nerror condition; in such cases, you can set `E = !`.<p>In total, dependently typed languages with the principle of explosion (which are certainly functional!), the type is also useful for another reason; a function from A to False is the equivalent (constructively anyway) of the negation of A, `~A`.  Therefore, False  ends up getting used quite a lot in type-level expressions, for the same reason as tests against the empty set occur a lot in set theory; even though strictly speaking you shouldn&#x27;t be able to produce a closed value of type False (or else you should file a bug), when you&#x27;re doing proofs by contradiction you can end up with one due to some false assumption in your context (which you can immediately use to prove that anything you wish derives from that context; this can be particularly useful to discharge impossible arms of pattern match expressions).  This also happens implicitly in languages that perform flow-sensitive analysis of pattern match expressions; if they detect that one arm never returns (e.g. because it throws an exception or runs a loop that clearly doesn&#x27;t terminate) they can implicitly assign it the bottom type, which can then be automatically cast to the type of the full expression.<p>In short: not only are function types with void (and even empty!) domain and codomain functional, they are actually remarkably useful :)  In fact, they are <i>so</i> fundamental, that almost all of (standard) dependent type theory can be constructed from just three base types: the empty type, the unit type, and bool!  It&#x27;s a bit unfortunate that two of these three fundamental types don&#x27;t have direct syntax in a lot of languages, but as you can see this is mostly because they are <i>so</i> ubiquitous that they are largely hidden within other language features.')