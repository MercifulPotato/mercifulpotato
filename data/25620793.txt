Item(by='pron', descendants=None, kids=[25621336, 25621977], score=None, time=1609667676, title=None, item_type='comment', url=None, parent=25619879, text='Consider the domain Zig targets -- low-level programming -- and other languages targeting it: C, C++, Ada and Rust. The first is very simple but severely lacks in both expressive power and safety, and the other three would all easily make any list of the top five most complex programming languages in the history of software; they&#x27;re byzantine temples for those who worship at the altar of accidental complexity.<p>Zig offers a radical design. It seeks to be as simple as C — which is particularly important in low-level programming for both portability [1] and humans and machine analysis — while also giving you safety and high expressivity. Obviously, radical design means doing things differently.<p>Zig rejects any kind of implicitness; all calls must appear as calls. This means no operator overloading, no destructors, and no magical traits. It does so, however, without giving up on expressivity by using other mechanisms.<p>All low-level programming languages suffer from low abstraction. That comes with the territory. By that I mean that implementation details (especially around memory management) are hard to hide. Changing those details in some component often require changing the clients of that component as well. But C++ and Rust have a design philosophy that tries to hide this intrinsic quality of low-level programming by making the final code appear on the page <i>as if</i> it has abstraction capabilities similar to high-level languages. Of course, that illusion breaks as soon as you try to <i>change</i> code, and it&#x27;s debatable whether this design helps or harms program comprehension. Zig rejects the C++ philosophy in favour of a brand new, and pretty revolutionary one, that reimagines how low-level programming is done. Unlike Rust, Zig isn&#x27;t a cleaned-up C++ with a few extra tricks, but it isn&#x27;t a new C, either. It&#x27;s something completely different.<p>You might prefer Zig&#x27;s design for this domain (as I do) or you might prefer the more traditional C++ design, but the great thing is that Zig is so simple and easy to learn that it&#x27;s easy to try and find out.<p>[1]: Consider what it would take to port C++ (or a C++-like language) to new microcontroller you build. You would either need to port LLVM or an extremely complex compiler — a huge undertaking. This is why C (well, there&#x27;s a tiny bit of Ada, too) still reigns supreme even in domains where correctness is of utmost importance: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;uqan23518Yc?t=632" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;uqan23518Yc?t=632</a>')