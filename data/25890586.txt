Item(by='Kwantuum', descendants=None, kids=None, score=None, time=1611480130, title=None, item_type='comment', url=None, parent=25889362, text='In javascript it&#x27;s pretty easy to write a function for partial application in either order, you can curry functions forward or backward.<p><pre><code>    const map = (arr, mapper) =&gt; arr.map(mapper); &#x2F;&#x2F; Non &quot;traditional&quot; order for arguments\n    const curry = f =&gt; (...first) =&gt; (...second) =&gt; f(...first, ...second); &#x2F;&#x2F; Classic currying: partially apply arguments to the start\n    const reverseCurry = f =&gt; (...second) =&gt; (...first) =&gt; f(...first, ...second); &#x2F;&#x2F; You might want to reverse() first and second depending on the desired syntax\n    const arrayMapper = curry(map)(array); &#x2F;&#x2F; Usually not that useful, more common to map over many arrays with the same function than to map over the same array with many functions\n    const funcMapper = reverseCurry(map)(func); &#x2F;&#x2F; Same benefits as having the classic argument order in the first place\n</code></pre>\nIf you&#x27;re working in a code base that doesn&#x27;t already implement &quot;most specific argument last&quot;, or does so inconsistently, it&#x27;s very easy to write partial application functions for both cases. If your functions aren&#x27;t variadic you can even get over the clunky double call syntax by checking the total number of arguments passed thus far, and if it&#x27;s greater than or equal to the function&#x27;s &quot;length&quot; (the number of named arguments that it takes) call it, otherwise return the partially applied function, something that is sometimes known as &quot;autocurry&quot;.')