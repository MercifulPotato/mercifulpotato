Item(by='jacques_chester', descendants=None, kids=[25280345, 25285119, 25280838, 25280892], score=None, time=1606936618, title=None, item_type='comment', url=None, parent=25280086, text='Loosely, my understanding Kubernetes works like this:<p>You have a Pod definition, which is basically a gang of containers. In that Pod definition you have included one or more container image references.<p>You send the Pod definition to the API Server.<p>The API Server informs listeners for Pod updates that there is a new Pod definition. One of these listeners is the scheduler, which decides which Node should get the Pod. It creates an update for the Pod&#x27;s &quot;status&quot;, essentially annotating it with the name of the Node that should run the Pod.<p>Each Node has a &quot;kubelet&quot;. These too subscribe to Pod definitions. When a change shows up saying &quot;Pod &#x27;foo&#x27; should run on Node 27&quot;, the kubelet in Node 27 perks up its ears.<p>The kubelet converts the Pod definition into descriptions of containers -- image reference, RAM limits, which disks to attach etc. It then turns to its container runtime through the &quot;Container Runtime Interface&quot; (CRI). In the early days this was a Docker daemon.<p>The container runtime now acts on the descriptions it got. Most notably, it will check to see if it has an image in its local cache; if it doesn&#x27;t then it will try to pull that image from a registry.<p>Now: The <i>CRI is distinct from the Docker daemon API</i>. The CRI is abstracted because since the Docker daemon days, other alternatives have emerged (and some have withered), such as rkt, podman and containerd.<p>This update says &quot;we are not going to maintain the Docker daemon option for CRI&quot;. You can use containerd. From a Kubernetes end-user perspective, nothing should change. From an operator perspective, all that happens is that you have a smaller footprint with less attack surface.')