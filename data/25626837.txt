Item(by='throwaway894345', descendants=None, kids=[25626889], score=None, time=1609721649, title=None, item_type='comment', url=None, parent=25626485, text='&gt; The optimal point on the tradeoff between developer velocity and performance&#x2F;correctness depends a lot on the domain<p>Agreed. This is what I was alluding to by &quot;many applications absolutely index on developer velocity and performance&quot;. Note that it&#x27;s even a bit more nuanced--within an application there are bits that are more sensitive than others. For example, the UI widgets are typically much less sensitive than the security, data privacy, and data integrity bits. Even still, I haven&#x27;t noticed a frenzied rewriting of these systems from Go&#x2F;C#&#x2F;Java&#x2F;etc into Rust, and I&#x27;m willing to bet that there&#x27;s a fair amount of this kind of code implemented in JavaScript or Python.<p>&gt; How much usage do you expect to have? The more usage, the more important performance and correctness are.<p>True, but this is a very low-value concern. Notably, hugely popular apps like Reddit can break altogether on a nearly daily basis (never mind more minor bugs, like some UI widget breaking) and they&#x27;re still content to write in a completely dynamic language.<p>&gt; How critical is your application? The more critical it is, the more important correctness is.<p>I think this is a much more important driver than usage, but relatively little software is so critical. As previously mentioned, there&#x27;s lots of software that governs privacy and security systems that isn&#x27;t being frenzily rewritten in Rust. Even OpenSSL, an application in which correctness is far more important than velocity, isn&#x27;t considering a rewrite to Rust <i>despite that it&#x27;s written in a language with worse static verifiability than the Go&#x2F;C#&#x2F;Java tier</i>. This is probably the kind of application that I would want to see in Rust--it&#x27;s very sensitive to performance <i>and</i> correctness; which is to say, I think OpenSSL is very near the boundary at which writing in Rust makes economic sense (something that is very stable and very sensitive to correctness and performance). It&#x27;s almost certainly not your web services.<p>&gt; Also, the argument that you can spend developer time to increase correctness just by writing more tests works up to a point, but then it doesn&#x27;t, because of diminishing returns. With Rust you can eliminate certain entire classes of bugs which tests will never reach.<p>Yeah, sorry, my brain was thinking one thing and my fingers typed another. I should have said &quot;writing additional tests would recoup a bit <i>less</i> than the additional 4% that Rust would get you&quot;; instead I typed &quot;more&quot;. I missed the edit window, so I can&#x27;t update my post.')