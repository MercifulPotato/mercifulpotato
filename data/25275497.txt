Item(by='KMag', descendants=None, kids=None, score=None, time=1606909307, title=None, item_type='comment', url=None, parent=25274913, text='There&#x27;s nothing stopping CPython from using a threaded interpreter, though doing it in C requires a compiler supporting GCC&#x27;s nonstandard labels-as-values[0]&#x2F;computed goto and undefined behavior (using goto to jump across functions).<p>Threaded code is a pretty standard implementation strategy for some languages (notably Forth), and my understanding it was even a pretty common compiler implementation strategy in the 1970s&#x2F; early 1980s.  It&#x27;s a pretty easy optimization, particularly for a stack-based VM or a VM with a small number of registers.<p>The main downside is memory usage, as Python bytecode can be memory-mapped directly from disk and therefore shared across processes and discarded by the OS under memory pressure rather than being written out to swap.  There&#x27;s obviously a bit of startup overhead at class load time.<p>Though, I&#x27;m a bit surprised that most stack-based interpreters don&#x27;t initially load classes with functions implemented as a dead-simple threaded implementation consisting of a pointer to the start of a regular bytecode interpreter and a pointer into a memory-mapped buffer of the on-disk bytecode.  Based on performance counters, they could JIT the hotspots into regular threaded code.<p>[0] <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Labels-as-Values.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Labels-as-Values.html</a>')