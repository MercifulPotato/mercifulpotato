Item(by='naniwaduni', descendants=None, kids=[25895523], score=None, time=1611516247, title=None, item_type='comment', url=None, parent=25894562, text='Let me rephrase. Codepoints are even less useful than abstract glyphs, cf. <a href="https:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2017&#x2F;01&#x2F;14&#x2F;stop-ascribing-meaning-to-unicode-code-points&#x2F;" rel="nofollow">https:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2017&#x2F;01&#x2F;14&#x2F;stop-ascribing...</a> (I don&#x27;t agree 100% with the write-up, and in particular I would say that working on EGCs is <i>still</i> just punting the problem one more layer without resolving it; see some of my other posts in this thread. But it makes an attempt at clarifying the issue here.)<p>The choice of the bytes view specifically is just that it&#x27;s the most popular view from which you can achieve one specific primitive: figuring out how much space a (sub)string occupies in whatever representation you store it in. A byte length achieves this. Of course, a length in bits or in utf-32 code units <i>also achieves this</i>, but I&#x27;ve found it rather uncommon to use utf-32 as a transfer encoding. So we need at least one string type with this property.<p>Other than this one particular niche, a codepoint view doesn&#x27;t do much <i>worse</i> at most tasks. But it adds a layer of complexity while also not actually solving any of the problems you&#x27;d want it to. In fact, it papers over many of them, making it less obvious that the problems <i>are still there</i> to a team of eurocentric developers ... up until emoji suddenly become popular.<p>Now, I can understand the <i>appeal</i> of making your immediate problems vanish and leaving it for your successors, but I hope we can agree that it&#x27;s not in good taste.')