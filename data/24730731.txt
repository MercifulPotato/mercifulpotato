Item(by='Tarrosion', descendants=None, kids=[24733770], score=None, time=1602256910, title=None, item_type='comment', url=None, parent=24729034, text='I quite liked this article, but both the article and the comments here mostly skip over my absolute favorite Julia feature: because Julia is fast end-to-end, you can code in the style that naturally matches your use case and mental models without sacrificing performance. Functional patterns and imperative patterns, vector-based or element-by-element, your types or built-in: they all work well and run quickly!<p>I do most of my programming in Julia and Python. Python libraries like numpy and pandas are fast and efficientâ€”if you&#x27;re staying &quot;within the lines&quot; of how the library is designed to work. And most of the time this is okay! But not irregularly I want to do array operations on arrays of user-defined types, or I want to walk through a dataframe row by row without paying a huge performance penalty, etc. And all the sudden the well-tuned Python ecosystem feels very restrictive.<p>In Julia, my workflow is roughly: 1) think about the problem. 2) Code an intuitive solution. 3) If necessary, tweak a little bit of code to improve performance by reducing allocations or type instability.<p>That&#x27;s a lot less mental work than my Python&#x2F;Matlab&#x2F;Java workflow of 1) think about the problem. 2) Think about how the solution can be expressed in the paradigm the language supports performance with. 3) Write a solution in this particular paradigm. 4) Tune for performance, which may be awkward if the initial solution was not intuitive.')