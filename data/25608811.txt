Item(by='sixdimensional', descendants=None, kids=[25611729, 25609164], score=None, time=1609546601, title=None, item_type='comment', url=None, parent=25607244, text='There are two components to your question - the practical side, &quot;how do I build a workflow system?&quot; and then, &quot;why Petri nets?&quot;.<p>If you really want to build a generic workflow engine, I think the way is to identify the pattern they follow and implement that.  Build classes, attributes and methods that abstract away automating a process in a generic sense (e.g. turn workflow into one or more services) and then integrate those service(s) into your application as the glue that holds together complex processes.  It&#x27;s obviously harder than that one sentence, of course there are lots of nuances, but that&#x27;s probably the simplest way I can think of to explain the high-level hand-wavy approach to doing this if you want to build it yourself, without going into all the details.<p>If you understand the pattern, and would rather not build, but buy or obtain an open source workflow engine&#x2F;management system, many exist [1][2].  Most enterprise applications (e.g. Oracle, SAP, Salesforce, etc. etc.) have such workflow tools built in already.<p>Regarding the second part of your question, &quot;why Petri nets?&quot;, well, one could argue that any system that automates a process in any way is a kind of workflow management system&#x2F;engine or could be modelled as a &quot;Petri net&quot;.  I guess you could say, &quot;why care about patterns in software engineering&quot; then?  The difference is, like many patterns, Petri nets give you a tried&#x2F;tested technique for conceptualizing and modelling the system&#x2F;process, validating its correctness, and in some cases, tools&#x2F;engines that implement these concepts can even give you the executable framework for building too.  You know, standing on the shoulders of giants and that kind of thing.<p>Technically, Petri nets are a superset for modelling&#x2F;designing&#x2F;visualizing&#x2F;validating what you can do in a workflow system.  Also, to be clear, the concept of Petri nets is in every way compatible with&#x2F;related to object oriented design, and even functional and procedural programming paradigms.<p>Perhaps I can try to answer your question in this way.. by relating Petri nets to design patterns in software engineering (think, Gang of Four, Patterns of Enterprise Architecture, etc.).  You know how, when you&#x27;re developing software - over the years, you start to see patterns emerge?  The best way to understand Petri nets and how they relate is to see what problem they solve in work you might have done yourself.<p>If you have ever implemented a large chunk of any information system, you start to realize, that even though it might be comprised of many smaller components working together, ultimately, it had to enable some kind of overall process to function.  And how, there were certain core components that you realize are more infrastructural in nature and are re-usable?  For example, logging, security (AAA, authentication, authorization, access control), etc.?<p>I was exposed to workflow systems when I first started working on case management systems (for example, legal cases).  Case management is a scenario that includes, coordinating multiple child processes to build a &quot;case&quot;, which is an instance of a process that is being executed.  Think.. Case ID #123 is an instance of a distributed process, which results in a case file, but may have many independent and ancillary sub-processes, approvals, communications, notes, reviews, etc. that must come together to &quot;complete&quot; the case.<p>You might diagram the flow of that legal process in a &quot;flow chart&quot;.  Business people love flowcharts right?  The next logical step is to think of.. what if these flow charts could represent&#x2F;become computable models (e.g. math&#x2F;validity&#x2F;correctness) and perhaps even a shell of executable code?<p>You could construct an entire monolithic case management system, that handled all the work related to legal cases - by learning the business process, hard-coding the logic from that flow chart (classes with attributes and methods that define the full behavior of the system, interactions, etc. if we were doing OOP), and so on.  If you did that, and you did that reasonably well, that system would certainly work for its designated scenario (legal cases).<p>In the midst of doing that, you might have realized that, the IT ticketing system you bought for your organization, had a similar process (for example, case management in ITIL).  You might notice.. startling similarities between the basic design of that system and the legal case management one.. to the point where you start asking.. is there a pattern here?<p>Sure enough, there is one.  The basis for that pattern is what some call workflow patterns -  Professor Wil van der Aalst and Professor Arthur ter Hofstede being two influential thinkers in the area [3].  If we follow this thread, we find one helpful paper: &quot;The Application of Petri Nets to Workflow Management&quot; [4] ,which I think would be of interest.<p>Then we start to realize that, some processes don&#x27;t happen in a monolithic way.  They need to be &quot;consistent&quot;, but the underlying code and execution could be distributed in different services or different systems and yet our process needs to pull it altogether to carry out the work of the process.  We might see that even though distributed, these processes and systems could be represented holistically.  Petri nets help in this situation.<p>I think one thing people might have missed when we got into this whole world of federated, independent teams, service-oriented architecture and now microservices, was that - ultimately, systematic behavior and processes must still function, and function well enough for organizations to fulfill their purpose.  While self-emergent behaviors are entirely possible and arise all the time, in complex systems.. when you absolutely must make your system&#x2F;process work, you need a way to engineer that and Petri nets give you a way to think about, model, and validate&#x2F;reason about that.<p>For a current very relevant example, consider microservices today.  On their own, they provide little value - but when orchestrated and working together to compose a larger system, to enable human and machine processes to execute and thrive, it would be nice to have ways to think about and model those processes that live on top.  Petri nets are one way to conceptualize and visualize those processes, where that conceptual model can be proven to be sound mathematically, and even turned in some cases directly into an executable framework within which to plug in your own code.  That&#x27;s what workflow systems often do, for example.<p>Another relevant and recent case - event sourcing.. and event-driven mechanisms, and event handling, and the processing that goes along with it to essentially create a &quot;directed process&quot; - these are all directly related too.  Also, there&#x27;s a reason that data workflow automations such as Apache Spark or Airflow, for example, chose directed acyclic graphs (DAG) as models for complex, reliable, distributed process execution - and you can represent those as Petri nets too.<p>What I always liked about Petri nets when I discovered them, was it gave me a way to link together strict state management, with process control, based in logical&#x2F;provable theory - but also gave me a way to bridge between the &quot;human&quot; side of process (&quot;flow charts&quot;) and the technical side of things.  It gave me a framework to &quot;plug in&quot; my different systems, functions, services, objects and behaviors into something that coordinated complex process both in theory and in practice.<p>I do not believe that one must implement monolithic process in code - as there is also emergent behavior - but, Petri nets and workflow management systems give you a way to think conceptually about how your system works.. and even potentially to build the &quot;glue&quot; that puts your system together, if you chose.<p>By the way, one interesting thing I saw that came out of this work, was simulation software where you could use Petri nets to essentially &quot;run&quot; a process in a simulated way and see if there were any natural bottlenecks in the process that you could optimize in advance - before building any code at all.  Process simulation [5] is another whole related rabbit hole to go down, but a fascinating one!<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Workflow_management_system" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Workflow_management_system</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;meirwah&#x2F;awesome-workflow-engines" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;meirwah&#x2F;awesome-workflow-engines</a><p>[3] <a href="http:&#x2F;&#x2F;www.workflowpatterns.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.workflowpatterns.com&#x2F;</a><p>[4] <a href="https:&#x2F;&#x2F;www.semanticscholar.org&#x2F;paper&#x2F;The-Application-of-Petri-Nets-to-Workflow-Aalst&#x2F;c79ac9d26d3246488fe4c9ebadffe3088ba16b83" rel="nofollow">https:&#x2F;&#x2F;www.semanticscholar.org&#x2F;paper&#x2F;The-Application-of-Pet...</a><p>[5] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Process_simulation" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Process_simulation</a>')