Item(by='cycomanic', descendants=None, kids=None, score=None, time=1605705931, title=None, item_type='comment', url=None, parent=25135790, text='&gt; Exactly. I wrote this explanation, but you beat me to it, so I&#x27;ll just post it here:<p>&gt; The real reason we use I&#x2F;Q sampling is because we want to frequency-shift a signal.<p>&gt; Why do we want to frequency-shift a signal? In radio frequency applications the signal of interest almost always has a much lower bandwidth than its highest frequency. In other words, the signal has a small bandwidth (say 40 MHz) centered around a high center-frequency (say 2.4 GHz). If we want to digitize the signal, then one way would be to use a very high sample-rate ADC (e.g. a 2.4 GHz ADC). But these are very expensive, and a much better way of digitizing the signal is to use a mixer (a frequency shifter) to shift the signal to be centered around 0 Hz and then use a relatively low sample-rate ADC (e.g. a 40 MHz ADC).<p>&gt; The way frequency shifting is done is by multipling the signal by a sine signal, which can be done in hardware. But this introduces a distortion to the signal because multiplying by a sine is not actually a frequency shift. It just so happens that this distortion is cancelled out by adding another copy of the signal multiplied with another sine delayed by 90Â°. But this addition needs to be complex (due to the relationship between sine functions and true frequency shifts), so what we do is sample the two distorted signals and do this complex addition with the digitial signals.<p>I&#x27;m not sure I understand you correctly, but I would not say you distort the signal when you multiply with a sine wave. Essentially you create to frequency components the sum and difference frequencies (f1+f2, f1-f2), now if f1 is your modulated signal (so some f1+fmod, where fmod is a band and can be positive and negative) and you want to convert to baseband you would select f2 so that it&#x27;s at the carrier (f1=f2) then you generate a baseband signal at 0 carrier frequency and a signal at 2xf1 which is usually outside your detector bandwidth so not detected. However this process only gives you half of the frequencies of your fmod, to get the other half you need to multiply with cosine(f2) which essentially gives you the component that was at 2xf1 now at baseband. So to handle that more elegantly in math you add the two components up as real and imaginary components, essentially that enables you to drop the cos&#x2F;sin(f1) terms from your equations.')