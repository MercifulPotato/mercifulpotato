Item(by='qayxc', descendants=None, kids=[24963370, 24957156, 24956652], score=None, time=1604194472, title=None, item_type='comment', url=None, parent=24956397, text='&gt; What kinds of wild things could we accomplish on this hardware if we weren&#x27;t bogged down in gigabytes and teraflops of bloat?<p>Not that many: An early 1990s PC platform could be thoroughly described in a 200 page book and you could write a boot loader for the CPU, a VGA driver, and drivers for the most common peripherals from scratch in a few weeks.<p>In fact, games of that era shipped with their own audio drivers, (C&#x2F;E&#x2F;V)GA libraries and peripheral support.<p>Today this would be a) impossible because many manufacturers (<i>cough</i> NVIDIA <i>cough</i>) don&#x27;t even release OSS drivers and specs and b) individual programs don&#x27;t own the hardware anymore - the OS does. Also the multitude of target platforms (CPU types, -core counts, and -speeds, graphics cards, peripherals, etc.) makes it virtually impossible to ship code that it optimal for each of even the most common combinations of hardware.<p>The final nail in the coffin of the &quot;super lean no bloat why-not-just-unikernel-everything-for-maximum-performance&quot; idea can be summed up in one word: cost.<p>Development costs would be <i>insane</i> if we started optimising every aspect of every program for performance (on every possible platform, no less), memory use, and (binary-) size.<p>And that&#x27;s even ignoring the fact that it&#x27;s more often than not outright impossible to optimise for binary size, runtime performance, and memory footprint all at the same time.<p>Plus interactions between programs (plugins, {shell-}extensions, data formats, clipboards, etc.) require &quot;bloat&quot; like common interfaces and &quot;neutral&quot; protocols.<p>Most of the myth of great &quot;old software&quot; comes from the fact that functionality was severely limited compared to modern apps and that many folks simply weren&#x27;t around to actually see and feel how much some of them actually sucked.<p>Sure, Visual Studio 6.0 runs incredibly fast on a vintage 3.2 GHz Pentium 4 with 2GiB of RAM using Windows 2000 - but when it released in 1998 many PCs had a 60MHz Pentium 1 or a 100MHz 486DX4 with 64MiB of RAM and it ran like a three-legged dog with worms on these machines compared to the DOS-based Borland-C...<p>Speaking of which, remember when sometime around the 2000s <i>all</i> Borland Pascal program stopped working, because CPUs had become too fast (&gt;200MHz IIRC)? That was because their runtime used a loop to determine how fast the CPU was, which caused a divide-by-zero on fast machines IIRC.<p>Good times indeed...')