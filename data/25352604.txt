Item(by='gresrun', descendants=None, kids=None, score=None, time=1607467812, title=None, item_type='comment', url=None, parent=25350878, text='Compose can also be implemented easily:<p><pre><code>    extension NullableExtensions&lt;T&gt; on T? {\n      R? map&lt;R&gt;(R Function(T) transform) =&gt; this == null ? null : transform(this!);\n    }\n    \n    V Function(V) compose&lt;V&gt;(Iterable&lt;V Function(V)&gt; functions) =&gt;\n        functions.reduce((composedFunction, function) {\n          return (V value) =&gt; composedFunction(function(value));\n        });\n    \n    num add3(num val) =&gt; val + 3;\n    num multiplyBy10(num val) =&gt; val * 10;\n    num subtract5(num val) =&gt; val - 5;\n    \n    final doABunchOfMath = compose([add3, subtract5, multiplyBy10]);\n    final optionallyDoABunchOfMath = (num? value) =&gt; value.map(doABunchOfMath);\n\n    doABunchOfMath(10); &#x2F;&#x2F; 98\n    optionallyDoABunchOfMath(10); &#x2F;&#x2F; 98\n    optionallyDoABunchOfMath(null); &#x2F;&#x2F; null\n</code></pre>\nThe nullable syntax (${Type}?) also makes it clear to readers that this is a type which may or may not contain a value. If you don&#x27;t supply the trailing &#x27;?&#x27;, Dart will enforce that the value must exist at compile-time and you can write your functions without worrying about nulls sneaking in where they&#x27;re unwanted.<p>In effect, int? is almost nearly Option&lt;int&gt;, except you cannot represent Option&lt;Option&lt;int&gt;&gt; with Dart&#x27;s nullable syntax.<p>Check out <a href="https:&#x2F;&#x2F;nullsafety.dartpad.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nullsafety.dartpad.dev&#x2F;</a> to play around with the possibilities!')