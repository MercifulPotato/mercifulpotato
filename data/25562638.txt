Item(by='ChrisLomont', descendants=None, kids=None, score=None, time=1609185770, title=None, item_type='comment', url=None, parent=25533943, text='&gt;It gets pretty hard to distinguish this coin from an unbiased one.<p>All you&#x27;re doing is trying to reinvent the Law of Large Numbers - nothing in this post shows a perfect hash function, and in fact is demonstrating my point - by you putting biased data into a hash you&#x27;re getting biased data out.<p>To completely remove the bias you need infinite flips. And thus you have improved nothing.<p>Next, if you&#x27;re going to flip 100 times to get 1 bit out, simply use the Neumann method - it does work, uses only a few flips on average.<p>Here&#x27;s a proof why your method doesn&#x27;t work: Let p = prob of getting a 1, q = 1-p is prob of getting a 0. Then XORing n of these together is a 1 iff there are an odd number of 1 bits. This happens Sum_{j=1 to N by odd} nCj p^j (1-q)^(n-j) of the time. This simplifies to (1-(1-2p)^n)&#x2F;2. For this to be exactly 1&#x2F;2, which is no bias, p must be exactly 1&#x2F;2. There is no other value that doesn&#x27;t fail.<p>This argument can be extended to whatever boolean functions you want. You&#x27;re not going to get the outcome you desire no matter how you structure it.<p>&gt;I&#x27;m not sure if you need a cryptographic hash actually.<p>It matters not the hash. None will do what you want.<p>This is why when crpyto uses weak PRNGs at the front, even after all the powerful crypto in the middle, they are weakened. You&#x27;re trying to do what decades of cryptographers know is impossible.')