Item(by='loup-vaillant', descendants=None, kids=[25317114], score=None, time=1607105699, title=None, item_type='comment', url=None, parent=25304374, text='&gt; <i>I&#x27;d rather my colleagues repeat themselves in their documentation comments than provide none at all.</i><p>To a point. Believe me, there are levels of repetition you would find less tolerable than a lack of documentation. Here&#x27;s a real world example: we had a bunch of classes with lots of attributes. The getters and setters for those attributes were automatically generated (with a macro), because we had lots and lots of them. In the headers however, we wrote the prototypes in full, so the tools could find them more easily:<p><pre><code>  Foo getFoo();\n  Bar getBar();\n  Baz getBaz();\n\n  void setFoo(const Foo &amp;foo);\n  void setBar(const Bar &amp;bar);\n  void setBaz(const Baz &amp;baz);\n</code></pre>\nSo far so good. Now documentation is an important thing. So important in fact that we had to document <i>every</i> single method in all classes. And since we were using Doxygen, we were a bit constrained.<p><pre><code>  Foo getFoo(); &#x2F;&#x2F;&#x2F;&lt; Get foo\n  Bar getBar(); &#x2F;&#x2F;&#x2F;&lt; Get bar\n  Baz getBaz(); &#x2F;&#x2F;&#x2F;&lt; Get baz\n\n  void setFoo(const Foo &amp;foo); &#x2F;&#x2F;&#x2F;&lt; Set foo\n  void setBar(const Bar &amp;bar); &#x2F;&#x2F;&#x2F;&lt; Set bar\n  void setBaz(const Baz &amp;baz); &#x2F;&#x2F;&#x2F;&lt; Set baz\n</code></pre>\nOK that&#x27;s redundant, not too bad, and QA is happy now. Well, no.  First, we are supposed to be using Javadoc style documentation. Second, we need to document every arguments, <i>and</i> the return values. How are we supposed to understand a getter if we don&#x27;t document its return value?<p><pre><code>  &#x2F;**\n   * Get foo\n   *\n   * @return foo\n   *&#x2F;\n  Foo getFoo();\n\n  &#x2F;**\n   * Get bar\n   *\n   * @return bar\n   *&#x2F;\n  Bar getBar();\n\n  &#x2F;**\n   * Get baz\n   *\n   * @return baz\n   *&#x2F;\n  Baz getBaz();\n\n  &#x2F;**\n   * Set foo\n   *\n   * @foo The new Foo\n   *&#x2F;\n  void setFoo(const Foo &amp;foo);\n\n  &#x2F;**\n   * Set bar\n   *\n   * @bar The new Bar\n   *&#x2F;\n  void setBar(const Bar &amp;bar);\n\n  &#x2F;**\n   * Set baz\n   *\n   * @baz The new Baz\n   *&#x2F;\n  void setBaz(const Baz &amp;baz);\n\n</code></pre>\nAnd so on, often for 20 attributes instead of just 3. I am not even kidding. Now we could say it&#x27;s just a matter of space, but it isn&#x27;t: <i>sometimes</i>, there was an attribute that was a bit special, and the comment reflected that:<p><pre><code>  &#x2F;**\n   * Set wiz\n   *\n   * @baz The new Wiz. Must not be Merlin.\n   *&#x2F;\n  void setWiz(const Wiz &amp;wiz);\n</code></pre>\nExcept the additional comment could as well be absent, because it was totally lost in the noise. I&#x27;ve missed several cogent pieces of information that way.<p>Worse, the tech lead, who acknowledged that this practice was useless at best, and had the clout to have this restriction relaxed, <i>refused to do so</i>. To this day I&#x27;m not sure why. I have a couple hypotheses (plain inertia, don&#x27;t fix what&#x27;s not <i>blatantly</i> broken, don&#x27;t want to argue with QA, afraid of regulationâ€¦), but nothing solid.<p>If I had to chose between no comment at all and <i>that</i>, I&#x27;m not sure I would chose that. Sure, I would lose valuable comments, but if I already lost them because of sheer noise, I didn&#x27;t lose much at all.')