Item(by='TrianguloY', descendants=None, kids=[25415491, 25425380, 25415896], score=None, time=1607939116, title=None, item_type='comment', url=None, parent=25414534, text='Recently, for an academic project, I were given a one static one-function very long class that implemented an algorithm (was obviously programmed as a cpp algorithm). The algorithm consisted of steps (gather data, transform data, print data, etc) so as a &#x27;what if&#x27; I refactored it by moving each step into a class (so the main function was now one line for each step). Also, what originally was multiple if&#x2F;else to different outcomes (print to file vs print to console) was now one abstract class with one sub class each. The algorithm code was practically the same, the difference was where it were located. Instead of needing to scroll a lot, you now needed to switch between files.<p>Was it worth it? Probably yes, not for the final code but for the experience of &#x27;this is an exaggeration that you should not repeat&#x27; (although the resulting class diagram was a work of art).<p>As usual, extreme abstracting is bad, but extreme lack of abstracting is too. You should find a common term that make the current work simple enough, but that also allows for future changes to be simple to implement.<p>If you are making a list-like class because you need to keep a collection of strings which you are only comparing, don&#x27;t use strings. Use &lt;T&gt; even if you only use it with strings, the extra cost while creating the class is almost nothing, but the cost of a future refactorization will surely be greater.<p>&quot;Try not to open doors you don&#x27;t need, but keep them accessible in case you need them later&quot;')