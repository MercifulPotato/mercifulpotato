Item(by='nickjj', descendants=None, kids=None, score=None, time=1611783477, title=None, item_type='comment', url=None, parent=25933698, text='&gt; Similarly, a computer game, having an EnemyDemon inherit from Enemy, so that it has .kill(), .damage(), and properties for health, speed etc.?<p>I&#x27;m not a game developer in the slightest but as a gamer and developer I&#x27;ve often thought about similar things a little bit.<p>In another example, let&#x27;s say you were playing a game like Diablo II &#x2F; Path of Exile where you have items that could drop with random properties. Both of those games support the idea of &quot;legacy&quot; items. The basic idea is the developers might have allowed some armor to drop with a range of +150-300% defense in version 1.0 of the game but then in 1.1 decided to nerf the item by reducing its range to +150-200% defense.<p>Instead of going back and modifying all 1.0 versions of the item to fit the new restrictions, the game keeps the old 1.0 item around as its own entity. It has the same visible name to the player but the legacy version has the higher stats. Newer versions of the item that drop will adhere to the new 1.1 stat range.<p>That made me think that they are probably not using a highly normalized + OOP approach to generate items. I have a hunch every item is very denormalized and maybe even exists as its own individual entity with a set of stats associated to it based on whenever it happened to be generated. Sort of like an invoice item in a traditional web app. You wouldn&#x27;t store a foreign key reference to the price of the item in the invoice because that might change. Instead you would store the price at the time of the transaction.<p>I guess this isn&#x27;t quite OOP vs not OOP but it sort of maybe is to some degree.<p>I&#x27;d be curious if any game devs in the ARPG genre post here. How do you deal with such high amounts of stat variance, legacy attribute persistence, etc.?')