Item(by='MaxBarraclough', descendants=None, kids=[25334178], score=None, time=1607357901, title=None, item_type='comment', url=None, parent=25331301, text='Sorry to double reply but I see I missed some of your points:<p>&gt; Basically with ADA, you develope much slower (and performance is usually lower)<p>Ada deliberately emphasises readability over writeability. It might take a bit longer to do initial development work in Ada than in C, although it&#x27;s likely that you&#x27;ll encounter fewer bugs, so Ada might win out even here. Subsequent maintenance is likely to be cheaper&#x2F;easier. I believe comparison studies have borne this out, although I&#x27;m not certain how trustworthy they are.<p>As for performance: with runtime checks disabled, Ada should perform about the same as C&#x2F;C++, as its abstractions don&#x27;t tend to have runtime costs, it&#x27;s just pretty plain imperative code. Ada isn&#x27;t typically used with garbage collection, for instance. Like C++, you have the option of using the language&#x27;s OOP features.<p>With runtime checks enabled, you&#x27;ll pay some runtime performance cost (let&#x27;s say very roughly 15%, to simply make up a number out of nowhere). C and C++ don&#x27;t give you the option of enabling as many runtime checks as Ada does, due to the free-form way arrays work, for instance. gcc and clang both give you the option of enabling runtime checks for certain kinds of errors, such as dereferencing <i>NULL</i>, but plenty of other kinds of error won&#x27;t be caught.<p>&gt; But if you want reliability, it does sound good.<p>Ada has some traction in the critical-systems space. The Boeing 777 flies on Ada, for instance. Of course, C and C++ are also both used for safety-critical software.')