Item(by='tptacek', descendants=None, kids=[25884800], score=None, time=1611420960, title=None, item_type='comment', url=None, parent=25883253, text='Regarding performance, I wrote a bit about this a few months ago in a post comparing different workload isolation techniques:<p><a href="https:&#x2F;&#x2F;fly.io&#x2F;blog&#x2F;sandboxing-and-workload-isolation&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fly.io&#x2F;blog&#x2F;sandboxing-and-workload-isolation&#x2F;</a><p>Two useful links from my Pinboard research for that post:<p>A person at Red Hat optimizing QEMU boot time:<p><a href="http:&#x2F;&#x2F;oirase.annexia.org&#x2F;tmp&#x2F;paper.pdf" rel="nofollow">http:&#x2F;&#x2F;oirase.annexia.org&#x2F;tmp&#x2F;paper.pdf</a><p>An Intel deck talking about qemu-lite:<p><a href="http:&#x2F;&#x2F;events17.linuxfoundation.org&#x2F;sites&#x2F;events&#x2F;files&#x2F;slides&#x2F;Light%20weight%20virtualization%20with%20QEMU%26KVM_0.pdf" rel="nofollow">http:&#x2F;&#x2F;events17.linuxfoundation.org&#x2F;sites&#x2F;events&#x2F;files&#x2F;slide...</a><p>(The other thing to follow up on if you&#x27;re interested in the background on this stuff is kvmtool).<p>In both cases, a big part of the answer seems to be eliminating BIOS overhead; getting rid of oproms appears to have been the single biggest win for Intel. But the Red Hat article also finds lots of overhead in QEMU itself, and both pieces talk about kernel config issues (for instance, scrubbing the kernel you boot of subsystems that have expensive initcalls).<p>By comparison: Firecracker is purpose-built in Rust for this one task, provides no BIOS, and offers only network, block, keyboard, and serial device support --- with tiny drivers (the serial support is less than 300 lines of code).')