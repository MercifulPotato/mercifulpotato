Item(by='Animats', descendants=None, kids=[25799424, 25798941, 25799808, 25799764, 25799304, 25799478, 25798906, 25801680, 25802575, 25799204, 25799679, 25799707, 25801053, 25798717, 25802208, 25799761, 25801295, 25798979, 25798860, 25798657, 25798739, 25799025, 25799412], score=None, time=1610757434, title=None, item_type='comment', url=None, parent=25798008, text='Yes. That&#x27;s what Go is for. Go is for doing the things that Google does on servers, which mostly means web apps of one kind of another. It has all the parts for that, and they&#x27;re well-exercised because they&#x27;re doing billions of operations per second on Google&#x27;s own work. It&#x27;s hard-compiled, so you don&#x27;t have all the extra overhead of the interpreted languages. Also, Go has a better async story than most web-oriented systems. Goroutines, or &quot;green threads&quot;, do both the job\nof threads and &quot;async&quot;. In async land, if anything blocks or uses much CPU time, you&#x27;re stalled. Not so in Go. A goroutine can block without stalling other goroutines.<p>Right now, I&#x27;m writing a client for a virtual world in Rust. There&#x27;s a big need for concurrency, but, unlike web stuff, it&#x27;s all tightly interrelated. There&#x27;s a GPU to keep busy. There&#x27;s network traffic of several different kinds. There are compute-bound tasks which need to be kept out of the frame refresh loop.<p>Rust is good for this. The existing C++ client is too much of a mess to make concurrent; people looked at it and gave up. In Rust, it&#x27;s coming along nicely.<p>Use the right tool for the job.')