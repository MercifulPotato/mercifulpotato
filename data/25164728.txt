Item(by='ReactiveJelly', descendants=None, kids=None, score=None, time=1605905041, title=None, item_type='comment', url=None, parent=25163129, text='I don&#x27;t think the point is to reduce overhead. It may actually increase it, as long as the overhead for AOT wasm is more than 0. [1] As I understand it, containers have almost no CPU overhead. I have no citation for that.<p>Lunatic, to me, looks more like a web browser hosting many JavaScript sandboxes. But instead of JavaScript it&#x27;s wasm, and instead of a web browser, it&#x27;s only a host process, like node.js. (I don&#x27;t know if node.js has a concept of running many side-by-side JS actors. Maybe it does)<p>So you have 1 Unix process hosting many Erlang-like actor processes.<p>I&#x27;m writing a little bit out of my depth, but I think the huge difference is permissions.<p>Sure, this all might be possible with containers. But Docker, the only container system I&#x27;ve used, is this huge thing. You have to install it, there&#x27;s a daemon, it hooks into systemd probably, usually you need to be root unless you do everything just right. It requires kernel support for lxc, so I can&#x27;t run it on the crappy little ARM boards I have to program.<p>Lunatic, like a web browser hosting JS sandboxes, is _just_ a Unix process. No root, no permissions. I think it will even work on Windows and OS X.<p>So yeah, if you&#x27;re talking about web services where you can already manage many Docker containers on a Linux host no-sweat, it might not add much. But if this can be deployed on arbitrary clients with no root and no Linux kernel dependency, it&#x27;s a very fun toy that must be useful for _something_.<p>[1] You may find this cool: <a href="https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2020&#x2F;02&#x2F;securing-firefox-with-webassembly&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2020&#x2F;02&#x2F;securing-firefox-with-weba...</a><p>Firefox has a C++ font shaping library. Starting in FF 75, they compile the C++ to webasm, then AOT compile the webasm into native code. Resulting in a memory-safe sandbox for C++. There is some overhead, and it looks like a lot of set-up work. They don&#x27;t give exact percent numbers on runtime overhead.<p>I don&#x27;t know if Lunatic is doing JIT or AOT. I&#x27;ll generously assume that one day they&#x27;ll do whatever is faster. Part of the point of wasm is to beat JS performance, so I think at least compared to Electron or Node.js (JS sandboxes in a Unix process) it should be competitive.')