Item(by='jillesvangurp', descendants=None, kids=[25451677], score=None, time=1608107665, title=None, item_type='comment', url=None, parent=25438302, text='I introduced graphql a few months ago to basically unblock myself from having to think about and design gazillions of custom REST endpoints for our mobile client developers. Turns out, that I don&#x27;t miss doing that. REST has been a huge drain intellectually on this industry ever since people got pedantic over Roy Fielding&#x27;s thesis and insisted that we stop treating HTTP like yet another RPC mechanism. The amount of debates I&#x27;ve been involved in over such arcane detail as the virtues of using a PUT vs POST and exactly which is more &#x27;correct&#x27; in what situation is beyond ridiculous. I appreciate a well designed REST API as much as anyone but for most projects where the frontend code is the single customer of the API, it&#x27;s not very relevant. If you are shipping SDKs to third parties, it&#x27;s a different matter of course.<p>In any case, we now have the graphql playground where you can prototype your queries with full autocomplete (based on the schema). I&#x27;ve done this with third party graphql APIs; it&#x27;s stupidly easy and you don&#x27;t need a lot of documentation generally.<p>We&#x27;re using the Expedia implementation for Kotlin and Spring Boot. I have a suspicion that that setup might be  lot easier to deal with than Appollo and node.js since it has the important feature of using reflection for creating the schema from code. I&#x27;ve not written a single line of graphql schema in nearly 6 months of creating dozens of graphql endpoints. We also use kotlinx serialization to generate cross platform parsing code in our multiplatform client (we use it on Android and in the browser and soon on IOS). So, this offloads a lot of hassle of dealing with schemas and parsing both client and server side that we used to have with REST based APIs. Maybe not the most common path but worth checking out if you are looking to get started with this stuff.<p>My process for adding a new endpoint:<p>1) write a function in a spring bean that implements the Mutation or Query marker interface. Spring Boot does the rest. It generates the schema at startup time and wires everything together.<p>2) start a dev server, prototype the new graphql query in the playground<p>3) paste the working query to a new function with a multi line string along with any model classes we need in our multiplatform (js, android, and soon ios native) client library and recompile that to add the new client code for the query.<p>4) update the dependency on our android and web projects (we use kotlin-js for our admin UI) to use it.<p>5) also add the new client to our integration test project so we can write some tests for the new endpoint. We have full end to end tests of our client and API. Our server uses some mocked databases and middleware when running the tests.<p>It&#x27;s definitely not perfect; the Expedia implementation definitely has some quirks and limitations. Also, Kotlin multiplatform has been a bit of a moving target in the last few months (though a lot more usable as of Kotlin 1.4.x). But overall it&#x27;s a great setup for a small team that has better things to do than crafting custom REST APIs.<p>In terms of performance, technically graphql is just an HTTP POST API on top of Spring Boot (for us at least). Yes, there&#x27;s a bit of overhead for query processing on the server but most of your performance is otherwise exactly the same as it would otherwise be. You of course pay a price for crafting complicated queries. But that&#x27;s the same price you pay for having poorly aligned UI and REST APIs where you end up making lots of REST calls because you did not design your API right (been there, done that). Graphql just allows you to iterate on that more easily. But it&#x27;s not inherently slower in any way. We are currently not doing any federation but that&#x27;s mostly because we have a monolith server instead of micro-services.')