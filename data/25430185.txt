Item(by='lmm', descendants=None, kids=[25430421], score=None, time=1608039785, title=None, item_type='comment', url=None, parent=25429846, text='&gt; After all, if you can tell if two pointers to unrelated objects are the same, that means you&#x27;re willing and able to canonicalize them to a common-denominator representation, in which case you already have an ordering based on that same canonicalization too... why forbid that?<p>UB wasn&#x27;t meant to forbid anything, it was meant to allow implementers to offer different behaviour. Implementers who want to represent pointers internally as integers and have comparisons just compare the underlying integers can do that. Implementers who have something more complicated e.g. segmented architectures are required to support equality comparison (which they can do easily by just having pointers to different segments always compare nonequal) but are not required to define an ordering between different segments.<p>To me it seems like the kind of compromise the standard makes all the time (which is not to say I agree with it). Requiring everyone to define an ordering on all kinds of pointers would be too burdensome for implementers (or maybe some implementers wanted to trap on unrelated pointer comparison, because if you&#x27;re doing pointer arithmetic with unrelated pointers you&#x27;ve probably got a bug). Whereas making equality comparisons UB would be way too burdensome for users; it would mean you couldn&#x27;t e.g. have a list of pointers and check whether a given pointer was in the list by searching through its elements.')