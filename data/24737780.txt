Item(by='alxlaz', descendants=None, kids=None, score=None, time=1602323158, title=None, item_type='comment', url=None, parent=24736992, text='As with much of Pike&#x27;s advice, it&#x27;s worth remembering <i>where</i> it comes from: Unix, specifically AT&amp;T-style Unix (and later Plan 9), where a fairly disciplined (programming-wise, at least :P) team of very good, and oftentimes very experienced developers wrote a lot of small, interconnecting utilities.<p>If your whole source code is written in that manner, and written by people who write code in that manner, this advice is easy to follow.<p>On the other hand there aren&#x27;t many files in the Plan 9 source tree that are longer than, what, 3,000 lines? 4,000? Attempting to shoehorn <i>that</i>, and many other well-intended nuggets of wisdom from the Unix &#x27;heritage&quot;, into your average commercial codebase, with dozens of third-party libraries and whatnot, is unworkable (I know, I <i>tried</i>).<p>Some programming advice pearls translate well into any project. &quot;Avoid gratuitous comments like &quot;increment i&quot;, use comments to explain the reasoning behind functionality, not describe what the source code already adequately describes&quot; can be applied on any source tree, starting at any point. But some of them -- such as this one -- only work if you write and organize your code in a particular way.<p>FWIW, I think that this bit of advice was useful back when Pike wrote it, in the age of slow, buggy C compilers (although some would argue we&#x27;re still in that era!) munching code off of network-mounted drives. Nowadays, not so much -- I think it has readability advantages but I doubt the performance gain (if any is left) is worth the extra programmers&#x27; effort. I like to follow it when I&#x27;m writing small utilities but I don&#x27;t really fuss about it for larger projects, and I&#x27;ve never been curious to see how fast it is. I believe (but never measured it, so take it with a grain of salt!) that it&#x27;s one of those things that 30+ years of computer systems evolution (in the biological sense -- &quot;advancement&quot; is probably too strong a word) has made obsolete.')