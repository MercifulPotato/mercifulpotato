Item(by='JangoSteve', descendants=None, kids=None, score=None, time=1601925519, title=None, item_type='comment', url=None, parent=24686691, text='&gt; In that case, applying the remedy of the first example (a set of dates, and inferring that every 2nd (even zero length, to account for adjacent fixed) interval will be default,) introduces another bug where if you lop off any random date in that set or list, you invert everything.<p>This is a good point, and something I usually describe recoverable problems versus non-recoverable problems. If I make start&#x2F;end dates in the first example instead of just a set of start dates, then I can always create application-level or database-level constraints that don&#x27;t allow either overlapping or incomplete segments. When business rules change, I can delete the constraints and update the business logic as necessary with no change to underlying data structures.<p>However, if I miss implementing a constraint and it erroneously allows overlapping or incomplete segments, I can easily run a query to identify all such invalid entries. Then I can then investigate and decide how to fix them.<p>However, if I go with the start-date-only set-based approach, and miss implementing a constraint, and it leads to a deleted date creating incomplete segments... I&#x27;m screwed. There will be no query you can do to identify incomplete segments to investigate or fix, because all segments are assumed to extend to the next start date. You can irreversibly lengthen one segment by deleting another, due to a forgotten constraint preventing you from making the change.<p>These could both be errors on the developer&#x27;s part, depending on the requirements at the time, but one data design may lead to more non-recoverable issues than the other. Add in the flexibility of the former approach, and I&#x27;d probably be more likely to implement the former approach than the one proposed.')