Item(by='dmytrish', descendants=None, kids=None, score=None, time=1611596921, title=None, item_type='comment', url=None, parent=25905166, text='&quot;unsafety&quot; is a very overloaded term. In this context, one specific technical meaning is assumed: _memory safety_ [0] (not type safety, not safety from hacking, etc, although they do depend on memory safety).<p>Programming languages are tools for building abstractions and concrete implementation of abstractions. They are very rarely verified and described mathematically and exhaustively; it is possible to state some properties of some programs, but it is mathematically impossible to state any meaningful property for an arbitrary program [1].<p>However, it is possible to constrain used abstractions in a way that allows to uphold some properties (to some degree). Memory safety of a language means that a program in that language can change a variable&#x2F;state if and only if it &quot;touches&quot; it semantically (e.g. via a valid pointer&#x2F;reference). A memory-safe language creates a reliable &quot;abstraction cage&quot; for (almost) any program written in it that guarantees (but not necessarily mathematically) that unrelated variables cannot be changed. &quot;Glitches in the Matrix&quot; (changing one variable magically changes a random other one) are still possible, but very rare in practice. Examples: Java&#x2F;Python (which incur significant inefficiency when executing a program), and recently (the safe part of) Rust, which often comes very close to C&#x2F;C++ in efficiency while retaining memory safety in most of its code.<p>C&#x2F;C++ are examples of memory unsafe languages: their memory abstractions are not even close to an &quot;abstraction cage&quot;&#x2F;&quot;Matrix&quot;, they are just thin &quot;guardrails&quot; and guides, not enforceable rules: it is easy to read&#x2F;corrupt an unrelated variable in a program (sometimes even via a malicious input to a program). This design choice was semi-deliberate: C&#x2F;C++ solve the task of programming existing computer hardware efficiently and nobody knew how to create a practical, efficient and memory-safe systems programming language even twenty years ago. It is possible for a coder to code &quot;defensively&quot;, using empirical best practices and tools for reducing possibility of using program memory incorrectly. C++ has a subset and tooling that comes tantalizingly close to memory safety, but it is still a costly uphill battle and even the best C&#x2F;C++ coders&#x2F;organizations fail to avoid memory misuse.<p>[0]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety</a>\n[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rice%27s_theorem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rice%27s_theorem</a>')