Item(by='avmich', descendants=None, kids=[24873855, 24872787, 24872920], score=None, time=1603479873, title=None, item_type='comment', url=None, parent=24871946, text='In some sense JSON is unimprovable, because some properties of JSON are reached their limits.<p>The idea of JSON is to offer two important ways to aggregate, which are different enough that they deserve separate treatment - ordered array and associative array. They are economically represented, with [] and {}, and internal structure is also made with small costs - commas (,) between elements and colons (:) for keys in associative array. We can argue that both of those features are required.<p>Chosen primitives - numbers, strings, booleans and null - are also selected from what&#x27;s regularly and consistently used, and the choice is supported by two decades of JSON application. Roots of this selection are in design of JavaScript, which in turn relied on common practice for basic primitives.<p>If JSON is considered as what I think it is, structure out of basic primitives, it&#x27;s at the optimal point. Crockford&#x27;s decision to avoid JSON versioning makes a good sense.<p>Applications of JSON - human-readable texts, performance-optimized communications - can suffer from e.g. lack of built-in comments, non-extensible &quot;type system&quot;, non-optimal bandwidth usage (if direct ASCII or even UTF-8 is used for JSON encoding, not some other compressed approach). They however can be fixed by building on top of JSON. For example, parties can agree upon reserved keys and compression schemas, constraints in form of grammars (JSON-Schema). This flexibility stems from the fact that JSON is at the very foundation of data structures, so &quot;better than JSON&quot; is to an extent like &quot;better than two&#x27;s complement number representation&quot;.')