Item(by='pron', descendants=None, kids=None, score=None, time=1607109145, title=None, item_type='comment', url=None, parent=25305574, text='&gt; Loom approach for Java is a reasonable one. No async-await shenanigans, no funny FP&#x2F;Haskell&#x2F;IO business.<p>There&#x27;s another important piece of the puzzle (putting aside any debate over the value of values): software is much more than syntax. When I think of some software construct, I don&#x27;t just think how I can express and manipulate it in code, but also how I can express it and manipulate it <i>while it is running</i> and after it&#x27;s run, i.e. present it in a profiler or assist troubleshooting when something goes wrong. In other words, how to make it a traceable, contextual entity.<p>The &quot;process&quot; construct on the Java platform -- <i>regardless of the frontend language used to write the program</i> -- is not that of an IO type, nor is it a syntactic coroutine; it is the thread. The JVM constructs stack traces <i>for threads</i>; it emits profiling, monitoring and debugging events <i>for threads</i>; its semantics of single-stepping follow <i>threads</i>; its GC heuristics are or can be designed around threads and even the JIT compilers perform optimisations that are implicitly based on threads [1]. In other words, the syntactic construct is just a part of of the problem, and the goal was not just to find a good fit <i>for the language</i>, but also all of the other important aspects of software. Adopting any other alternative would have required introducing that new concept into all layers of the platform as well. We&#x27;re building a platform, not just a language.<p>Just to give you an example of a design issue we&#x27;re struggling with now because even the mere number and duration of threads changes some of their runtime aspects: how do we perform thread dumps in a way that would tell the user what they want to know, i.e. what the different parts of their application are currently doing? Merely dumping a million stack traces probably wouldn&#x27;t do the job, even if we grouped and deduped them. If we were to introduce a new kind of process, such &quot;program dumps&quot; would be the least of our worries; just the coordination with debugger&#x2F;profilers&#x2F;APM vendors would be a multi-year project.<p>&gt; <a href="https:&#x2F;&#x2F;twitter.com&#x2F;impurepics&#x2F;status&#x2F;1180064851219144704" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;impurepics&#x2F;status&#x2F;1180064851219144704</a><p>OT, but, as someone who&#x27;s interested in analytic philosophy and formal languages, such incorrect usages of &quot;referential transparency&quot; are a pet-peeve of mine. Java is more referentially transparent than Scala (at least Scala 2.x) because it doesn&#x27;t have macros. It does not mean &quot;an expression can be replaced by its <i>value</i> without changing [the value of the value of an enclosing expression]&quot; but &quot;an expression (term) can be replaced by its <i>reference</i> (aka denotation) without changing the <i>reference</i> of its enclosing expression;&quot; hence <i>referential transparency</i> -- a syntactic term is a transparent representation of its reference, something that isn&#x27;t true once you have macros. It&#x27;s just that if your language is a pure-functional one, i.e. one with value semantics, i.e. one whose term references are values in the object domain of the language, then a reference is a value. That incorrect usage of referential transparency is nothing but a synonym for being pure functional (or of &quot;value semantics&quot;) rather than a feature of it.<p>&gt; It&#x27;s justifiable in Rust, because Rust aims for zero-cost abstractions.<p>It&#x27;s not that async&#x2F;await is inherently more &quot;zero-cost&quot; than user-mode threads; they&#x27;re just like that <i>in Rust</i> given its peculiarities. A different syntactic construct allows them to restrict recursion and virtual dispatch that would make stack size non-deterministic and interfere with their chosen memory-management strategy.<p>[1]: The compiler inlines calls (which are on the same thread); it doesn&#x27;t inline multiple monadic stages (which often entail some megamorphic callsite).')