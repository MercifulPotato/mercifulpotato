Item(by='pron', descendants=None, kids=None, score=None, time=1607109145, title=None, item_type='comment', url=None, parent=25305574, text='&gt; Loom approach for Java is a reasonable one. No async-await shenanigans, no funny FP&#x2F;Haskell&#x2F;IO business.<p>There&#x27;s another important piece of the puzzle (putting aside any debate over the value of values): software is much more than syntax. When I think of some software construct, I don&#x27;t just think how I can express and manipulate it in code, but also how I can express it and manipulate it <i>while it is running</i> and after it&#x27;s run, i.e. present it in a profiler or assist troubleshooting when something goes wrong. In other words, how to make it a traceable, contextual entity.<p>The &quot;process&quot; construct on the Java platform -- <i>regardless of the frontend language used to write the program</i> -- is not that of an IO type, nor is it a syntactic coroutine; it is the thread. The JVM constructs stack traces <i>for threads</i>; it emits profiling, monitoring and debugging events <i>for threads</i>; its semantics of single-stepping follow <i>threads</i>; its GC heuristics are or can be designed around threads and even the JIT compilers perform optimisations that are implicitly based on threads [1]. In other words, the syntactic construct is just a part of of the problem, and the goal was not just to find a good fit <i>for the language</i>, but also all of the other important aspects of software. Adopting any other alternative would have required introducing that new concept into all layers of the platform as well.<p>Just to give you an example of a design issue we&#x27;re struggling with now because even the mere number and duration of threads changes some of their runtime aspects: how do we perform thread dumps in a way that would tell the user what they want to know, i.e. what the different parts of their application are currently doing? Merely dumping a million stack traces probably wouldn&#x27;t do the job, even if we grouped and deduped them.<p>&gt; It&#x27;s justifiable in Rust, because Rust aims for zero-cost abstractions.<p>It&#x27;s not that async&#x2F;await is inherently more &quot;zero-cost&quot; than user-mode threads; they&#x27;re just like that <i>in Rust</i> given its peculiarities. A different syntactic construct allows them to restrict recursion and virtual dispatch that would make stack size non-deterministic and interfere with their chosen memory-management strategy.<p>[1]: The compiler inlines calls (which are on the same thread); it doesn&#x27;t inline multiple monadic stages (which often entail some megamorphic callsite).')