Item(by='matt7340', descendants=None, kids=None, score=None, time=1611934820, title=None, item_type='comment', url=None, parent=25957434, text='My experience with junior (and sometimes not junior) developers has been that the lack of understanding leads to confusion about what they&#x27;re trying to test. I think the ambiguity leads to a tendency toward mocks, which leads to tests that are focused on collaboration and implementation rather than output. Sometimes that makes perfect sense, but I&#x27;ve also seen where it encouraged more tests that are too implementation reliant.<p>Nothing wrong with mocks of course, sometimes they are absolutely required. I just favor isolation using stubs, and using mocks sparingly and only when absolutely needed.<p>&gt; ...in reality every mock needs to act as a stub\nI disagree. In fact a collaborator method call that doesn&#x27;t return a value is a great candidate for mocking. Conversely, a collaborator that does return a value can usually be stubbed.<p>&gt; ...when you stub you can also go ahead and add code to verify some behaviors (mock) to get some extra coverage\nEntirely dependent on context of course, but to generalize, this feels risky. In many cases adding extra coverage via mocks might be making tests more brittle, for little to no value gain. Further if every method you mock is returning a preset value, there&#x27;s no reason to verify expectations on it, because it&#x27;s a stub that will allow verifying expectations on the output of the object&#x2F;function under test.<p>As far as library naming, it&#x27;s just a pet peeve stemming from &quot;mock&quot; somehow becoming synonymous with &quot;test double&quot;. If people use a &quot;mocking&quot; library for stubs... well... that&#x27;s good! :)')