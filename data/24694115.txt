Item(by='lmm', descendants=None, kids=None, score=None, time=1601949972, title=None, item_type='comment', url=None, parent=24693644, text='&gt; This is equally true in Java. Types are erased at runtime. They don&#x27;t exist in the bytecode.<p>For the record this isn&#x27;t true, as anyone who&#x27;s seen a ClassCastException knows. A subset of type information is erased under limited circumstances, but a lot of type information is still present in the bytecode.<p>&gt; Just because the type checking and evaluation are done using one tool, &quot;javac&quot; doesn&#x27;t really mean anything.<p>What means something is that the types are part of the language specification and, even more importantly, part of the consensus of the language community.<p>In particular, if you depend on a Java library, you can be extremely confident that the type information of that Java library is actually correct, because you can be extremely confident that the library was built in a way that involved checking the types. This is simply not the case for Python; it&#x27;s very normal to build Python without running mypy. It&#x27;s like arguing that C is a safe language because you can run Valgrind on your C code: yes, that external tool exists, but it&#x27;s not part of the language by default, and so you can&#x27;t rely on the rest of the ecosystem to have used it.<p>&gt; A deeper analysis would suggest that &quot;ascriptions&quot; are actually the things you use to disambiguate when type inference is not powerful enough (<a href="https:&#x2F;&#x2F;docs.scala-lang.org&#x2F;style&#x2F;types.html" rel="nofollow">https:&#x2F;&#x2F;docs.scala-lang.org&#x2F;style&#x2F;types.html</a>).<p>&gt; Scala, for example, calls its type declarations &quot;annotations&quot;, except when they are needed to disambiguate, when they are &quot;ascriptions&quot;. So under the scala definition, python&#x27;s annotations are exactly the same as scalas as long as they are used for type checking, which, if you use mypy, they are.<p>The distinction is a lot more general: type ascriptions change the behaviour of the code while type annotations do not. So a system that only has annotations and not ascriptions is significantly more limited than a full type system that has ascriptions as well, at least in practice - in theory we can do perfect type inference (e.g. H-M), but that ignores some edge cases that are important for real-world programming e.g. handling literals in the source code.')