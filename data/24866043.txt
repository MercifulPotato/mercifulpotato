Item(by='jpeloquin', descendants=None, kids=[24867066], score=None, time=1603427361, title=None, item_type='comment', url=None, parent=24865134, text='I remember a problem similar to the one you describe when using a dot product both to substitute for a fast loop and for its normal mathematical purpose, in the same operation:<p><pre><code>  points = np.array([[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]])\n  M = np.array([[0.866, 0.5, 0], [-0.5, 0.866, 0], [0, 0, 1]])  # rotation\n  points @ M  # works\n  M @ points  # raises ValueError, also a different transform\n</code></pre>\nRegarding messing up the multiplication order, numpy by itself doesn&#x27;t have the information to raise a relevant type error, sadly.  As you probably know, based on your other comments, the important thing is whether the adjacent basis vectors (dimensions) match, not how they are written.  That is, given M = M_ij (a_i âŠ— b_j), a vector v_i a_i must be multiplied on the left, a vector v_i b_i must be multiplied on the right, and a vector v_i c_i (with basis vector c) shouldn&#x27;t be used at all.  Numpy just does array math; it doesn&#x27;t keep track of dimensions.  Hopefully the code has accurate comments, or you&#x27;re using a language with a decent type checker.<p>However, I think you can track dimensional compatibility using xarray:<p><pre><code>  import xarray as xr\n  import numpy as np\n  points = xr.DataArray([[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]], dims=(&quot;idx&quot;, &quot;a&quot;))\n  M = xr.DataArray([[0.154, 0.988, 0], [-0.988, 0.154, 0], [0, 0, 1]], dims=(&quot;a&quot;, &quot;b&quot;))  # rotation\n  points.dot(M)  # works\n  M.dot(points)  # also works\n  # M&#x27;s a-dim is matched to point&#x27;s a-dim, so both\n  # results have same values regardless of\n  # multiplication order, just transposed.\n  assert np.all(points.dot(M).T == points.dot(M))\n</code></pre>\nI only just tried xarray in response to your post, so not sure if there are pitfalls in practice, or if this is the best way to use it.')