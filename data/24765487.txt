Item(by='lmilcin', descendants=None, kids=[24765958, 24766908, 24771189, 24766937], score=None, time=1602596731, title=None, item_type='comment', url=None, parent=24765192, text='So one of the applications I have worked with was an embedded credit card terminal app which needed a transactional database. Since I could not find a product that would fit all requirements I decided to write one.<p>Now, you can imagine smart algorithms, trees, hashes...<p>Nothing of that sort. The database was written as append only transactional log. To retrieve data, entire file was scanned for initial record and all its updates. No indexes. Some algorithms were plainly O(n^3).<p>Yeah, I got into many heated discussions with &quot;computer scientists&quot; in the team. Yet for all their might they were not able to improve upon the program because they forget that algorithmic complexity is only one factor of performance.<p>Because I used extremely simple algorithms (like linear search) the operations were very simple and progressed quite fast on a CPU that was good at prefetching from the storage.<p>The total amount of memory available was just 0,5MB meaning that the &quot;super inefficient&quot; scans still completed within perception threshold of the user.<p>While O(n^3) was used for some operations, the application state machine which limited number of actual number of steps. Most transactions follow same basic pattern of execution and so I don&#x27;t care what happens when somebody does 500 updates to the transaction when I can figure out there will ever be 5 state changes at most.<p>There were other consideration for the program. For example, it had to use very little instructions (we were very short on space) and it had to work in constant memory (to be able to statically calculate stack space necessary, for example).')