Item(by='qppo', descendants=None, kids=[24992197, 24992173, 24992268, 24992178, 24992270, 24992568], score=None, time=1604517563, title=None, item_type='comment', url=None, parent=24991848, text='If you&#x27;re writing async code you don&#x27;t need to worry about pinning unless you&#x27;re manually writing futures or designing an executor. But if you are curious, this chapter explains it pretty good:<p><a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;async-book&#x2F;04_pinning&#x2F;01_chapter.html" rel="nofollow">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;async-book&#x2F;04_pinning&#x2F;01_chapter...</a><p>&gt; Apparently, recursion adds a new level of complexity to async.<p>It really doesn&#x27;t - it&#x27;s just some users may be surprised by the lack of magic when it comes to Rust. Async is implemented with futures, futures are types, and you can&#x27;t recursively define a type without boxing.<p>&gt; Apparently, this boxing and pinning is what you get when you don&#x27;t have a GC, and that when you do have a GC, you simply don&#x27;t need to deal with it. So that was the final straw for me.<p>It&#x27;s kind of weird to me that language developers would pass on Rust because they don&#x27;t understand memory management. How is memory going to be managed in Dark? If it&#x27;s GC&#x27;d, how is that implemented?')