Item(by='jorangreef', descendants=None, kids=None, score=None, time=1610795714, title=None, item_type='comment', url=None, parent=25801211, text='Having worked on hash table implementations in C, and having done everything to minimize cache misses, e.g. using tiny 8-bit bloom filters within a cache line to avoid further cache line probes, I now prefer Zig to C, because I believe it makes memory alignment far more explicit in the type system.<p>You can even align the stack memory for a function and this is all upfront in the documentation. You don&#x27;t need arcane compiler specific pragmas. Zig just makes it easy. Zig&#x27;s alignment options are so powerful and neat and available compared to C, right down to allocations with custom alignments, and all first class at the language level. Compare that with C&#x27;s malloc() and posix_memalign(). Implementing a Direct IO system in Zig recently was also a breeze.<p>I also appreciate Zig&#x27;s approach to memory management, where even the choice of allocator is considered important, and for things like async&#x2F;await, Zig&#x27;s explicitness around memory requirements is brilliant. Zig&#x27;s @frameSize builtin (<a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;0.7.1&#x2F;#frameSize" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;0.7.1&#x2F;#frameSize</a>) will tell you exactly how much memory a whole chain of functions will need to run async, including their stack variables. You can even choose where you want their async frames to be stored: global, heap or stack.<p>Again and again, Zig&#x27;s design decisions have just been spot on. Huge kudos to Andy Kelley and the Zig communities.')