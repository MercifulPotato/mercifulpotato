Item(by='chubot', descendants=None, kids=None, score=None, time=1604251143, title=None, item_type='comment', url=None, parent=24960816, text='Hm that&#x27;s interesting, actually the paper  is sort of wishy-washy about the contribution?  It doesn&#x27;t claim that ropes are faster.<p>It claims that they make systems &quot;more robust&quot;.  I think they basically mean that certain apps that use long strings are less likely to run out of memory.<p>I guess my response is that I don&#x27;t think Python or JS really need native ropes, even for string heavy workloads like templating: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24960806" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=24960806</a><p>(Also, I would expect penalties of pointer chasing and thus ropes to be much more severe in 2020 vs. 1995, like maybe 10x more?)<p><i>We claim that the traditional implementations ofstrings, and often the supported functionality, are not well suited to such general-purpose use.They should be confined to applications with specific, and unusual, performance requirements.We present ‘ropes’ or ‘heavyweight’ strings as an alternative that, in our experience leads to systems that are more robust, both in functionality and in performance.</i><p>Conclusion:<p><i>It is not clear whether the implementation we suggested above is in any senseoptimal. However, it performs sufficiently well for our purposes, and sufficientlywell that for most purposes it is preferred over traditional ‘flat’ string representations.Our experience has been that it results in software that is noticeably more robust,particularly in that it scales correctly to unexpectedly large inputs.</i><p>edit: I guess they are making a computational complexity claim then?  But again I would say it&#x27;s a common idiom in Python and JS to append to a list and join().  At least now it is, maybe in 1995 programmers weren&#x27;t used to that idiom.')