Item(by='pron', descendants=None, kids=[25570867], score=None, time=1609254354, title=None, item_type='comment', url=None, parent=25570298, text='How did he underestimate statistical machine learning? Whatever achievements were made, they did not take place within a decade, nor have they reduced the <i>overall</i> cost of programming by 10x even after more than three decades.<p>And, indeed, the one thing that Brooks presented as being the most promising direction, i.e. buy vs. build. He said that unlike changes to programming languages and methodology that wouldn&#x27;t give a huge boost, buy vs. build <i>might</i> (although he wasn&#x27;t sure about that). So he was exactly right about that.<p>Also, 1986 wasn&#x27;t 1966. In 1986 people didn&#x27;t write simple software in COBOL. They used things like Magic and Business Basic and even Smalltalk, and, shortly after, Visual Basic and Access. Excel was released in 1987, and we had spreadsheets in the early 80s, too (and Brooks explicitly mentions them in No Silver Bullet). RAD tools and &quot;no code&quot; was very much in vogue in the late 80s and early 90s. That was Brooks&#x27;s present, not future. He even says that <i>this</i> is the right direction:<p><i>I believe the single most powerful software-productivity strategy for many organizations today is to equip the computer-naive intellectual workers who are on the firing line with personal computers and good generalized writing, drawing, file, and spreadsheet programs and then to turn them loose. The same strategy, carried out with generalized mathematical and statistical packages and some simple programming capabilities, will also work for hundreds of laboratory scientists.</i><p>When generalised, Brooks&#x27;s prediction amounts to expecting diminishing returns due to reduction of accidental complexity, and we&#x27;re seeing exactly that.<p>&gt;  I&#x27;d argue we did get 10x improvement -- if -- we hold the size &amp; complexity of the system constant.<p>Only if we do the one thing Brooks says would work: Buy vs. Build. When we write from scratch -- no way. Even then, I think that while we may see a 10x reduction for specific simple task, we won&#x27;t see it for large, complex software, which is where most of the effort in software is invested.')