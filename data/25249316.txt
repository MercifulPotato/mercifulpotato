Item(by='bmitc', descendants=None, kids=None, score=None, time=1606694453, title=None, item_type='comment', url=None, parent=25246581, text='I don&#x27;t think there&#x27;s an easy answer to this question. Software engineers still don&#x27;t know how to exactly or even efficiently communicate with each other. It&#x27;s still an evolving field and process. In general, it is helpful to understand software development as a sub-field of systems theory and design, so any book that discusses systems should help one better understand software development.<p>In general, I do also echo some of the other comments. If you are helping to design the app, you shouldn&#x27;t necessarily need to understand the implementation details. In my experience, clients, whether they be external or internal or colleagues, getting too involved into what they think the implementation should be is usually a disaster. It puts pressure on the system to conform to how they think it should be, which is usually not necessarily how it should be, and it basically adds unnecessary constraints. The real constraints should be what the software should do and specifications on that, including how the software is intended to be maintained and extended.<p>Some thoughts on some specific courses and books that I think would be helpful to better understand the goals of software development and design and ways to think about it all:<p><i>Programming for Everyone - An Introduction to Visual Programming Languages</i>: <a href="https:&#x2F;&#x2F;www.edx.org&#x2F;course&#x2F;programming-for-everyone-an-introduction-to-visual" rel="nofollow">https:&#x2F;&#x2F;www.edx.org&#x2F;course&#x2F;programming-for-everyone-an-intro...</a><p>I think this course should be taken by managers, designers, and even software engineers. The primary result is that you&#x27;ll come out of it knowing state charts, which are an extension to state machines, and this will be very useful for <i>thinking</i> about software and <i>organizing</i> what the software should do. Handling state is one of the primary problems in software, and you might notice that all of the various paradigms (OOP, functional, imperative, actors, etc.) in computer programming relate to the various ways people think about handling state in a computing system.<p><i>How to Code: Simple Data and Complex Data</i>:<p><a href="https:&#x2F;&#x2F;www.edx.org&#x2F;course&#x2F;how-to-code-simple-data" rel="nofollow">https:&#x2F;&#x2F;www.edx.org&#x2F;course&#x2F;how-to-code-simple-data</a><p><a href="https:&#x2F;&#x2F;www.edx.org&#x2F;course&#x2F;how-to-code-complex-data" rel="nofollow">https:&#x2F;&#x2F;www.edx.org&#x2F;course&#x2F;how-to-code-complex-data</a><p><a href="https:&#x2F;&#x2F;www.edx.org&#x2F;micromasters&#x2F;ubcx-software-development" rel="nofollow">https:&#x2F;&#x2F;www.edx.org&#x2F;micromasters&#x2F;ubcx-software-development</a><p>These courses are taught by a designer of the Common Lisp language and based upon the excellent book <i>How to Design Programs</i>. It is essentially a language agnostic course that uses Racket to build up design paradigms that teaches you how to sort out your domain problem and designs into data and functions that operate on that data. The courses are part of a MicroMasters program, so if you really want to get into Java, that is taught in the follow-on courses.<p>Based upon your last comment, here are some book suggestions on how computers work:<p><i>Code: The Hidden Language of Computer Hardware and Software</i>: <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Code-Language-Computer-Hardware-Software&#x2F;dp&#x2F;0735611319&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Code-Language-Computer-Hardware-Softw...</a><p><i>The Pattern On The Stone: The Simple Ideas That Make Computers Work</i>: <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Pattern-Stone-Computers-Science-Masters&#x2F;dp&#x2F;0465066933&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Pattern-Stone-Computers-Science-Maste...</a><p><i>But How Do It Know? - The Basic Principles of Computers for Everyone</i>: <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;But-How-Know-Principles-Computers&#x2F;dp&#x2F;0615303765&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;But-How-Know-Principles-Computers&#x2F;dp&#x2F;...</a><p><i>The Elements of Computing Systems: Building a Modern Computer from First Principles</i>: <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Elements-Computing-Systems-Building-Principles&#x2F;dp&#x2F;0262640686&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Elements-Computing-Systems-Building-P...</a>')