Item(by='dmitriid', descendants=None, kids=[25015907], score=None, time=1604762609, title=None, item_type='comment', url=None, parent=25015423, text='&gt; How are GET requests a crutch?<p>They were not in the original spec IIRC. URL&#x27;s are limited in legth (it&#x27;s not in the spec, but most clients have a limit) etc.<p>&gt; Which is what any caching proxy must do anyway?<p>Nope. A caching proxy can benefit from HTTP Cache Headers [1]. But cache headers don&#x27;t work well with GraphQL&#x27;s GET requests, and don&#x27;t work at all with the default, which is POST.<p>&gt;  This problem is not limited to GraphQL, it&#x27;s a generic authorization problem.<p>GraphQL makes it significantly more complex though. Because your requests are ad-hoc.<p>&gt; You don&#x27;t have to build a complexity analyzer or figure out recursion levels, there are already tools that do that for you.<p>Indeed. By adding more and more complexity. And no, tools only solve a part of the problem. Simply a dataloader on a server doesn&#x27;t entirely solve the N+1 problem.<p>&gt;  But you can go another way and just create a list of approved queries.<p>Turning it into REST with none of the benefits of REST.<p>&gt; Usually? That&#x27;s just speculation. And that&#x27;s entirely on the implementation of that service<p>It&#x27;s not speculation. That&#x27;s the main use case for GraphQL. But even if you just slap it on top of a single database, you still have the problem of ad-hoc queries hammering your database.<p>[1] <a href="https:&#x2F;&#x2F;www.keycdn.com&#x2F;blog&#x2F;http-cache-headers" rel="nofollow">https:&#x2F;&#x2F;www.keycdn.com&#x2F;blog&#x2F;http-cache-headers</a>')