Item(by='zackmorris', descendants=None, kids=None, score=None, time=1612045589, title=None, item_type='comment', url=None, parent=25973385, text='Oh man, reading what you wrote out, it just occurred to me that learning is actually caching.<p>We already have a multitude of machines that can solve any problem: the global economy, corporations, capitalism (Darwinian evolution casted as an economic model), organizations, our brains, etc.<p>So take an existing model that works, convert it to code made up of the business logic and tests that we write every day, and start replacing the manual portions with algorithms (automate them). The &quot;work&quot; of learning to solve a problem is the inverse of the solution being taught. But once you know the solution, cache it and use it.<p>I&#x27;m curious what the smallest fully automated model would look like. We can imagine a corporation where everyone has been replaced by a virtual agent running in code. Or a car where the driver is replaced by chips or (gasp) the cloud.<p>But how about a program running on a source code repo that can incorporate new code as long as all of its current unit tests pass. At first, people around the world would write the code. But eventually, more and more of the subrepos would be cached copies of other working solutions. Basically just keep doing that until it passes the Turing test (which I realize is just pass√© by today&#x27;s standards, look at online political debate with troll bots). We know that the compressed solution should be smaller than the 6 billion base pairs of DNA. It just doesn&#x27;t seem like that hard of a problem. Except I guess it is:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;opencog&#x2F;opencog" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;opencog&#x2F;opencog</a>')