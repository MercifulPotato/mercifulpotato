Item(by='hardwaresofton', descendants=None, kids=None, score=None, time=1610418622, title=None, item_type='comment', url=None, parent=25733309, text='I think saying &quot;packages&quot; was an error on my part, because how this is different from the usual C++&#x2F;other language example is that Haskell is a ML language, and gives you a <i>lot</i> of abstractions (rather than packages per say) to use. Generally using packages in haskell is easy because you don&#x27;t care what abstraction they were written in (almost always IO is there somewhere, or they offer a doTheThingIO function which is the lowest common denominator), and if they&#x27;re completely functional libraries then it <i>really really</i> doesn&#x27;t matter.<p>The commenter was railing against the abstractions the codebases used, not the underlying packages actually. I don&#x27;t want to get into explaining it, but it is very easy to write production-ready simple haskell, but also very easy to spend hours building abstractions in the type system (normally) to build yourself a straight jacket. OK so if I explain it a little bit, there are at least three ways that have surfaced in recent time (lets say the last 5 years) on ways to structure large effectful haskell codebases (which is most software you&#x27;d want to write).<p>- Everything in IO (just do everything in the IO monad)<p>- monad stacks &amp; transformers<p>- The ReaderT pattern<p>- Effects (free&#x2F;freer, polysemy, fused-effects, etc)<p>All of these approaches have high quality libraries to support their use, but you could stay at that first one (everything in simple IO) and be very happy for a very long time.<p>I&#x27;d argue that C++&#x27;s problematic features are of a different nature -- when one of them goes wrong you normally have a much more disastrous outcome (whether at runtime or when you&#x27;re trying to grok the code). For example compare C++&#x27;s templating system to haskell&#x27;s support of generics for example, one is infinitely safer to approach and easier to understand than the other for the simple case, due to how the languages are built (i.e. no inheritance). Haskell it&#x27;s more up to you to strangle yourself with the complexity -- the <i>necessary</i> abstractions are pretty simple (typeclasses, monads are simple in use, if not in concept), but the <i>unnecessary</i> abstractions basically scale to PhD.<p>I will absolutely concede that Haskell does encourage you to reach for higher and higher levels of abstraction for diminishing returns. But I will take Haskell&#x27;s abstractions over Java&#x27;s abstractions any day of the week, even though Haskell&#x27;s can be more inscrutable.')