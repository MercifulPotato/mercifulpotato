Item(by='joshuamorton', descendants=None, kids=[24704390], score=None, time=1602018887, title=None, item_type='comment', url=None, parent=24695007, text='&gt; You&#x27;re trying to gloss over everything as &quot;removing ambiguity&quot;, but by that logic any change to a program is just &quot;removing ambiguity&quot;. In general there are other possible ascriptions for a given term that would form valid programs, and in general those programs could have arbitrarily different behaviour from the program in question.<p>I&#x27;m not, for what it&#x27;s worth. There are cases where you could argue that type annotations are just removing &quot;ambiguity&quot; (the type system is successfully inferring, you place an annotation that agrees with the inference, or a stricter annotation that still checks successfully). I can see how this is an ambiguity, but it isn&#x27;t what I meant.<p>But scala&#x27;s definition of ascriptions are for places where the type system can&#x27;t figure something out, and needs extra information to successfully check. More powerful type inference might address these issues (most common languages don&#x27;t use H-M). Ambiguity was perhaps the wrong word to use. &quot;aren&#x27;t able to infer things on their own&quot; is maybe the more important bit.<p>Type ascriptions don&#x27;t &quot;change&quot; behavior, because there wasn&#x27;t valid behavior without them. The type system failed to check (but again, different inference algorithms might be able to get around this)')