Item(by='elihu', descendants=None, kids=None, score=None, time=1603679452, title=None, item_type='comment', url=None, parent=24891766, text='&gt; Are you familiar with unsafe IO?<p>&gt; It&#x27;s used pervasively in low-level code because the idealism of monads just doesn&#x27;t cut it. In my opinion, this proves that the pragmatism of side effects is a necessary evil for actually getting things done in a performant way.<p>It seems like you aren&#x27;t very familiar with the ways Haskell programmers deal with side effects and mutation.  UnsafePerformIo is sometimes needed, and there are a few common idiomatic ways to use it, but there are usually better options.  What at first looks like an impenetrable wall between the IO monad and pure code is actually surprisingly permeable, just not (usually) in ways that violate expected semantics.  For instance, you can read a file into a string in the IO monad and pass the string into pure code to process it.  The string is lazy, so the pure code actually triggers the file to be read as it&#x27;s consumed.<p>Another escape hatch is the ST Monad.  It allows you to run imperative computations (i.e. use mutable variables and arrays) within pure code.  Since the ST computations are deterministic, they don&#x27;t violate any important guarantees about pure code.  You can&#x27;t read and write files from the ST Monad, but if you want to do array-based quicksort or something similar it&#x27;s available.<p>Some aspects of Haskell are hard to work with.  You&#x27;re right that laziness introduced some performance issues that can be tedious to fix, and some of the libraries are hard to use.  However, it&#x27;s a perfectly reasonable tool for many general-purpose programming applications.  It&#x27;s not a replacement for C, but you could say the same thing about C# or Java or any other language with a garbage collector.<p>(edit: fixed grammar typo)')