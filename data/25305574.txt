Item(by='sideeffffect', descendants=None, kids=[25306388], score=None, time=1607104859, title=None, item_type='comment', url=None, parent=25301549, text='&gt; Scala&#x2F;Haskell&#x27;s IO type<p>Since you&#x27;ve brought out Haskell&#x27;s IO and Scala libraries&#x27; IOs (Monix, ZIO, Cats Effect), or F#&#x27;s Async, I think it&#x27;s worthwhile to point out how they&#x27;re different from the async-await approach that&#x27;s in C#&#x2F;Kotlin&#x2F;Rust&#x2F;etc.<p>They both require &quot;special&quot; handling -- in C# it&#x27;s the `async`&#x2F;`await` syntax, in Scala it&#x27;s the flatMap function or for-comprehension -- there they are similar. But their meaning is different. IO&#x2F;Task in Scala doesn&#x27;t represent a possibly started and under-way computation; it represents a &quot;dead&quot; program, yet to be started, a mere value. And it has all the advantages that mere values have, like refactoring (extract variable, ...) or restarting in case or failure and so on. Pass it into a method, return it from a method, store it in a data structure&#x2F;collection, create `IO[IO[X]]`, whatever you want, just like you would with `Option[X]` or `List[X]`. In Scala, you have to differentiate between `A =&gt; B` and `A =&gt; IO[B]`, because `B` and `IO[B]` are different, but both are still values. Your program then ends up being this one big IO&#x2F;Task value, which is then executed &quot;at the end of the world&quot;. These pictures illustrate it quite well:<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;impurepics&#x2F;status&#x2F;1182946618280153094" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;impurepics&#x2F;status&#x2F;1182946618280153094</a><p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;impurepics&#x2F;status&#x2F;1180064851219144704" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;impurepics&#x2F;status&#x2F;1180064851219144704</a><p>On the other hand, async-await has none of the benefits, only downsides. You get functions of two colors, but no benefit in return. It&#x27;s justifiable in Rust, because Rust aims for zero-cost abstractions. But for Kotlin&#x2F;C#, it&#x27;s a sad choice.<p>The Loom approach for Java is a reasonable one. No async-await shenanigans, no funny FP&#x2F;Haskell&#x2F;IO business. You just use threads for concurrency as God intended them and you can have gazillions of them, because they are M:N. And I respect that, even though I&#x27;m partial to IO&#x2F;Task for the reasons outlined above.')