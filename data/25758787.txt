Item(by='dragontamer', descendants=None, kids=[25758982], score=None, time=1610518138, title=None, item_type='comment', url=None, parent=25758676, text='Kogge-Stone proved that ANY associative function can be parallelized with a prefix-sum arrangement. Associative defined as in f(f(x, y), z) == f(x, f(y, z)... or more commonly (A+B) + C == A + (B+C), where + is any associative operator)<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Prefix_sum" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Prefix_sum</a><p>In particular, this arrangement: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Prefix_sum#&#x2F;media&#x2F;File:Hillis-Steele_Prefix_Sum.svg" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Prefix_sum#&#x2F;media&#x2F;File:Hillis-...</a><p>Now &quot;add&quot; (or +) is associative. But it also works for *, min, max, and even weird stuff like &quot;Can the Bishop move here&quot; or &quot;Can the Rook move here&quot;. So the goal is to find an associative operator that you apply byte-per-byte.<p>------<p>Okay, a brief detour. It seems obvious to me that a finite-state machine can decode x86 byte-by-byte. FSM is the &quot;obvious&quot; sequential algorithm that determines whether the byte is the start-of-instruction, or the middle-of-instruction, as well as what instruction it is by the end.<p>Remember: we&#x27;re just trying to make a FSM decode ONE instruction right now. That&#x27;s pretty obvious how to do that. (Alternatively, imagine a RegEx that can parse an instruction from the bytestream when given the start-of-instruction. All Regular-expressions have a finite-state-machine representation).<p>Hillis &#x2F; Steele proved that finite-state machines are associative operators (!!!), and therefore can be used in parallel-prefix sum arrangements. (<a href="http:&#x2F;&#x2F;uenics.evansville.edu&#x2F;~mr56&#x2F;ece757&#x2F;DataParallelAlgorithms.pdf" rel="nofollow">http:&#x2F;&#x2F;uenics.evansville.edu&#x2F;~mr56&#x2F;ece757&#x2F;DataParallelAlgori...</a>)<p>The page number is 1176:<p>&gt; Since this composition operation is associative, we may compute the automaton state after every character in a string as follows:<p>&gt; 1. Replace every character in the string with the array representation of its state-to-state function.<p>&gt; 2. Perform a parallel-prefix operation. The combining function is the composition of arrays as described above. The net effect is that, after this step, every character c of the original string has been replaced by an array representing the state- to-state function for that prefix of the original string that ends at (and includes) c.<p>&gt; 3. Use the initial automaton state (N in our example) to index into all these arrays. Now every character has been replaced by the state the automaton would have after that character.<p>In short: computing the &quot;state&quot; of a sequential FSM applied across its inputs can be EASILY performed in parallel through the prefix-sum model.<p>Any finite state machine can be converted into parallel prefix form through this mechanism.<p>&quot;Work Efficient&quot; Parallel Prefix arrangement is O(log(n)) depth and O(n) total elements, which means that parallel decoding to any width (ie: 8-way decoder, 16-way decoder, or even 1024-way decoder) is LINEAR in terms of power-consumption and O(log(n)) with respect to time.<p>The layout for work-efficient Parallel Prefix is: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Prefix_sum#&#x2F;media&#x2F;File:Prefix_sum_16.svg" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Prefix_sum#&#x2F;media&#x2F;File:Prefix_...</a>')