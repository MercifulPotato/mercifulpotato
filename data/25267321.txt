Item(by='bityard', descendants=None, kids=[25267902, 25272772, 25267764], score=None, time=1606843482, title=None, item_type='comment', url=None, parent=25266699, text='&gt; That feels like a niche use case to me.<p>I wouldn&#x27;t call it a niche use case at all, it&#x27;s exactly how the software for all major Linux and BSD operating systems are packaged and built.<p>For example, when (not if) a vulnerability is found in OpenSSL, package maintainers just commit an update to the openssl package and users only have to download and install one package to patch their system against the vulnerability.<p>Contrast with a fully-static OS and applications: the maintainers would have to update the openssl package, rebuild it, and then also rebuild _every single other program_ that relies on it as well. On my system, that&#x27;s 123 packages. I don&#x27;t have all of those installed, but as a user, it means I would have to download new full copies of around a dozen packages to patch one flaw in one package.<p>And of course, the packages themselves are much _much_ larger too. Most software that I can install as a flatpack or appimage are at least an order of magnitude larger than the deb version, take longer to start, and also take up more valuable RAM when running.<p>Proponents of static linking have generally experienced the pain of dynamically-linked software either through container deployment or by accidentally messing up their system with third-party packages and repos and the like. I get it, I have been there too. But even through managing a dynamically linked system is certainly more complex, it brings a lot of benefits to the table.')