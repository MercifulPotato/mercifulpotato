Item(by='kcartlidge', descendants=None, kids=None, score=None, time=1612124918, title=None, item_type='comment', url=None, parent=25976719, text='I agree. With you <i>and</i> with the other opinions (why should only one perspective be right?).<p>I&#x27;ve been the lead developer on teams where I introduced Docker to solve consistency&#x2F;reproducibility issues in AWS and Azure.<p>I&#x27;ve also done smaller applications in DotNet Core, Go, Node, Python, and Ruby. In those cases I&#x27;ve use other alternatives, <i>including</i>:<p>- Known Linux version, with git push-to-deploy (my favourite)<p>- Packer (the server), with embedded codebase (still quite simple)<p>- Docker (for most non-trivial deployments)<p>- Known Linux version, with chef or ansible (as an alternative to Docker)<p>- Terraform the machine, upload the codebase, run scripts on the server (ugh)<p>Every method had it&#x27;s place, time, and reason. If possible, for simplicity, I&#x27;d go with the first option every time and then the others in that order.<p>The thing is, though, I may have an order of preference but that is <i>totally</i> overridden by the requirements of the project and whether or not the codebase is ever to be shared.\nFor solo projects and small sites, I&#x27;ve not benefited from Docker as I have never had any server&#x2F;OS issues (and I&#x27;ve been doing dev stuff for decades).<p>However the moment there was a need for collaborators or for pulling in extra dependencies (and here is the crunch point for me) such as headless browsers or other such &#x27;larger&#x27; packages, then I would move on to either Packer&#x2F;Terraform for fairly slow-changing deployment targets or Docker for fast-changing targets, as otherwise I inevitably started to find subtle issues creeping in over time.<p>In other words keep it simple while (a) you can and (b) you don&#x27;t need to share code, but complexity inevitably changes things.')