Item(by='jdblair', descendants=None, kids=[24802025], score=None, time=1602843256, title=None, item_type='comment', url=None, parent=24785405, text='This isn&#x27;t explicitly related, but interesting, so I offer it up here.<p>When I read 40ms, it triggered a memory from tracking down a different 40ms latency bug a few years ago. I work on the Netflix app for set top boxes, and a particular pay TV company had a box based on AOSP L. Testing discovered that after enough times switching the app between foreground and background, playback would start to stutter. The vendor doing the integration blamed Netflix - they showed that in the stutter case, the Netflix app was not feeding video data quickly enough for playback. They stopped their analysis at this point, since as far as they were concerned, they had found the issue and we had to fix the Netflix app.<p>I doubted the app was the issue, as it ran on millions of other devices without showing this behavior. I instrumented the code and measured 40ms of extra delay from the thread scheduler. The 40ms was there, and was outside of our app&#x27;s context. Literally, I measured it between the return of the thread handler and the next time the handler was called. So I responded, to paraphrase, its not us, its you. Your Android scheduler is broken.<p>But the onus was on me to prove it by finding the bug. I read the Android code, and learned Android threads are a userspace construct - the Android scheduler uses epoll() as a timer and calls your thread handler based on priority level. I thought, epoll() performance isn&#x27;t guaranteed, maybe something obscure changed, and this change is adding an additional 40ms in this particular case. So I dove into the kernel, thinking the issue must be somewhere inside epoll().<p>Lucky for me, another engineer, working for a different vendor on the project, found the smoking gun in this patch in Android M (the next version). It was right there, an extra 40ms explicitly (and mistakenly) added when a thread is created while the app is in the background.<p><a href="https:&#x2F;&#x2F;android.googlesource.com&#x2F;platform&#x2F;system&#x2F;core&#x2F;+&#x2F;4cdce42%5E%21&#x2F;#F0" rel="nofollow">https:&#x2F;&#x2F;android.googlesource.com&#x2F;platform&#x2F;system&#x2F;core&#x2F;+&#x2F;4cdc...</a><p><pre><code>  Fix janky navbar ripples -- incorrect timerslack values\n  \n  If a thread is created while the parent thread is &quot;Background&quot;,\n  then the default timerslack value gets set to the current\n  timerslack value of the parent (40ms). The default value is\n  used when transitioning to &quot;Foreground&quot; -- so the effect is that\n  the timerslack value becomes 40ms regardless of foreground&#x2F;background.\n  \n  This does occur intermittently for systemui when creating its\n  render thread (pretty often on hammerhead and has been seen on\n  shamu). If this occurs, then some systemui animations like navbar\n  ripples can wait for up to 40ms to draw a frame when they intended\n  to wait 3ms -- jank.\n  \n  This fix is to explicitly set the foreground timerslack to 50us.\n  \n  A consequence of setting timerslack behind the process&#x27; back is\n  that any custom values for timerslack get lost whenever the thread\n  has transition between fg&#x2F;bg.\n  \n\n  --- a&#x2F;libcutils&#x2F;sched_policy.c\n  +++ b&#x2F;libcutils&#x2F;sched_policy.c\n  @@ -50,6 +50,7 @@\n   \n   &#x2F;&#x2F; timer slack value in nS enforced when the thread moves to background\n   #define TIMER_SLACK_BG 40000000\n  +#define TIMER_SLACK_FG 50000\n   \n   static pthread_once_t the_once = PTHREAD_ONCE_INIT;\n   \n  @@ -356,7 +357,8 @@\n                              &amp;param);\n       }\n   \n  -    prctl(PR_SET_TIMERSLACK_PID, policy == SP_BACKGROUND ? TIMER_SLACK_BG : 0, tid);\n  +    prctl(PR_SET_TIMERSLACK_PID,\n  +          policy == SP_BACKGROUND ? TIMER_SLACK_BG : TIMER_SLACK_FG, tid);\n   \n       return 0;</code></pre>')