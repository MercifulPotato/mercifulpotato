Item(by='TrueDuality', descendants=None, kids=[24944735], score=None, time=1604073836, title=None, item_type='comment', url=None, parent=24941272, text='The biggest one first: Operationally maintaining the JVM is a nightmare. It can be fast, but that isn&#x27;t guaranteed and its not trivial to find out why, and easy for developers to mess up. It uses significantly more memory than anything else which will be your largest cost driver when running large services, compute is cheap, RAM is not.<p>Security is probably the next biggest one. Vulnerabilities in the JVM are a problem but you&#x27;ll have that in most software (given maybe only Flash beats the JVM in the history of boths existence) but the defaults for running a lot of things like groovy aren&#x27;t secure (there is a debug port you can directly manipulate the memory of the running process without authentication). Commonly people use these debug ports in production, not just leave the defaults but actively choose to let them run. This is a very common pattern in Java based services usually caused by my first point. I am not aware of any other language or framework that offers remote memory access as a feature.<p>Then there are the dependencies and package ecosystem. I believe the &quot;built on the JVM&quot; languages like Kotlin have gotten a lot better at this, but as soon as you start tapping into the pure Java &quot;enterprise grade&quot; libraries you&#x27;re most likely bringing in way more than you bargained for both in terms of complexity, maintainability, and security. A lot of those libraries are simply poorly built.')