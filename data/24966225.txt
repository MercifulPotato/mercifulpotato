Item(by='pron', descendants=None, kids=None, score=None, time=1604309993, title=None, item_type='comment', url=None, parent=24963711, text='&gt; but I really think anybody who has all those prerequisites could also learn enough type theory to write specifications in a couple hours because you don&#x27;t actually need a deep understanding of type theory to use it<p>That has not been my experience. Typed formalisms have further complications with &quot;partial&quot; functions -- either they&#x27;re actually partial, which is a rather complex concept, or you need refinement types to define them, as well as with constructive mathematics, which isn&#x27;t necessary for specification. Plus, what are you going to do with your specifications after a few hours if you can&#x27;t write proofs after few hours (or a few days)? And because of that the tutorials don&#x27;t and won&#x27;t just teach specification first and proof later -- as the TLA+ tutorials do -- so even if this were hypothetically true, you have nowhere to learn things like that. Lean has very good tutorials, and you can compare how far they get how quickly with the TLA+ tutorials. I don&#x27;t know if it&#x27;s even possible to teach such formalisms the same way as TLA+, but even if it were possible, I haven&#x27;t seen such tutorials. Those languages are so infused with their formalism&#x27;s proof theory that it&#x27;s hard to separate the two [1]. For example, most typed formalisms define integer division by zero to equal zero. Suppose they didn&#x27;t, and they wanted to teach how to define division &quot;properly&quot;. How much would a student need to know in order to define and use the div function? OTOH, TLA+ handles partiality in what I think is a simpler way, with a careful definition of Hilbert&#x27;s epsilon operator (see <a href="https:&#x2F;&#x2F;pron.github.io&#x2F;posts&#x2F;tlaplus_part2#the-choose-operator-and-the-meaning-of-undefined" rel="nofollow">https:&#x2F;&#x2F;pron.github.io&#x2F;posts&#x2F;tlaplus_part2#the-choose-operat...</a>)<p>Finally, most specifications people in industry are interested in are not of sequential algorithms but concurrent ones, which you also can&#x27;t do after a few hours (or a few days).<p>&gt; In my experience people pick up Isabelle (&#x2F;HOL) really quickly<p>Depends what you mean by &quot;really quickly.&quot; Isabelle has some accidental complications such as the nested languages. But I think something like Why3 can be picked up quickly, although it doesn&#x27;t handle concurrency easily.<p>&gt; Not being able to specify the type of u in Lean might seem kinda cheaty, but I&#x27;d say that&#x27;s similar to how one declares generic type parameters in e.g. Java. You wouldn&#x27;t say that those languages&#x27; generic functions aren&#x27;t actually functions, would you?<p>The type system in Java or Haskell cannot be used as a sound mathematical foundation, so whatever I call those things it would mean something quite different from maths functions. I call them subroutines, but those that call them functions know (I hope) that they&#x27;re overloading the term. In any event, students that do learn simply typed lambda calculus learn it in the context of programming languages whose type systems are inconsistent and they certainly don&#x27;t learn how to do maths with them.<p>Anyway, `id` is not a function in Lean because the universe argument doesn&#x27;t have a type. But I wonder, in Agda, is `id id` some object even when a specific universe cannot be inferred? If so, how does Agda avoid Russel&#x27;s paradox?<p>[1]: Which I think is a big problem. The clean separation of model and proof is an important property of a formal logic designed for ease of learning, expression and comprehension, and we must not forget that ease of learning, expression, and comprehension -- so that <i>practitioners</i> rather than logicians will be able to make everyday use of it -- has been a central goal of formal logic since at least Frege, if not Boole or even Leibniz, equal in importance to, if not superseding, that of mechanical proof. I might be getting carried away, but I think that TLA+ is a pretty special accomplishment in the history of formal logic in that it is perhaps the first truly rich formal logic that is commonly used by non-specialist practitioners in their day-to-day work.')