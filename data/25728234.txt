Item(by='hardwaresofton', descendants=None, kids=[25728493], score=None, time=1610369608, title=None, item_type='comment', url=None, parent=25726588, text='Haskell is an excellent language, and you are free to choose <i>not</i> to drown yourself in the most complex uses of it.<p>Haskell has the type system Java wishes it did, and half of the reason languages like Rust are interesting is because they&#x27;ve learned from Haskell (which is the <i>point</i> of Haskell, a research langage, though it happens to also be a pretty darn good language for building practical things). Simple basic data types like `Maybe t` and `Either l r` are such a revelation that you wonder how you lived without them.<p>I&#x27;ve shared this anecdote before, but Option&lt;T&gt; in Java is an example of the blub paradox[0], and discovering Haskell and finding out about Algebraic Data Types (ADTs) and the Maybe type cured my blub. The crux was this: Option&lt;T&gt;s seems to &quot;infect&quot; any codebase you use it on, because you realize that anything can fail and be null -- living in java land made it seem like it was out of place it&#x27;s actually Option&lt;T&gt; that is right -- if you allow nullable types in your code base, or you do operations that can fail, properly representing that failure is the right decision.<p>Without over stating  some of the best features of Haskell are:<p>- Compile time type checking (this cannot be understated) and non-nullable types<p>- Expressive and simple data type creation via `data`, `type`<p>- An excellent system for attaching functionality and composing functionality to data types via `typeclass`es and `Constraint`s.<p>- An emphasis on errors as values (unfortunately exceptions are in the language too, but you can&#x27;t really stop them from existing)<p>- Forced delineation between code with side-effects and code without (this results in some complexity if you come from a world with side-effects everywhere and no control)<p>- Fantastic runtime system with good support for concurrency, parallelism and shared memory management.<p>- Very easy refactoring (if you&#x27;re not adding any complexity&#x2F;abstraction) because you can just change what you want and let the compiler guide you the rest of the way.<p>Haskell has it&#x27;s warts (hard to debug space leaks, relatively small ecosystem, the ability to drown yourself and your team in abstraction), but it&#x27;s just about the most production-ready research language I&#x27;ve seen.<p>Whether or not you like it, the likelihood it&#x27;s already improved your life in whatever language you&#x27;re using is very high.')