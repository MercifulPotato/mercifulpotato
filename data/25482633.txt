Item(by='pantelisk', descendants=None, kids=[25482944], score=None, time=1608423459, title=None, item_type='comment', url=None, parent=25480419, text='In my experience GO is not a good language for WASM. The simplest wasm binary you will create, will be at least ~3mb in size, even if it only prints &quot;hello world&quot;, because GO will need to embed its internals and the garbage collector in the wasm bundle. In a browser scenario this is not particularly attractive...<p>It&#x27;s really a pity especially since Go is marketed as &quot;a better C&quot;. So far C&#x2F;C++ has been the best optimal target for wasm.\nRust on the other hand is extremely promising but I don&#x27;t have enough experience with it or data to make a case for or against :)<p>AssemblyScript looks amazing though. One thing to consider is that many times you do not need to make your whole project in wasm. Instead you should find crucial bottlenecks (eg matrix math for light calculations, or some blur operation, or some physics calculation or whatever) and take that part out and put it in wasm. That part may already be written in JS and might be very difficult to rewrite in C (time consuming, web dev team might have weak C skills, tougher to debug). For such a scenario AssemblyScript looks fantastic, and this is actually the most common scenario I &#x27;ve personally encountered (and sometimes I &#x27;d end up writing asm.js by hand or go and recreate my logic in C...). So yeah, I have not used  AssemblyScript yet but there are many pain points that a good  implementation could blow away.<p>edit: what I describe above is for browser scenarios. I have not used wasm outside of the browser (didn&#x27;t find a reason to, since I can run native binaries compiled specifically for the target OS - why add one more layer of complexity through wasm?). So, outside of the browser, your experiences might be different.')