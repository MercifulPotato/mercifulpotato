Item(by='hardwaresofton', descendants=None, kids=None, score=None, time=1608562324, title=None, item_type='comment', url=None, parent=25493353, text='Thanks for explaining more, appreciate it and hopefully others will find this as useful as I did.<p>&gt; Performance suffers whenever any native API gets called from a JS loop, as exporting Java&#x27;s objects into JS, and accessing them is very resource intensive. The only way around it was to move loops to Java side of the code.<p>One of the gotchas around nativescript (and react native) was that trying to do intensive calcuations was never supposed to happen on the main thread. Nativescript was first to add support for background workers[0] which alleviate this.<p>I do believe of course that you found CPU intensive tasks&#x2F;looping to be slower on the JS side of things though.<p>&gt; Flutter is not much better, though feels to be a bit more professionally done. It&#x27;s too a memory hog, it&#x27;s too a CPU hog, and it&#x27;s still gets way more issues over a native app to warrant its use just for economic reasons.<p>This I&#x27;m somewhat surprised to hear, I thought it would have been way better on the memory side of things since Flutter is essentially a rebuild-the-world approach.<p>&gt; RN also shares the same Java-JS interop issues as NS.<p>This is inline with what I expected -- the thing about RN when I tried it was that it just didn&#x27;t <i>have</i> the ability to access native objects from JS as if they were JS objects. Maybe that&#x27;s changed since I last tried it.<p>[0]: <a href="https:&#x2F;&#x2F;docs.nativescript.org&#x2F;core-concepts&#x2F;multithreading-model" rel="nofollow">https:&#x2F;&#x2F;docs.nativescript.org&#x2F;core-concepts&#x2F;multithreading-m...</a>')