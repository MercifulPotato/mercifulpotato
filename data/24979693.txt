Item(by='Diggsey', descendants=None, kids=[24982655, 24979741], score=None, time=1604412013, title=None, item_type='comment', url=None, parent=24979097, text='The &quot;Colored function problem&quot; is a complete fallacy: aside from the fact that async and non-async fns <i>are</i> interoperable in Rust (block_on) and other languages, the same argument could be made against functions with <i>any</i> preconditions.<p>&gt; The solution to expensive context switches is cheap context switches, plain and simple.<p>Except the performance difference between a kernel-mode context switch and a user-mode one is only going to narrow in the future. The overhead that cannot be eliminated from context switches is their effect on the cache, since you start to run into the laws of physics at that point...<p>The real solution to expensive context switches is to just do fewer of them... No context switch is always faster than a &quot;fast&quot; context switch.<p>&gt; I sincerely believe this is Rust&#x27;s ballpark<p>I think it&#x27;s plausible that Rust could get a library-level solution for fibers that does not rely on unstable details of the compiler. Rust will never again have that baked in to the language, as it would make the language completely unsuitable for many low-level tasks.<p>Fibers, especially the way they are implemented in Go, come with a lot of their own complexity.<p>Just look at this issue: <a href="https:&#x2F;&#x2F;marcan.st&#x2F;2017&#x2F;12&#x2F;debugging-an-evil-go-runtime-bug&#x2F;" rel="nofollow">https:&#x2F;&#x2F;marcan.st&#x2F;2017&#x2F;12&#x2F;debugging-an-evil-go-runtime-bug&#x2F;</a><p>This is just one of the segfaults caused by Go&#x27;s complex stack control. I don&#x27;t want to rely on a runtime that contains these sorts of bugs, and the best way to avoid that is to avoid having a runtime in the first place.')