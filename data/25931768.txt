Item(by='heipei', descendants=None, kids=[25932166, 25932707, 25931905, 25934113, 25934253, 25937860, 25932113, 25931812], score=None, time=1611771684, title=None, item_type='comment', url=None, parent=25930177, text='This post feels like a uninformed and undifferentiated rant against &quot;things are too complex&quot;. Let&#x27;s start with the first paragraph: What does the JavaScript fetch API have to do with data management? How can you compare the fetch() API with Swagger (an API documentation format) with Protobuf (a serialisation format)? That doesn&#x27;t even make sense.<p>Second paragraph: &quot;The UI should automatically update everywhere the data is used&quot;. Again, what does this have to do with any of the above? That is state management, yeah, and you can build proper state management with any HTTP library and any message serialisation format.<p>Request batching: How would that happen &quot;automatically&quot;? By waiting to fire requests and then batching them?<p>UX when fetching data: What does that have to do with any of the above? You still have to decide how your UI displays the fact that a piece of data is loading. What do you expect there to be in place? Best thing I could imagine is to have a global operations indicators a la Adobe Lightroom which tells you how many HTTP requests are in flight.<p>I could go on, but the last paragraphs maybe highlights the lack of understanding the author had: &quot;UI Frameworks (at this point, React has won)&quot;. If React had &quot;won&quot; then why would we be having this discussion. React hasn&#x27;t &quot;won&quot; because it solves one piece of the puzzle: Rendering. For every little other thing you have to incorporate another library or figure out your own solution: Routing, State Management, CRUD &#x2F; HTTP API, etc. If anything, Ember.js would most closely fit the bill of incorporating most of the things the author seems to care about yet can&#x27;t articulate clearly.')