Item(by='pentlander', descendants=None, kids=None, score=None, time=1602260921, title=None, item_type='comment', url=None, parent=24730749, text='Not the OP but I am currently working at a company moving towards a Bazel monorepo and I previously worked at Amazon. For me the lightbulb of &quot;this is a great system&quot; didn&#x27;t click until I actually left Amazon.<p>Compared to Gradle, Brazil is great because it lets you avoid thinking about a lot of smaller details. You declare a dependency on major version in the Config file and it&#x27;ll grab the latest minor version from your versionset. A versionset is basically just a giant package-lock.json or cargo.lock file for all of your deps that is constantly updated in the CI&#x2F;CD system. Since artifacts are deployed at a versionset level, you can always look up what specific version of a package is deployed anywhere. This means you don&#x27;t have to think about minor versions 90% of the time, but when something breaks you can easily find it since the versionset interface is connected to the code browser. You can also easily ask &quot;where does this package version exist&quot; and see all the versionsets that are using a version of a package.<p>I think one of the other big things I miss about it is how well the tooling worked with multiple packages. Brazil had a concept of a &quot;workspace&quot;. Normally if you&#x27;re working with a package it pulls the deps from S3 or wherever. But if you wanted to work with multiple packages that depend on each other, you would run &quot;brazil ws add package-foo-1.0&quot; and it would clone that package to your workspace. Any other package in your workspace that depends on &quot;package-foo-1.0&quot; would now understand to use the local copy to build instead of pulling it remotely. This worked fairly seamlessly with the the Intellij Brazil plugin, making cross package refactoring pretty easy. Doing the same with gradle or npm requires manual work.<p>One of the biggest ways that brazil was misused was around handling of major versions. For context, only a single major version of a package is allowed to exist in a versionset at a time. If you tried to merge in a different major version of a package into your versionset, your pipeline would fail to build due to &quot;Major version conflicts&quot;. One of the biggest sins was around bumping the major versions of the dependencies in a library without bumping the major version of that library at the same time. This would lead to many broken pipelines. Let&#x27;s say you have a library Foo-1.0 with a bunch of users on other teams. You decide to bump up the Guava version from 25 to 29 and publish the new version of Foo-1.0. Anyone consuming Foo-1.0 would automatically pick up the new version of that lib because it&#x27;s just a minor version change, however the merge would fail with a &quot;major version conflict&quot; because the major version of Guava they&#x27;re using in their versionset is still 25. This means you would either have to pin that library back at a previous version, or bump your dependency on Guava in all of you packages to 29.<p>I think this last point really highlights the big difference between Bazel and Brazil. Bazel makes bumping versions a pain because you have to upgrade everything at the same time. However it also ensures that if there&#x27;s a security issue with a lib, everyone is forced to upgrade at once. Brazil allows teams to adopt newer versions at their own paces, however you need a more complex CI&#x2F;CD system, you have to deal with major version conflicts, and you have to deal with longer campaigns to upgrade libs with security issues. I think the two systems just have different tradeoffs, though the biggest advantage Bazel has is that it doesn&#x27;t require the tight integration with a CI&#x2F;CD system so it&#x27;s easier to open source and operate.')