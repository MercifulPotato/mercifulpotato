Item(by='lmilcin', descendants=None, kids=[25981675], score=None, time=1612119960, title=None, item_type='comment', url=None, parent=25981307, text='I think it is important distinguish the necessary from accidental complexity.<p>Macros are typically more difficult to understand but if done well that would be because they are sinking complexity from a bunch of code.<p>For example, if a macro implements variations of repeating construct, you are removing those variations from your entire codebase and putting complexity of dealing with that into a single macro.<p>Now, the issue is when you start creating accidental complexity.<p>For example, there are various techniques that reduce overall complexity just by being consistent in how you do things. Using only hygienic macros or writing macros consistently in a way that allows the reader predicting what they do reduces a lot of perceived complexity.<p>If the reader of the code does not have to understand the macro to be able to more or less predict what it does and what are basic guarantees it provides, it reduces a huge amount of complexity when you try to read and understand.<p>If writing a macro can be compared to writing an operator in a language then all other language design rules apply. It would be a bad language that constantly surprises the user.<p>Unfortunately, Lisp code tends to be much more abstract with lots of complex, custom operators (macros) as building blocks. If these building blocks are not clear and cannot be relied upon (ie. you don&#x27;t understand how they work and can&#x27;t predict what they will do) then this is much more damaging to trying to understand how the codebase works than writing unclear functions.')