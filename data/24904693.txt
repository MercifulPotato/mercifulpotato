Item(by='psykotic', descendants=None, kids=[24904743], score=None, time=1603776494, title=None, item_type='comment', url=None, parent=24904670, text='Indeed, the difference is that the lexer offers guarantees about the synthetic INDENT&#x2F;DEDENT tokens. From an error sync perspective, the benefit is that the programmer (redundantly) re-asserts the block level every line by the amount of indentation. As a small addendum on Python&#x27;s suspension of indentation tracking when nesting &gt; 0, when I designed the syntax for indentation-based block structure in another language, I required such nested code to always have indentation beyond the current block&#x27;s level even though no INDENT&#x2F;DEDENT&#x2F;NEWLINE tokens are emitted in this state. So this was legal:<p><pre><code>    x = (1 +\n        2)\n\n    x = (1 +\n            2)\n\n    x = (1 +\n      2)\n\n    x = (1 +\n     2)\n</code></pre>\nBut this was illegal:<p><pre><code>    x = (1 +\n    2)\n</code></pre>\nThe legal variants are all identical to<p><pre><code>    x = (1 + 2)\n</code></pre>\nfrom the parser&#x27;s perspective. Adding this restriction (which is already the idiomatic way to indent nested multi-line expressions) means that you can reliably sync to block levels even when recovering from an error in a nested state. If your lexer already strips leading indentation from multi-line string literals you could add a similar constraint for them.<p>The moral of a lot of these tricks is that by turning idioms and conventions into language enforced constraints you can detect programmer errors more reliably and you can do a better job of error recovery. That said, even in a curly brace language like C# you could still use the indentation structure as a heuristic guide for error recovery--it&#x27;s just going to be less reliable.')