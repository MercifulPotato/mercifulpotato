Item(by='dataflow', descendants=None, kids=[25929520], score=None, time=1611760333, title=None, item_type='comment', url=None, parent=25928896, text='&gt; In a barrier signaling and waiting is a single atomic operation. Each thread (of a group of N) reaching a barrier will wait until all N threads have reached an waited (and implicitly signaled) it.<p>Yeah that&#x27;s exactly what std::latch::arrive_and_wait does.<p>I don&#x27;t think <i>atomicity</i> is a thing here though... arrive_and_wait() is just count_down() followed by wait().<p>&gt; A countdown latch is an event that will release one (or more) waiter only after has been signaled N times. Signaling and waiting threads are not necessarily the same and often are distinct sets.<p>C# still calls this a Barrier, except that it requires <i>one</i> of the waiters to be a participant (see AddParticipant() and SignalAndWait()): <a href="https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.threading.barrier?view=net-5.0" rel="nofollow">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.threading...</a><p>They even allow removing participants!<p>This is a little bit like a mutex that has a try_lock. It&#x27;s not strictly the vanilla Computer Science &quot;mutex&quot; with lock&#x2F;unlock per se, but it&#x27;s not a fundamentally different concept; it&#x27;s just a handy yet pretty close generalization. \nI guess if you really want to give this a new name then maybe it&#x27;s not a terrible idea given it&#x27;s a slight generalization of a barrier, but <i>latch</i> is certainly not going to be any more accurate (or less confusing) than barrier.')