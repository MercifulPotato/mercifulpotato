Item(by='misnome', descendants=None, kids=None, score=None, time=1608299267, title=None, item_type='comment', url=None, parent=25465424, text='&gt; in practice annotations make code LESS readible, not more<p>Agree, and disagree. I think it depends on lots of things, including how &quot;heavy&quot; you are with type annotations - I think annotating everything, or mandating to, including inline variable definitions - is over-the-top and usually makes the code harder to read. Likewise, chasing down every minor type error for the corner cases can end up wasting loads of time for almost no gain.<p>I also won&#x27;t argue that sometimes the type definitions are excessively verbose and get in the way of reading code, and your point about less experienced devs is also true - for developers who aren&#x27;t so familiar with type annotations, at worst, they make it harder to understand.<p>But carefully used, they can really aid understanding a function or codebase. We have a large, somewhat messy codebase open source academic codebase where the input to a function could come from dynamic dispatch some ~5 layers away, and usually the first task of diagnosing a problem is working out what you&#x27;ve actually been passed. Type annotations help solve this problem, as a somewhat statically verifiable documentation of inputs. We&#x27;ve found bugs using them.<p>It&#x27;s probably not controversial to say that expected types&#x2F;inputs aren&#x27;t always obvious from the context of a function, and so need to be documented, to help people using the code. The alternatives to annotations are docstring documenting of types, which is defining types but decoupled and in a non-statically-checkable way - so easy to get them out-of-sync, which is easy when developers are undisciplined; naming (hard, and messy for compound types), pyi files (checkable, keeps them out of the way, but decouples definitions from code), or type comment - which solves some of the readability and checkability, but is still harder to keep up-to-date than inline.<p>So, overall I like them and have seen them bring value to the code I work with, even if that&#x27;s just documentation, but don&#x27;t think it&#x27;s a black-and-white issue. I&#x27;ve certainly eschewed using them when helping less experienced developers write small personal scripts, but use them in my own code or when refactoring something vaguely defined to cross-check my assumptions.')