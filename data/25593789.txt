Item(by='umanwizard', descendants=None, kids=[25593997], score=None, time=1609430194, title=None, item_type='comment', url=None, parent=25593716, text='&gt; Why not hide it a bit by letting the implicit copy to happen to simpler structures.<p>This is already the case. Built-in types that are simple enough to be copied implicitly already are (roughly: those which don&#x27;t manage any memory or other resources), and you can enable this for your own types with `#[derive(Copy)]`, as long as they are composed only of implicitly copyable types.<p><pre><code>    #[derive(Copy)]\n    struct S {\n        x: i32,\n        y: usize,\n        z: Option&lt;Result&lt;(), ()&gt;&gt;,\n    }\n\n    fn f(x: S) {\n        &#x2F;&#x2F; ...\n    }\n\n    fn main() {\n        let s = S { x: 0, y: 0, z: Some(Ok(())) };\n        f(s);\n        f(s);\n    }\n\n</code></pre>\nSomething like `String` isn&#x27;t implicitly copyable in Rust, because it manages memory, and therefore copying it would require a heap allocation.<p>The Rust way of forcing non-trivial clones to be explicit is much better than C++ IMO, where someone forgetting a `&amp;` or an `std::move` somewhere can cause an innocuous-looking function call to be arbitrarily slow.<p>In C# there are not implicit copies either (except of value types), because more complex types in C# are accessed via pointers to garbage-collected heap objects. Rust doesn&#x27;t have a garbage collector, though.')