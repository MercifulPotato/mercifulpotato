Item(by='bitwize', descendants=None, kids=[25234843], score=None, time=1606514693, title=None, item_type='comment', url=None, parent=25229389, text='&gt; Why wouldn&#x27;t they? The usual rationale for rejecting R6RS is that it&#x27;s somehow &quot;too big&quot;. But Racket already has a library whose size blows R6RS out of the water. So this rationale is irrelevant in this context.<p>No one begrudges Racket for having a huge library. The Racket team have obviously had enormous success building large, comprehensive real-world systems.<p>But Racket is an implementation -- not the Scheme standard. The historic value of the Scheme standard <i>is</i> its smallness and ease of implementation -- a small base upon which to build large systems. Large, comprehensive implementations -- such as T -- have been built on top of this small basis for almost as long as there&#x27;s been an RnRS.<p>R6RS represented a fundamental shift in philosophy for what is Scheme. It de-emphasized the &quot;small language kernel&quot; approach and emphasized a comprehensive, software-engineering approach for building &quot;real world systems&quot;. But the Lisp community already has a comprehensive, software-engineering-oriented language, Common Lisp (which borrowed some of its best features, like lexical scoping, from Scheme). So what&#x27;s the point of building Scheme into a large software-engineering language to compete with Common Lisp?<p>It&#x27;s a bit hard to fathom today, when most modern programming languages -- excluding ECMAScript but including, for example, Rust -- are defined in terms of a single reference implementation, but there are advantages to keeping the language <i>standard</i> small while allowing <i>implementations</i> to grow to arbitrary size and accrete features. Advantages which Scheme has turned into its own little niche among the family of Lisp programming languages.<p>&gt; And what is this &quot;Scheme community&quot; that rejected R6RS? It&#x27;s always been my impression that it was rejected by authors of toy implementations.<p>Of course, because Gambit, Chicken, and Gauche -- among others -- are mere toys.<p>A toy implementation that implements all of R5RS is at least  <i>possible</i>. You can&#x27;t build a toy implementation of Common Lisp, Python, or Rust, that covers even a small fraction of the core language. But you can build a Scheme that&#x27;s nearly or entirely R5RS-compliant in maybe a few thousand lines of C, and from there build out the language to incorporate Python- or Rust-like features. &quot;Toy&quot; Schemes can even be useful in production, as an embedded scripting layer to a larger system.')