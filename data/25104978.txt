Item(by='marcus_holmes', descendants=None, kids=[25107099], score=None, time=1605475216, title=None, item_type='comment', url=None, parent=25101820, text='I get the reasoning behind this, and I agree with some of that. But I don&#x27;t agree with this. For reasons:<p>1. You can&#x27;t trust the front end. Backends <i>must</i> be written assuming that every call from the front end is malicious. Validations must be duplicated in both the UI (to show people that they can&#x27;t do the thing), and the back end (to stop them from the doing the thing).<p>2. There will be multiple front ends. If all your business logic is in the front end, you&#x27;ll have to duplicate it into all of them. Where it will rapidly get out of synch and you&#x27;ll have different behaviours on different clients.<p>3. The entities that make the most sense for storing your data into a database are not the same entities that make the most sense for using in a UI. Forcing your UI to use the same entities as your database will mean more work for both, and often ends up influencing the database design badly.<p>4. There are ways of writing APIs that allow for rapid change. Uncoupling the storage entities from the display entities is a key step, so you can change things in the database without affecting the front end (and vice versa).<p>5. There are ways of writing database schemas that allow for rapid change. My favourite is adding a hstore &quot;metadata&quot; field that I can use to create &quot;temporary&quot; fields in the table for experimental features.<p>I&#x27;ve written a few back ends, and the advice in the article strikes me as dangerously sensible-sounding while being mostly wrong. I can see a newbie product manager buying into this completely and making a huge mess.')