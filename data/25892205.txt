Item(by='3np', descendants=None, kids=None, score=None, time=1611498002, title=None, item_type='comment', url=None, parent=25886877, text='I want to stress the (unfairly loosely defined) &quot;these kinds of projects&quot; there.<p>There is nothing wrong with SQLite as such and in many situation it is perfect for the task. For a backend service that may need to scale, have availability requirements, is going to be run in a clustered or distributed environment, etc, it is not suitable. For one, you suddenly <i>need</i> to couple physical location of persisted data with usage of the same. Running it on networked filesystems is not supported.<p>Yes, there are some caveats there and ways to work around it but it&#x27;s a square-peg-round-hole kind of situation.<p>For mobile or desktop apps, data jobs that can&#x27;t be parallelized, local or light-weight analytics, embedded, it&#x27;s great (though I do think many times it&#x27;s used where something like leveldb or rocksdb would have been more appropriate but w&#x2F;e).<p>I&#x27;m sure there are other use-cases in both &quot;great choice&quot; and &quot;terrible choice&quot; I saw in the wild and can&#x27;t recall.<p>For something like gitea - it depends on the hosting environment,. requirements and scale. Obv for you it is not a pain-point, for me it absolutely is.<p>---<p>I <i>really</i> appreciate when project give the user the choice, like they do here!<p>ORMs are not the devil and can afford flexibility without having to spend time implementing for each supported backend specifically, if performance isn&#x27;t critical enough that DB-specific optimizations are needed.<p>IMO for a project that is going to be self-hosted by a wide range of users, it&#x27;s often premature optimization to make the v1 tied to a specific DB.')