Item(by='cromwellian', descendants=None, kids=[25222710], score=None, time=1606383489, title=None, item_type='comment', url=None, parent=25217291, text='I think what&#x27;s missing from the tools discussion is the infrastructure that the tools sit on top of:<p>1) CitC (Client in the Cloud). Mounts your development environment on FUSE filesystems that exist in the cloud. The entire monorepo is mapped into your CitC directory. You can access it from your desktop shell, your home laptop, or a Web Browser based IDE. Any edits you make are overlaid onto the (readonly) source repository, looking seemless and creating reviewable changelists on the fly. Effortless sharing of editing between multiple machines.   ObjFS, which also sits in your client, allows blaze(bazel) build artifacts to be shared as well, between clients, even between users. In other words, if I work on 3 machines, I don&#x27;t need to &quot;check out&quot; my work 3 times. In fact, I almost never &quot;check out&quot; anything at all. I work in a single monorepo with Mercurial, edit files, which produce reviewable changelists against the main repo. I don&#x27;t need to decide what files to check out or track, nor decide which machine I will work on, and I often switch between IntelliJ locally, IntelliJ via Chrome Remote Desktop on my office computer, and a VS-Code like Web IDE.<p>2) Skyframe (<a href="https:&#x2F;&#x2F;bazel.build&#x2F;designs&#x2F;skyframe.html" rel="nofollow">https:&#x2F;&#x2F;bazel.build&#x2F;designs&#x2F;skyframe.html</a>). Imagine parsing the entire monorepo and every single BUILD file into a massive pre-processed graph that knows every possible build target and its dependencies. This allows ultra-efficient determination of &quot;what do I need to rebuild? what tests need to be re-run&quot; across all of Google. I guess the closest thing to this is MvnRepository.net or BinTray, but Skyframe doesn&#x27;t just parse the stuff and give you a search box, it informs CI tools.<p>3) Citc&#x2F;Critique extensions to Mercurial -- take a chain of commits and make them a single code review, or take a a chain of commits and make them into a stacked chain of code reviews.<p>4) Critique presubmit tools (e.g. errorprone, tricorder, etc). Google has a huge number of analysis tools can run on every review update, for bugs, security problems, privacy problems, optimizations, data-races, etc. Yes, these are usually available outside, but it&#x27;s just so easy to enable them internally compared to doing it on GitHub. Lots of other codehealth tools, for automatically applying fixes, removing unused code, auto-updating build files with correct dependencies.<p>5) Forge -- basically Blaze&#x27;s remote build execution (what Bazel calls RBEs). Almost every build at Google is extremely parallelized, and if you need to run flake tests, running a suite of tests 10,000 times is almost as fast as running it once.<p>6) Monitoring&#x27;s been mentioned, but monitoring combined with CodeSearch hasn&#x27;t been touched on. Depending on configuration, you can often see from Critique or CodeSearch what release or running server code ended up in and what happened to it (did it cause bugs?).  CodeSearch has an insane number of overlays, it can even overlay Google&#x27;s Sentry-like exception logger being able to tell you about how many times some line of code produced a crash.<p>A lot of Googlers use maybe 25% of all of the features in CodeSearch and Critique.<p>Here&#x27;s a in-depth article from Mike Bland\n<a href="https:&#x2F;&#x2F;mike-bland.com&#x2F;2012&#x2F;10&#x2F;01&#x2F;tools.html" rel="nofollow">https:&#x2F;&#x2F;mike-bland.com&#x2F;2012&#x2F;10&#x2F;01&#x2F;tools.html</a>')