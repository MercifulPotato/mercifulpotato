Item(by='glangdale', descendants=None, kids=None, score=None, time=1610686395, title=None, item_type='comment', url=None, parent=25786939, text='You may in fact be right, but I&#x27;m keeping away from neural network and AI&#x2F;ML approaches for now. Part of my motivation here is as a crutch to human understanding - I want the system to be able to <i>fail</i> conclusively (i.e. &quot;no such program at this size and with these assumptions exists&quot; as opposed to &quot;I couldn&#x27;t find anything&quot;). It&#x27;s a lot easier to search for a 5-instruction sequence mentally if a computer has told you there _really_ is no 4-instruction sequence.<p>This is a lot of compiler-type stuff, some bespoke optimizations and - like you say - <i>tons</i> of effort in pruning the search space. The backend to this is a SMT solver, but I have done a great deal of stuff to not get taken hostage by the mysteries of SMT solving (lots of tiny solves rather than handing huge parts of the problem to the solver). SMT solvers are great, and I encourage people to learn to use them, but they often need lots of domain-specific help.<p>I do think that once I start bootstrapping our way up from short sequences to putting together bigger programs, there will be some AI-ish stuff happening. There are common patterns to how we put together programs that feel like they could be &quot;learned&quot; (after a fashion).<p>The other big white whale here is to generate a program from a specification rather than from a black box. At the moment the superoptimizer can only make a better version of something that already exists. I do have a few ideas here, too, but there&#x27;s a stretch goal.')