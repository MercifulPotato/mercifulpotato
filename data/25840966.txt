Item(by='jiggawatts', descendants=None, kids=[25841326], score=None, time=1611102283, title=None, item_type='comment', url=None, parent=25833122, text='Almost always when I see PowerShell critiqued by people used to Linux and Bash, the criticisms leveled against if often add up to: &quot;I am used to the workarounds for the limitations of my system. Sure, your system does not have these limitations, but what if I need the workarounds, like with my current system?&quot;<p>This is like... AutoCAD before the year 2000. It was <i>digital paper</i>, and acted exactly like a drafting board with pens, rulers, and protractors. It was better than paper, but not by much! SolidWorks came out and blew it away. It was proper 3D, with constructive solid modelling. It could generate drawings of arbitrary projections or cross sections in under a second, saving months of time. Yet... people complained the <i>same way</i>. What if I need drafting tools? What if I want to draw lines manually? How do I draw &quot;just&quot; a circle? Why do I need to define what I&#x27;m doing in 3D? Just give me digital paper! That&#x27;s what I want!<p>I made a comment on YC News nearly a year ago that I&#x27;m going to partially repeat below: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23257776" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23257776</a><p><i>PowerShell is more UNIX than UNIX.</i><p>Seriously. In UNIX, if you want to sort the output of &quot;ps&quot;... <i>sss</i>... that&#x27;s hard. Sure, it has some built-in sorting capabilities, but they&#x27;re not a &quot;sort&quot; command, this is a random addon it has accumulated over time. It can order its output by some fields, but not others. It can&#x27;t do complex sorts, such as &quot;sort by A ascending, then by B descending&quot;. To do that, you&#x27;d have to resort to parsing its text output and feeding that into an external tool. Ugh.<p>Heaven help you if you want to sort the output of several different tools by matching parameters. Some may not have built-in sort capability. Some may. They might have different notions of collations or internationalisation.<p>In PowerShell, no command has built in sort, except for &quot;Sort-Object&quot;. There are practically none that do built in grouping, except for &quot;Group-Object&quot;. Formatting is external too, with &quot;Format-Table&quot;, &quot;Format-List&quot;, etc...<p>So in PowerShell, sorting processes by name is simply:<p><pre><code>    ps | sort ProcessName\n</code></pre>\nAnd never some one-character parameter like it is in UNIX, where every command has <i>different characters for the same concept</i>, depending on who wrote it, when, what order they added features, what conflicting letters they came across, etc...<p>UNIX commands are more an accident of history than a cohesive, coherent, composable design. PowerShell was designed. It was designed by one person, in one go, and it is beautiful.<p>The acid test I give UNIX people to see if they really understand how weak the classic bash tools they use is this:<p>Write me a script that takes a CSV file as an input, finds processes being executed by users given their account names and process names from the input file, and then terminates those processes. Export a report of what processes were terminated, with ISO format dates of when the processes were started and how much memory they used into a CSV sorted by memory usage.<p>Oh, there&#x27;s a user called &quot;bash&quot;, and some of the CSV input fields may contain multiple lines and the comma character. (correctly stored in a quoted string, of course!)<p>This kind of thing is trivial in PowerShell. See if you can implement this, correctly in bash, such that you never kill a process that isn&#x27;t in the input list.<p>Give it a go.<p>...<p>After I posted the above, &quot;JoshuaDavid&quot; provided a <i>correct</i> Bash solution, which blew my mind because I just assumed it was borderline impossible: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23267901" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23267901</a><p>Note how complex his solution is, and that he had to resort to using &quot;jq&quot; to convert the output of &quot;ps&quot; to JSON for the processing!<p>Compare to the solution in PowerShell, of which nearly half is just sample data: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23270291" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23270291</a><p>Clear, readable, and easy to modify even for a junior tech.<p>What I didn&#x27;t say in that thread was this: I didn&#x27;t actually bother to work out the solution to my toy problem in PowerShell <i>before</i> JoshuaDavid posted his solution.<p>I made up the problem simply assuming that it&#x27;s ludicriously difficult in bash -- without checking -- and I similarly assumed that it&#x27;s trivial in PowerShell -- without bothering to check.<p>I was that confident.<p>Are you still that confident that Bash is superior to PowerShell? Or have you internalised its constraints, and are too used to drawing fiddly little lines on digital paper to realise that your tooling is hopelessly outmatched by solid modelling?')