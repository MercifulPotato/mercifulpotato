Item(by='pwm', descendants=None, kids=None, score=None, time=1604498564, title=None, item_type='comment', url=None, parent=24988495, text='&gt; However, that doesn’t necessarily imply an all-or-nothing approach where either you’re in a pure function or you can do anything with anything.<p>To elaborate this point I&#x27;d say that the most important practical use of all that &quot;monad mumbo-jumbo&quot; in Haskell is that you can tag your functions with what they can and can&#x27;t do and then the type system tracks this for you:<p><pre><code>  -- pure function\n  f1 :: Text -&gt; Int\n\n  -- can fail\n  f2 :: Text -&gt; Maybe Int\n\n  -- can read from some MyEnv record\n  f3 :: Text -&gt; Reader MyEnv Int \n\n  -- can keep a set of bool as state around\n  f4 :: Text -&gt; State (Set Bool) Int\n</code></pre>\netc... and of course to go nuclear:<p><pre><code>  -- can do anything\n  f5 :: Text -&gt; IO Int\n</code></pre>\nThe tracking part is that you can&#x27;t call f5 from within f1, the type checker says no. It enforces separation between all these various effect boundaries.<p>Also we don&#x27;t have to stop here. A natural next step is defining exact effects one is after. For example say I want my function to be able to get some entity from a DB:<p><pre><code>  -- any type that is an instance of Entity can identify itself by uuid\n  class Entity e where\n    identify :: e -&gt; UUID\n\n  -- The effect we want, ie. get an entity via its uuid\n  class (Monad m, Entity e) =&gt; GetEntity e m where\n    getEntityById :: UUID -&gt; m (Maybe e)\n</code></pre>\nnow we can say things like:<p><pre><code>  data User = MkUser {uId :: UUID, uName :: Text}\n\n  -- a User can identify itself\n  instance Entity User where\n    identify = uId\n\n  -- as User is an Entity so we can get it via its uuid (if it exists)\n  getUserById :: (GetEntity User m) =&gt; UUID -&gt; m (Maybe User)\n  getUserById = getEntityById\n</code></pre>\nAlso notice how getUserById does not say anything about IO or a DB. All it states is that whatever context it will run in that context must know how to get a user via its uuid. You can then plug in whatever actual context you want, say:<p><pre><code>  newtype Prod a = MkProd {unProd :: ReaderT ProdDB IO a}\n    deriving newtype (Functor, Applicative, Monad, MonadReader ProdDB, MonadIO)\n\n  -- get a user from a DB for real\n  instance GetEntity User Prod where\n    getEntityById :: UUID -&gt; Prod (Maybe User)\n    getEntityById eid = do\n      ProdDB {..} &lt;- ask\n      -- query the DB, etc...\n</code></pre>\nor<p><pre><code>  newtype Mock a = MkMock {unMock :: State (Map UUID User) a}\n    deriving newtype (Functor, Applicative, Monad, MonadState (Map UUID User))\n\n  -- get a user from a mock DB\n  instance GetEntity User Mock where\n    getEntityById :: UUID -&gt; Mock (Maybe User)\n    getEntityById eid = gets (Map.lookup eid)\n</code></pre>\nAll in all the programmer have fine-grained control over what various parts of their code can or can&#x27;t do.')