Item(by='to11mtm', descendants=None, kids=None, score=None, time=1612027192, title=None, item_type='comment', url=None, parent=25965730, text='Also, serialization and object versioning challenges. I think I mentioned this in another comment but the lack of static typing in erlang&#x2F;elixir tends to fence your composition model to where these sorts of problems are elided or explicitly handled in code.<p>But AFA Async, I guess I have thoughts.<p>&gt; With akka actors, instead of just dealing with the actors and actor pools, they suggest you make actors non-blocking. The way you do this is with Futures.<p>I don&#x27;t know how things work in JVM&#x2F;Akka specifically but on the .NET side the use of async is &#x27;Tolerable&#x27;. We have a ReceiveActor that lets you wire up your message type to an async method and it handles all of the stashing&#x2F;etc internally until the future completes. You have to type a couple extra words but they&#x27;re the same words you have to type everywhere else you use async.<p>With the other sugar .NET gives you it&#x27;s really not too bad. In the system our team built, the main piece of &#x27;blocking&#x27; code we have is a call to a C library that does not have any real &#x27;async&#x27; bindings. The rest were things like loggers, although typically if &#x27;logging&#x27; is blocking either you&#x27;re logging too much or the rest of the system is probably not in a good state anyway. (edit: FWIW, the &#x27;block&#x27; is 80-100ms and constant, we can live with it for our case)<p>&gt; How do you identify the bottlenecks of the system? Maybe your execution context is full - actually I&#x27;d love to know how people debug their execution contexts in general.<p>Interestingly, Akka.NET doesn&#x27;t quite have this sort of problem.The default Dispatcher (At least that&#x27;s what we call the base type) runs on the .NET Thread pool which has a good degree of &#x27;self tuning&#x27;, and you can peek at the number of threads vs what the pool maxes out at with 4 lines of code or so. However in .NET we have &#x27;SynchronizationContexts&#x27; which result in the need for special dispatchers for things like a UI update (as most UI frameworks have their own context for handling UI).<p>&gt; One of the benefits of this arrangement is if something is going slowly you can order the list of actors by biggest mailbox and you can see where your bottleneck is.<p>You could probably hack together something off of akka visualmailbox [0] as it shows how to grab metrics from &#x27;inside&#x27; a mailbox. I did a toy port to .NET and while on that side I had to do a lot of &#x27;configuration&#x27; and still need to create metrics collecting mailboxes for all the types (we don&#x27;t have traits...) but it seemed to actually work not-bad.')