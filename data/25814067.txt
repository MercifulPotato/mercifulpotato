Item(by='eesmith', descendants=None, kids=None, score=None, time=1610912092, title=None, item_type='comment', url=None, parent=25811733, text='Rust should be a lot faster than Python if your time is mostly spent parsing the contents of those lines. Think that each Python op-code will be running extra assembly instructions, just to handle the virtual machine overhead.<p>I see a number of micro-optimizations that may give you a few percent more in Python.<p>For example, you use GameSituation as a mutable way to maintain parse state. You modify it with things like &quot;gameSituation.outs += 1&quot;.<p>Mutating instance attributes has a much higher overhead in CPython than in C&#x2F;C++ (and presumably Rust). You can reduce some of that overhead by telling the class which slots to have.<p>Consider &quot;spam.py&quot; containing the following:<p><pre><code>  class Foo:\n    def __init__(self):\n      self.a = 0\n\n  class Bar(Foo):\n    __slots__ = (&quot;a&quot;,)\n\n  % python -m timeit -s &#x27;import spam; x=spam.Foo()&#x27; &#x27;x.a = 3&#x27;\n  5000000 loops, best of 5: 41 nsec per loop\n  % python -m timeit -s &#x27;import spam; x=spam.Bar()&#x27; &#x27;x.a = 3&#x27;\n  10000000 loops, best of 5: 32.4 nsec per loop\n</code></pre>\nIf you replace your GameSituation with a dict then you can get a little faster, but not enough to worry about.<p><pre><code>  % python -m timeit -s &#x27;import spam; x={}&#x27; &#x27;x[&quot;a&quot;] = 3&#x27;</code></pre>\n10000000 loops, best of 5: 29 nsec per loop<p>Another micro-optimization is to reduce the number of temporary strings. Consider:<p><pre><code>     if (batterEvent.startswith(&#x27;W+&#x27;) or batterEvent.startswith(&#x27;IW+&#x27;) or batterEvent.startswith(&#x27;I+&#x27;)):\n        tempEvent = batterEvent[2:]\n</code></pre>\nIf you track the current offset in the string, then you can do things like:<p><pre><code>     if batterEvent[i:i+2] in (&quot;W+&quot;, &quot;I+&quot;) or batterEvent[i:i+3] == &quot;IW+&quot;:\n        i += 2\n</code></pre>\nand use the start position parameter in the re.match() calls.<p>(BTW, there appears to be a bug in your original code, since &quot;IW+&quot; is 3 letters long.)<p>Another BTW, you might change &quot;for line in f.readlines()&quot; to &quot;for line in f&quot;. Shouldn&#x27;t affect performance but should reduce your overall memory use.<p>In closing, character-level string processing in CPython is slow so I doubt you&#x27;ll get all that much faster.<p>You might try pypy, but with the number of temporary strings you create, my guess is pypy still won&#x27;t be that much faster. Should be easy to test though.')