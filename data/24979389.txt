Item(by='Joker_vD', descendants=None, kids=[24979564], score=None, time=1604409845, title=None, item_type='comment', url=None, parent=24979097, text='There is an easy solution to the colour problem: make all functions async. All of them. Of course, having code like this<p><pre><code>   async func foo(x int) task[int] { return await(2 * x); }\n\n   &#x2F;&#x2F; No &quot;async&quot; only because cpu_bound_future_factory() returns a task\n         func bar(y int) task[int] { return cpu_bound_future_factory(async func() task[int] { return await(y - 5); }); }\n\n   async func baz(a,b int) task[int] { return await(await foo(a) + await bar(b)); }\n</code></pre>\nis not fun, especially when you have to await the result of the arithmetic operators, and write all those now-redundant async and await, so let&#x27;s also drop &quot;async&quot; and make &quot;await&quot; implicit--although we&#x27;ll need something for non-awaiting. Let&#x27;s call it &quot;nowait&quot;. Now we can write code like this:<p><pre><code>   func foo(x int) task[int] { return 2 * x; }\n\n   func bar(y int) task[int] { return nowait cpu_bound_future_factory(func() task[int] { return y - 5; }); }\n\n   func baz(a, b int) task[int] { return foo(a) + bar(b); }\n</code></pre>\nA-a-and we&#x27;re back to multithreading, basically. So yeah, looks like cheap context switches is the solution.')