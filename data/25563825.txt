Item(by='yowlingcat', descendants=None, kids=None, score=None, time=1609193393, title=None, item_type='comment', url=None, parent=25557313, text='&gt; \nI try to keep my software systems as functional as possible (where &quot;functional&quot; here means &quot;no explicit state&quot;). But there are always places where it makes sense to think in terms of state, and so I try to model that state monotonically whenever possible. At least subjectively, it&#x27;s usually a lot simpler (and easier to follow) than unrestricted state.<p>Agreed. You mention LVars so I&#x27;m curious what you think about MVars and STM in general. I&#x27;ve always been fond of STM because relational databases and their transactions are a familiar and well understood concept historically used by the industry to keep state sane and maintain data integrity. SQLite is great, but having something that&#x27;s even closer the core language or standard library is even better.<p>It&#x27;s part of why I like using SQL to do the heavy lifting when possible. I like that SQL is a purely functional language that naturally structures state mutations as transactions through the write-ahead log protocol. My flavor of choice (Postgres) makes different levels of efficient read and write available through read isolation levels that can give me up to ACID consistency without having to reinvent the wheel with my read and write semantics. If I structure my data model keys, relations and constraints properly, I get a production strength implementation with a lot of the nice properties you talk about. And that&#x27;s regardless of my service layer choice for my language that I can trust to stand up.<p>There&#x27;s one exception in particular that I&#x27;ve seen begin to gain steam in the industry which I think is interesting, and that&#x27;s Elixir. Because Elixir wraps around Erlang&#x27;s venerable OTP (and distributed database mnesia), users can build on the top of something that&#x27;s already solved a lot of the hard distributed systems problems in the wild in a very challenging use case (telecom switches). Of course, mnesia has its own issues so most of the folks I know using Elixir are using it with Phoenix + SQL. They seem to like it, but I worry about ecosystem collapse risk with any transpiled language -- no one wants to see another CoffeeScript.')