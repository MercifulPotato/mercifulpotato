Item(by='ridiculous_fish', descendants=None, kids=[25044335, 25043691], score=None, time=1604984127, title=None, item_type='comment', url=None, parent=25041455, text='Right, the branch may or may not be optimized out; probably it depends on llvm&#x27;s alias analysis. That&#x27;s not good, it means you might break it accidentally.<p>IME Rust is more dependent than C++ on these fragile optimizations. I think it is because idiomatic Rust is more abstract, and also because C++ has more advanced specialization features which allows implementing optimizations directly. For example in C++ you can say &quot;if the type is uint8_t then do this instead...&quot; but this is harder in Rust.<p>You asked for other examples: consider a simple operation over an array, like bitwise not. A C-style for-loop does the obvious thing but idiomatic Rust emits a gazillion one-byte &#x27;not&#x27; instructions. This doesn&#x27;t involve &#x27;unsafe&#x27; but it does illustrate that you really do have to babysit Rust to get efficient codegen. <a href="https:&#x2F;&#x2F;rust.godbolt.org&#x2F;z&#x2F;PjW5vo" rel="nofollow">https:&#x2F;&#x2F;rust.godbolt.org&#x2F;z&#x2F;PjW5vo</a><p>(In fairness C++ has its own stupid pitfalls too: <a href="https:&#x2F;&#x2F;travisdowns.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;19&#x2F;toupper.html" rel="nofollow">https:&#x2F;&#x2F;travisdowns.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;19&#x2F;toupper.html</a>)')