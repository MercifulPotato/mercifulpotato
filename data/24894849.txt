Item(by='Twisol', descendants=None, kids=None, score=None, time=1603710595, title=None, item_type='comment', url=None, parent=24893848, text='&gt; Easy.<p>The formal definitions are straightforward enough, but the definitions alone don&#x27;t really motivate themselves. A lot of mathematical maturity is about recognizing that a good definition gives a lot more than is immediately apparent. Someone without that experience will want to fully understand the definition, and fairly so -- but a plain reading defies that understanding. That is objectively frustrating.<p>&gt; As a bit of an aside, it&#x27;s interesting that the CS (Haskell, mainly) descriptions of a Monad are much more complicated than the math.<p>I actually do agree with this, though. I feel like monads are much simpler when presented via &quot;join&quot; (aka &quot;flatten&quot;) rather than &quot;bind&quot;; and likewise with applicative functors via monoidal product (which I call &quot;par&quot;) rather than &quot;ap&quot;. &quot;bind&quot; and &quot;ap&quot; are really compounds of &quot;join&quot; and &quot;par&quot; with the underlying functorial &quot;map&quot;. That makes them <i>syntactically</i> convenient, but <i>pedagogically</i> they&#x27;re a bit of a nightmare. It&#x27;s a lot easier to think about a structural change than applying some arbitrary computation.<p>Let&#x27;s assume the reader knows abut &quot;map&quot;. Examples abound; it&#x27;s really not hard to find a huge number of functors in the wild, even in imperative programs. In short, &quot;map&quot; lets us take one value to another, within some context.<p>Applicative functors let us take two values, `f a` and `f b`, and produce a single `f (a, b)`. In other words, if we have two values in separate contexts (of the same kind), we can merge them together if the context is applicative.<p>Monads let us take a value `f (f a)` and produce an `f a`. In other words, if we have a value in a context <i>in a context</i>, we can merge the two contexts together.<p>Applicative &quot;ap&quot;, `f (a -&gt; b) -&gt; f a -&gt; f b`, is &quot;par&quot; followed by &quot;map&quot;. We merge `(f (a -&gt; b), f a)` to get `f (a -&gt; b, a)`, then map over the pair and apply the function to its argument.<p>Monadic &quot;bind&quot;, `(a -&gt; f b) -&gt; f a -&gt; f b`, is &quot;map&quot; followed by &quot;flatten&quot;. We map the given function over `f a` to get an `f (f b)`, then flatten to get our final `f b`.<p>It&#x27;s a lot easier to think about these things when you don&#x27;t have a higher-order function argument being thrown around.')