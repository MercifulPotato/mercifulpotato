Item(by='ashtonkem', descendants=None, kids=None, score=None, time=1607669966, title=None, item_type='comment', url=None, parent=25381278, text='The best summation I could possibly give is from the article you linked:<p>&quot;In object-oriented languages, it&#x27;s easy to add new types but difficult to add new operations. Whereas in functional languages, it&#x27;s easy to add new operations but difficult to add new types&quot;.<p>Put more concretely: if your Java code base is full of one-off classes with little to no sub-classing or multiple implementations of internal interfaces, then Clojure <i>might</i> work for you. But if you have a lot of sub-classes and repeatedly implemented domain specific interfaces I would hesitate mightily before considering Clojure.<p>My team&#x27;s domain was such that the operations were very fixed, but the types expanded constantly. There is only a fixed set of things that the back office can possibly do with a bond or a future, but new types of instruments come into existence (or sometimes our awareness) with pretty surprising regularity.<p>But the article you linked had a slight of hand trick with how they described multi-methods. They only give an example <i>one</i> multi-method. What if you need to emulate a Java interface with M methods on it? Well now you&#x27;ll need M multi-methods with an implementation for each virtual &quot;class&quot;. You quickly see how that falls apart if you need to add a type <i>or</i> an operation, since either way requires you to manually check and make sure that all operations are implemented for all types. Again, it works, but it&#x27;s error prone.<p>Defrecord &amp; defprotocol work much better. We ended up trying them and they were ... okay. They work, with some footguns, most of which I can&#x27;t remember anymore, but if you end up going too far down that road (like we did) you end up asking yourself why you&#x27;re writing Java in Clojure instead of just writing Java in Java.')