Item(by='jorl17', descendants=None, kids=[25978752, 25977566], score=None, time=1612060864, title=None, item_type='comment', url=None, parent=25974842, text='I instantly thought of something similar when I looked at your code.<p>I like the simplicity!<p>I used to combine RabbitMQ and Celery for async tasks. Mostly because it&#x27;s what I learned to do since it was already in use at my first job. But Celery is such a pain -- or, at least, it was at that job. So many configuration options, different places where they were stored in different versions[1]. Weird errors. Poor documentation (at least at the time?)... I just started going for something simpler: rq and rq-scheduler with redis. For most of my use cases it&#x27;s more than enough.<p>I&#x27;ve got to say that your approach has gotten me thinking of maybe simplifying everything even more. We&#x27;ll see where I end up. In about 4 weeks I&#x27;ll have to introduce asynchronous tasks in our current project, and though I was thinking of going the rq-way, your article has given me food for thought.<p>Other than that, your backend stack is mostly like what we use for our projects. We also use plain old docker + docker-compose, with the small difference that we have a somewhat hacked-together system I built with bash several years ago to extend docker-compose&#x27;s functionality a bit and make every component somewhat more reusable between projects and easier to fine-tune on a &quot;per-environment&quot; (development, staging, production, etc) basis. We also use nginx, but your article has convinced me to look into alternatives.<p>Once again, thank you for your articles, they&#x27;re a joy to read and think about!<p>[1] To be fair, that job had several aging Django codebases and I know most of them are still stuck with Python 2 and outdated Celery and django-channels versions. I constantly kept pushing for us to get rid of technical debt, but we never got to it...it&#x27;s part of the reason why me and a mate left it for our own endeavors together.')