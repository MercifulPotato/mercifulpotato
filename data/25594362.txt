Item(by='derefr', descendants=None, kids=None, score=None, time=1609433683, title=None, item_type='comment', url=None, parent=25591316, text='&gt; In other words, this causes players to see the monster dying twice.<p>The frames that are replayed aren&#x27;t <i>visibly</i> replayed. They&#x27;re re-<i>computed</i>, but the visible effect is more of a &quot;lurch&quot; from one world-state to another one. In this case, the monster has been dead for a second or two already, but suddenly each player&#x27;s score counter would jump around to show that it&#x27;s actually player P who did it, and gained the points for it. Except for player P themselves, who experiences no change.<p>It&#x27;s very similar in experiential effect to the effect when an inherently-networked client-server game does client-side prediction, and then the server sends the canonical state which disagrees from the client&#x27;s predicted state, and the client has to lurch into the server&#x27;s canonical state. People&#x27;s avatars pop into different positions; in an FPS, you might suddenly be dead &quot;out of nowhere&quot;; in a racing game, you might suddenly be spiralling out of the way because your path turned out to collide with that of another car that wasn&#x27;t originally there; etc.<p>Inherently-networked games sometimes have interpolation (&quot;lerp&quot;-ing) code to smooth out this lurch between client-side predicted positions and canonical server-side state — usually, if the <i>only</i> thing that&#x27;s incorrect is positioning, the client will try to generate a few interpolated frames of movement that takes objects <i>from</i> their incorrectly-predicted positions <i>to</i> their server-prescribed positions; and then it&#x27;ll play those frames in fast-forward, so that they&#x27;ve all been played out well before the server sends its next update.<p>But this only works when the server isn&#x27;t communicating every single frame (otherwise there&#x27;s no time to replay the lerp); and it basically only works for positioning changes — if someone does manage to cause a discrete alteration to the game-state (like changing who killed an enemy), that will still usually cause a sudden &quot;lurch&quot; into the new game-state in these engines. The interpolation-frame generator code just gives up.<p>(Though, for especially-important things like who won a match, inherently-networked games just do a hard consensus-sync of all players — usually during a screen transition — before actually showing a results screen. People get quite cross when their results lurch!)<p>And, of course, games that <i>weren&#x27;t</i> inherently-networked, but which are instead being networked &quot;on the emulation layer&quot;, have no logic for lerping, and <i>cannot</i>, unless lerping logic is hand-written by some kind soul for each emulated game&#x27;s engine. Possible if you&#x27;re hand-crafting an emulator designed to play a single game; quite unlikely if you&#x27;re just building a general system emulator — especially if, as with most authors of general-system emulators, your goal is faithful reproduction of the behavior of the original system.<p>&gt; Would you suggest some reading on this?<p>No idea if there is any reading on how emulators do this, tbh. (I&#x27;m self-taught on this subject, from working with open-source emulator codebases.) But any modern textbook on [inherently-]networked client-server game-engine development should talk about client-side run-ahead prediction and interpolation-frame generation.<p>I <i>believe</i> there&#x27;s some book which deep-dives into the network architecture of Doom, or Quake, or Unreal Tournament, or one of those early networked games, and uses it to explain the history&#x2F;invention of these client-side prediction features. I can&#x27;t seem to Google it for the life of me, though. Can anyone here assist?')