Item(by='peter_d_sherman', descendants=None, kids=None, score=None, time=1605205094, title=None, item_type='comment', url=None, parent=25072817, text='&gt;&quot;Why is Jam better than Make?<p>There really are a lot of reasons, we name just a few of them.<p>Compiling simple things with Jam is trivial. However, compiling complex projects (usually with complex directory hierarchies) is still very simple.<p><i>Jam automatically scans source files for #include statements and computes header dependencies automatically, and it does so fast.</i><p>The Jam language is simple and expressive, and lets you define your own build rules, actions, and functions very easily, unlike the ALGOL-like syntax of Makefiles.<p>Jam knows about platform-specific directory separators.<p>Jam is fully customizable, and easy to extend.<p>Jam has a <i>tiny footprint</i>, and is a lot faster than Make at building large projects (independent of target build times, of course).<p>We have already mentioned that you don&#x27;t need to modify Jamfiles in order to compile the same project with distinct compilers and toolsets.<p>Jam parses all Jamfiles in a project before beginning to build targets. <i>It knows the full dependency graph</i> and can do parallel builds safely with the ‘-j’ flag.<p>Jam is compatible with Autoconf. <i>All configuration-specific definitions are gathered in a single file</i> named ‘Jamrules’ that is shared by all Jamfiles of the same project. The ‘Jamrules’ file is generally generated by processing a ‘Jamrules.in’ template with the ‘configure’ script on Unix systems.&quot;')