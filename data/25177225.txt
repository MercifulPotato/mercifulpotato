Item(by='scottlamb', descendants=None, kids=None, score=None, time=1606051149, title=None, item_type='comment', url=None, parent=25175564, text='I peeked at the reddit conversation earthboundkid mentioned. [1] The author wrote there:<p>&gt; Go’s code readability, concurrency model, fast compilation, gofmt, go profiler, go vet, performance and so on. Also, we didn’t ditch Go GC entirely. We’re still using it pretty expansively in all non-critical paths and wherever it’s hard to trace the memory ownership and release.<p>&gt; I see this as a no different than taking some pieces of your code and converting them to assembly (utilize SIMD instructions, for e.g.), which Go does as well. Also, note that the workload that databases need to incur are lot heavier than typical Go applications.<p>I don&#x27;t think most of those are too satisfying as reasons to choose Go over Rust for this program. I think Go&#x27;s code readability and safety are significantly compromised by this kind of manual memory management, enough so that I&#x27;d consider Rust more readable in this context. Likewise Rust&#x27;s performance is significantly better—the biggest reason Go is faster to compile is that it has a simple compiler that does almost no optimizations. Rust can do that, too, in debug mode, especially with the recent cranelift backend. And Rust has equivalents to &quot;go fmt&quot; and &quot;go vet&quot;.<p>Now it&#x27;s quite possible that when they started this program years ago, Rust wasn&#x27;t a good choice. Obviously at least the cranelift backend I just mentioned didn&#x27;t exist at the time. Pragmatically, you often end up with this kind of &quot;path-dependent design&quot; &#x2F; &quot;for legacy reasons&quot;. Porting is a lot of effort, maybe more than is worth it. You can&#x27;t always be chasing the hot new fashion or you&#x27;d get nothing else done. I think it still should be acknowledged however that a better tool exists now.<p>I agree with them the concurrency model in Go is genuinely more pleasant than in Rust. In Go, you just write synchronous code and it gets translated to a green thread model for you. In Rust, there&#x27;s the async stuff which is harder to program and an async ecosystem that is still settling today. That&#x27;s a clear advantage for Go, and maybe also why they say Go is more readable. (I find Rust otherwise pleasant to read.) And maybe Go is more reasonable for the non-critical path stuff as they said, and maybe that does have to be in the same program.<p>[1] <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;golang&#x2F;comments&#x2F;jobgq9&#x2F;manual_memory_management_in_go_with_jemalloc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;golang&#x2F;comments&#x2F;jobgq9&#x2F;manual_memor...</a>')