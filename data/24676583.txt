Item(by='jiggawatts', descendants=None, kids=[24678014, 24677396, 24676862, 24687157], score=None, time=1601786817, title=None, item_type='comment', url=None, parent=24675140, text='&gt; I think avoiding numeric types is a good decision.<p>Only if this format is intended for use-cases that never need to deal with numbers.<p>&gt; One should remember that any sane application will be parsing the config file into internal data structures and validating it anyway so it gets little benefit from the numbers being already “parsed”.<p>That statement couldn&#x27;t possibly be more wrong.<p>Number parsing (and encoding!) is a decidedly non-trivial problem. You need to concern yourself with -- <i>at a minimum</i> -- all of the following:<p>- Unsigned 64-bit numbers.<p>- A series of digits that would be bigger than a 64 bit whole number. Convert to float? Truncate in some way? Error?<p>- NaN<p>- Infinity<p>- Negative zero<p>- Denormal numbers.<p>- Differentiating between decimal&#x2F;currency types and floating point numbers. Not all decimal values can be exactly represented as floats!<p>- Efficiently encoding floating point to use the minimum digits without losing precision.<p>- Parsing those minimal numbers with perfect &quot;round-tripping&quot;.<p>- Doing the above efficiently.<p>- Securely too! Efficient parsers cut corners on sanity checks. I hoped you fuzzed your parser...<p>The above can easily amount to many kilobytes of extremely complex code. Look up &quot;ryu&quot; as an example of what Google came up with to make JSON number parsing reasonably efficient.<p>Meanwhile, reading a fixed-length number from a binary format can be done in a <i>single machine instruction</i>. One. It might not even take an entire CPU clock cycle! Okay, two, if you need to bounds-check your buffer, but there&#x27;s ways to avoid that.<p>Afterwards, the bounds check is again literally just two machine instructions in complexity. That&#x27;s not the difficult bit!<p>The difficult bit is the parsing.')