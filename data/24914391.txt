Item(by='lmm', descendants=None, kids=None, score=None, time=1603852070, title=None, item_type='comment', url=None, parent=24912273, text='I think there&#x27;s real value add from a language that&#x27;s designed to work in an IDE-first way, that uses the GUI not to replace text but to enhance it. The best example I know of this is Scala&#x27;s implicits: they&#x27;re not visible in the code itself, but in an IDE you can see where they&#x27;re coming from (e.g. ctrl-shift-P in IntelliJ), so they&#x27;re a great way to express concerns that are secondary but not completely irrelevant (e.g. audit logging - basically anything you&#x27;d consider using an &quot;aspect&quot; or &quot;decorator&quot; for). Another example is type inference (which a lot of languages have): your types aren&#x27;t written in the program text, but they&#x27;re available reliably when editing, so you can use them to express secondary information.<p>People on HN seem to think programming languages should be designed for a text editor as the primary way of editing, and I think that&#x27;s a mistake that holds programming culture back (and is why we see these &quot;graphical&quot; languages go too far in the other direction, because the only way to get people to take a proper language editor seriously is to make a language that&#x27;s impossible to edit in a text editor). Having a canonical plain text representation is important. Having good diff&#x2F;merge is important. Editor customizability is important. But if you embrace the IDE and build an IDE-first language, without abandoning those parts, you can get a much better editing experience.')