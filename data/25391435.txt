Item(by='richmattes', descendants=None, kids=None, score=None, time=1607722845, title=None, item_type='comment', url=None, parent=25390952, text='ROS isn&#x27;t really one thing. Per the &quot;about&quot;[1] it&#x27;s really made up of several pieces:<p>Plumbing:<p>ROS is centered around a publish&#x2F;subscribe messaging framework, with a central broker that ROS processes (called nodes) register with to advertise their publications and request subscriptions.  Message definitions that are passed on the pub&#x2F;sub &quot;topics&quot; are specified in language agnostic Interface Definition Language (IDL) files.  There&#x27;s an RPC service layer built on top of the messaging infrastructure, and the central broker also hosts a &#x27;parameter server&#x27; database that nodes can use to query or update named values.  ROS client libraries that provide APIs for topics&#x2F;services&#x2F;parameters are provided for several languages, primarily C++ and Python.  A set of commonly used message definitions and conventions, which form de-facto standard interfaces, are used to establish interoperability and substitutability between ROS nodes.<p>Tools:<p>ROS provides build tools for individual software packages based on CMake and custom metadata embedded in an xml file.  Packages can be grouped into workspaces, built with ROS tools, and workspaces can be layered on top of one another.  Other ROS tools exist for process management (the launch system), introspection of running ROS processes, interaction with topics&#x2F;services, and visualization of message data published with well-known message types.  This list is by no means comprehensive<p>Capabilities:<p>Building on the concepts of publication&#x2F;subscription with shared interface descriptions, and the package abstraction, various packages are publicly available that use ROS interfaces to accomplish various functions.  These could include reading data from a sensor and converting the data to a ROS message, implementing robotic navigation algorithms, providing a visualization or UI, or controlling the behavior of a simulation.  It&#x27;s possible to build on and modify a lot of existing capabilities to build a system, which arguably speeds up the<p>Ecosystem:<p>ROS is widely used across industry and academia, and there&#x27;s lots of people familiar with its workings.  These people work together to advance the state of the art of the ROS framework and the capabilities implemented with it, the standards&#x2F;conventions for interoperating with various components, and<p>ROS 2 is an evolution of ROS.  It keeps a lot of the same concepts, but replaces the bespoke pub&#x2F;sub messaging protocol with an abstraction to plug in lower-level messaging libraries (DDS is used by default).  The reasons and motivations for starting over with ROS 2 are outlined here[2], but may require some familiarity with ROS 1 to get all of the nuance.<p>[1] <a href="https:&#x2F;&#x2F;www.ros.org&#x2F;about-ros&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.ros.org&#x2F;about-ros&#x2F;</a>\n[2] <a href="https:&#x2F;&#x2F;design.ros2.org&#x2F;articles&#x2F;why_ros2.html" rel="nofollow">https:&#x2F;&#x2F;design.ros2.org&#x2F;articles&#x2F;why_ros2.html</a>')