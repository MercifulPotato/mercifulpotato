Item(by='aphyr', descendants=None, kids=[25525098, 25525356], score=None, time=1608779859, title=None, item_type='comment', url=None, parent=25523976, text='&gt; However, either they do not scale or even when they do (newsql), they are 10x slower and handle less volume, etc.<p>There&#x27;s something to be said about CQL specifically here, because its transactional model is an odd duck, and not always for scalability reasons. Scylla and Cassandra <i>could</i> offer richer transactions without significant performance penalties--indeed, which would significantly speed up some types of transactional workloads, but instead there are, as the grandparent poster notes, strange edge cases.<p>For instance, you can&#x27;t select multiple CQL rows where the select would cover a column backed by a CQL collection. That&#x27;s been fixed in Cassandra, but is still present in Scylla, and limited the kinds of tests we could write for Scylla.<p>You also can&#x27;t perform an LWT write <i>without</i> a guard clause: linearizable upserts in the Jepsen tests require the presence of an always-null field in every row whose only purpose is to convince Scylla that yes, we really <i>would</i> like to use Paxos for this write.<p>Likewise, there&#x27;s no logical notion of a batch combining reads <i>and</i> writes, or, for that matter, a batch of reads. If you want those sorts of things in C* or Scylla, I imagine one winds up stringing together reads and CaS statements in retry loops, or something to that effect. We were trying to hack together a batch read via a no-op write, except that it&#x27;s actually impossible to do that robustly--you can only &quot;read&quot; values involving guard clauses, and there&#x27;s no guard which will pass on all values. It&#x27;s just... awkward.<p>This isn&#x27;t a scalability thing--all three of these cases could be executed in a single Paxos round, scoped to a single partition. It&#x27;s just... weird API design.')