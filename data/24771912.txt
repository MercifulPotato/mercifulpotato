Item(by='skohan', descendants=None, kids=None, score=None, time=1602635255, title=None, item_type='comment', url=None, parent=24769770, text='&gt; but what&#x27;s a reason C&#x2F;C++ can&#x27;t allocate memory in a satisfactory way by default on those platforms?<p>Custom allocators are important when memory performance is relevant.  Allocation&#x2F;deallocation is <i>really</i> slow compared to using memory which is already allocated to a program, so this can often be one of the biggest performance syncs in a program, especially one which churns through a lot of data (e.g. videogames, simulation, ML training etc.)<p>Custom allocators can also help with memory coherency: you can pack objects you&#x27;re using together close together in memory, which minimizes the amount of CPU cache misses, which can also be one of the most expensive parts of execution.  It may be difficult or impossible for a compiler to design a more optimal memory layout than a programmer with knowlege of how the program will use the data.<p>&gt; And how do other languages get away with it?<p>Custom allocators are most relevant in performance-critical contexts, so you&#x27;re probably already using C++ because a higher-level language was already too slow for your use-case.  In other words, other languages pay the same cost for memory management, but if you&#x27;re programming in Python you&#x27;re probably working in a domain where the performance difference doesn&#x27;t matter.<p>Even programs written in a &quot;fast&quot; GC&#x27;d language like GO will have a performance ceiling largely dictated by memory churn.')