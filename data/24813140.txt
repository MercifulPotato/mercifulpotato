Item(by='mpweiher', descendants=None, kids=None, score=None, time=1602967153, title=None, item_type='comment', url=None, parent=24811641, text='&gt;&gt; It unwisely rejected the parsimonious case and chose tremendous complexity.<p>&gt; Swift&#x27;s keyword syntax isn&#x27;t complex at all.<p>Yes it is, particularly compared to the <i>parsimonious</i> options.  Either parens or Smalltalk-style keywords can do the job, so you absolutely, positively do not need both.<p>Particularly, if you are going to have keywords, you just don&#x27;t need parens.  So it&#x27;s already more complex than it needs to be (not parsimonious).  Just explaining the various omitted or extra keywords takes 4 pages in the Swift book, the <i>entire</i> Smalltalk syntax fits on a Postcard.<p>What is complex or not obviously depends on what your baseline is.  If it&#x27;s C++, Swift might seem simple (though many disagree).<p>&gt;  (e.g. Python) so it&#x27;s a tested idea.<p>The question was not whether it was tested, but whether it was a parsimonious design, which it is not.  It was also not a good design, because it led to a number of follow-on problems that they had to incrementally fix while adding even more complexity.<p>Python is not a good comparison because they didn&#x27;t really have a choice:  they already had the paren syntax, which they could hardly deprecate.<p>However, choosing that design without a backwards compatibility restriction is unconscionable, IMHO, particularly if you already have a <i>different</i> keyword design all over your code-base.  That&#x27;s cutting off your nose to spite your face.<p>Anyway, even the baseline keywords-in-parens is complex and more complex than it needs to be (because it isn&#x27;t parsimonious), but then you get follow-on problems:  blocks inside parens are really ugly, so you add trailing closure syntax.  Yet another special case, which is very different from arguments inside the parens.  But then you discover that sometimes you need more than one trailing closure, and then you need yet another special case, the open-keyword-trailing-block syntax, which is different yet again.<p>Of course, instead of having 3-4 different syntactic mechanisms, you could have chosen just the one and not needed any of the others.<p>&gt; You don&#x27;t have two keywords, you have an optional variable name. It&#x27;s intuitive at the first time you see it<p>No, it&#x27;s absolutely positively not the least bit intuitive.  And it makes no sense, because internal variable names have no business leaking to the interface.  If you want to rename the names of your variables inside your method, it changes the signature!  Not even C does this.<p>&gt; that doesn&#x27;t mean it&#x27;s &#x27;tremendous complexity&#x27;<p>Although the argument could be made, I wouldn&#x27;t, not by itself, no.  However, this is just one example of countless others, see for example Rob Rix, whom I quoted before:<p><i>Swift is a crescendo of special cases stopping just short of the general; the result is complexity in the semantics, complexity in the behaviour (i.e. bugs), and complexity in use (i.e. workarounds).</i><p>I also talk more about it here:<p><a href="https:&#x2F;&#x2F;blog.metaobject.com&#x2F;2015&#x2F;05&#x2F;i-am-jealous-of-swift.html" rel="nofollow">https:&#x2F;&#x2F;blog.metaobject.com&#x2F;2015&#x2F;05&#x2F;i-am-jealous-of-swift.ht...</a><p>&gt; is a bit too harsh to Swift,<p>Nope.  The comment I replied to made the indefensible claim that Swift was parsimonious.  Which it&#x27;s not.  Not even close.')