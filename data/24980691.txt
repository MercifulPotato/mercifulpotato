Item(by='gpderetta', descendants=None, kids=[24980763], score=None, time=1604418589, title=None, item_type='comment', url=None, parent=24979359, text='the issue is turning blocking calls (or non-async calls) into non-blocking ones, or simply yielding from a callback deep into a callstack (the usual example is turning an internal iterator into an external one).<p>Of course you can add async to the whole callstack, but it could be third party code and it might require code duplication if async adds a penalty to compared to non-async code.<p>Ideally the fixed stack size&#x2F;conversion to state machine would be an optimization that the compiler would apply if it can prove that the coroutine ever yields form top level (or from a well known and fixed stack depth) and resort to dynamic stacks otherwise. I have been thinking a lot about this, and I think the key is reifying the incoming continuation and, as long as it doesn&#x27;t escape the called coroutine , the optimization can be guaranteed. I believe that rust lifetime machinery might help, but it is something I&#x27;m not familiar with.')