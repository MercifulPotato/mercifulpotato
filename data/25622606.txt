Item(by='0xbadcafebee', descendants=None, kids=[25629838], score=None, time=1609690534, title=None, item_type='comment', url=None, parent=25619988, text='Sounds like we need to reinvent data stores!<p>SQL is due for replacement. The combination of schema and data in one constantly mutating hodge podge with no atomic immutable versioning or rollback is absolutely ancient. Migrations are an okay hack but definitely not good enough.<p>ZFS and LVM prove filesystems can do snapshots and restores on a version of filesystem history without a lot of pain, so clearly we just need more work here to make it an everyday thing. Versioning should be the default and probably also an infinite transaction log, seeing as capacity and performance is ridiculous now.<p>And couldn&#x27;t we lock writes, revert a perpetual write journal&#x2F;transaction log to some previous version, and then continue a new write history tree? If you run out of space, overwrite the old history. If you don&#x27;t run out of space, allow reverting back.<p>And allow bulk atomic updates by specifying a method to write files that aren&#x27;t &#x27;live&#x27; until you perform some ioctl, and then atomically expose them and receive the new history version. Then you could do immutable version-controlled storage on a filesystem, right?<p>Blob&#x2F;object stores should be much simpler to do the same with. Just an API rather than ioctl.<p>In this way, replacing a data store immutably will just be replacing a <i>reference to a storage version</i>, the same as using snapshots, but built into the filesystem&#x2F;API.')