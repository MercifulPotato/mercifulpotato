Item(by='dragontamer', descendants=None, kids=[24773980], score=None, time=1602631053, title=None, item_type='comment', url=None, parent=24762840, text='Hmm, a few more allocators to mention.<p>0. Garbage Collection: Reference Counting -- C++, Python, Rust. Reference counting augments any of the allocators discussed in the blogpost with a simple garbage-collection scheme.<p>1. Garbage Collection: Stop and Copy -- This is the easiest garbage collection to implement. This is closely related to the Linear-Allocator, except &quot;free&quot; compiles into a nop. Only &quot;new&quot; matters. When &quot;new&quot; runs out of space (which it will inevitably do), you scan the entire memory space, and copy all &quot;current live objects&quot; to the 2nd heap. (An identically sized heap).<p>Stop and copy uses up 50% of the space (If you have 32GB available, you can only have 2x16GB heaps, and can only use up to 16GBs total). Still, the gross simplicity of stop-and-copy is cool.<p>2. Garbage Collection -- Mark and Sweep: is a bit complicated in my experience. It works well in practice, but its harder to program (especially if you want to do it efficiently, with tri-color invariants and all that).<p>--------<p>Because of the gross simplicity of alloc() in stop-and-copy, it can be very fast in some use cases! If you can&#x27;t figure out how to make free() work with linear allocators, just stop-and-copy the darn thing.<p>-------<p>Garbage collection is reserved for when your links start to point to each other in ways far more complicated thank linked lists.<p>If you have cycles in your linked lists ... or your linked lists act like cons pairs (aka: car &#x2F; cdr) from Lisp, garbage collection is basically almost inevitable. There&#x27;s no real way to know when to delete a pointer safely if you&#x27;re using Lisp-style car&#x2F;cdr pairs. Even reference counting is bad, because cycles are pretty common in that style of programming.')