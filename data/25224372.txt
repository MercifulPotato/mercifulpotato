Item(by='tsimionescu', descendants=None, kids=[25225048], score=None, time=1606434328, title=None, item_type='comment', url=None, parent=25223860, text='Of course that type doesn&#x27;t encode everything there is to know about that function, even assuming purity.<p>Here are some functions that match that type signature:<p><pre><code>    map1 foo x:xs = [foo x]\n\n    mapR foo x:xs = append (mapR foo xs) foo x\n\n    mapI foo x:xs = foo x : mapI foo x:xs\n</code></pre>\nOf course, we can create many more functions that arrange the values in other creative ways, that add more or fewer values etc. If the function isn&#x27;t pure, we can also imagine many more dimensions of functions that do arbitrarily different things from what you would expect.<p>If you want complete signatures without dependent types, you need functions which take only single values of different unknown types, like apply: (a -&gt; b) -&gt; a -&gt; b. If you have more than one parameter of the same unknown type, you&#x27;ll have some ambiguity already.<p>Non-dependent types can only be used to encode extremely simple properties of a program. They are certainly useful, but they are not in any way the be-all, end-all of static verification.')