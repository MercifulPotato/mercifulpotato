Item(by='kilburn', descendants=None, kids=None, score=None, time=1605895538, title=None, item_type='comment', url=None, parent=25161544, text='&gt; For example, in your second link, one of the functions expects a &#x27;complex&#x27; instance DispatchProps which has a method toggleOn... This abstraction doesn&#x27;t make sense conceptually. What is a DispatchProps? It doesn&#x27;t adhere to Alan Kay&#x27;s notion of a &#x27;message&#x27;, it&#x27;s clearly a structure (it&#x27;s a complex one because it exposes a method). Components should communicate to each other via messages, not structures.<p>the `mapDispatchToProps` idea has been in `react-redux` since the very beginning. I don&#x27;t understand what are you complaining about here. If you prefer, you can ignore this practice and pass the whole dispatch function to the component, and then call `dispatch(actionCreator(params))` directly. Typescript won&#x27;t get in the way of you doing that.<p>&gt; Also, the method builder.addMatcher(...) accepts a function as an argument - It doesn&#x27;t seem like an ideal abstraction either. Functions are not messages.<p>The addMatcher API is not concerned with sending messages, it is concerned with receiving them. You are specifying what should happen when a certain message type arrives. Hence it seems normal to me to specify that as a function that given the message does some stuff. Since these are reducers, the &quot;does some stuff&quot; part is: given a previous state and an action of type X, compute and return the new state Y.<p>&gt; Also, the thunkSendMessage function signature is very complex; the return type is highly convoluted. That&#x27;s definitely not a message.<p>Of course not. It is a function that sends some kind of message after asynchronously calling some API and getting its response, or another kind of message if the API call failed. That&#x27;s what the complex type says. The usefulness of thunks is that you <i>do</i> have this notion of &quot;ongoing asynchronous process that may succeed or fail&quot; explicitly represented (so you can for instance cancel it), which you&#x27;ll have a much harder time if you want to represent by using just actions and reducers.<p>&gt; You can already see the complexity seeping into the interfaces. Just a few years of TypeScript is distorting the original philosophy. I remember Dan Abramov was very careful about what to pass into functions and what to return from them and made it a point to encourage cloning objects using the ... spread operator.<p>I think you are misremembering some things here. Dan Abramov used to advocate for a strict separation between presentational and container components [1], including the use of `connect` in exactly the same fashion you are criticizing in your first point.<p>Likewise, cloning objects using the spread operator was never a goal in and of itself. Dan advocated for it as an easier way to avoid mutating the state. Not mutating the state was the point here. Redux-toolkit accomplishes this point by using immer, a library that conceptually gives you a copy of the state so you can just mutate and return that instead (with the advantage that non-modified parts are not cloned).<p>Also, you can just not use that and return spread-operator-cloned objects from your reducer functions instead. Everything will keep working normally (and passing the type checks) in that case.<p>[1] <a href="https:&#x2F;&#x2F;medium.com&#x2F;@dan_abramov&#x2F;smart-and-dumb-components-7ca2f9a7c7d0" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@dan_abramov&#x2F;smart-and-dumb-components-7c...</a><p>PS: Thanks for your work Mark!')