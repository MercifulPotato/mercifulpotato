Item(by='MaxBarraclough', descendants=None, kids=[24955253], score=None, time=1604172256, title=None, item_type='comment', url=None, parent=24954020, text='&gt; You can prove in math your design will work<p>It&#x27;s possible, but extremely labour-intensive, to mathematically prove the correctness of a program. I mentioned this in my previous comment.<p>&gt; In Programming, unless you are working at switch levels, how could you prove your code is most optimized?<p>&#x27;Most optimised&#x27; is an entirely different problem than &#x27;your design will work&#x27;.<p>Complexity theory lets us do something like this, but at a more abstract level, rather than at the level of real-world performance on a particular machine.<p>As you say, real-world code is almost guaranteed <i>not</i> to be perfectly optimal in terms of performance. We really never need to aim for this though. Market forces push for high correctness and performance, to varying degrees across different different problem domains. Performance matters in game-engines and for high-frequency trading, and in those applications, the software engineers put in great effort to optimise their systems, using fewer abstractions.<p>Sometimes the software engineering challenge may be a life-critical hard-real-time system, such as in medicine or aviation. Software engineers are able to deliver such systems. It&#x27;s not of great concern that these systems aren&#x27;t perfectly optimal in terms of their performance, provided the programs give the right outputs and always meet their deadlines.<p>The generation of perfectly optimised code has been researched, branded <i>superoptimisation</i>, [0] but it&#x27;s little more than an academic curiosity. I doubt it will ever be possible to scale it up to be practical for large programs. (I&#x27;m not sure if&#x2F;how they deal with the way most modern processors are terribly complex and don&#x27;t have easily predictable performance.)<p>&gt; Abstraction has removed the possibility of doing that.<p>It&#x27;s very often a sound decision to trade off on performance in order to gain on some other dimension, such as development velocity, or maintainability, or indeed correctness, given the project&#x27;s resource constraints. As tools improve, the Pareto frontier advances, and we get a little closer to being able to &#x27;have it all&#x27;.<p>An example of this might be the use of Rust for web development work, which can apparently greatly improve performance (or greatly reduce the computational resources needed). It can bring the performance of C++, while retaining many of the advantages of safer, higher-level languages like Java and C#.<p>Whether it does this well enough to really grain traction, we&#x27;ll have to wait and see, but I think it&#x27;s a good example.<p>&gt; The closest thing I&#x27;ve seen to Engineering in the Programming world is Industrial Engineering.<p>Industrial engineering is an entirely different discipline than software engineering.<p>For examples of &#x27;proper software engineering&#x27;, the obvious candidates are avionics (as discussed in the article I linked above), and development methodologies involving formal methods, such as with the <i>Tokeneer</i> project. [1][2]<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Superoptimization" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Superoptimization</a><p>[1] <a href="https:&#x2F;&#x2F;blog.adacore.com&#x2F;tokeneer-fully-verifed-with-spark-2014" rel="nofollow">https:&#x2F;&#x2F;blog.adacore.com&#x2F;tokeneer-fully-verifed-with-spark-2...</a><p>[2] [Huge PDF] <a href="http:&#x2F;&#x2F;www.adacore.com&#x2F;uploads&#x2F;downloads&#x2F;Tokeneer_Report.pdf" rel="nofollow">http:&#x2F;&#x2F;www.adacore.com&#x2F;uploads&#x2F;downloads&#x2F;Tokeneer_Report.pdf</a>')