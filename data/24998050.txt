Item(by='Diggsey', descendants=None, kids=None, score=None, time=1604583101, title=None, item_type='comment', url=None, parent=24982655, text='&gt; Blocking an OS thread as a mean to be compatible is not exactly what we&#x27;re trying to do here.<p>It&#x27;s what Go does whenever you call into a C function or make a system-call. As long as those blocking functions are not the bottleneck then it works fine.<p>My problem with the &quot;colored function&quot; analogy is that it implies that the problem is somehow due to the surface syntax, when in reality the problem still exists in all languages that support procedural IO: some of those languages like to just pretend that the problem doesn&#x27;t exist.<p>The only language I&#x27;m aware of which truly solves that is Haskell, since all IO happens via a monad.<p>&gt; Yes, that&#x27;s not the absolute performance possible. But why care about that?<p>This point was not about performance. It&#x27;s about the pitfalls of writing all of your code on top of a complex and buggy runtime.<p>Programming is a lot simpler, and development is a lot faster, when I don&#x27;t have to worry about that.<p>There are also several things that are a lot more complicated when you bake a complex runtime into the language like Go does. Thread-local storage is completely broken for one. If you do any kind of GUI programming, you may need to use `runtime.LockOSThread` as most GUIs expect function calls from a single thread. etc. etc.')