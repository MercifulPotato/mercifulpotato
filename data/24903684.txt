Item(by='filoeleven', descendants=None, kids=None, score=None, time=1603762682, title=None, item_type='comment', url=None, parent=24893755, text='I can only speak about Clojure, since it’s the only lisp I know.  After just a few days of playing with it though, I started to see the parentheses as a warm and friendly hug, wrapping everything inside of them in its own scope that doesn’t affect its parents.  Reading JavaScript, my main driver, became harder in comparison.<p><pre><code>  function doSomething(a, b) {&#x2F;* something! *&#x2F;}\n</code></pre>\nis okay, since the “function” keyword is a simple indicator, and it’s clear that it’s a function declaration.  The kids these days often use<p><pre><code>  const doSomething = (a, b) =&gt; {&#x2F;* whatever *&#x2F;}\n</code></pre>\nand that is awful for readability.  It’s much harder to scan for function definitions amidst value declarations.  I’m nearly 20 chars in before I even know it’s a function.  Worse yet is something like<p><pre><code>  const doSomething = (a, b) =&gt; b =&gt; “some closure”;\n</code></pre>\nThis threatens to stretch my capability to understand the context I’m in when reading it.  “b” is just kinda floating there amongst the infixed arrows, and I have to read on to know it’s an argument, and I have to run through the calculation of what “b” is every time.  Compare:<p><pre><code>  (defn do-something [a b] (fn [b] “some clojure”))\n</code></pre>\nI can count the parens, there is no implicit scoping of the function body. My editor can too, which means I often don’t have to.  It’s obvious that it returns a function.  This part is Clojure-specific, but I also have strong guarantees that the returned function cannot pull the rug out from under me with whatever I pass to it by arbitrarily mutating some argument.<p>To me at least, (fn-name args) was both more readable and makes more sense than fnName(args) after a few days, and I never learned a lisp until I was 37.  Maybe I just found a style preference later in life, marking me as a lisp survivor.  Maybe we’ve just been doing it wrong for decades and have grown accustomed to it.  I can’t say.  But the power of the language itself coupled with the code editing features it enables makes me think that the whole field has been on the wrong track, or maybe even off the rails, for decades.<p>The JS code I write now is more flexible, more resilient, more testable, and more maintainable as a result of learning Clojure.  I doubt anyone can say the opposite: that a C-style language improved their understanding of lisp.  (Not addressing you with this part, dear poster, since your gripe is rooted in the syntax.)<p>[NaN] “kids these days“ is just friendly ribbing.  I’ve got the grey beard now, so I‘m free to play the part.  Language maintainers tend to be older, and we cause more problems.')