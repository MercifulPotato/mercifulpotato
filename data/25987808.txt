Item(by='piaste', descendants=None, kids=[25988145, 25988795], score=None, time=1612179860, title=None, item_type='comment', url=None, parent=25987538, text='&gt; Even one of the best known and oldest F# library FParsec has it&#x27;s high-performance parts in C# - that&#x27;s telling.<p>To be more specific, it has a C# library so it can use _unsafe {}_ blocks to perform manual memory management. This is one key performance-oriented feature that F# lacks.<p>Other than that, you _can_ write F# that&#x27;s about as fast as non-unsafe C#, although it means giving up most of the nicer and safer features of F#. Use mutable structs and classes instead of immutable records, for&#x2F;while loops instead of higher-order functions, magic values instead of option&#x2F;result types, etc... I&#x27;ve done it in a couple of hot paths where it made sense, but quite reluctantly.<p>Inline functions are still fine though for writing zero-cost helpers, and I don&#x27;t think C# has them (there&#x27;s an &lt;AggressiveInlining&gt; attribute but IIRC it&#x27;s just a hint, the compiler isn&#x27;t required to actually obey).<p>Ironically, F# _could_ become the best language for high-performance .NET programming, because it supports directly inlining IL instructions intermixed with regular code (whereas C# has to go through the ILGenerator class). Unfortunately it&#x27;s considered such a niche case that it&#x27;s not planned to be expanded beyond the standard library, and to use it in your code you have to enable an undocumented &#x2F; unsupported compiler flag.')