Item(by='mixedCase', descendants=None, kids=[25889150, 25894914], score=None, time=1611455557, title=None, item_type='comment', url=None, parent=25887978, text='Hard agree with 4 and 5. Soft agree with 6, I think there&#x27;s nothing&#x27;s wrong with sharing specially since many of the important teachings are incompatible with the kind of people for whom these lessons are not obvious after a couple of years of experience.<p>But points 1 to 3 give me a visceral negative reaction. I&#x27;ll go into detail:<p>1) If you&#x27;re writing anything that&#x27;s not a script with a few lines, and you care about your software not being terrible to maintain and change for <i>other people</i> in real production settings, typed languages wipe the floor with dynamic languages (excluding ecosystem moats, just judging the languages).<p>Good types act as documentation, a higher form of tests, and a form a development paradigm to make it easier to iterate through code new or old by building&#x2F;modifying stacks of machine-checkable assertions that you can pass around.\nNot enough devs are taught how to think with types and extract the most out of them, but any half-decent dev can be taught how to do it in a few days and the difference is night and day to anyone who has experienced it first-hand.<p>2) Java is terrible, but it&#x27;s not as unworkable as some other mainstream languages given its extensibility and ecosystem. Java was <i>sold</i> to managers as &quot;prevents cheap workers from making mistakes&quot;, but it was never about that and it&#x27;s mostly terrible at it.<p>3) I would say that&#x27;s a deceitful take, for only the absolute minority of systems have to care about scaling beyond a single server with failover (and a separate database if going with managed DB). For those systems that <i>absolutely do care</i> about horizontal scalability the answers should be absolutely obvious to any senior dev from the moment the requirements are stated. And for those cases where someone feels there may be a need for a complex scalability solution but there&#x27;s not an obvious case for it yet, development will most of the time be better off starting with the simple solution and selectively optimizing as needed, just don&#x27;t make it impossible to switch later down the road.')