Item(by='estebank', descendants=None, kids=[25163773], score=None, time=1605898112, title=None, item_type='comment', url=None, parent=25162956, text='&gt; I simply don&#x27;t think that you can auto-generate zero-cost safe C or C++ bindings automatically.<p>As stated, that&#x27;s likely an accurate statement, <i>but</i> if you separate the requirements for the bindings the problem looks <i>way</i> more tractable:<p>- auto-generate: I&#x27;m pretty positive that this point is only hard given the following, and I feel you would agree with that assessment, so I&#x27;ll just focus on the other ones.<p>- zero-cost: doing zero-cost ffi is the best option, but a lot of advanced constructs that people want to use cannot be well represented in that way because they rely on the internal consistency of the host language. That means that dynamically loading a library written in Rust might make it so that you can <i>only</i> interact with ADTs, trait objects and whitelisted provided traits on those ADTs, potentially only through trait objects. That&#x27;s not zero-cost, but it is super powerful. ObjectiveC has lived its entire existence going through vtables and that has even enabled runtime introspection that was super useful.<p>- safe: safety can be accomplished easily enough if you don&#x27;t constrain yourself to zero-cost <i>or</i> if you put constraints on <i>what</i> is supported for zero-cost ffi. You could say that method calls on trait objects is safe, but type parameters are out of scope because ffi and monomorphization are not compatible. You could restrict yourself to either no borrows crossing ffi, or no mutable data (only internal mutability through trait methods) allowed.<p>- C or C++: I would focus on <i>other</i> languages, personally. Having easy interop with Java, C#, Python and JavaScript would open opportunities that do not have anything to do with systems programming per-se, but that would make it more likely that the next numpy isn&#x27;t written in pure C.<p>- automatically: the need for extra annotations in either end of the interop simplifies part of the problem and might even help with documentation. Adding some light ownership information to APIs in non-Rust languages would be great for non-Rust users of those APIs.')