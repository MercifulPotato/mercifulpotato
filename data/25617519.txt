Item(by='AsyncAwait', descendants=None, kids=[25620383], score=None, time=1609629002, title=None, item_type='comment', url=None, parent=25616356, text='&gt;  I want to remind that, parallel sysV-init was pretty fast machinery and was very manageable.<p>That does nothing for the fact that SysV init was a pile of shell scripts inconsistent across distros and even individual packages. I&#x27;d take systemd&#x27;s declarative, portable service definitions any day over that mess.<p>SysV init did not take care of consolekit being an unmaintained mess either. systemd did.<p>Besides, systemd can recognize that I had plugged in a specific kind of device that needs this sort of setup and do that for me automatically. Hence the &#x27;manager&#x27; part. None of its supposed &#x27;competitors&#x27; can do that themselves.<p>&gt; Kernel doesn&#x27;t breach this principle either. It provides an interface between the hardware and software &amp; lives in its own space; that&#x27;s it.<p>I don&#x27;t know, eBPF for example is an entire complex beast of its own that could be argued to violate that, well beyond what&#x27;s &#x27;required&#x27;.<p>If you take the view that as long as the system has a single defined job, (interfaces to hardware and exposes APIs to userspace for the kernel), systemd does have a definition like that too. It manages the system&#x27;s dynamic resources during its lifetime. That&#x27;s a &#x27;single&#x27; job. It&#x27;s not if you decompose it, but the kernel is in a similar situation at that point.<p>&gt; When systemd overtakes a part of the system with its module, it&#x27;s very hard to discover it.<p>systemd does not do that, sounds like you&#x27;re blaming bad distro defaults (optional components being enabled by default) on systemd.')