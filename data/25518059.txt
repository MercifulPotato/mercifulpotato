Item(by='jstimpfle', descendants=None, kids=[25518186], score=None, time=1608734782, title=None, item_type='comment', url=None, parent=25517457, text='&gt; bounds checking enabled by default for arrays and strings<p>You can make your own explicit bounds checks, or you can use valgrind (which, just like any type system, can understand only simple situations).\nYou can use C++ which actually does allow you to do bounds checking by default, if you&#x27;re into such things.<p>&gt; - real enumerations that aren&#x27;t implicit converted into numeric types (fixed in C++11, if one bothers to use enum classes)<p>&gt; - enumerations can be used as indexes (C++ can work around this with enum classes and some boilerplate templates)<p>&gt; - ability to actually define subtypes that are enforced by the type system (C++ offers this, provided one does the required boilerplate class&#x2F;template code)<p>These are total non-issues in practice, since treating them as integers is usually what you want (you almost always want to support some light arithmetic on them, you want to store sentinel values sometimes...).\nFurthermore (as you say) C++ allows you to treat them as separate types.<p>&gt; most data conversions must be done explicitly<p>This is the same with C, except for integral types where though you need to turn on warnings to avoid implicit downcasts of integral types with some (most?) compilers. For upcasts, implicit is what you want.<p>&gt; memory allocation by default doesn&#x27;t require doing math with data sizes (C++ as well, yet there is too much malloc()&#x2F;free() pollution in C++ code bases)<p>That&#x27;s FUD, if you do memory allocation - of course you need to compute the number of bytes you need.<p>If you do &quot;new Foo[count]&quot; you&#x27;re likely doing it wrong anyway, just like if you&#x27;re calling malloc directly.\nTo equate memory allocation with malloc (or syntax sugar in fancy object languages) is WRONG.\nmalloc() is a stupid default allocator, and you don&#x27;t know\nwhat allocator you&#x27;re getting if you don&#x27;t provide your own. Good system performance often requires writing (simple)\ncustom allocators instead of using malloc which has to deal with random allocation sizes, allocation patterns,\nand multiple threads.<p>Whether using your own allocator or not, it shouldn&#x27;t be too much to expect you to write a single line like:<p><pre><code>    #define ALLOCATE(type, count) ((type *) do_alloc(sizeof (type), (count)))\n</code></pre>\nOr even<p><pre><code>    #define ALLOCATE(ptr, count) (ptr = do_alloc(sizeof *(ptr), (count))\n</code></pre>\nNow tell me, why exactly is &quot;new Foo[count]&quot; safer than &quot;ALLOCATE(Foo, count)&quot;? Or just do this minimal boilerplate by hand, this is not a practical issue unless your\ncode is very badly factored (good code requires only few allocations).<p>&gt; no need to deal with pointers for out parameters, thanks reference parameters, which even in C++ there isn&#x27;t any guarantee they aren&#x27;t null, even though that would actually trigger UB)<p>This is not a problem at all in practice, and anyway, if you need a lot of that you&#x27;re doing something wrong. I very much like that C keeps it simple and you always see what happens. This is unlike Pascal and its Objects extensions, where it&#x27;s impossible to see which data you&#x27;re actually mutating because there are like 10 different &quot;adressing modes&quot;. For example, dynamic arrays in Pascal can be assigned to other variables (or passed through a function parameter), and they will share memory, but only until one calls SetLength() on one &quot;reference&quot; at which point a Copy-on-Write is happening and they split lifes. This is not only not useful but extremely confusing. And the whole object extensions to Pascal (I can speak for Delphi) are built in that way - trying to not let the user see the complexity of what they&#x27;re doing - which works until it doesn&#x27;t, which is when you&#x27;re dealing with extremely difficult to debug problems. Frankly Delphi ecosystem is a mess because it&#x27;s a set of layers where each time they tried to be clever and add another philosophy-driven set of classes with implicit behaviours on top that was supposed to fix the previous layer&#x27;s mistakes.<p>&gt; - if one wants to do crazy C like code, all the necessary gear is available, pragmas to turn off bounds checking, pointer arithmetic, unchecked casts, unions, mapping variables to explicit memory addresses, pointers to callbacks, it is everything there in the package. The original bare bones ISO Pascal wasn&#x27;t no longer relevant in the mid-80&#x27;s, unless the teacher didn&#x27;t knew any better.<p>This is why I took issue - you can&#x27;t have both low-level bit twidding and &quot;memory safe&quot; programming. At most you can have a language that lets you choose between one or the other in a rather integrated system, but then you&#x27;re still dealing with this abstraction gap, and having to traverse it constantly is not pleasant.')