Item(by='yorwba', descendants=None, kids=None, score=None, time=1609180267, title=None, item_type='comment', url=None, parent=25549290, text='&gt; we decided to move forwards with a game based software that:<p>&gt;     Would have a low ‘barrier of entry’<p>&gt;        Be easy for students from any background to pick up<p>&gt;        Be visual and simplistic to wrap your head around<p>&gt;        Have some level of a competitive &#x2F; addictive nature and well defined metrics of success<p>...<p>&gt; ... For the frontend, we had to create a clear visualization of what the processes were doing, and also had to build a UI that allowed for intuitively creating programs in Redcode. The latter was especially important for us as the goal for this project was to require as little technical experience as possible, and we also knew that Corewars was a challenging game.<p>This sounds like a typical case of listing your requirements (low barrier to entry, easy to pick up, simplistic to wrap your head around), but picking something that doesn&#x27;t satisfy those requirements (a challenging game) while thinking that you can make it work somehow (build a UI to make it more intuitive).<p>I&#x27;m not surprised they ran into a problem with that approach.<p>&gt; ... Before deployment, we’d assumed that Corewars could be learned and played by students at a semi-competitive level within a sitting. Even with the beginner mode that featured a scoped back set of assembly commands and high visibility into the game’s processes, it took Adi an hour and a half of 1:1 teaching time within the groups to get them comfortable with the game. We can estimate from this testing it would take students ~3 hours to learn the game individually, and another ~3-4 hours of logical challenge questions to get to a competitive level.<p>(I think those numbers are more likely to be underestimates, except for students with a lot of prior knowledge.)<p>My high school CS teacher assigned writing a Corewars interpreter as a project, likely because he thought it would be a fun way to expose his students to assembly language. I did enjoy it, but most other students were already pretty lost just trying to understand how programs were executing in the reference implementation, let alone writing their own interpreter.<p>I think something like AntMe ( <a href="http:&#x2F;&#x2F;wiki.antme.net&#x2F;en&#x2F;Main_Page" rel="nofollow">http:&#x2F;&#x2F;wiki.antme.net&#x2F;en&#x2F;Main_Page</a> ) would&#x27;ve been a better choice of programming game (I only have experience with the two my CS teacher tried on his students, so it&#x27;s likely I&#x27;m missing something better): the game world is an abstraction of physical reality, so it&#x27;s not hard to visualize, and there&#x27;s a variety of tasks of different complexity (from just making the ants walk around like LOGO turtles, to foraging for food, to waging war against other ant colonies).')