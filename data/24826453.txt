Item(by='IshKebab', descendants=None, kids=[24828453], score=None, time=1603116328, title=None, item_type='comment', url=None, parent=24819555, text='Lol ok I would but apparently I have to sign up to Debian Salsa and you can&#x27;t sign up with a gmail account. I don&#x27;t think they really want contributions! Anyway here is the code. I made some minor improvements that won&#x27;t affect the runtime. You need to `npm install @types&#x2F;node`.<p><pre><code>    &#x2F;&#x2F; The Computer Language Benchmarks Game\n    &#x2F;&#x2F; https:&#x2F;&#x2F;salsa.debian.org&#x2F;benchmarksgame-team&#x2F;benchmarksgame&#x2F;\n    &#x2F;&#x2F;\n    &#x2F;&#x2F; contributed by Ian Osgood\n    &#x2F;&#x2F; Optimized by Roy Williams\n    &#x2F;&#x2F; modified for Node.js by Isaac Gouy\n    &#x2F;&#x2F; multi thread by Andrey Filatkin\n\n    import { Worker as NodeWorker, isMainThread, parentPort, workerData } from &#x27;worker_threads&#x27;;\n    import * as os from &#x27;os&#x27;;\n\n    enum MessageVariant {\n        Sab,\n        Au,\n        Atu,\n        Exit,\n    }\n\n    interface SabMessage {\n        variant: MessageVariant.Sab;\n        data: Float64Array;\n    }\n\n    interface AuMessage {\n        variant: MessageVariant.Au;\n        vec1: UVWField,\n        vec2: UVWField,\n    }\n\n    interface AtuMessage {\n        variant: MessageVariant.Atu;\n        vec1: UVWField,\n        vec2: UVWField,\n    }\n\n    interface ExitMessage {\n        variant: MessageVariant.Exit;\n    }\n\n    type Message = SabMessage | AuMessage | AtuMessage | ExitMessage;\n\n    interface UVW {\n        u: Float64Array;\n        v: Float64Array;\n        w: Float64Array;\n    }\n\n    type UVWField = keyof UVW;\n\n    const bytesPerFloat = Float64Array.BYTES_PER_ELEMENT;\n\n    if (isMainThread) {\n        mainThread(+process.argv[2]);\n    } else {\n        workerThread(workerData);\n    }\n\n    async function mainThread(n: number) {\n        const sab = new SharedArrayBuffer(3 * bytesPerFloat * n);\n        const u = new Float64Array(sab, 0, n).fill(1);\n        const v = new Float64Array(sab, bytesPerFloat * n, n);\n\n        const workers = new Set&lt;NodeWorker&gt;();\n        startWorkers();\n\n        for (let i = 0; i &lt; 10; i++) {\n            await atAu(&#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;);\n            await atAu(&#x27;v&#x27;, &#x27;u&#x27;, &#x27;w&#x27;);\n        }\n\n        stopWorkers();\n\n        let vBv = 0;\n        let vv = 0;\n        for (let i = 0; i &lt; n; i++) {\n            vBv += u[i] * v[i];\n            vv += v[i] * v[i];\n        }\n\n        const result = Math.sqrt(vBv &#x2F; vv);\n\n        console.log(result.toFixed(9));\n\n        async function atAu(u: UVWField, v: UVWField, w: UVWField) {\n            await work({ variant: MessageVariant.Au, vec1: u, vec2: w });\n            await work({ variant: MessageVariant.Atu, vec1: w, vec2: v });\n        }\n\n        function startWorkers() {\n            const cpus = os.cpus().length;\n            const chunk = Math.ceil(n &#x2F; cpus);\n\n            for (let i = 0; i &lt; cpus; i++) {\n                const start = i * chunk;\n                let end = start + chunk;\n                if (end &gt; n) {\n                    end = n;\n                }\n                const worker = new NodeWorker(__filename, {workerData: {n, start, end}});\n\n                worker.postMessage({ variant: MessageVariant.Sab, data: sab });\n                workers.add(worker);\n            }\n        }\n\n        function work(message: Message) {\n            return new Promise(resolve =&gt; {\n                let wait = 0;\n                workers.forEach(worker =&gt; {\n                    worker.postMessage(message);\n                    worker.once(&#x27;message&#x27;, () =&gt; {\n                        wait--;\n                        if (wait === 0) {\n                            resolve();\n                        }\n                    });\n                    wait++;\n                });\n            });\n        }\n\n        function stopWorkers() {\n            workers.forEach(worker =&gt; worker.postMessage({ variant: MessageVariant.Exit }));\n        }\n    }\n\n    function workerThread({n, start, end}: {n: number, start: number, end: number}) {\n        let data: UVW | undefined = undefined;\n\n        if (parentPort === null) {\n            return;\n        }\n\n        parentPort.on(&#x27;message&#x27;, (message: Message) =&gt; {\n            switch (message.variant) {\n                case MessageVariant.Sab:\n                    data = {\n                        u: new Float64Array(message.data, 0, n),\n                        v: new Float64Array(message.data, bytesPerFloat * n, n),\n                        w: new Float64Array(message.data, 2 * bytesPerFloat * n, n),\n                    };\n                    break;\n                case MessageVariant.Au:\n                    if (data === undefined) {\n                        throw Error(&#x27;Au received before Sab&#x27;);\n                    }\n                    au(data[message.vec1], data[message.vec2]);\n                    parentPort!.postMessage({});\n                    break;\n                case MessageVariant.Atu:\n                    if (data === undefined) {\n                        throw Error(&#x27;Atu received before Sab&#x27;);\n                    }\n                    atu(data[message.vec1], data[message.vec2]);\n                    parentPort!.postMessage({});\n                    break;\n                case MessageVariant.Exit:\n                    process.exit();\n            }\n        });\n\n        function au(u: Float64Array, v: Float64Array) {\n            for (let i = start; i &lt; end; i++) {\n                let t = 0;\n                for (let j = 0; j &lt; n; j++) {\n                    t += u[j] &#x2F; a(i, j);\n                }\n                v[i] = t;\n            }\n        }\n\n        function atu(u: Float64Array, v: Float64Array) {\n            for (let i = start; i &lt; end; i++) {\n                let t = 0;\n                for (let j = 0; j &lt; n; j++) {\n                    t += u[j] &#x2F; a(j, i);\n                }\n                v[i] = t;\n            }\n        }\n\n        function a(i: number, j: number) {\n            return ((i + j) * (i + j + 1) &gt;&gt;&gt; 1) + i + 1;\n        }\n    }</code></pre>')