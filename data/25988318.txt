Item(by='ParadigmComplex', descendants=None, kids=[25988506], score=None, time=1612185147, title=None, item_type='comment', url=None, parent=25985645, text='&gt; For a more extreme case, there is a schroot (or a docker container) with &#x2F;home, audio and X mapped in. Works surprisingly well for desktop apps, like those embedded IDEs which require a specific Linux distribution you donâ€™t want to run. You do have manage desktop integration (menu items, file associations) yourself though.<p>Very early Bedrock Linux prototypes were exactly this; including the choice of schroot.  Bedrock could be correctly described as taking this idea and running with it, trying to stomp out as many of the &quot;you do have to&quot;&#x27;s and &quot;except&quot;&#x27;s as it can.<p>&gt; Those solutions are hard to set up than bedrock, but they also do not have special filesystem magic,<p>I think a fair description of the trade-off between Bedrock and the two alternatives you&#x27;ve laid out should mention the breadth of functionality Bedrock offers they do not.  This includes but is not limited to:<p>- Shell tab completion.  For example, Debian&#x27;s zsh can tab-complete Arch Linux&#x27;s pacman<p>- Init systems.  For example, one could run Void Linux&#x27;s runit init, install Arch Linux&#x27;s systemd, and reboot into systemd.<p>- Kernels.  One could run Arch&#x27;s kernel, install Debian&#x27;s, update the bootloader configuration, reboot, and select Debian&#x27;s kernel.<p>et al.<p>I expect, if you think about it long enough, you could see some ways schroot with things like &#x2F;home mapped in could be extended to cover those use cases.  If you pursue those, you&#x27;d end up recreating Bedrock.<p>&gt; so I bet they are much easier to debug.<p>I am doubtful any user which understands setup schroot you described, who also takes the time to familiarize himself or herself with Bedrock, would have comparative difficult debugging a Bedrock system.')