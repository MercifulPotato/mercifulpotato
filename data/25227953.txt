Item(by='Someone', descendants=None, kids=None, score=None, time=1606478543, title=None, item_type='comment', url=None, parent=25226603, text='Its a whole different ball game. The current solution recognizes Mac system calls and routes them (maybe with some exceptions) 1:1 to the host OS, so there is a single OS that knows all what’s happening in the system.<p>If you have two OSes, it gets complicated. You have two virtual memory maps, two structures tracking open files, two disk caches, two clipboards, two networking stacks, etc.<p>As an example, if an application on the guest OS tries to open a file for exclusive access, the guest OS checks it’s data structures to see whether that’s possible. That’s insufficient, as the file may be open on the host OS. Similarly, the guest OS may cache writes to a file, and the host OS won’t check the guest OS’s disk cache when an application on the host OS reads from that same file.<p>So, you either make that impossible by giving the guest OS a disk for its exclusive use (could be a virtual one), or you provide ways for the two OSes to co-exist on the same hardware. That can be made to work, (but isn’t ideal; copying files between the two OSes would be cumbersome) for disks, but is too impractical for other hardware (you’re not going to set aside one of your USB ports for exclusive use by the guest OS, just in case it needs it, and certainly aren’t going to require users to plug in a second keyboard and mouse or even a separate graphics card for use by the guest OS)<p>So, the two have to cooperate. I think <a href="http:&#x2F;&#x2F;cs.yale.edu&#x2F;homes&#x2F;aspnes&#x2F;pinewiki&#x2F;Virtualization.html" rel="nofollow">http:&#x2F;&#x2F;cs.yale.edu&#x2F;homes&#x2F;aspnes&#x2F;pinewiki&#x2F;Virtualization.html</a> lays out the options well.<p>The ideal goal to run any guest OS, unmodified, isn’t attainable, as it would require the host OS to, somehow, know how every possible guest OS, including ones yet to be written, accesses its hardware. So, you either support specific OSes (say only Mac OS), or set rules that guest OSes must follow to be supported.<p>Edit: the latter is what typically is done, and isn’t that bad, nowadays, as most OSes are made to run on PC hardware, where device discovery, etc. is standardized.')