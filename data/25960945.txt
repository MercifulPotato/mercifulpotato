Item(by='bob1029', descendants=None, kids=[25961113, 25966044, 25961739, 25966087], score=None, time=1611946835, title=None, item_type='comment', url=None, parent=25958012, text='I have personally found that making even the most primitive efforts at single-writer principle and batching IO in your software can make many orders of magnitude difference.<p>Saturating an NVMe drive with a single x86 thread is trivial if you change how you play the game. Using async&#x2F;await and yielding to the OS is not going to cut it anymore. Latency with these drives is measured in microseconds. You are better off doing microbatches of writes (10-1000 uS wide) and pushing these to disk with a single thread that monitors a queue in a busy wait loop (sort of like LMAX Disruptor but even more aggressive).<p>Thinking about high core count parts, sacrificing an entire thread to busy waiting so you can write your transactions to disk very quickly is not a terrible prospect anymore. This same ideology is also really useful for ultra-precise execution of future timed actions. Approaches in managed lanaguages like Task.Delay or even Thread.Sleep are insanely inaccurate by comparison. The humble while(true) loop is certainly not energy efficient, but it is very responsive and predictable as long as you dont ever yield. What&#x27;s one core when you have 63 more to go around?')