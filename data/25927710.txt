Item(by='dgb23', descendants=None, kids=None, score=None, time=1611752770, title=None, item_type='comment', url=None, parent=25925335, text='&gt; The process of meeting human needs is messy because both human needs and the tools we have at our disposal are a constantly moving target.<p>Software development is inherently explorative. Finding the right solutions is exactly that: finding, discovery, learning and play. IMO This is best enabled by fast feedback loops and highly dynamic, interactive systems and visualization.<p>Sometimes it is possible&#x2F;feasible to parametrize a tool beyond what it is supposed to be doing to enable this kind of play and discovery, but also to make the process of building data, plumbing and so on just a bit more efficient and fun.<p>Game programmers get that: At some point while developing a game, they create the tools that produce the data, or the parameters, typically controlled with a visual interface, a configuration language or a scripting language. Level editors, state machines, behavior trees, story boards, flow scripting etc.<p>Another field that does this well is scientific computing, they use Jupiter Notebooks etc. with integrated REPLs and graph visualization.<p>The whole &quot;no-code&quot; and &quot;low-code&quot; trend[0] also shows that people are willing to program with constrained, visual languages. It empowers them and connects their mental model more directly to a product (instead of having to go all the way through a team of implementers for every change that could be exposed as data).<p>[0] I personnally don&#x27;t like the terms &quot;no-code&quot; and &quot;low-code&quot; at all, because they describe what it is not, instead of what it is: visual programming. It&#x27;s like &quot;no-sql&quot;: Could be anything from a configuration file, to a document db, to a key-value store or a ACID graph db.')