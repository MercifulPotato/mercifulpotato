Item(by='jagrsw', descendants=None, kids=[25823289, 25821536], score=None, time=1610974388, title=None, item_type='comment', url=None, parent=25818126, text='A possibly similar story:<p>I sometimes play video games on Steam under Linux. Recently I bought a new CPU (based on Zen3) and one of the games - Dirt Rally - started segfaulting.<p>After a quick fight with attaching strace to a running process under Steam (it was crashing v. quickly, so some racy script was needed), it turned out it crashes with<p><pre><code>  SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_PKUERR, si_addr=0x7ff88440e7b8}\n</code></pre>\nA quick session with kernel sources, revealed it&#x27;s about Memory Protection Keys (this causes SEGV_PKUERR), which seemed like something that game was not using at all, because it&#x27;s quite a new feature. After another hour or two, I found out what was the cause. The game was mmaping a PROT_EXEC memory segment without the PROT_READ flag, and was trying to read something from there with a &#x27;mov&#x27; assembler instruction.<p><pre><code>  mprotect(0x7ff884400000, 139264, PROT_EXEC) = 0\n</code></pre>\nAnd under older i386&#x2F;x86-64 CPUs it implicitly means PROT_EXEC|PROT_READ, because there is no way to make something executable, but readable. Under newer CPUs, the Linux kernel uses Memory Protection Keys to make the memory region actually executable-only.<p>After creating a quick&#x27;n&#x27;dirty LD_PRELOAD&#x27;able lib, the problem went away. Though, I wonder about Linus Torvald&#x27;s mantra here, that the Linux kernel shouldn&#x27;t break the userspace :)<p><pre><code>  $  cat game.c\n  #include &lt;sys&#x2F;mman.h&gt;\n  #include &lt;unistd.h&gt;\n  #include &lt;sys&#x2F;syscall.h&gt;\n  \n  int mprotect(void *addr, size_t len, int prot) {\n   if (prot == PROT_EXEC) {\n    prot |= PROT_READ;\n   }\n   return syscall(__NR_mprotect, addr, len, prot);\n  }\n  $ gcc game.c -shared -o game.so\n  $ LD_PRELOAD=.&#x2F;game.so steam</code></pre>')