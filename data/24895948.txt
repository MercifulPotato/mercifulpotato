Item(by='hajile', descendants=None, kids=[24903878], score=None, time=1603719104, title=None, item_type='comment', url=None, parent=24895429, text='Those are both great languages.<p>Rust is very much a ml variant. It&#x27;s all the things you claim and probably more. It&#x27;s also at least an order of magnitude more complex. If you know rust, you&#x27;ll probably find SML super easy to learn and refreshingly easy to code.<p>People gravitating toward SML likely want a few things: easy to learn, simple infix syntax with functional support, compile time type static type checks, multithreaded, very fast without a drastic recode.<p>Common lisp libraries are better, but not drastically so (well, I&#x27;ve never had 5 grand to throw at lisp works, so I can&#x27;t comment there). CL is more complex to learn (must people can probably learn the entire SML language in the time it takes to master the loop macro). Macros are powerful, but mean that even if you can find a lisp dev, it&#x27;ll take a long time for them to learn your custom variant of the language.<p>CL offers unofficial threading, but last I checked it was much harder than the SML solutions. CL is pretty fast out of the box, but if you ever need peak performance, the code changes a lot and can become very finicky (though CL makes seamlessly hiding those bits easier than most languages). Even at it&#x27;s most optimized, I don&#x27;t know that it can match milton in performance or memory usage.<p>Dynamic vs static typing is a battle that&#x27;s all but over. When you have devs coming and going on a team, type make transitions easier. Loads of dynamic languages have started adding them and even CL sort of does.<p>CL has loads of interesting features from well known ones like macros&#x2F;reader macros or metaobject protocol to less known ones like optional dynamic scoping.<p>I&#x27;m just saying why I enjoy SML (not trying to argue that it&#x27;s the end all, be all of programming). There are other great languages too. Do what you love.')