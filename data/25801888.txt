Item(by='jorangreef', descendants=None, kids=[25802085], score=None, time=1610801265, title=None, item_type='comment', url=None, parent=25801851, text='Good question.<p>Assuming we both mean &quot;memory safety&quot; as in a guarantee given by the language (e.g. Rust), then no, logically speaking, it can&#x27;t be a requisite for correctness, and it&#x27;s not even a subset of correctness.<p>Here&#x27;s why:<p>If you can write a correct program in a language which does not guarantee memory safety (which we certainly could, for example, simply by not allocating memory at all, or not using pointers etc, or by using runtime checks e.g. to ensure there are no double frees or out of bounds reads&#x2F;writes), then memory safety is neither a subset of, nor a requisite for correctness.<p>Memory safety is a double-edged sword. It can make correctness easier to achieve. But that also depends on how the language implements memory safety. If this is done by at the expense of a steeper learning curve, then that could in itself be an argument that the language is less likely to lead towards correctness, as opposed to say an almost memory safe language that implements 80% of this guarantee while optimizing for readability, and with a weekend learning curve.<p>Historically, the lack of memory safety has obviously been the cause of too many CVEs. But even CVEs in themselves are more a measure of security than correctness. I would say that exhaustive fine-grained error handling checked by the compiler is probably right up there for writing correct programs.')