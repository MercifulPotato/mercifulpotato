Item(by='novok', descendants=None, kids=[25524911], score=None, time=1608776348, title=None, item_type='comment', url=None, parent=25524314, text='I work in improving performance at a big tech company.  It can be like dragging feet to get executives, managers and developers to care about improving performance because incentives are misaligned and it&#x27;s frankly a chore compared to the million other things you have to be doing. It&#x27;s also significantly harder to show the business metric improvement that comes from performance improvements than it does from simple A&#x2F;B tests due how much variance there are in performance metrics compared to A&#x2F;B testing.  It&#x27;s very much like security actually.<p>For games, it&#x27;s not a &#x27;culture&#x27;, it&#x27;s because games become very frustrating to play when non-responsive in anything fast paced, and thus will review badly and become &#x27;not fun&#x27; and thus will not sell.  It&#x27;s directly connected to sales metrics, which is why management in game companies give space for it, and why CDPR recently offered refunds for a game because of bad perf on the PS4 tier of consoles, which is fairly unprecedented.  You&#x27;ll notice worse performance in slower paced games typically, such as Civ 6.<p>Also I&#x27;ve worked on trying to improve swift build perf and have worked on large C++ codebases before.  The reason why C++ is slow to compile typically is because templates cause an explosion in code generation, everyone uses boost &amp; the stdlib smart pointers &amp; containers, which all template heavily and result in slow build perf and large binary sizes.  Swift &amp; rust do that, often implicitly and in an invisible to the programmer way and type inference are the typical reasons why it is slow and they too, create large binaries.  When I started running into swift&#x27;s build problems, I internally said to myself &quot;oh boy, it&#x27;s C++ again&quot; and if you go to WWDC and talk to Xcode&#x27;s engineers or swift compiler engineers, they often call swift &#x27;new c++&#x27; and other not as nice names.  Swift and rust are also incredibly complicated languages with a lot of edge cases when you start getting into the weeds, on par with C++.<p>Why are these languages using features such as type inference, stricter and more complicated type systems along with heavy templating?  It&#x27;s because now computers are fast enough to provide these &#x27;developer ergonomics&#x27; and &#x27;multithreaded memory safety without locks&#x27; that these features become viable in the compilers of today vs. the compilers of yesterday.  If they could deliver such abilities in the past without having a compiler that takes too long, they would have.  In the past C++ was known as a slow compiling language, like swift is today.  You also notice slow build times in other &#x27;statically sophisticated&#x27; languages such as scala or haskell.<p>Golang was specifically designed as a language to provide fast compile times.  When they were designing the language, if they had to decide between cool language feature and fast build time, they chose fast build time.<p>Try to expand your horizons, just because you like something, it doesn&#x27;t mean most people like it.  I wish most people liked performance improvement work.')