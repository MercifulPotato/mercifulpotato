Item(by='undecisive', descendants=None, kids=[25776934], score=None, time=1610618378, title=None, item_type='comment', url=None, parent=25766924, text='&gt; You did not explain how this is dangerous whatsoever. What about all those companies or teams out there using exclusively functional programming and succeeding? Their own experience would be evidence that avoiding OOP is good (as it has been good, demonstrably, for them). If they merely spoke from their own experience and attested to the good things that demonstrably came from avoiding OOP, you would consider that dangerous?<p>I can&#x27;t tell whether you&#x27;re intentionally building a straw-man here. My original example of a downvotable comment had three statements:<p>&quot;object orientation is dangerous&quot;: It clearly isn&#x27;t. <i>Badly written</i> object oriented software can be dangerous, and you can argue that OO languages could do more to promote safety within themselves, but that doesn&#x27;t make OO as a theoretical construct a bad thing, or all OO code bad, or all OO developers wrong.<p>&quot;you must write C++ using functional paradigms&quot;: Again, there are separate challenges when writing fully FP-style C++, certainly there is nothing to say you MUST write C++ that way. And many projects would probably not welcome you rewriting their codebase in that way. If someone goes back to their employer &#x2F; open-source project &#x2F; teachers and tells them they are doing it wrong because their code contains OO, they may well be laughed out of the door.<p>&quot;it&#x27;s the only way to make good programs&quot;: This is obviously a lie.<p>Then, look at the context - I said &quot;answers that are dangerous, vulnerable, misleading, or represent an extreme viewpoint as fact (...)&quot; - I intended the above three statements to be an example of the latter, I figured that people can easily imagine dangerous &#x2F; vulnerable &#x2F; misleading SO posts themselves. But yes, while I do consider there to be dangerous effects from stating a subjective viewpoint as an absolute like this, I do think that the above statements take a reasonable yet subjective statement like &quot;Few pieces of advice have served me as well as [avoid OOP]&quot; into a totally unreasonable objective statement &quot;it&#x27;s the only way to make good programs&quot;<p>Also, take a look at my later statement &quot;Everything is a balance of strengths and weaknesses, and there are times when OO is the right tool for the job.&quot; I thought it would be relatively clear from this that there must always be times where OO is <i>not</i> the right tool for the job. My original statement was not an attempt to bad-mouth FP. But telling beginners to never use X because it&#x27;s evil for whatever reason does have its dangers, whether that paradigm is FP or OOP.<p>&gt; any use case solvable by OOP is also solvable with at least equal quality and equal satisfaction of the constraints using functional programming.<p>I suspect games programmers and kernel devs might disagree with that. But even if not, I would say that the bar you have set is terribly low. To my mind, a good program should also be readable, expressive, and in keeping with the project&#x27;s coding standards. Generally, that&#x27;s where I find that even some well-written FP code may fall down. But again, that&#x27;s not an argument against FP itself, because I would not argue against FP. As I said before...<p>&gt; A comment like &quot;I would prefer to see this in a functional paradigm, with as few side effects as possible&quot; is absolutely fine.<p>In fact, I would go as far as to say I might even agree with that statement. I certainly wouldn&#x27;t downvote it. Sure, I&#x27;d like to see better arguments about why the side effects in that case are a problem, and why FP might be able to improve the code. But that is a perfectly valid and true statement. But hopefully now you can see why that statement is materially different to &quot;object orientation is dangerous, you must write C++ using functional paradigms, it&#x27;s the only way to make good programs&quot;.')