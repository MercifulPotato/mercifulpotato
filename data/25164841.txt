Item(by='Tuna-Fish', descendants=None, kids=None, score=None, time=1605905815, title=None, item_type='comment', url=None, parent=25163091, text='&gt; (ARM has 16. So does x86-64.)<p>64-bit ARM has 32 GPRs.<p>&gt; Fixed-length instructions instead of variable-length.<p>This is the big legacy of RISC that helps &quot;RISC&quot; cpus most against x86. M1 has 8-wide decode, with very few stages and low power consumption. Nothing like it can be done for an x86 cpu. The way modern x86 handles this is typically with a uop cache. But this costs a lot of power, area and only provides full decode width for a relatively small pool of insns -- 4k on modern Zen, for example.<p>&gt; &gt; One of the key ideas of RISC was to push a lot of heavy lifting over to the compiler. That is still the case. Micro-ops cannot be re-arranged by the compiler for optimal execution.<p>&gt; Modern compilers do use instruction scheduling to optimize execution, and instruction scheduling for microcoded execution is well-understood.<p>Compiler-level instruction scheduling is mostly irrelevant for modern OoO architectures. Most of the time the CPU is operating from mostly full queues, so it will be doing the scheduling from the past 10-~16 instructions. Compilers are mostly still doing it out of inertia.<p>&gt; &quot;precious silicon&quot;<p>The big difference from that 25 years ago to today is indeed that silicon is now the opposite of precious. We have so many transistors available that we are looking for ways to effectively use more of them, rather than saving precious silicon.')