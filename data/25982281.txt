Item(by='didibus', descendants=None, kids=None, score=None, time=1612125082, title=None, item_type='comment', url=None, parent=25980517, text='&gt; The issue is, given a person that knows the language does not know how to structure their code, what is likely going to be the outcome with regards to maintainability.<p>&gt; My production experience is mostly with C, C++, Python and Java<p>&gt; On the other hand Clojure imposes exactly ZERO structure on your application. That is powerful but only if you know how to structure the application yourself, know what kind of choices you need to make and know ins and outs of various options<p>All I can say is I have Java, C#, C++, JavaScript professional experience and also Clojure.<p>From my experience, I&#x27;ve noticed that actually I can navigate better even a messy Clojure codebase, because the language is actually quite simple. Even if someone plasters poorly thought out macros everywhere, the rules of macros and macro-expansion are very simple and clear. I can easily figure out what they do and then start to make sense of the mess. And the REPL allows me to very quickly explore everything that is structured confusingly and hard to read.<p>This is not true with messy C++, C# or Java from my experience. When Java gets messy, you are now dealing with pre-processors, custom annotations, XML&#x2F;reflection, magic strings, hidden circular dependencies, and ton of coupling, and those can really get out of hand. There&#x27;s no simple systematic method to unraveling the mess, like there is in Clojure.<p>And on the data side of things, this is also true. Clojure data-model being immutable also means it can systematically be unraveled. Again, in Java, C# and C++, you have so many hidden data dependencies that can trip you up, realizing the spread of the shared data across a messy code base is quite difficult, in Clojure, the only challenge is figuring out its flow, but not its sharing.<p>But, to caveat, all the Clojure services I&#x27;ve worked on were developed while I was lead. So it&#x27;s possible that having me around managed to prevent getting them in a place that cannot be salvaged. And similarly most Java, C++ or C# projects I&#x27;ve led also never ended up in such a rot for as long as I was around. Where as the Java, C++ and C# projects I&#x27;ve found to be unsalvageable mess I&#x27;ve generally inherited from others or people before me. I haven&#x27;t yet had to inherit a Clojure project where I wasn&#x27;t involved with from the start. I do wonder what would happen then. My best experience here is open source, till now, most Clojure open source code base I&#x27;ve explored I&#x27;ve found simple to unravel, but maybe open source has a higher quality bias.<p>Edit: One last thing that keeps me hopeful is Emacs, probably the oldest most distributed development project ever using a Lisp, and I find it pretty easy to understand its code base and add to it.')