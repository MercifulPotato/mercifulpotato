Item(by='KronisLV', descendants=None, kids=None, score=None, time=1612104654, title=None, item_type='comment', url=None, parent=25976473, text='In my personal experience, there are a few reasons for using Docker:<p>1) By installing packages on the system directly, you can&#x27;t be sure that a future update won&#x27;t break it. For example, when using Tomcat or a similar application server, new updates sometimes deprecate or disable functionality in the older versions, or add new configuration parameters, that the configuration from the older versions won&#x27;t have, thus leading to weird behaviour. This will be especially noticeable, if you set up development, test or production environments some time apart, or in different locations, where the available packages may not be 100% consistent (i&#x27;ve had situations where package mirrors are out of date for a while).<p>2) Furthermore, if you maintain the software long term, it&#x27;s likely that your environments will have extremely long lists of configuration changes, managing which will be pretty difficult. This results in the risk of either losing some of this configuration in new environments, or even losing some of the knowledge over time, if your approach to change management isn&#x27;t entirely automated (e.g. Ansible with the config in a Git repo and read-only access to the servers), or you don&#x27;t explain why each and every change is done.<p>3) Also, it&#x27;s likely that if you install system packages (e.g. Tomcat from standard repositories instead of unzipping it after downloading it manually), it&#x27;ll be pretty difficult for you to tell where the system software ends and where the stuff needed by your app begins. This will probably make migrating to newer releases of the OS harder, as well as will complicate making backups or even moving environments over to other servers.<p>4) If your application needs to scale horizontally, that means that you&#x27;ll need multiple parallel instances of it, which will once again necessitate all of the configuration that your application needs to be present and equal for all of them. You can of course do this with Ansible, but if you don&#x27;t invest the time necessary for it, then it&#x27;s likely that inconsistencies will crop up. In the case of Knight Capital, this caused them to lose more than 400 million dollars in less than an hour: <a href="https:&#x2F;&#x2F;dealbook.nytimes.com&#x2F;2012&#x2F;08&#x2F;02&#x2F;knight-capital-says-trading-mishap-cost-it-440-million&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dealbook.nytimes.com&#x2F;2012&#x2F;08&#x2F;02&#x2F;knight-capital-says-...</a><p>Edit: It was stated in this case that &quot;scale is not an issue&quot; and therefore this point could be ignored. But usually scale isn&#x27;t an issue, until it suddenly is.<p>5) Also, you&#x27;ll probably find that it&#x27;ll be somewhat difficult to have multiple similar applications deployed on the server at the same time, should they have any inconsistencies amidst them, such as needing a specific port, or needing a specific runtime on the system. For example, if you&#x27;ve tested application FOO against Python 3.9.1, then you&#x27;ll probably need to run it against it in production, whereas sif you have application BAR that&#x27;s only tested with Python 3.1.5 and hasn&#x27;t been updated due to a variety of complex socioeconomical factors, then you&#x27;ll probably need to run it against said older runtime.<p>6) Then there&#x27;s the question of installing dependencies which are not in the OSes package repositories, but rather are available only in the npm (for Node.js), pip (for Python) or elsewhere, where you&#x27;re also dealing with different mechanisms for ensuring consistency and making sure that you&#x27;re running with exactly the version that you have tested the application on can be a bit of a pain. For an example of this going really wrong, see the left-pad incident: <a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2016&#x2F;03&#x2F;23&#x2F;npm_left_pad_chaos&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theregister.com&#x2F;2016&#x2F;03&#x2F;23&#x2F;npm_left_pad_chaos&#x2F;</a><p>Essentially, it&#x27;s definitely possible to live without containers and still have your environments be mostly consistent (for example, by using Ansible), but in my experience it&#x27;s just generally harder than to tell an orchestrator (preferably Docker Swarm&#x2F;Hashicorp Nomad, because Kubernetes is a can of worms for simple deployments) that you&#x27;d like to run application FOO on servers A, B and C with a specific piece of configuration, resource limits, storage options and some exposed ports.<p>I feel like this is a largely issue of tooling and our development approaches, NixOS attempts to solve this, but i can&#x27;t comment on how successful it is: <a href="https:&#x2F;&#x2F;nixos.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nixos.org&#x2F;</a>')