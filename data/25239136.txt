Item(by='cturner', descendants=None, kids=[25239526], score=None, time=1606586317, title=None, item_type='comment', url=None, parent=25238544, text='I feel like I have only scratched the surface :) If you take interest in this, we hang out in #dinghy on freenode. We have bursts of activity, and then long periods of silence.<p>But I do feel like the world is ripe for a revolution in a few directions here.<p>-- Browser<p>To your point that a conventional browser creates unavoidable complexity: I agree.<p>It may be possible to disrupt that stack entirely, by creating something that developers would prefer to develop for.<p>The new conversational interaction between whatsapp users and corporate chatbots (e.g. airline rebooking over whatsapp) shows developer and user appetite for non-HTTP internet activity. As does Slack, somewhat.<p>This gopher-like &#x27;Gemini&#x27; thing that has been popping up recently is interesting.<p>On the Dinghy website, there is a proposal for an engine, &#x2F;Limit&#x2F;. It would be a Forth VM that would maintain an async connection back to a webserver-like server. Instead of having HTTP+HTML+CSS+Javascript, you would deliver sites as forth bytecode. This could be tighter yet more flexible than a web browser. An Everything-Is-A-X based overthrow of the current web browser model.<p>&#x2F;Limit&#x2F; could be simulated in a browser (using javascript and websockets) so that people who only had a browser could browse a Limit server without adding new software.<p>Hypothesis: &#x2F;Limit&#x2F; would have common purpose with alt-OS communities that do not have first-class browsers: Haiku, Plan9, Amiga, Suckless, people who run old SGIs for fun. Imagine if you could just recompile a C codebase, and change some headers, and get a full-featured browser-like thing running on these systems.<p>-- Networking<p>I am confident that there is a non-complex path through this problem.<p>Hypothesis: interaction with the systems API should be purely asynchronous, and TCP interaction will look nothing like the Berkeley sockets API.<p>Tanenbaum warns of the dangers of an async systems API (<a href="http:&#x2F;&#x2F;songseed.org&#x2F;dinghy&#x2F;tanenbaum.html" rel="nofollow">http:&#x2F;&#x2F;songseed.org&#x2F;dinghy&#x2F;tanenbaum.html</a>).<p>But there is an occam-based OS, RMoX, that looks to be a demonstration of the async OS concept. I hit obstacles trying to evaluate&#x2F;verify this.<p>On the Dinghy website, there is a paper for &quot;Drift&quot;. This proposes an async OS for the amd64 architecture. I noticed drafting problems in this paper earlier, will revise soon.<p>The addition of io_uring to Linux may allow another approach: create an async API mezzanine on io_uring; regard this as your Bedrock, rather than the hardware itself.<p>Once io_uring is mature, it may be possible to fork Linux in order to discard &#x2F;all&#x2F; syscalls except io_uring. This kernel would have ongoing Linux driver support, but with a much smaller kernel surface area.<p>-- Your requirements<p>Regarding your stated requirements, &#x27;SD card navigation, text editor, image and audio file player, simple graphics&#x27;, you could build this on top of the Maximite architecture. But it would lack networking.<p>Whereas the Dinghy concept goes beyond your stated requirements.')