Item(by='deepGem', descendants=None, kids=[24898103, 24897781], score=None, time=1603728758, title=None, item_type='comment', url=None, parent=24897540, text='I guess what you mean is the no-op garbage collector which is available in Java 11 <a href="http:&#x2F;&#x2F;openjdk.java.net&#x2F;jeps&#x2F;318" rel="nofollow">http:&#x2F;&#x2F;openjdk.java.net&#x2F;jeps&#x2F;318</a><p>Even this isn&#x27;t fail proof right ?<p>Last-drop latency improvements. For ultra-latency-sensitive applications, where developers are conscious about memory allocations and know the application memory footprint exactly, or even have (almost) completely garbage-free applications, accepting the GC cycle might be a design issue. There are also cases when restarting the JVM -- letting load balancers figure out failover -- is sometimes a better recovery strategy than accepting a GC cycle. In those applications, long GC cycle may be considered the wrong thing to do, because that prolongs the detection of the failure, and ultimately delays recovery.<p>So essentially you need to know the memory footprint of your applications. To err on the side of caution just get as much memory that is available in the market.<p>At this point like another reply mentions here aren&#x27;t you just better off writing C++ code ?')