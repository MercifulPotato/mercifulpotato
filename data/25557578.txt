Item(by='jabl', descendants=None, kids=[25557871], score=None, time=1609142909, title=None, item_type='comment', url=None, parent=25557115, text='&gt; Flags don&#x27;t have to add an extra implicit input&#x2F;output everywhere. Both ARM and PowerPC avoid updating the flags unless explicitly requested.<p>You mean things like having variants of common arithmetic instructions that update or don&#x27;t update flags?<p>&gt; Besides fixed-size instructions and the traditional variable-size instructions, one can do variable-size instructions in bundles. An example would be 25-bit and 50-bit instructions packed into 128-bit bundles, with the remaining 3 bits used to specify all the sizes. (eight patterns: nnnnn, nww, wnw, wwn, nnnw, wwnw, wnww, wnnn) Extending that out to a typical cache line of 512 bits might be better. Another option is to use 1 of every 16 bits to indicate where instructions start.<p>Yeah, something like that could be nice. Though how would jump instructions be encoded? Bundle + offset within bundle?<p>&gt; Where RISC-V got wasteful was the registers. Compilers are seldom able to use anywhere near 32 registers. On normal code, normal compilers seem to need about 8 to 10 registers free after deducting the ones reserved by the ABI. The ABI might need 3 to 5 registers. (stack, PLT, GOT, TLS, etc.) That means that roughly 11 to 15 registers are needed. Clearly, 4 bits (16 registers) is enough. Shoving some of those ABI-reserved registers out of the general-purpose set wouldn&#x27;t be a bad idea; most of those are just used for addressing.<p>Nah, I think 32 registers was a good choice. (Relatively) common loop optimizations like unrolling or pipelining need more registers. Also, some of those registers are callee saved and some are call clobbered; by making use of this information the compiler can avoid spilling and reloading of registers around function calls.<p>For x86-64 16 registers is fine, partly because in many cases one can operate directly on memory without needing to explicitly load&#x2F;store to architectural registers, and partly because the target was and is OoO cores that aren&#x27;t as dependent on those register-consuming compiler optimizations.')