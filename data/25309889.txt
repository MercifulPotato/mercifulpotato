Item(by='BeetleB', descendants=None, kids=None, score=None, time=1607125723, title=None, item_type='comment', url=None, parent=25307282, text='I don&#x27;t think so. I once took on the challenge of writing as many unit tests as possible for a project at work (the project did not have unit tests - but was well covered with other types of tests).<p>The two key takeaways I got from the effort:<p>First, I had no idea how coupled my code was until I tried writing many unit tests for it. If it&#x27;s hard for you to instantiate your class without involving N other libraries&#x2F;objects, your code is very coupled. No one in my team would have looked at the code and said &quot;It&#x27;s highly coupled&quot;. The real proof was &quot;Can you test this in isolation?&quot; If not, you&#x27;re strongly coupled.<p>I had to redesign a lot of bits to succeed, and as another commenter pointed out, in my attempts to do so my code really was a lot better. I discovered good principles of design in doing it.<p>The second thing I learned, which may appear to disagree with the first: There are always easy ways to write code to be unit testable. Most of those easy ways are bad and reduce the &quot;quality&quot; of your code. Forcing yourself to not redesign just &quot;for the sake of writing tests&quot;, while still ensuring you have 100% code coverage, will really force you to think heavily about your code, architecture, failure points, etc.<p>So a 100% code coverage really doesn&#x27;t tell you if you have good code. But less than 100% does indicate potential problems.<p>(I personally did not go for 100%, FYI).')