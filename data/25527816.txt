Item(by='steveklabnik', descendants=None, kids=[25529698], score=None, time=1608820847, title=None, item_type='comment', url=None, parent=25526929, text='I can&#x27;t speak to the same level of depth about the C++ model as the Rust one, but, while you <i>could</i> do those things, it&#x27;s not the usual way that it works, at least, if I&#x27;m understanding your terms correctly. I&#x27;ll admit that I find your terms in the first bullet pretty confusing, and the second, only slightly. Let&#x27;s back up slightly. You have:<p>* A future. You can call poll on a future, and it will return you either &quot;not yet&quot; or &quot;done.&quot; This API is provided by the standard library. You can create futures with async&#x2F;await as well, which is provided by the language. These tend to nest, so you can end up with one big future that&#x27;s composed out of smaller futures.<p>* A task. Tasks are futures that are being executed, rather than being constructed. Creating a task out of a future may place the future on the heap.<p>* An executor. This is provided by Tokio. By handing a future to Tokio&#x27;s executor, you create a task. The job of the executor is to keep track of all tasks, and decide which one to call poll on next.<p>* A reactor. This is also provided by Tokio. An executor will often employ a reactor to help decide which task to execute and when. This is sometimes called an &quot;event loop,&quot; and coordinates with the operating system (or, if you don&#x27;t have one of those, the hardware) to know when something is ready.<p>* A Waker. When you call poll on a future, there&#x27;s one more bit that happens we couldn&#x27;t talk about until we talked about everything else. If a future is going to return &quot;not yet,&quot; it also constructs a Waker. The Waker is the bridge between the task, the reactor, and the executor.<p>So. You have a task. That task needs to get something from a file descriptor in a non-blocking way. At some point, there&#x27;s a future way down in the chain whose job it is to handle the file descriptor. When you ask it to be created, it will return &quot;not ready&quot;, and construct a waker that uses epoll (or whatever) via the reactor. At some point, the data will be ready, and the reactor will notice, and tell the executor &quot;hey this task is now ready to execute again,&quot; and when some time is free, the executor will eventually call poll on it a second time. But until that point, the executor knows it&#x27;s not ready, and so won&#x27;t call poll again.<p>Whew. Does that make sense? I linked my talks in this thread already, but this is kind of a re-hash of them.')