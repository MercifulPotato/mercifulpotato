Item(by='throwaway894345', descendants=None, kids=None, score=None, time=1603387793, title=None, item_type='comment', url=None, parent=24858975, text='&gt; I have a very hard time getting behind these complex configuration languages. To me what makes a configuration format good is the simplicity of reading the configuration of a program, and almost all of these languages are optimizing for feature complexity over readability. I think that all of the popular config formats (yaml, json, toml, etc) have issues, but none of the major issues with them have to do with being unable to represent a fibonacci sequence in their language.<p>Static languages like JSON and YAML are fine for toy configurations, but they don&#x27;t scale to the most basic real-world configuration tasks. Consider any reasonably sized Kubernetes project that someone wants to make available for others to install in their cluster&#x27;s. The project probably has thousands of lines of complex configuration but much of it will change subtly from one installation to another. Rather than distributing a copy of the configs and detailed instructions on how to manually configure the configuration for each use case, it becomes very naturally expedient to parameterize the configuration.<p>The most flat-footed solution involves text-based templates (a la jinja, mustache, etc) which is pretty much what Helm has done for a long time. But text-based templates are tremendously cumbersome (you have to make sure your templates always render syntactically correct and ideally also human readable, which is difficult because YAML is whitespace-sensitive and text templates aren&#x27;t designed to make it easy to control whitespace).<p>A similarly naive solution is to simply encode a programming language into the YAML. Certain YAML forms encode references (e.g., `{&quot;Ref&quot;: &quot;&lt;identifier&gt;&quot;}` is equivalent to dereferencing a variable in source code). Another program evaluates this implicit language at runtime. This is the CloudFormation approach, and it also gives you some crude reuse while leaving much to be desired.<p>After stumbling through a few of these silly permutations, it becomes evident that this reuse problem isn&#x27;t different than the reuse problems that standard programming languages solve for; however, what <i>is</i> different is that we don&#x27;t want our configuration to have access to system APIs including I&#x2F;O and we may also want to prevent against non-halting programs (which is to say that we may not want our language to be turing complete). An expression-based configuration language becomes a natural fit.<p>After using an expression-based configuration language, you realize that it&#x27;s pretty difficult to make sure that your JSON&#x2F;YAML output has the right &quot;shape&quot; such that it will be accepted by Kubernetes or CloudFormation or whatever your target is, so you realize the need for static type annotations and a type checker.<p>Note that at no point are we trying to implement the fibonacci sequence, and in fact we prefer not to be able to implement it at all because we expressly prefer a language that is guaranteed to halt (though this isn&#x27;t a requirement for all use cases, I believe it does <i>satisfy</i> the range of use-cases that we&#x27;re discussing, and the principle of least power suggests that we should prefer it to turing-complete solutions).')