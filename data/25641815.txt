Item(by='ncmncm', descendants=None, kids=None, score=None, time=1609818320, title=None, item_type='comment', url=None, parent=25631154, text='This is implausible on its face.<p>If your new C program is faster than your old C++ program, then you may simply rename files from &quot;.c&quot; to &quot;.cc&quot;. Then, you have two C++ programs, one faster than the other.<p>If your custom hash table really is faster than any library you find, congratulations! Recoding its interfaces, without giving up any performance, you can make it available for use in other C++ programs. As one may deduce, this has <i>already happened</i>, and has produced the better hash table libraries you appear not to know about. Available C++ hash table libraries have benefit of overwhelmingly more optimization attention than could be afforded on behalf of a single program, and they deliver that performance to all dependent programs.<p>Every programming project is an exercise in practical economics: your strictly-limited available attention goes where you choose. The greater productivity of coding in a more powerful language frees up attention that may then be allocated to areas that would otherwise suffer neglect. Whatever amount of attention you devote to making code in a poor language work at all, you may spend a fraction of coding in a better language, and the balance on other beneficial uses, such as better performance.<p>That the new program is faster than the old program reliably demonstrates that the old program was not so well optimized as you suggest. (Your comment elsewhere, that &quot;<i>the whole project uses only [a] minimal set of C++ features</i>&quot; reveals perhaps more than you intended.) One may surmise that the old program&#x27;s authors spent more of their limited attention on its effectiveness at playing chess than the latter program&#x27;s author needed to.<p>That the third, assembly-language program is faster still demonstrates that the previous programs left performance on the table. My experience is that it is not hard to double the speed of a typical program just by paying attention to cache and pipeline effects. Most likely, the asm coder just happens to know more about those effects, knowledge that could as well have been applied to the others. Most programs seem fast enough <i>exactly</i> until another, faster one comes along; then they are instantly slow.')