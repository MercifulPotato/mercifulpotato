Item(by='lmm', descendants=None, kids=None, score=None, time=1605147167, title=None, item_type='comment', url=None, parent=25059670, text='&gt; does &quot;deploy&quot; push to an artifact repository, does it create a container image, does it create a deb package, or does it create a standalone jar?<p>&quot;package&quot; creates some kind of package, &quot;deploy&quot; pushes it to some kind of artifact repository. The details of what kind of package and what kind of repository will vary from project to project, but you don&#x27;t need to know them to start work on the project. In theory there could be projects out there that do surprising things (after all, nothing actually <i>stops</i> you from configuring your build to push a container image to a repository when someone runs &quot;mvn test&quot;), but the overwhelming majority of projects find a way to fit themselves into the maven lifecycle, and it really reduces the &quot;where do I start&quot; effect when you check out a new project: I don&#x27;t have to read the build file or hunt for documentation, I can run &quot;mvn install&quot; and see what it does, and be confident that that&#x27;s &quot;how you build this project&quot;.<p>&gt; The problem, as I said, lies in that child Maven projects are not self-contained. They usually depend on information declared in the parent builds. This breaks the assumption that people can work on a project without worrying about the parent project.<p>Well, SBT projects also come with a bunch of default tasks that aren&#x27;t defined explicitly in their project definition; some of them are defined by plugins and some of them are defined... somewhere (I genuinely don&#x27;t know where the tasks that are available by default come from, or how to see a list of all of them except by using the interactive commands). So an SBT project is not self-contained in that sense either. In maven anything that&#x27;s not explicitly defined in the project is coming from its parent pom, which is either the default parent pom or an explicitly specified one, and the default parent pom is a real pom that you can look at that follows the normal rules.<p>So you do have to understand the concept of a parent pom, but it&#x27;s not an extra thing that you have to understand, because the default parent and any parent pom you&#x27;re using in a multi-module project work exactly the same way.<p>&gt; And building from the IDE is a dumb mistake if the IDE doesn&#x27;t use the correct build tool underneath: the build is there for a reason and the IDE shouldn&#x27;t bypass it.<p>Yes and no: the IDE has a bunch of knowledge of its own that the build tool doesn&#x27;t, such as which files the user has changed, or which specific test the user has asked to run, or which import the user wants to add a dependency for. So I don&#x27;t think the idea of the IDE dumbly invoking the build tool and letting it do its thing works (particularly in a language like Scala where you have to rely heavily on incremental compilation if you don&#x27;t want enormous build times); instead there needs to be a deeper integration where the build tool and the IDE share a structured model of the project, and the IDE can perform a build via that model (effectively embedding part of the build tool as a library, if you like). Likewise I don&#x27;t want to invoke a separate build REPL to understand the project definition, I want to be able to explore it within the IDE.')