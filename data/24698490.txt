Item(by='jlokier', descendants=None, kids=None, score=None, time=1601997119, title=None, item_type='comment', url=None, parent=24697159, text='&gt; Finally, as far as I know, the kernel does not use thread local&#x2F;fiber local storage, instead heavily relies on per-cpu data.<p>It does use FLS.  Everywhere you see &quot;current-&gt;&quot; or &quot;current_thread_info()&quot; in the Linux kernel, it&#x27;s FLS, not per-cpu.<p>There&#x27;s a lot of those, some of them wrapped in other macros and inlines.  &quot;current&quot; refers to the current task, which is the kernel&#x27;s name for what the article calls fibers.<p>Per-cpu data is used in the kernel as well, and I agree with you about using the analogous thing for coroutines which is TLS for certain things.  Indeed, a FLS implementation almost certainly uses TLS for its root-of-data pointer and keeping tracking of the current thread&#x27;s coroutine queue.<p>&gt; Agner reports a reverse throughput of ~13 cycles on Neahalem. [...] it is not just a register load but it also has to update shadow limit registers<p>You&#x27;re thinking of a segment register load, but these days we would use the WRFSBASE or WRGSBASE instructions, which don&#x27;t update the segment descriptor (shadow limit etc) and don&#x27;t use the GDT&#x2F;LDT.<p>Windows has supported this for userspace scheduling for a long time (but Windows has good fiber support with native FLS anyway), Java coroutines want to use it for performance on Linux, and Linux kernel looks like it will enable this soon; the CPUs have supported it for years.<p>When those instructions aren&#x27;t available, since the &quot;current coroutine&quot; is almost certainly a TLS variable itself that must be updated on context switch, use that as the base for FLS too.  Then FLS access is one extra level of pointer indirection on access, but still hoisted and cached.  For portable coroutines-and-threads code, use a portable TLS variable or pthread_getspecific() for this.')