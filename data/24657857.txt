Item(by='charrondev', descendants=None, kids=None, score=None, time=1601601922, title=None, item_type='comment', url=None, parent=24657173, text='I spent my last 2 weeks optimizing a decade old SaaS to handle massive traffic spikes from one of our biggest customers. We had other customers serving similar amounts of traffic, but with smaller data sets.<p>- Increasing the numbers of servers running the app. App connections were still stacking up though. This gave us more breathing room though for connections to start stacking and handle small spikes.<p>- The database seemed very overloaded with so many concurrent connections. I began putting everything I could into memcached (we already had a lot of data in it, but I put more).<p>- now we had a cache hotspot. Some digging found a age old bug in our cache driver where it didn’t actually keep things in process memory after fetching from memcached and we had a medium sized key getting fetch 100s of times per request.<p>- Days and days of app optimization after profiling. Our average response time went improved by more than 50%. The site would still start collapsing under a little load.<p>- While profiling in a single request all queries would complete very quickly (&lt;50ms). Somehow the DB was still the bottleneck. We overprovisoned it significantly and it still would collapse.<p>- I started collecting counts and timings for cumulative and maximum single cache&#x2F;db, read&#x2F;writes to our log stack.<p>- the bottleneck was clearly still the DB.<p>- at this point we were desperate. Thinking it might have been an issue in the underlying VM we live migrated the DB to a new VM.<p>- the database was still the bottleneck.<p>In the end the thing that fixed it? A simple OPTIMIZE TABLE.<p>Somehow ANALYZE TABLE hadn’t detected anything but rebuilding the table still fixed the issue.<p>If anyone is looking for a good load testing tool, Vegeta was invaluable. I highly recommend it.')