Item(by='Geminidog', descendants=None, kids=[25509760], score=None, time=1608661300, title=None, item_type='comment', url=None, parent=25508514, text='&gt; BTW, the term &quot;organizational&quot; usually refers to how you organize your people.<p>Then what, in your opinion, is a better adjective for &quot;technical debt&quot; that best conveys my point?<p>&gt;How do you organize it into layers? How do you organize it into files?<p>Namespacing, files, and &quot;layers&quot; are aesthetic forms of organization that do not produce actual barriers in organization. They are for people to read and do not produce actual structured barriers.<p><pre><code>  Namespace MathLayer1 {\n      function mathlayer1combinator()\n  }\n\n  Namespace OtherLayer2 {\n      function otherlayer2combinator()\n  }\n</code></pre>\nYou will note because both functions are combinators, they can always be moved&#x2F;called interchangeably into either namespace&#x2F;file&#x2F;layer provided that you handle circular dependencies (easily done in C++ by declaring everything in a header file first and making sure you don&#x27;t have any sort of circular recursion in the definitions).<p>Thus &quot;organizational&quot; mistakes in namespacing&#x2F;layers are actually trivial because none of the combinators in the namespace are tied to context. If you find you can&#x27;t move a function out of a namespace it is always because of the fact that that function is not a combinator and is likely relying on some other state declared within the namespace&#x2F;class. It is not the namespace itself that is causing this issue.<p>Another way to think about a namespace or layer is that all it does is put a prefix on your combinator for readability purposes.<p><pre><code>    Layer3.combinatorG as opposed to just combinatorG\n</code></pre>\nA third perspective is to view the combinator as a concept that transcends namespacing or layers. A combinator is never limited by scope because it carries the scope with it rather then existing as an entity tied to scope.<p>Machine organization is a problem though. Machines are a physical limitation placed upon our virtual code and people exploiting this limitation as a feature makes code even less modular. A machine barrier is no different from a namespace or object with one difference: Moving or reusing code in a different machine requires data transfer. There is no reason to impose this limitation on our code unless we have no choice.<p>Thus the limitations of machines should only be utilized to optimize for performance, not as a feature to organize your code. Inevitably in practice this can cause organizational debt if you placed a function in machine A for optimization reasons and suddenly find that you need to use that function in machine B things will be inconvenient.<p>Hopefully, if that function is a combinator, moving it for use in machine B will be less of a pain. But keep in mind in the idealistic world of programming the machine barrier doesn&#x27;t exist. Formally moving your combinator out of Machine B into Machine A is the same as if the Machine was called a Namespace. There is no intrinsic difference. It is the physical limitations of the real world that is making things inconvenient so my statement about combinators still holds logically.<p>That being said the physical barrier of machines can be abstracted away in a single project directory. There are strategies to handle this (imperfectly), docker or RPCs for example.<p>It&#x27;s Good to have awareness of the exact formal and logical consequences of certain actions rather then rely on some fuzzy intuition of design. Clarity in the fundamentals of what&#x27;s going on is key to developing a logical rule set so that optimal structure can be calculated rather then sub-optimally designed from intuition.')