Item(by='fentonc', descendants=None, kids=[25501827], score=None, time=1608598018, title=None, item_type='comment', url=None, parent=25500220, text='The Cray vector processors had a set of 8 64-element x 64-bit &#x27;vector&#x27; (V) registers, as well as 8 64-bit &#x27;scalar&#x27; (S) and 8 24-bit &#x27;address&#x27; (A) registers - so it would sort of be similar to 4096-bit wide SIMD. When you did an operation like a vector add, you could do &quot;V0 V1+V2&quot;, and it would automatically do 64 consecutive adds, and it would be done in 64 + a few cycles (since the hardware was still only doing 1 add per cycle). As someone else mentioned, it also supported &quot;Vector chaining&quot;, so if your next instruction was &quot;V2=V0*V3&quot;, it could take the result from the adder and pipe it into the multiplier so now your addition and multiplication are nearly fully overlapped (and you&#x27;re cruising along at 160 MFLOPS in 1976!). I think it might have supported 3 chains, so you could very briefly peak at 240 MFLOPS, but you couldn&#x27;t sustain it because of the startup latencies involved.<p>As a &#x27;practical&#x27; example, I was able to write an N-body simulator of Jupiter and 63 of its moons (using the vector registers) orbiting one another in only 127 total instructions!')