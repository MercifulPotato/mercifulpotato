Item(by='maweki', descendants=None, kids=None, score=None, time=1610881686, title=None, item_type='comment', url=None, parent=25809724, text='This is exactly my point. In every somewhat lisp-like language, or even just considering operator overloading by any means (interfaces, for example), the concept of a step becomes unclear.<p>Say instead of the for-loop the author would use something like &#x27;for idx in len(ls):&#x27; and then access items with [idx]. I think it&#x27;s obvious that in order to know the runtime complexity, would would need to know what kind of access [] provides (linked list in linear time, array in constant time, treelist or skiplist in log time). That&#x27;s why I said it&#x27;s easy to hide behind implementation details. And if you do count them, with all intricacies, it gets quite complex.<p>We could now look at what the turing machine implementing that algorithm would do, as no &quot;shortcuts&quot; are allowed there. And the computational complexity is strongly bound to that kind of computation (Specifically it is unknown whether the number of derivation steps in lambda calculus translates to number of steps in a turing machine).')