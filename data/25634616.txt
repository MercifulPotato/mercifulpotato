Item(by='mikelevins', descendants=None, kids=None, score=None, time=1609781059, title=None, item_type='comment', url=None, parent=25634208, text='You can use a stateful repl to develop stateless code, but in order to provide the features of an old-fashioned Lisp or Smalltalk system, the kind of system I prefer to work with, you can&#x27;t make any stateful changes off limits because there&#x27;s no way to know in advance what changes you&#x27;re going to need to make.<p>As you&#x27;re rummaging around through the dynamic state of the running system, you&#x27;ll discover changes that need to be made, and you might discover them absolutely anywhere. Sure, you could always kill the running system, make the change to the sources, and rebuild the system, but that&#x27;s exactly what we&#x27;re trying to avoid.<p>Consequently, old Lisp and Smalltalk systems are allergic to restrictions on runtime changes. Loosely speaking, if I find something I can&#x27;t change while my program is running, that restriction is a bug in my development environment.<p>Old systems like this will <i>discourage</i> certain kinds of changes because they&#x27;re usually ill-advised, but will not <i>forbid</i> them, because forbidding them is anathema.<p>As an example, several Common Lisps implement <i></i>package locks<i></i> on certain system packages. A <i></i>package lock<i></i> prevents you from changing the definitions of system-defined constructs.<p>But it&#x27;s Lisp, so it doesn&#x27;t <i>really</i> prevent the change. It just makes it more inconvenient. You have to say &quot;Mother, may I?&quot; first, which gives you the opportunity to soberly consider whether making that specific change is really really what you want to do.')