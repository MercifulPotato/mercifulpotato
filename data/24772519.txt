Item(by='scottlamb', descendants=None, kids=None, score=None, time=1602642337, title=None, item_type='comment', url=None, parent=24772233, text='&gt; At this point, Thread#25 calls free(fooptr), but it now has to be a global-synchronization, since the data came from Thread#10&#x27;s pool.<p>I don&#x27;t think this is true. As I understand it, it just gets put into Thread#25&#x27;s pool rather than returned to Thread#10s. If there&#x27;s a long-running imbalance—like a producer-consumer pattern in which all the mallocs are from Thread#10 and all the frees are from Thread#25—that will lead to more global synchronization because the allocator will have to repeatedly refill Thread#10&#x27;s pool and empty Thread#25&#x27;s pool. But if it&#x27;s just that there&#x27;s some shuffling of threads between the allocations and frees but stuff is generally balanced, there&#x27;s little if any additional cost.<p>I think you&#x27;re suggesting using a set of &quot;task-local&quot; custom allocators, and each of those can ignore threads? I suppose that would work, as each task is only on one thread at once, and there has to be a barrier anyway when it hops from thread to thread. But I&#x27;m skeptical it&#x27;s faster than the system allocator. I&#x27;d love')