Item(by='egeozcan', descendants=None, kids=None, score=None, time=1610803649, title=None, item_type='comment', url=None, parent=25799004, text='I implemented this. Some notes:<p>1) Make front-end calculate the next-id for each element after a sort, and call the back-end to update only required records.<p>2) next_id is a unique key, so if data was stale, worst case, a transaction error occurs, inform user that sort failed and undo the optimistic update, but this happens if multiple users are sorting the same list like crazy. generally, it just works. can be problematic if users are doing mass updates on a giant list. in such a case, instead of allowing free-sort, adding a user-adjustable &quot;priority&quot; column which allows equals would make much more sense.<p>3) deletes and inserts are more costly, because now they also require an extra read and update, but we never have the case of updating the whole list, and updating a record through a unique indexed key is an insignificant cost (in most cases - noted as otherwise someone would surely nerd-snipe me with an uncommon case, hehe).<p>4) for whatever reason, you want sorted results from the back-end and not do sorting on the front-end, if keys are not sorted, means recursive CTE, which isn&#x27;t the end of the world but could be slower and means additional complexity.<p>5) you can change next_id to prev_id and spare the updates for the common case of inserting at the bottom (you still need the read, and a retry mechanism on transaction fail though)')