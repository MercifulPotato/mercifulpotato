Item(by='simias', descendants=None, kids=[25521994, 25517202, 25517240], score=None, time=1608725414, title=None, item_type='comment', url=None, parent=25516136, text='I seem to be in the minority but I really dislike this type of sugar. I find that it always makes code harder to read because you can&#x27;t disambiguate what the code is doing without some heavy context, and changes to the class can profoundly change the way the code is behaving without triggering as much as a warning.<p>For this same reason I really dislike that in C++ you can just implicitly drop the &quot;this-&gt;&quot; to target class members. You can never tell at a glance what &quot;foo = blah&quot; does if you don&#x27;t know whether &quot;foo&quot; is a member of &quot;this&quot; or not.<p>I think your page demonstrates what I mean in the &quot;nested WithStatement&quot; example:<p><pre><code>    Foo foo;\n    Bar bar;\n    Baz baz;\n\n    f();               &#x2F;&#x2F; prints &quot;f&quot;\n\n    with(foo)\n    {\n        f();           &#x2F;&#x2F; prints &quot;Foo.f&quot;\n\n        with(bar)\n        {\n            f();       &#x2F;&#x2F; prints &quot;Bar.f&quot;\n\n            with(baz)\n            {\n                f();   &#x2F;&#x2F; prints &quot;Bar.f&quot;.  `Baz` does not implement `f()` so\n                       &#x2F;&#x2F; resolution is forwarded to `with(bar)`&#x27;s scope\n            }\n        }\n        with(baz)\n        {\n            f();       &#x2F;&#x2F; prints &quot;Foo.f&quot;.  `Baz` does not implement `f()` so\n                       &#x2F;&#x2F; resolution is forwarded to `with(foo)`&#x27;s scope\n        }\n    }\n    with(baz)\n    {\n        f();           &#x2F;&#x2F; prints &quot;f&quot;.  `Baz` does not implement `f()` so\n                       &#x2F;&#x2F; resolution is forwarded to `main`&#x27;s scope. `f()` is\n                       &#x2F;&#x2F; not implemented in `main`&#x27;s scope, so resolution is\n                       &#x2F;&#x2F; subsequently forward to module scope.\n    }\n</code></pre>\nWi<p>I get that sometimes it can cut on a lot of repetition, but I think I would be fine if the syntax was more explicit while still avoiding repetition, for instance:<p><pre><code>    with (some_object) {\n        .some_member = 1;\n        .some_other = 4;\n        not_a_member = .some_method();\n    }\n</code></pre>\nAnd beyond that make it non nestable (i.e. only the first level of &quot;with&quot; is taken into account) to avoid the situation above with complicated overloading.<p>In my experience that would account for 99% of uses of `with` while making the code a lot more readable without requiring a lot of context to make sense of it.<p>Although frankly even that might arguably overkill, for dynamic languages or ones with type inference you might as well just do something like:<p><pre><code>    {\n        let v = &amp;mut some_annoyingly.long.thing();\n\n        v.foo = bar;\n        v.baz();\n    }\n</code></pre>\nIt&#x27;s almost the same amount of typing and you don&#x27;t need any magic.')