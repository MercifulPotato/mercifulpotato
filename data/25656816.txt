Item(by='YeGoblynQueenne', descendants=None, kids=None, score=None, time=1609933277, title=None, item_type='comment', url=None, parent=25652643, text='&gt;&gt; I wonder... is it still justified to learn Prolog now?<p>Unfortunately no. There was a great push to develop the theory of logic programming, based on resolution theorem proving, back in the &#x27;70s and &#x27;80s. This effort culminated in the design of Prolog, a general-purpose logic programming language with a resolution theorem-prover. Shortly after the AI winter of the &#x27;80s hit and research in logic programming was severely disrupted. Research and progress continued but at a much slower pace and the earlier heights have never been reached again since. Consequently, we don&#x27;t have a &quot;better Prolog&quot; because there are very few people who can even imagine what such a &quot;better Prolog&quot; would look like, let alone design and implement it. Alas, we have ran out of Robinsons, Kowalskis, Colmerauers, and so on.<p>Another reason of course is that Prolog is a very fine-tuned language that gets many things right because its design makes very sensible trade-offs. For example, the much-maligned depth-first search and the consequent clause ordering, absence of an occurs check, negation-as-failure, extra-logical features such as the dynamic program database, etc, are all pragmatic choices that balance the need for a general-purpose language that works, with aspirations of theoretical purity. That is to say, there is nothing fundamentally broken about Prolog, it&#x27;s acutally a very good logic programming language and it&#x27;s just not that easy to design a radically better logic progamming language, especially one based on resolution.<p>Regarding minikanren, my understanding is that it&#x27;s not meant as a &quot;better Prolog&quot;, rather it&#x27;s meant as a small, embedded Prolog (and here by &quot;Prolog&quot; I mean a logic programming language based on resolution, in the same sense that Scheme is &quot;a Lisp&quot;). It&#x27;s meant for programmers of imperative languages who would like to integrate logic programing functionality in their applications. Minikanrens (there are many) can essentially be imported as libraries that allow logic programming in a syntax closer to the embedding language. The alternative would be either to switch entirely to Prolog (which of course is a huge decision), or to write a buggy, slow version of Prolog in the programmer&#x27;s preferred imperative language.<p>Minikanrens have various differences with Prolog, such as absence of side-effects and a dynamic database, a different search strategy, occurs check, etc. but these are not unmitigated improvements. They are different trade-offs than the ones chosen by Prolog.<p>Note however that resolution-based languages like Prolog are not the only logic programming languages. For two prominent examples of alternative approaches, see Datalog and Answer Set Progamming. Both sacrifice Turing-completeness but offer, e.g. decidability, the ability to benefit from the power of modern SAT solvers, classical negation, etc.<p>Again, there are trade-offs. The thing to understand is that theorem proving -proving the truth or falsehood of statements in a formal language- is damn hard, even with computers, and there are always going to be trade-offs when the purpose is to have a real-world application.')