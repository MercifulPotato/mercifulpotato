Item(by='mikelevins', descendants=None, kids=[25626886], score=None, time=1609704735, title=None, item_type='comment', url=None, parent=25623382, text='So go ahead and set up that working situation and try this:<p>Define a function foo() in one module that calls a function bar() in another one, but don&#x27;t define bar().<p>Now call foo().<p>Now, in the debugger that you break into, give a definition for bar(), and resume the execution of foo(). Don&#x27;t quit the program and restart it; that&#x27;s cheating!<p>If that works fine, please tell me what tools you&#x27;re using, because they&#x27;ll materially improve my tools for some work I need to do.<p>Also, try this:<p>Define some classes and make a bunch of instances of them. Write a few methods on the classes. Start your program running with code that uses those classes and methods.<p>Now change one or more of the class definitions. Don&#x27;t stop and reload the program! Again, that&#x27;s cheating.<p>When you land in the debugger (you do land in an interactive debugger, right?) use it to inspect the stack and find out which classes and methods are on the stack and what&#x27;s responsible for the breakage. Ask the Python runtime to show you all the functions, types, and values that are on the stack, and when you find the likely culprit, ask it to take you to the source for the version that&#x27;s currently on the stack.<p>Now, while you&#x27;re still suspended in the call stack, redefine the offending classes and methods and tell Python to use the new ones. Now resume the broken computation. If you hit another problem, use the same tools to find and fix that one, too.<p>After you&#x27;ve done all that, please let me know what your Python toolchain is so that I can use it, too.<p>Also, if that&#x27;s all perfectly doable in Matlab and R, that&#x27;s good to know. Let me know about those tools, too. I haven&#x27;t had much occasion to use them, but that might have to change if they work that way, too.')