Item(by='kaoD', descendants=None, kids=[25612694], score=None, time=1609592305, title=None, item_type='comment', url=None, parent=25612506, text='What confuses me is... why do you think the meaning is different? There is no meaning overload. It&#x27;s a single meaning.<p>T: &#x27;static would happily typecheck with &amp;&#x27;a str if &#x27;a: &#x27;static.<p>T: &#x27;static typechecks:<p>- OwnedValue<p>- OwnedValueWithReferences&lt;&#x27;a&gt; where &#x27;a: &#x27;static<p>- &amp;&#x27;a ReferencedValue where &#x27;a: &#x27;static &#x2F;&#x2F;&#x2F; &amp;&#x27;static ReferencedValue<p>- Foo&lt;&amp;&#x27;a Bar&gt; where &#x27;a: &#x27;static &#x2F;&#x2F;&#x2F; Foo&lt;&amp;&#x27;static Bar&gt;<p>...and more.<p>See the example here: <a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=857389cd5251e037f5ba608566b89b04" rel="nofollow">https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;mode=debug&amp;editio...</a><p>Notice how bar2 has a &amp;&#x27;a str where &#x27;a: &#x27;static and it can be happily passed to bar.<p>Of course in T: &#x27;static you&#x27;re subtyping a type and in &#x27;a: &#x27;static you&#x27;re subtyping a lifetime (which implicitly subtypes the type that it&#x27;s applied on)... but the &quot;: &#x27;static&quot; part means exactly the same: &quot;the left part of this bound can live up to the end of the application&quot;. Whether it&#x27;s a lifetime, a borrowed type or an owned type does not matter.<p>&gt; It is what it is I guess... just confusing as to why it was decided to use the same syntax for these things, instead of something different.<p>Because they are the same.<p>We could of course separate them into &#x27;noref, &#x27;yesrefbutstatic, &#x27;staticref, etc. But then we&#x27;d have a needlessly restrictive std:.thread::spawn that would accept only Owned, or only Owned&lt;&#x27;static&gt; or only &amp;&#x27;static Referenced. The implications are the same, hence they&#x27;re the same. We wouldn&#x27;t gain anything and we&#x27;d be needlessly restricted.<p>A simpler way to put it: owned values have an implicit &#x27;static lifetime.')