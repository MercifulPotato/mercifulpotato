Item(by='fluffything', descendants=None, kids=[24672851, 24673322, 24674718, 24672822], score=None, time=1601739877, title=None, item_type='comment', url=None, parent=24671403, text='&gt; [Things I avoid] parking_lot: More compact and efficient implementations of the standard synchronization primitives. [goes on about efficiency...]<p>lol, really? No, like, not at all.<p>Parking lot has 1 killer feature, and 1 killer feature only, and this feature makes using the standard synchronization primitives _almost always_ the wrong choice for almost all applications:<p><pre><code>    DEADLOCK DETECTION\n</code></pre>\nThat&#x27;s right, if you ever need a Mutex, chances are that your program might run into a deadlock at some point. Do your future self a huge favor and don&#x27;t use the standard library&#x27;s std::Mutex. Instead, use parking_lot::Mutex, turn on deadlock detection at compile-time, and save your future self potentially hours of trying to figure out what your program is doing, why is it deadlocking, and how to fix it.<p>parking_lot::Mutex panics if your program deadlocks, printing out the backtrace of each thread involved in the deadlock. This makes discovering, understanding, and fixing dead-locks a 5 minute issue, that&#x27;s easily and quickly discovered during development in the minutes after introducing a deadlock bug.<p>I mean, you are completely right that, on top of that, parking_lot synchronization primitives are much much faster than those in the standard library. But that&#x27;s only the cherry on top.<p>---<p>FWIW, nice post, I agree with all your judgements there. If you are looking for an async runtime that&#x27;s smaller than tokio, check out the `smol` crate. For a thread-pool, i either just use rayon&#x27;s (you can just push tasks onto its thread pool), or the futures&#x27;s simple thread pool from the futures crate.')