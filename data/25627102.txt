Item(by='kolme', descendants=None, kids=None, score=None, time=1609724386, title=None, item_type='comment', url=None, parent=25623486, text='I&#x27;m going to have to disagree with almost everything you said, let&#x27;s have a look:<p>&gt; I always think it&#x27;s hilarious when Clojure enthusiasts try to address concerns about the language by talking about parentheses, as if that was actually the major barrier to entry.<p>Not that they are a major barrier, but they <i>do</i> scare people away. I know this because I&#x27;ve been tempted to try lisps before and after having a look at some source code, I was &quot;scared&quot; of the parenthesis. They are ugly (at least I thought at first sight) and they seem like very tedious to type. Of course I know better now, but that was _the_ reason I had not to try lispy things, at least on a couple of occasions. So yes, the <i>&quot;the parens are A-OK!&quot;</i> is absolutely warranted when trying to sell Clojure or any lisp for that matter.<p>&gt; It&#x27;s slow<p>So what? If I&#x27;m not writing anything CPU bound, I&#x27;m not very concerned about that. Clojure is fast enough for most things. The performance penalty is completely justified if it takes me half the time to write an app. This is just a trade off, or do you write all your stuff in ASM?<p>&gt; Development with the REPL is slow because the startup times are glacial and REPL-oriented development usually requires tons of from-scratch restarts.<p>This is just very much not true. First of all, nobody is forcing you REPL-oriented programming. Second of all, it doesn&#x27;t take more than a couple of seconds for most apps to restart. And third, if you use &quot;def&quot; and &quot;defonce&quot; correctly you&#x27;ll hardly ever have to restart the REPL.<p>&gt; The tooling sucks.<p>That&#x27;s just your opinion, man, and it&#x27;s also pretty rude. Clojure have awesome IDEs and tooling, and the aforementioned REPL-development allows you to have the same &quot;react-hot-relading&quot; developer experience, <i>anywhere.</i><p>&gt; Java interop is a black art.<p>Java (and Javascript) interop is pretty straight forward. You call functions and instantiate classes and stuff. No naked dancing under the moon involved.<p>&gt; The ecosystem practically doesn&#x27;t exist.<p>It maybe didn&#x27;t some time ago. The ecosystem right now is thriving with pretty cool projects.<p>&gt; The lack of static types hurts you in many ways, most of all your ability to refactor with confidence.<p>That&#x27;s also pretty subjective, in my opinion the only thing that gives you confidence to refactor is unit testing.<p>Plus there&#x27;s other ways to validate parameter and return values in Clojure, and they are not limited to the type.<p>You&#x27;ll agree, that a return value is of a given type doesn&#x27;t guarantee that it&#x27;s <i>correct.</i><p>&gt; Clojurescript is weakly typed, Clojure is strongly typed.<p>Plain wrong, types are semantically equal in both languages (they are weak). The semantics of the target languages are just implementation details.<p>You can try this on a REPL of any variant you like:<p><pre><code>  (def foo 42)\n  (def foo &quot;Hello, World!&quot;)\n</code></pre>\nSharing code between Clojure and Clojurescript is fine, especially if you stick to the built-in data types and functions. Of course if you have a lot of specific interops interleaved, it&#x27;s going to be painful.')