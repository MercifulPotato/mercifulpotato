Item(by='brandmeyer', descendants=None, kids=[24964976], score=None, time=1604272590, title=None, item_type='comment', url=None, parent=24962887, text='(jumping up the thread to try and hop over some confusion...)<p>The problem isn&#x27;t with unsigned types generally.  Its with subregister unsigned types.  So, size_t and uintptr_t are fine.  uint32_t, uint16_t, uint8_t (on LP64 ABIs) are pessimized and demand zero-extension instructions (or proofs that they can be safely elided) prior to causing side-effects.  uint64_t on a LP128 ABI would also be problematic.<p>signed 32-bit int is also fine... because RISC-V specifically has a suite of arithmetic instructions that unconditionally sign-extend from bit 31.  Even without those, it would still be fine because the carve-out for undefined behavior is wide enough for INT_MAX+1 to remain positive.  Same thing for all of the other narrow-width signed integer types.  If you increment SHRT_MAX and then use it to index memory, its perfectly legal undefined behavior to access base + SHRT_MAX+1 instead of base + SHRT_MIN.<p>However, that&#x27;s not legal for the unsigned types.  They are all mandated to wrap in 2&#x27;s complement.  base + UINT_MAX+1 must access base + 0 when the index is `unsigned int`, even on a 64-bit machine.')