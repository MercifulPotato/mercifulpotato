Item(by='rswail', descendants=None, kids=None, score=None, time=1604123829, title=None, item_type='comment', url=None, parent=24948960, text='That&#x27;s because you are thinking that the <i>representation</i> of a resource is <i>the</i> resource.<p>&quot;The map is not the territory&quot;.<p>A PUT is a way for the client to transfer its <i>representation</i> of a resource to the server. There&#x27;s nothing that stops the server from changing the state of that resource independently and asynchronously.<p>&gt; The verbs quickly lose their meaning<p>That&#x27;s because people tend to think in terms of CRUD, POST is Create, GET is Read, PUT&#x2F;PATCH are Update, DELETE is Delete.<p>But that&#x27;s misinterpreting things:<p>POST is to transfer the state of a new resource that has been created by the client. That resource might be subject to a long running business process (eg a Sales Order). That Sales Order will change its state as it progresses through the business process.<p>GET is a way for a client to request the transfer of a server&#x27;s representation of an existing resource. It should do a GET to synchronize it&#x27;s understanding of the current state. Use of E-tags etc allow for caching and avoiding stale changes.<p>PUT&#x2F;PATCH is a way for a client to transfer a change in the representation of a resource to the server. For example, changing the delivery address. Often though, these attributes should be resources in their own right (eg &#x2F;order&#x2F;id&#x2F;delivery-instructions). There is nothing to stop an initial post of the Sales Order creating the subresources as part of the processing of the POST. If you use JSON API and&#x2F;or JSON-LD etc, you can provide backwardly compatible extensions in a response that older clients will ignore and newer clients can use.<p>DELETE is a way for the client to say that as far as it is concerned, the resource no longer exists. In the Sales Order example, it could represent the cancellation of the order, but might be rejected by the server (eg if it has already been shipped), or it might trigger something else (eg a refund).<p>&gt; gRPC does away with the verbs entirely<p>gRPC forces the protocol to be &quot;verb first&quot; and focus on defining the behavior of those verbs. For each one, it has to clarify the idempotency, the state of the things being changed, how to find out about those changes, the different process errors that can occur, etc etc.<p>The trouble with gRPC is that it throws away everything that was learned in the &quot;SOAP wars&quot; of the 2005-10 period, where &quot;enterprise suppliers&quot; were desperate to keep their moats by defining ever more complex protocols on top of RPC to cover up the cracks and problems. An example, WS-ADDRESS, a standard for naming things over an RPC pipe that replicates the entire URL definition, but over a layer of RPC that was being tunnelled through port 80. WS-SECURITY, which did what TLS and HTTP Authorization does, but again, over layers of RPC and XML over HTTP over SSL.<p>All of that crap was unnecessary but was created because the idea of dealing with the nouns instead of the verbs is harder, because you have to think through the processes and changes in terms of state machines and events, instead of imperative processing where state is distributed and indeterminate.<p>&gt; gRPC would let people focus on the actual problems at play<p>gRPC exposes the random distractions of one side&#x27;s internal processing activities instead of focusing on how the two sides of a process co-ordinate and co-operate.')