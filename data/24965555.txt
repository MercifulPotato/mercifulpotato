Item(by='rwmj', descendants=None, kids=[24966659], score=None, time=1604303081, title=None, item_type='comment', url=None, parent=24964966, text='The article doesn&#x27;t mention that file descriptors &quot;in flight&quot; over sockets are garbage collected if the listening process doesn&#x27;t pick them up.  This has been the subject of serveral bugs&#x2F;security issues: <a href="https:&#x2F;&#x2F;nvd.nist.gov&#x2F;vuln&#x2F;detail&#x2F;CVE-2008-5029" rel="nofollow">https:&#x2F;&#x2F;nvd.nist.gov&#x2F;vuln&#x2F;detail&#x2F;CVE-2008-5029</a> <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;779472&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;779472&#x2F;</a><p>Al Viro&#x27;s description sums up one of the recent problems (which was fixed):<p><i>Among the features provided by io_uring is the ability to &quot;register&quot; one or more files with an open ring; that speeds I&#x2F;O operations by eliminating the need to acquire and release references to the registered files every time. When a file is registered with an io_uring, the kernel will create and hold a reference for the duration of that registration. This is a useful feature but it contained a problem that, seemingly, only somebody with a Viro-level understanding of the VFS could spot, describe, and fix; it is a new variant on the cycle problem described above. In short: a process could create a Unix-domain socket and register both ends with an io_uring. If it were then to pass the file descriptor corresponding to the io_uring itself over that socket, then close all of the file descriptors, a cycle would be created. The io_uring code was unprepared for that eventuality. </i>')