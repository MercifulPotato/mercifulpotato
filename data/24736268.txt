Item(by='john_moscow', descendants=None, kids=[24736812, 24736964, 24743631, 24736634, 24736751, 24737537], score=None, time=1602296467, title=None, item_type='comment', url=None, parent=24735366, text='If you want to be able to compile a certain language fast, translation units need to be modular. I.e. if <i>Source1</i> is referenced by <i>Source2</i> and <i>Source3</i>, you should be able to compile Source1 once, save its public part into a binary structure with logarithmic access time, and then just load it when compiling <i>Source2</i> and <i>Source3</i>.<p>This works splendidly with Pascal because each .pas file is split into <i>interface</i> and <i>implementation</i> sections. The <i>interface</i> section is a contextless description of what the module exports, that can be easily translated to a bunch of hash tables for functions, types, etc, that will be blazingly fast.<p>It&#x27;s a whole different story with C&#x2F;C++. In order to support preprocessor macros and C++ templates, referencing a module means recursively &quot;including&quot; a bunch of header files (i.e. reparsing them from scratch), meaning O(n^2) complexity where n is the number of modules. You can speed it up with precompiled headers, but you will still need to separately parse each sequence of references (e.g. #include &lt;Module1.h&gt; \\n #include &lt;Module2.h&gt; and #include &lt;Module2.h&gt; \\n #include &lt;Module1.h&gt; will need to be precompiled separately. C++20 modules do address this, but since C&#x2F;C++ is all about backwards compatibility, it&#x27;s still a hot mess in real-world projects.<p>That said, C# solves this problem near perfectly. Each .cs file can be easily translated to an mergeable and order-independent &quot;public&quot; part (i.e. hierarchical hash table of public types), and that part can be reused when building anything that references this file. It is also interesting how C# designers achieved most of the usability of C++ templates by using constrained generic types that are actually expanded at runtime (JIT IL-to-native translation to be more specific).')