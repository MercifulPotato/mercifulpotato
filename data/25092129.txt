Item(by='the8472', descendants=None, kids=None, score=None, time=1605359876, title=None, item_type='comment', url=None, parent=25091881, text='&gt; According to the article, if I use ext4 with journaling and have a file with &quot;a foo&quot; and write &quot;bar&quot; at position 2, possible resulting states are: &quot;a foo&quot;, &quot;a boo&quot;, &quot;a bao&quot; or &quot;a bar&quot;.<p>It makes a lot more sense if you consider it shared, concurrently accessed memory. If you try to access it without atomics you can get funny results. And if you kill one process in the middle you might be stuck with reordered accesses indefinitely. Something like ext4 provides more than that.<p>If you want ACID then you&#x27;ll have to opt into that. The same as you have to do with concurrent programming (e.g. via std::atomic). But there are many cases where none of this is needed, where all you need is a bag to hold a few bytes for a while. E.g. cache files or large media blobs.<p>The only issue is ubiquity of the necessary tooling, or the lack thereof. Many standard libraries now ship with concurrency-safe data structures while you often have to reach for 3rd-party libraries for safe file abstractions if you don&#x27;t want to code your own.<p>&gt; If SQLite can implement transactions on top of the current filesystem APIs, then obviously its possible to put that behaviour in the kernel.<p>If userspace can already implement it (when needed) based on provided kernel primitives, why should the kernel maintain two APIs side by side? Userspace needs many different levels of granularity. Sometimes integrity doesn&#x27;t matter at all. Sometimes it only matters that writes make it to disk in correct order but it&#x27;s ok for the last ones to get lost. And sometimes you need multiple processes memory-mapping a file and doing shared byte-level access and only random byte-ranges need to be committed to storage at any given time.')