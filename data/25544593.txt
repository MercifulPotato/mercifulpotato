Item(by='thewebcount', descendants=None, kids=[25545439, 25544623], score=None, time=1609001730, title=None, item_type='comment', url=None, parent=25543386, text='I hit a similar issue in OpenGL on macOS about 10 years ago. We had a fairly complex set of draw calls. It worked fine on high-end machines, and was perfectly usable, if a bit slow, on mid-range machines, but on low-end iMacs with crappy Intel graphics cards, it would cause the machine to panic and reboot.<p>It ended up being that the draw calls filled up the smaller command buffer on the low end card, and the driver would crash. In talking with the implementors, they explained the situation, so I asked, &quot;How do I determine that I&#x27;m filling up the command buffer?&quot; The answer was basically, &quot;The size of the command buffer is an implementation detail and there&#x27;s no way to query OpenGL for it or for the size of the commands you&#x27;re adding.&quot; Gee, thanks!<p>We ended just breaking up the draw calls into more smaller calls and it solved the problem, but this entire bug was such an ordeal. Thankfully we&#x27;re moving away from OpenGL and things are a bit more sane in Metal. Had I not had access to the OpenGL team at Apple at the time, there&#x27;s no way I would have been able to figure out what was going on. I&#x27;m not sure if I would have thought to do the same work in smaller batches.')