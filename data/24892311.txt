Item(by='mikepurvis', descendants=None, kids=None, score=None, time=1603679332, title=None, item_type='comment', url=None, parent=24892094, text='It&#x27;s frustrating how many ways there are for a git clone to get out of sync, especially when it&#x27;s an automation-managed one that is supposed to be long-lived (think stuff like gracefully handling force-pushed branches and tags that are deleted). I&#x27;ve dealt with a bit of this with my company&#x27;s Hound (code search engine) instance. Currently there&#x27;s a big snarl of fallback logic in there that tries a shallow clone, but then unshallows and pulls refs if it can&#x27;t find what it&#x27;s looking for, culminating in this ridiculousness:<p><pre><code>    git fetch --prune --no-tags --depth 1 origin+{ref}:remotes&#x2F;origin&#x2F;{ref}\n</code></pre>\nSee the whole thing here: <a href="https:&#x2F;&#x2F;github.com&#x2F;mikepurvis&#x2F;hound&#x2F;blob&#x2F;6b0b44db489f9aeff390ad8a95cc57d6543b002e&#x2F;vcs&#x2F;git.go#L60" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;mikepurvis&#x2F;hound&#x2F;blob&#x2F;6b0b44db489f9aeff39...</a><p>The pipeline I manage is many repos rather than a monorepo, and maintaining long-licheckouts in this context is not really realistic, but what does work and is very fast is just grabbing tarballsâ€” GitLab and Github both cache them, so they don&#x27;t don&#x27;t cost additional compute after the first time, and downloading them is strictly less transfer and fewer round trips than the git protocol.<p>The only real cost is that anything at build time which needs VCS info (eg, to embed it in the binary) will need an alternate path, for example having it be able to be passed in via an envvar.')