Item(by='lmm', descendants=None, kids=None, score=None, time=1608977310, title=None, item_type='comment', url=None, parent=25540322, text='&gt; But that is basically just saying your existing way to bisect is not fully reliable and you fear using rebase would make it quantitatively noticeably worse. What I am saying is it can and should be fully reliable, and this is not theoretical either.<p>What you&#x27;re proposing doesn&#x27;t actually improve matters; you don&#x27;t gain anything (other than saving a bit of machine time) by only testing known-compiling commits. At the end of the day the bisect lands you on either a single commit or a string of commits (in the case where some commits don&#x27;t compile), and that&#x27;s the diff that you have to go through manually; the whole point of bisect is to make that diff as small as possible. If you limit your bisect to testing changes from the history of master (one way or another), you guarantee that you&#x27;ll land a diff that&#x27;s a complete feature branch; if you allow the bisect to go through every commits then you have a decent chance of landing on a much smaller diff.<p>&gt; But I am arguing from plenty of real-life experience with a workflow, which is incidentally rebase-based (but the same guarantees would hold just as well if I moved it to a purely merge based approach) where I a) know that every &quot;merge&quot; to master has been fully tested before it lands b) can reliably bisect over ~years of commits with a simple git alias, without having to ever manually bisect skip bad commits[+]. And by construction, not because I hope that devs will generally have tested their commits sufficiently manually or are diligent about fixing merge conflicts in a way that does not result in intermittent broken commits. So whilst several of your other reasons are perfectly valid (long-lived branches), you can maybe see why this one is a bit amusing to me.<p>I&#x27;ve got plenty of real-life experience with plenty of different workflows, thank you very much. If you decide you want a history-of-master history, there are plenty of ways to get that (I&#x27;d argue squash-merging is the lowest-overhead way to do it). But the result of that is you get a much less useful bisect than a workflow where you have small commits on feature branches and use merges.<p>&gt; It&#x27;s not impractical at all, in fact if your company pays me for it I&#x27;m more than happy to set it up for you :)<p>I don&#x27;t work for that company any more, but bear in mind this was for a codebase with 500 developers where builds took around 1.5 hours. We looked at building speculative batches of PRs together but decided the costs were higher than the benefits; master occasionally got broken and we fixed it when it happened.<p>Fundamentally a broken master is always a problem you can have, because flaky tests happen (and, as you mention, meta-level problems can happen). It&#x27;s good to minimise the times when master is broken, but it&#x27;s not realistic to assume you can avoid it entirely, so your workflow should be able to handle having the occasional isolated broken commit in the history of master.')