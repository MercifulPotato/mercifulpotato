Item(by='thechao', descendants=None, kids=[25852433], score=None, time=1611174868, title=None, item_type='comment', url=None, parent=25851412, text='I&#x27;m into PL(T) stuff and I&#x27;ve gotten tired about hearing about Jai. One thing I like is Jai adopting the SPAD X-form (Chi-form); he (mis)attributes it to Sean Barret:<p><pre><code>    The syntax name: type = value; specifies that a variable named name is of the type type and is to receive the value value\n</code></pre>\nWhere the inferred&#x2F;imperative-assignment form is a visual reduction:<p><pre><code>    name : type = expr\n    name := expr\n</code></pre>\nIt has the lovely property that if you elide the type expression the variable gets an inferred type. If you keep the type expression, then the language has both a type-expression for type-checking and type of the value-expression for type-inference; then, the PL can be designed in one of a few ways:<p>1. If the type expression mismatches the type of the value-expression, fail;<p>2. If the type expression can be unified with the type of value-expression, keep the unified; or,<p>3. If the value expression can be coerced to the type expression, keep the type expression.<p>SPAD used the second behavior and it was the bees-knees. This was especially true since SPAD supported refinement (quotient) types, so you could do things like this:<p><pre><code>    name : int(-2 &lt; n and n &lt;= 10) = ... complex expression that we can&#x27;t prove is in the range (-2, 10] ...;\n</code></pre>\n... and this would fail to compile.')