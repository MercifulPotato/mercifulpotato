Item(by='wahern', descendants=None, kids=None, score=None, time=1603938405, title=None, item_type='comment', url=None, parent=24924158, text='&gt; -n % n (where n is unsigned) suffers from the problem that -n calculates a two&#x27;s complement. That value is implementation-defined, due to the implementation-defined width of the unsigned type.<p>In C a &quot;computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type.&quot; (C11 6.2.5p9) In other words, it behaves as-if it were two&#x27;s complement. So the &quot;problem&quot; of assuming two&#x27;s complement isn&#x27;t actually a problem at all. (On machines that use signed-magnitude representation for integer types, for example, such as some only recently retired Unisys mainframes, C compilers actually emulate unsigned arithmetic in the generated code.)<p>While the number of value and padding bits of integer types (other than the fixed-width types) is implemented-defined, that dilemma is precisely what the construct (-n % n) is intended to deal with, and to do so in a type-safe manner (i.e. no risk of somebody changing the underlying types without changing UFOO_MAX to UBAR_MAX, presuming the macros even exist).<p>Your alternative construct just assumes &quot;bits&quot; out of thin air, but because the number of padding bits is implementation-defined in C you can only deduce this from UFOO_MAX. In the next C version there should be new macros that specify the number of value bits, but there&#x27;s still the type-safety problem of the compiler unable to enforce the constraint that a macro (or any other parameter, for that matter) represents a characteristic of the type you&#x27;re actually operating on.')