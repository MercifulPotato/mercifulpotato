Item(by='BlueTemplar', descendants=None, kids=None, score=None, time=1604753543, title=None, item_type='comment', url=None, parent=25012204, text='Ok, I&#x27;ll try to find some Ward Cunningham&#x27;s work.<p>----<p>&gt; Technical debt is precisely the mismatch between the language you are programming in, and the domain you are programming for.<p>That&#x27;s a concept on a very different level from<p>&gt; the lack of understanding of what the client wanted (often the ignorance of the client himself of what he actually wanted)<p>And the term &quot;technical debt&quot; seems to be a very bad name for either of those. Just look at the examples the others provided : the word &#x27;technical&#x27; makes one think that it&#x27;s an issue with tool (= codebase) maintenance first !<p>----<p>&gt; semantically, you get to define your own classes and methods and create your own little world inside that language, where things can be combined and chained together<p>That is if you&#x27;re even using OOP in the first place. I&#x27;m now viewing it with suspicion, especially after the only course we had on it, in Java, where we weren&#x27;t even warned about things like &quot;Composition over Inheritance&quot;. (Ok, we also had a half-course on UML.)<p>OOP seems to me more like a tool that should only applied to specific problems : for instance making a GUI (I have some Python-Qt experience).<p>In the same way, I do see programming languages themselves as more or less fitting to certain problems.  \nSpeaking of which, this semester I had to pick between C+ (C++ with a minimum of libraries, and god forbid, no OOP) and Fortran, and I picked C+ because Linux is mostly written in C.  \nAnd hopefully one can find a language where you can keep the &quot;impedance mismatch&quot; between the language and the problem to a minimum.  \nBut for that you have to figure out what the problem actually is in the first place, which might take several design cycles !<p>But I&#x27;ll try to read up on this &quot;aspect-oriented programming&quot;.')