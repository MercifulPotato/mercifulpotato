Item(by='ncmncm', descendants=None, kids=[25476932], score=None, time=1608366830, title=None, item_type='comment', url=None, parent=25475687, text='A design pattern is <i>anything</i> you see hand-coded in multiple programs.<p>We don&#x27;t often see data-structure patterns nowadays <i>just because</i> such patterns were recognized early as in need of core language features to capture them into libraries. Hash tables were a tough nut, so the core features that are needed to capture them in libraries, or even direct core-language implementations, didn&#x27;t make it into some of the languages that are still in common use.<p>The set of patterns that can be captured into a library is a moving target for a language that is still evolving rapidly, and for the landscape of new and upcoming languages; but a fixed target for a mature language like C. In C, X can, Y can&#x27;t, and that will probably always be true of C.<p>As time goes on, the set of patterns that can be captured into libraries of new and evolving languages grows, and with it our expectations of new languages. A language, new or old, that fails to capture what other languages are seen to do (for reasons) is rightly seen as less powerful.<p>There is a place for less powerful languages, for use in limited domains, that are therefore quicker to learn and maybe safer to use, for less experienced or more distracted users. But we should always be clear about why the language is being made or kept less powerful, and what is lost by it.<p>When starting a new project with open-ended goals, we don&#x27;t know what challenges the project will face and whether a deliberately limited language will be enough for the job. By the time we learn, it is generally far too late to change horses. Thus, aging OS kernels and databases we use are often still coded in C largely because that was all that was practically available when they started out.<p>Go is a recent deliberately-limited language that, because it was chosen to implement projects with open-ended goals, is getting painful extensions, and getting harder to learn. Rust was deliberately limited to reduce the burden of implementing its toolchain and to make it easier to pick up, but is rapidly expanding (according to plan) to satisfy the growing needs of its increasingly sophisticated user base.')