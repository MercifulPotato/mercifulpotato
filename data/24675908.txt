Item(by='kevincox', descendants=None, kids=[24677103], score=None, time=1601773878, title=None, item_type='comment', url=None, parent=24674490, text='This looks fantastic. I was recently reading a config file from Rust and ended up going with JSON5 but this is simpler to read. In a language like Rust you don&#x27;t need the types because you specify that in the struct anyways. Sure, this means that there are effectively more types than strings but the user doesn&#x27;t need to differentiate.<p>In Rust you do something like this:<p><pre><code>  #[derive(Clone,serde::Deserialize)]\n  struct {\n    an_int: u64,\n    a_float: float,\n    ordered_map: linked_hash_map::LinkedHashMap&lt;String, chrono::DateTime&lt;chrono::Utc&gt;&gt;,\n    unordered_map: std::collections::HashMap&lt;i32, String&gt;,\n  }\n</code></pre>\nSo there is no need to worry about if maps are ordered or if a value is an integer, real or string in the format itself. Ironically for Python (which the reference implementation is in) it does seem much more annoying to have to manually call `int()` on each element.<p>I&#x27;m just a little sad that tabs are disallowed. I really think the best rule for indentation-sensitive languages is that each line must either have the same indentation in which case it is the same level, same indentation plus any amount in which case it is the next level, or the exact indentation of any previous level in which case it is a dedent. These &quot;solutions&quot; which just forbid tabs are half-assed and ones that try to convert tabs to a set amount of spaces just lead to confusion.<p>Additionally it would be nice if there was an example of a dict inside a list. I think it would work like the following but can&#x27;t confirm from reading the site.<p><pre><code>  -\n    key: value\n  -\n    key: value\n    other-key: other-value</code></pre>')