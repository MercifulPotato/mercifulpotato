Item(by='carapace', descendants=None, kids=None, score=None, time=1604871213, title=None, item_type='comment', url=None, parent=25026561, text='Step 0: discard unnecessary information and recode the problem to make plain what is actually being asked for.<p>A string that contains each three-tuple in order but not necessarily contiguous, and is the shortest possible string that meets this criteria.<p>The second clause of the problem rules out simply concatinating the fifty succesful login attempts.  But that does give us an upper limit on the length of the string.<p>N[max] = 3 * 50 = 150<p>Next consider the simple brute-force solution:  Iterate through the integers from n (to be determined later, for now set it to zero or one) to 10^150 - 1 and check each one.  Halt when the solution is found.<p>Depending on the urgency of the situation this is as much thinking as you might need to do.  There are several fairly obvious ways to trim the amount of integers you would need to check.<p>But of course, the generate-and-test strategy is overkill for this problem, and relatively uninteresting compared to the possibility of devising a clever mathematical or logical solution.<p>One angle would be to explore generation functions that might produce minimal strings directly from the set of three-tuples.<p>Another angle would be to set up the problem for a contraint-solver.  I&#x27;m a little rusty these days but I think you could convert the problem to a SAT instance and use an off-the shelf SAT solver.<p>(As an aside, watch out for unfounded assumptions, e.g. maybe all ten digits don&#x27;t appear in the logins.  Do digits appear more than once in a given keylog entry?)<p>It took me about ten minutes to write the brute force python code, and about half an hour to get it to work.  (The biggest problem I had was debuggin a stupid Python 2&#x2F;3 error: map() returns an iterator now not a list.  FML.  Also, getting conda to work in windows with vscode was a lil hassle (use cmd.exe not PowerShell.)  FML.)<p>For the curious:<p><pre><code>    keylog = list(map(list, &#x27;&#x27;&#x27;\\\n    319\n    680\n    180\n    690\n    129\n    620\n    762\n    689\n    762\n    318\n    368\n    710\n    720\n    710\n    629\n    168\n    160\n    689\n    716\n    731\n    736\n    729\n    316\n    729\n    729\n    710\n    769\n    290\n    719\n    680\n    318\n    389\n    162\n    289\n    162\n    718\n    729\n    319\n    790\n    680\n    890\n    362\n    319\n    760\n    316\n    729\n    380\n    319\n    728\n    716&#x27;&#x27;&#x27;.splitlines()))\n\n\n    def predicate(N):\n        f = N.find\n        # This works because there are no repeated digits (like 112).\n        for a, b, c in keylog:\n            i = f(a)\n            if -1 == i:\n                return False\n            j = f(b, i)\n            if -1 == j:\n                return False\n            if -1 == f(c, j):\n                return False\n        return True\n\n\n    def do():\n        n = 9999\n        while True:\n            N = str(n)\n            if predicate(N):\n                print(N)\n                break\n            n += 1\n\n    do()</code></pre>')