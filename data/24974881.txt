Item(by='codebje', descendants=None, kids=None, score=None, time=1604361435, title=None, item_type='comment', url=None, parent=24965983, text='When I say range types I mean a type like &#x27;5..23&#x27; - a sub-range of some other type. Haskell doesn&#x27;t have these. Most languages don&#x27;t - one example that does is Ada:<p><a href="https:&#x2F;&#x2F;en.wikibooks.org&#x2F;wiki&#x2F;Ada_Programming&#x2F;Types&#x2F;range" rel="nofollow">https:&#x2F;&#x2F;en.wikibooks.org&#x2F;wiki&#x2F;Ada_Programming&#x2F;Types&#x2F;range</a><p>As you can see from that link, it&#x27;s bounds checked at runtime. You could have a modulo type that wraps on overflow, which is of course what most numeric types are in most programming languages, including Haskell, but the modulus is fixed at some power of two for obvious reasons.<p>There&#x27;s only one thing I truly value out of a good type (or static analysis) system, and that&#x27;s enabling fearless refactoring. I want the type system to pick up on any downstream consequences of a change I make rather than finding out by phone call at 3am the day after a deploy that some edge case got overlooked.<p>Dependent types can (in theory) give that over smart constructors. If my parser should leave me with, say, a sorted vector, or an assertion that if one field is some value then some other field is Just something, then I&#x27;d like to be able to rely on those facts in downstream code making use of the results of the parser. If it&#x27;s just a smart constructor as we usually write them a later refactor (sorting on a different key, for example) doesn&#x27;t change anything that any other bit of code can be verified against.<p>A dependent type carrying a proof that a vector is sorted based on some criteria and an assertion about the existed of some value can be verified at compile time.<p>I&#x27;m not sure what the status is of dependent types for Haskell. You could do similar propositional assertions now with Ghosts of Departed Proofs, and LiquidHaskell exists for these sorts of assertions, so dependent types aren&#x27;t the only path to this kind of static safety, either. I won&#x27;t claim that this is practical - though I would be surprised if it&#x27;s not practical to do in small doses.<p>Nevertheless, I would still just be reaching for smart constructors in current day Haskell.')