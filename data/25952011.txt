Item(by='derefr', descendants=None, kids=[25955099], score=None, time=1611881416, title=None, item_type='comment', url=None, parent=25941357, text='That&#x27;s a big &quot;for starters.&quot;<p>In-band signaling — or rather, in-band <i>markup</i> — is a big part of what makes a &quot;terminal&quot; (i.e. a TTY&#x2F;PTY device) semantically a &quot;terminal&quot;: a hybrid character-grid &#x2F; event-log that works both as a sink for streamed-in text, <i>and</i> as a &quot;plotter&quot; for making line-printer art. A device that both streams <i>out</i> as, effectively, an input-event log (where this log can be captured for replay, as with script(1) or most logging systems); but which also maintains a notion of being a ring-buffer &quot;containing&quot; a rectangularly-bounded volume of text (and control-events), such that clients just connecting onto it can begin streaming just from the beginning of that buffer, to end up with one complete &quot;image&quot; of the latest PTY state, minus any scrollback, without needing previous history.<p>All that is kind of <i>predicated</i> on control-characters being embedded in the text and &quot;following&quot; the text around, such that taking a slice of the text (as the PTY&#x27;s ring-buffer does every time a line is expunged) will preserve the corresponding slice of events.<p>What would reading back the contents of a PTY device look like in a world with out-of-band TTY signalling? What would flow over a serial port? Would it even <i>be</i> a character-stream device, or are you imagining a TTY&#x2F;PTY as operating in something more akin to a structured datagram event-stream mode, such that you&#x27;d use sendmsg(2) and recv(2) on it rather than write(2) and read(2)?<p>I mean, it&#x27;s not an impossible dream; but that really is a &quot;start over with a whole separate ecosystem that no existing software works with until made compatible&quot; kind of change. Effectively it&#x27;d be a separate thing from TTYs, that just happens to have similar functionality. But it wouldn&#x27;t support any existing software, <i>or</i> any existing hardware, except by virtualization (i.e. running a PTY emulator process inside your modern OoB-signalling terminal emulator.) <i>Kind</i> of like what Windows has been going through to replace its own command-line.<p>---<p>Personally, I&#x27;d prefer to keep in-band signalling (in the &quot;in-band markup&quot; sense above, not the &quot;you have to recognize conventional escape-code sequences heuristically to even know they&#x27;re not regular text&quot; sense.)<p>But I&#x27;d rather just make the in-band signalling <i>structured</i> — i.e. to make TTYs into a data-stream containing a variable-length self-synchronizing bit-encoding with clear prefix separation for control- and data- packets.<p>Y&#x27;know, like UTF-8 is for text.<p>...<i>or</i>, well, <i>speaking</i> of Unicode: we could just <i>use</i> Unicode for this, reserving another block† of control characters to go with the 30-odd ones that sit at the beginning of the BMP. Then &quot;is this is a control codepoint, and if so, what does it mean&quot; could just be answered by consulting a Unicode table. (In such a setup, CSI command parameterization would be accomplished with zero-width joiners, variant selectors, and other things. Just picture control-characters as invisible emoji — specifically like the flag emoji that are formed by spelling out country-codes in a sort of &quot;flags meta-alphabet&quot;; or like that family emoji [<a href="https:&#x2F;&#x2F;emojipedia.org&#x2F;family&#x2F;" rel="nofollow">https:&#x2F;&#x2F;emojipedia.org&#x2F;family&#x2F;</a>] with the combinatoric variants.)<p>† Why not use the Private Use Area? Because this would be an explicitly inter-compatible signalling <i>standard</i>, not a proprietary usage. It&#x27;s not <i>text</i>, but it <i>is</i> a standard signal within a text document. Just like emoji — or like the existing control codepoints in Unicode.')