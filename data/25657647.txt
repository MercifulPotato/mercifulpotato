Item(by='patrec', descendants=None, kids=None, score=None, time=1609940837, title=None, item_type='comment', url=None, parent=25652742, text='&gt; How do you guys think about the opportunity cost of learning dead&#x2F;dying&#x2F;new&#x2F;unpopular languages?<p>Interesting question. My advice would be as follows:<p>1. Learn <i>one</i> practical language really well, well enough that you can both immediately write correct code, with no IDE or documentation, to both algo style problems (hacker rank etc.) and the things that typically come up in your day job or hobby projects (e.g. if you do datascience and use pandas a lot, be sure you can do all common operations from memory; if you do web development, you should be able to churn out a simple REST handler in your framework of choice without thought). You don&#x27;t need to rote-memorize the language&#x27;s entire API surface of course, but you should be able to churn out all the frequently needed stuff without thought.<p>2. Learn one or two other languages less well, but well enough to cover the spectrum of stuff you need to do, efficiently. Relying on the IDE and frequently looking up stuff is likely fine. For example, everyone should know at least one scripting language well enough to automate things by gluing stuff together and if you need to periodically do some simple web UI for a one-off tool, learn enough javascript to do so effectively if not necessarily elegantly. If you want to do systems stuff you&#x27;ll at least need average C  skills and so on and so forth.<p>3. Only now that you covered your bases to do &quot;realistic&quot; tasks effectively, look at learning some more exotic languages. Otherwise you risk flitting from one thing to the next wasting a lot of time setting up a third rate dev environment for a weird language and hunting for some semi functional library that helps you achieve X and never working on anything meaty enough to really learn much.<p>But once you are productive and cover a range of tasks with mainstream languages, learning either maybe-up-and-coming or already-half-dead-but-interesting language can definitely pay off. Because if you make good choices about which languages to learn you can either broaden your horizons in ways that will pay off even if you don&#x27;t ever use the language for &quot;real work&quot; or, if, you&#x27;re lucky, you might have picked an up and coming language and be one of the small pool of people with any amount of experience with it, which will give you a strong competitive advantage. Don&#x27;t allow your main language skills to grow dull (unless you are switching to a new bread-and-butter language), but there is no problem with learning X and then forgetting a lot of the day-to-day stuff about it, if you got some lasting enlightenment out of it.<p>Also: don&#x27;t put esoteric languages on your CV if you just have toyed with them, only list things you have used professionally or done some non-trivial hobby project with (unless, maybe, you are looking for a job in &quot;obscure language X&quot;).<p>One of the annoying things with people telling you to learn X because it will help you to grow intellectually is that they often don&#x27;t really provide concrete examples, so let me provide a few suggestions:<p>1. Lisp: templating trees by bashing together strings (or CPP style tokens) is braindamaged. Having a compiler at runtime is powerful and useful. A real REPL (not Python, ruby, scala, ...) is powerful and useful. Most DSLs suck and would have been better replaced with a simple sexp format.<p>2. Smalltalk: You can have a syntax that&#x27;s as basically simple as lisp but more readable.  Everything is live, inspectable and modifiable and you can persist the whole state of the world trivially. This has dangers, too.<p>3. Python: syntax can, and maybe should, look like pseudo-code. By getting the pragmatics mostly right (e.g. slices, convenient dicts, convenient and immutable strings, mutation returns None, good error messages and repr, basic pseudo-Repl), you can make a very productive language without particular hardcore engineering skills or understanding of CS theory (or history). On the other hand these will also  become real limitations at some point.<p>2. APL&#x2F;J&#x2F;K: there are more reductions, inner products and outer products that are useful beyond those involving addition. Array rank and broadcasting. The joys of right associativity. Function power (including infinite) and under. The effects (good and bad) of extreme conciseness.<p>4. C&#x2F;C++&#x2F;Zig&#x2F;Rust: understanding ownership, stack, heap, pointers. Low-level thinking.<p>5. Clojure: cons cells as in lisp or scheme suck. So do traditional FP linked lists. Reducers&#x2F;transducers, schema-language leveraged for property-based tests. One way to think about concurrency with immutability.<p>6. Erlang: you can have some very nice properties without a horrendously complex implementation, if you make the right engineering trade-offs. E.g. Erlang is pretty much the only thing that gives you preemptive multi-tasking with very high granularity. Pseudo-ropes are an interesting way to do strings. Supervision trees are a powerful concept and way to think about failure and failure handling in concurrent code. The value of deep production introspectability and in particular low-overhead tracing.<p>7. SQL: Data is king. The power of a truly high level language (even if flawed). Where the abstraction breaks down, badly (e.g. locking, or the DB switching execution plans under you). &quot;Null&quot; done right (true ternary logic, even if confusing is a lot better than the NaN crap in ieee 754 or null in mainstream languages). Why you still want to avoid Nulls most of the time. ORMs are for losers.<p>8. Ocaml: a proper type system can make writing certain types of code much less error prone and is possible without Haskell-level ivory-tower-wankery. There is value in having a somewhat simple minded but predictable compiler.<p>9. Zig: you can do almost everything C++ can do at a tiny fraction of the conceptual overhead.')