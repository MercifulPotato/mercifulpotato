Item(by='NOGDP', descendants=None, kids=[25098670], score=None, time=1605402553, title=None, item_type='comment', url=None, parent=25096995, text='You can&#x27;t &#x27;think away&#x27; the additional complexity of lifetimes and the borrow checker though. It&#x27;s something you have to understand and keep in mind.<p>&gt; Better type-inference. In Java this has improved but is still much more clunky and boilerplatey. Good type-inference is important to not annoy the user.<p>In my opinion, Java without type inference is fine - it&#x27;s very minor issue, and there is a fairly limited scope of code that would actually benefit from type inference in terms of quality&#x2F;readability. If you use a decent editor most of the redundant typing is auto-completed anyway.<p>&gt; Traits &#x2F; type-classes. They enable a way of programming that comes much closer to duck-typing and avoid wrapping your objects in wrapper-classes to support interfaces like you are forced to do it in Java.<p>Eh, Rust traits are better than Java&#x27;s interfaces, but you can implement multiple interfaces for your own objects in Java without any wrappers. The issue is extending external objects to support new interfaces. Plus, the point is to have correct code defined and checked at interface&#x2F;trait boundaries, something JS doesn&#x27;t do at all.<p>&gt; Better and less noisy error handling (looking at you Java, Go, C++ and most other languages)<p>The error messages for Rust can be much more complex than Java, and are probably more complex on average, simply because it&#x27;s a more complex language and type system.<p>I would say the benefits of Java&#x27;s type system far outweigh the imperfections and tiny costs when compared to a language like JS.')