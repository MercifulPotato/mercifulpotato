Item(by='beyondCritics', descendants=None, kids=[24807191], score=None, time=1602903277, title=None, item_type='comment', url=None, parent=24806884, text='C does destructive conversions automatically, if you ask for it. E.g.<p><pre><code>  unsigned n;\n  n = 2.99;      &#x2F;&#x2F; n = 2\n  n = -1;        &#x2F;&#x2F; n = 2^M-1;\n  n = 1.0E33;    &#x2F;&#x2F; undefined but not catched\n</code></pre>\nBoth C and C++ follow the same philosopy: &quot;Trust the programmer&quot;. The programmer is expected to use his expressive freedom, to solve performance problems and stay away from problematic constructs without being told to so. C is a systems programming language from the 70&#x27;s, designed to solve performance problems and C++ inherits from that.\nIt is true, that in C++, you can overload assignment, addition and throw exceptions everywhere, thus making even simple expressions like<p><pre><code>  auto n = a + b;\n</code></pre>\ncompletely unpredictable. But the coder simply has abused the freedom C++ gave him. T some extent, the same is possible in C, look here <a href="https:&#x2F;&#x2F;www.ioccc.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.ioccc.org&#x2F;</a>')