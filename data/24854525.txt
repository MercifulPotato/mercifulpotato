Item(by='wahern', descendants=None, kids=None, score=None, time=1603336080, title=None, item_type='comment', url=None, parent=24853578, text='LPeg also has what it calls match-time captures (<a href="http:&#x2F;&#x2F;www.inf.puc-rio.br&#x2F;~roberto&#x2F;lpeg&#x2F;#matchtime" rel="nofollow">http:&#x2F;&#x2F;www.inf.puc-rio.br&#x2F;~roberto&#x2F;lpeg&#x2F;#matchtime</a>), which can be used to parse non-context free grammars like common TLV (tag, length, value) formats. For example, I&#x27;ve written a pure LPeg parser for parsing PKIX objects like X.509 certificates. Example edited code snippets with some high-level and low-level bits:<p><pre><code>  -- returns DER object pattern that captures inner value\n  local function Cobject(identifier, patt)\n    local match\n\n    if lpeg.type(patt) then\n      match = function (s)\n        return lpeg.match(patt * -P(1), s)\n      end\n    elseif type(patt) == &quot;function&quot; then\n      match = patt\n    elseif patt == nil then\n      match = function (s)\n        return s\n      end\n    else\n      error(sformat(&quot;expected function, pattern or nil, got %s&quot;, type(patt)), 2)\n    end\n\n    return Cmt(identifier, function (s, pos)\n      local n, pos = assert(unpacklength(s, pos))\n      local s1 = s:sub(pos, pos + n - 1)\n      pos = pos + n\n\n      return (function (pos, v, ...)\n        if v then\n          return pos, v, ...\n        else\n          return false\n        end\n      end)(pos, match(s1))\n    end)\n  end\n\n  local BIT_STRING = Cobject(P&quot;\\x03&quot;, function (s)\n    local pad = s:byte(1) -- first octet is number of padding bits\n    assert(pad == 0, &quot;BIT STRING not octet aligned&quot;) -- we only support DER\n    return s:sub(2)\n  end)\n\n  local IA5String = Cobject(P&quot;\\x16&quot;)\n\n  local OID = function (oid)\n    if oid then\n      local s = packoid(pkix.txt2oid(oid))\n      return P(sformat(&quot;\\x06%s%s&quot;, packlength(#s), s)) * Cc(oid)\n    else\n      return Cobject(P&quot;\\x06&quot;, function (s)\n        return assert(unpackoid(s))\n       end)\n    end\n  end\n\n  local SEQUENCE = function (patt)\n    return Cobject(P&quot;\\x30&quot;, patt)\n  end\n\n  local TBSCertificate = SEQUENCE(Ct(\n    Cg(Version, &quot;version&quot;) *\n    Cg(CertificateSerialNumber, &quot;serialNumber&quot;) *\n    Cg(AlgorithmIdentifier, &quot;signature&quot;) *\n    Cg(Name, &quot;issuer&quot;) *\n    Cg(Validity, &quot;validity&quot;) *\n    Cg(Name, &quot;subject&quot;) *\n    Cg(SubjectPublicKeyInfo, &quot;subjectPublicKeyInfo&quot;) *\n    Cg(UniqueIdentifier(1), &quot;issuerUniqueID&quot;)^-1 *\n    Cg(UniqueIdentifier(2), &quot;subjectUniqueID&quot;)^-1 *\n    Cg(Extensions, &quot;extensions&quot;)^-1 *\n    Cg(P(1)^1, &quot;trash&quot;)^-1\n  ))\n\n  local Signature = BIT_STRING\n\n  local Certificate = SEQUENCE(Ct(\n    Cg(TBSCertificate, &quot;tbsCertificate&quot;) * \n    Cg(AlgorithmIdentifier, &quot;signatureAlgorithm&quot;) * \n    Cg(Signature, &quot;signature&quot;)\n  ))</code></pre>')