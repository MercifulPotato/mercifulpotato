Item(by='thesz', descendants=None, kids=None, score=None, time=1602776816, title=None, item_type='comment', url=None, parent=24788502, text='&gt;If that is &quot;hard&quot;, I would hate to see what you think of things like cache coherency across cores...<p>Cache coherence across cores is easy. The number of corner cases is much smaller.<p>The number of corner cases of old architectures (MIPS, or SPARC) is staggering. I designed a MIPS core prototype and I was done in single week with all arithmetic and memory access commands and spent three weeks designing, implementing and debugging branch handling, due to branch delay slot &quot;feature&quot;.<p>&gt;You do a check for the full range before the access, because for best performance you would want to pull in as much as possible in one go anyway.<p>You cannot do that - pull as much as possible in one go, - for case page boundary is crossed. But the very fact that you have to check before issuing operation make things more complex than they can be.<p>&gt;&gt;&quot;load multiple&quot; from PC (which is exposed to programmer in quite peculiar way)<p>&gt;What&#x27;s hard about that?<p>State handling. Can this instruction be interrupted?<p>&gt;&gt;Or out-of-order execution.<p>&gt;Everything gets turned into uops, this instruction can emit more than one.<p>There are more than &quot;everything gets turned into uops&quot; out-of-order execution engines - scoreboarding, for example, provides most of benefits for much less energy cost.')