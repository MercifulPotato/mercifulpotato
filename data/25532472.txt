Item(by='geofft', descendants=None, kids=None, score=None, time=1608851857, title=None, item_type='comment', url=None, parent=25531372, text='To the point about data scientists - there isn&#x27;t really a way you could <i>solely</i> hire the software engineers, right? So there is value in Python allowing the data scientists to iterate much quicker than they could if they were writing in a &quot;production-ready&quot; language.<p>I agree there&#x27;s work to be done in closing that gap so you don&#x27;t need an extra software engineer for productionalizing mostly-working Python (and I&#x27;m excited about tools for managing large-scale Python - e.g., several of my coworkers are trying out MyPy, which I haven&#x27;t personally felt too much of a need for but seems like it could help), but the gap exists precisely because you can write something working in Python quickly, and it&#x27;s not so much of an investment that you&#x27;d feel bad throwing it away if it doesn&#x27;t work.<p>The company that started with Python and spent years on a full rewrite <i>made enough money with Python to survive those years</i>. If they had started in a more &quot;production-ready&quot; language they might not have shipped at all, and if they did they might not have shipped the right thing.<p>And at least for me personally, as an infra person, the question I&#x27;m evaluated on at the end of the day (or year) is &quot;Did the infrastructure work,&quot; not &quot;Did you write production-quality software to support the infrastructure.&quot; Some of the most critical software I&#x27;ve written (across multiple companies) has been 50 lines of Python shared via a Slack snippet or a shared homedir and only retreated into version control months later. There are a lot of problems that genuinely require only 50 lines of complexity, and the ceremony of a language like Java makes it much harder to understand what&#x27;s going on. For those problems that do require umnanageable Django monoliths, by all means, write it in something else.')