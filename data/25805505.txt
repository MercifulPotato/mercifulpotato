Item(by='wasyl', descendants=None, kids=None, score=None, time=1610831163, title=None, item_type='comment', url=None, parent=25803305, text='&gt; Scoping is mysterious<p>It definitely is confusing, but while the rules to scoping are pretty extensive, they&#x27;re also well defined. The trick is to know how Gradle &quot;travels&quot; through objects and looks for the property in class properties, extensions, extras, etc. I wrote about it [1] if you&#x27;re interested.<p>&gt; Gradle script is interacting with things you can&#x27;t see<p>Not necessarily -- yes, the receiver for top-level calls (Project instance) is implicit, but you can access it via `project` property. You could prefix each top-level call in your Gradle script with `project.`, making all calls explicit.<p>Btw `sourceSets { }` calls the lambda on a `SourceSetContainer` instance, accessible via `Project#sourceSets` property [2], so you can get an instance of it. I suppose there might some objects that are configurable but not accessible, but nothing comes to my mind right away, actually.<p>&gt; a build tool is a thing that tracks dependencies so that it only has to rebuild things whose inputs have changed. Gradle doesn&#x27;t do that at all.<p>You might&#x27;ve had a bad experience with a misconfigured plugin&#x2F;build or a bug. Gradle does track dependencies, and while it doesn&#x27;t do that perfectly always, it avoids a lot of unnecessary work, on many layers (incremental compilation, task avoidance, task caching). As a general rule, when running the same task(s) twice, the second invocation shouldn&#x27;t execute any taks.<p>&gt; This is because the entire dependency graph is constructed dynamically on every run\nIt&#x27;s true that configuration&#x2F;task graph creation is still happening on every invocation (this will change with Configuration Cache [3]). But it&#x27;s definitely not accurate that this prevents Gradle from knowing which steps have already been done. Again, I fully believe it didn&#x27;t work for you, but it doesn&#x27;t mean Gradle doesn&#x27;t do that.<p>I&#x27;m not trying to say Gradle doesn&#x27;t have flaws. In fact, I think your comment proves the points from the article. Unless one invests in learning how Gradle works, it&#x27;s impossible to spot e.g. why the build isn&#x27;t doing any task avoidance, or understand scoping. It&#x27;s rather unfortunate, because after that initial investment Gradle is a pretty great tool to work with.<p>[1] <a href="https:&#x2F;&#x2F;medium.com&#x2F;tooploox&#x2F;where-do-gradle-properties-come-from-bf77e43ee572" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;tooploox&#x2F;where-do-gradle-properties-come-...</a>\n[2] <a href="https:&#x2F;&#x2F;docs.gradle.org&#x2F;current&#x2F;dsl&#x2F;org.gradle.api.Project.html#org.gradle.api.Project:sourceSets" rel="nofollow">https:&#x2F;&#x2F;docs.gradle.org&#x2F;current&#x2F;dsl&#x2F;org.gradle.api.Project.h...</a>\n[3] <a href="https:&#x2F;&#x2F;docs.gradle.org&#x2F;current&#x2F;userguide&#x2F;configuration_cache.html" rel="nofollow">https:&#x2F;&#x2F;docs.gradle.org&#x2F;current&#x2F;userguide&#x2F;configuration_cach...</a>')