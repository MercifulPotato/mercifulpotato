Item(by='tel', descendants=None, kids=[25089301], score=None, time=1605306066, title=None, item_type='comment', url=None, parent=25084848, text='It&#x27;s absolutely a different approach to generics. Or, rather, that&#x27;s the ringer. I want to say first: OCaml&#x27;s take on modules is just a really nice way of doing namespacing as well.<p>Secondly, generics depend upon (a) having a means to discuss functionality which abstracts over one or more types and certain behaviors those types must support, (b) having a means to bundle up one or more types along with some behaviors, and (c) being able to combine those two.<p>In Typescript&#x2F;Java&#x2F;C# this is mostly carried out by classes and subtyping. Abstraction occurs when we ask not for a specific type but instead for something a little less than that specific type, one of its supertypes; bundling occurs in classes; and the combination occurs naturally as subtypes are transparently upcast to their supertypes.<p>There are two practical drawbacks to this approach:<p>First, it&#x27;s hard to abstract over behavior that doesn&#x27;t merely consume your abstract type but also returns it. When we do (c) via subclassing we have to upcast and it&#x27;s not always clear or possible to re-downcast things back to the appropriate type. OO has tons of workarounds for this issue and related ones.<p>Second, it&#x27;s hard to abstract over multiple interrelated types at once. For instance, a generic graph implementation might want to be abstract both in the types of nodes and the type of edges. The generic implementation can thus handle annotations at either the edges or the nodes. In OO abstraction, you might do something like have the edges be an associated type of the nodes, but this creates an unnecessary asymmetry.<p>The solution is a classic one. Instead of having the class represent an object, have the class represent a bundle of operations which act on abstract objects (the C++ vtable approach). For example, in pseudocode<p><pre><code>    class GRAPH\n\n      type Graph\n      type Node\n      type Edge\n\n      # These are hard to do with subclassing since Graph will often be upcast on return\n      def emptyGraph(): Graph\n      def simplify(g: Graph): Graph\n\n      # These represent non-trivial interactions between multiple types abstracted simultaneously\n      def addNode(g: Graph, n: Node): Graph\n      def neighbors(g: Graph, n: Node): List&lt;Node&gt;\n</code></pre>\nAnd this, with the appropriate type discipline, is what OCaml does. Unfortunately, what you&#x27;ll find is that OCaml&#x27;s type discipline is critical and difficult to emulate. Making this sort of modularity work consistently involves some notions of equivalences and transparency that are natural to discuss when talking about modules but rarely show up in OO systems.')