Item(by='sevensor', descendants=None, kids=None, score=None, time=1602685437, title=None, item_type='comment', url=None, parent=24775364, text='Agreed.<p>I&#x27;ve been studying Racket lately.  Historically I&#x27;ve mainly worked in C and Python, although I&#x27;ve scratched the surface with lisps before.  One of the things that strikes me about Racket is that every new special form I learn has its own evaluation rules.  They may be very similar, they may follow certain patterns, but they don&#x27;t attain total consistency.  (Especially confusing to me has been the existence of expressions with arity other than one, which are OK in some forms but not in others.)  Most of the special forms are macros underneath; you can go and read them, although they&#x27;re still parenthesis soup to me at the moment.  Still, there&#x27;s a path through the fog -- you know that underneath it all, there is a small number of primitive forms, and all this syntactic abstraction is ultimately built on top of them.<p>Contrast this with Python.  Python has a lot of syntax.  You can&#x27;t reason your way through Python by reference to a small number of primitive forms.  Instead, just about every expression evaluates to an object, and if you know what kind of object it produces, you can go look up what that object does.  What I really enjoy about learning Racket is seeing how syntactic abstraction lets the language get away with not creating new data structures when it doesn&#x27;t have to.  However, a marriage of the two approaches seems like too much.  To understand what a macro does, now you&#x27;re going to have to map the macro&#x27;s special syntax back to Python&#x27;s ordinary syntax, and then you&#x27;re going to have to figure out how to use whatever kind of objects that syntax produces.  This imposes a whole new layer of reasoning on the reader.<p>I&#x27;m not a fan of this PEP and I&#x27;d avoid using it in my code if it were adopted.  I already have enough trouble explaining generator comprehensions to my colleagues; a half dozen new quasi-Python languages that compose with each other in surprising ways would be more than enough to make them retreat back to C#.')