Item(by='dragontamer', descendants=None, kids=None, score=None, time=1602001517, title=None, item_type='comment', url=None, parent=24698906, text='&gt; It&#x27;s deeper than that, the shaders are _binary_ compatible.<p>I&#x27;d be surprised if this fact was true.<p>GCN 1.0 and GCN 1.2 aren&#x27;t even binary compatible. Opcode 0x1 is &quot;ReadLane&quot; in GCN 1.0, but is &quot;Add F32&quot; in GCN 1.2.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;CLRX&#x2F;CLRX-mirror&#x2F;wiki&#x2F;GcnInstrsVop2" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;CLRX&#x2F;CLRX-mirror&#x2F;wiki&#x2F;GcnInstrsVop2</a><p>Vop2 are the &quot;2-source &#x2F; 1-destination&quot; instruction format. You can see from the table that GCN 1.0 and GCN 1.2 don&#x27;t even line up at all.<p>It wouldn&#x27;t be hard to compile GCN 1.0 into GCN 1.2 instructions, but it wouldn&#x27;t be binary-compatible, just assembly-language compatible (like 8080 -&gt; 8086).<p>--------<p>Some other facts:<p>* RDNA is Wave32 native. Wave64 compatibility is available though, so that should mostly work for backwards compatibility (aside from DPP, which you do point out may not exist in PS4)<p>* S_WAITCNT (&quot;wait for memory&quot; instruction) has grossly changed in RDNA. In GCN, waiting for VM_CNT(0) will wait on loads and stores. But VM_CNT(0) only waits for loads on RDNA.<p>You need to change every S_WAITCNT VM_CNT(0) (GCN) into S_WAITCNT VM_CNT(0), followed by a new S_WAITCNT_VSCNT 0 instruction (wait for 0 outstanding loads, THEN wait for 0 outstanding stores).<p>This isn&#x27;t &quot;binary compatible&quot;, but if you just inserted one instruction on every GCN S_WAITCNT, you&#x27;d get the proper behavior in RDNA.<p>-----<p>I&#x27;m seeing GCN -&gt; RDNA as a &quot;mostly easy compile&quot; between the assembly languages. But it doesn&#x27;t seem binary compatible to me. I wouldn&#x27;t be surprised if there were one or two issues that popped up however.')