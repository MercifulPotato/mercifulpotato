Item(by='hardwaresofton', descendants=None, kids=[25614913], score=None, time=1609602885, title=None, item_type='comment', url=None, parent=25613089, text='&gt;  The moment you need control flow to define your resources, I&#x27;d argue that you&#x27;re verging away from the realm of declarative infrastructure.<p>Declarative infrastructure shouldn&#x27;t be pursued for it&#x27;s own sake -- what I want is efficient, and simple to manage infrastructure automation. The declarative nature is awesome, but once you start doing plumbing of variables and complexity from one static script from another, the cognitive load of keeping this all in line is better managed with a programming language in my opinion, you&#x27;re just choosing bash&#x2F;jq&#x2F;awk&#x2F;etc instead of a different language.<p>I think &quot;the way the declarations are made must be static files&quot; is dogmatic or at least limiting for me. Yes it is absolutely the simplest way to view what&#x27;s present, but the problem is when someone goes into change any of this they will be dealing with your bolted-together complexity (even if it&#x27;s not very complex).<p>&gt; I&#x27;m using Terraform to manage 10^4 machines in combination with sane CI&#x2F;CD, Bash&#x2F;JQ (for dealing with Terraform outputs), Packer and Ansible. Everytime I see somebody reaching to a full programming language to define their infrastructure, they seem to be doing too much with one tool.<p>&gt; Terraform should merely provision things and in that role I find it fine as is. Preferred, even.<p>I can&#x27;t argue with the efficiency and efficacy of your setup, but I don&#x27;t think much of this has to do with what we were discussing -- Pulumi does not seek to do the jobs of those other tools -- it&#x27;s not going to build your VM images or do provisioning (unless you use it that way like with terraform[0]).<p>Here&#x27;s a concrete example of a benefit I got form using Pulumi over terraform recently, in some code working with SES:<p><pre><code>    import * as fs from &quot;fs&quot;;\n\n    &#x2F;&#x2F; ... more imports and other lines\n\n    &#x2F;&#x2F; Email Access key\n    const emailAccessKey = new aws.iam.AccessKey(\n      `${stack}-ses-access-key`,\n      {user: emailUser.name}\n    );\n\n    export const emailUserSMTPPassword = emailAccessKey.sesSmtpPasswordV4;\n    export const emailUserSecret = emailAccessKey.encryptedSecret;\n\n    &#x2F;&#x2F; Write the smtp username and password out to a local secret file\n    const apiSecretsDir = path.join(__dirname, &quot;secrets&quot;, &quot;api&quot;, stack);\n    const smtpUsernameFilePath = path.resolve(path.join(apiSecretsDir, &quot;SES_USERNAME.secret&quot;));\n    const smtpPasswordFilePath = path.resolve(path.join(apiSecretsDir, &quot;SES_PASSWORD.secret&quot;));\n\n    emailAccessKey.sesSmtpPasswordV4.apply(password =&gt; {\n      console.log(`Writing SES SMTP username to [${smtpUsernameFilePath}]`);\n      fs.writeFileSync(smtpUsernameFilePath, emailUsername);\n\n      console.log(`Writing SES SMTP password to [${smtpPasswordFilePath}]`);\n      fs.writeFileSync(smtpPasswordFilePath, password);\n    });\n</code></pre>\nI wanted to write information out to a file... So I just did, and that was it. No need to reach for the stack output later and pipe it anywhere -- any time pulumi runs it will update that variable if&#x2F;when it changes, and the next tool (which requires the file at that path to be present) will continue on without knowing a thing.<p>I can&#x27;t say that this is perfect Pulumi code (ex. I could have defined a custom Resource to do this for me), but I have saved myself having to do the plumbing with bash scripts and terraform output awk-ing, and the information goes just where I want it (NOTE: the secrets folder is encrypted with git-crypt[1]). When someone comes to this file (ses.ts), they&#x27;re going to be able to easily trace where these values where generated -- similar with bash scripts, but now they don&#x27;t have to be a bash&#x2F;awk&#x2F;jq master to manipulate information. There are definitely <i>some</i> gotchas to using Pulumi (like the `.apply` there), but in the end, I&#x27;d prefer to make changes like this in a consistent language I like (Typescript).<p>My toolkit looks very similar to you, except I basically only use make + kubectl + pulumi + ansible (rarely, because of the kind of servers I rent).<p>[0]: <a href="https:&#x2F;&#x2F;www.terraform.io&#x2F;docs&#x2F;provisioners&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.terraform.io&#x2F;docs&#x2F;provisioners&#x2F;</a><p>[1]: <a href="https:&#x2F;&#x2F;www.agwa.name&#x2F;projects&#x2F;git-crypt&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.agwa.name&#x2F;projects&#x2F;git-crypt&#x2F;</a>')