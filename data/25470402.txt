Item(by='thisiszilff', descendants=None, kids=[25473760, 25470605], score=None, time=1608317120, title=None, item_type='comment', url=None, parent=25469957, text='There is definitely a spectrum of &quot;knowledge&quot; at play when it comes to these considerations. The most obvious DRY violations are those kinds of things that you go &quot;oh I need to test for this case&quot; because that is usually an indication of some knowledge you need to know when interacting with a piece of code. EG, if you ever use -1 as a sentinel value then the knowledge of &quot;what -1&quot; means should be consolidated together, otherwise all clients will have to know that -1 is a sentinel, what it means and at best you&#x27;ll have duplicate code, at worst those interpretations won&#x27;t align and you might have a subtle bug where that -1 is doing something somewhere (ie it is supposed to mean &quot;No information provided&quot; but somewhere something is keeping an arithmetic mean of this field and those -1s are now screwing up your metrics and you don&#x27;t really notice).<p>When we think about the knowledge of &quot;how to <i>do</i> something&quot; that&#x27;s where things can get confusing. 9&#x2F;10 times I&#x27;d say that right move is to look for common assumptions or facts. IE it isn&#x27;t just &quot;doing something&quot; that is important, but the assumptions made in the process of doing it:<p>As an example, consider finding the average word length in some piece of text. We might start writing that feature like:<p><pre><code>  def count_words(text: str) -&gt; int:\n      return len(text.split(&#x27; &#x27;))\n\n  def average_word_length(text: str) -&gt; int:\n      num_words = count_words(text)\n      word_lengths = []\n      for word in text.split(&#x27; &#x27;):\n          word_lengths.append(len(word))\n      return sum(word_lengths) &#x2F; num_words\n\n\n</code></pre>\nthen the piece of knowledge they share is &quot;what a word is&quot; and the DRY refactoring would pull out that piece of knowledge into its own function<p><pre><code>  def words(text: str) -&gt; List[str]:\n      return text.split(&#x27; &#x27;)\n\n</code></pre>\nthat might be code you write when starting to write a feature and that&#x27;s the kind of &quot;ding ding ding there&#x27;s common knowledge here&quot; that should guide refactoring. The system has a concept of a &quot;word&quot; that we&#x27;ve introduced and its important that knowledge about &quot;what a word is&quot; in one place. For DRY things it frequently doesn&#x27;t make any sense for there to be multiple statements of &quot;what a word is&quot; where the system wants to use the same concept.<p>Kind of orthogonal to this is abstraction where the focus is on &quot;usefulness&quot; and that is where 100% you can abstract incorrectly, prematurely, get screwed over by requirement changes, write a library that hides everything and makes people angry. The example you provide seems more like an error in abstraction where things that should be close together are too far apart in the system (ie, some &quot;fact&quot; is hidden away and another part of the system wants to know it), but the consolidation and DRYing of those facts, I&#x27;d argue, is a lot easier once we&#x27;ve figured out how to identify them')