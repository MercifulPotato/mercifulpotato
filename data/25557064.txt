Item(by='Geminidog', descendants=None, kids=[25557326], score=None, time=1609134941, title=None, item_type='comment', url=None, parent=25556440, text='There&#x27;s many topics in this area. Ones that are well known in industry are algorithmic complexity theory and type theory. Ones that are less well known include the two resources below.<p><a href="http:&#x2F;&#x2F;www4.di.uminho.pt&#x2F;~jno&#x2F;ps&#x2F;pdbc.pdf" rel="nofollow">http:&#x2F;&#x2F;www4.di.uminho.pt&#x2F;~jno&#x2F;ps&#x2F;pdbc.pdf</a><p><a href="https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu" rel="nofollow">https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu</a><p>I suggest you get use to ML style languages before diving into those two resources (Haskell is a good choice) as it&#x27;s not easy to learn this stuff and I think it&#x27;s also part of the reason why it hasn&#x27;t been so popular in industry.<p>The first resource builds towards a prolog like programming style where you feed the computer a specification and the computer produces a program that fits the specification.<p>The second resource involves utilizing a language with a type checker so powerful that the compiler can fully prove your program correct outside of just types.<p>Both are far away from the ideal that the industry is searching for but in terms of optimizing and formalizing design these two resources are examples of the right approach to improving software design.<p>I haven&#x27;t found anything specifically on the organization of software modules so as far as I know none exists. But given the wide scope of software research I&#x27;m sure at least one paper has talked about this concept.')