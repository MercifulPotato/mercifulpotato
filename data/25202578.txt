Item(by='ben509', descendants=None, kids=None, score=None, time=1606249186, title=None, item_type='comment', url=None, parent=25199472, text='&gt; This statement makes me think... how come the TS compiler is not using something like a hash&#x2F;map (object) of union members to basically ignore redundancy?<p>The trouble is the operation isn&#x27;t &quot;is X a member of Y&quot;, rather it&#x27;s &quot;does X match any values of Y according to predicate P.&quot;<p>You <i>can</i> break that out if you have knowledge of possible X&#x27;s and P, as is the case with type matching.<p>Say we are checking G[] against {str, &quot;foo literal&quot;, int[]}. I have no idea how TS implements these internally, but say the underlying type expressions are:<p><pre><code>    [{head: String}, \n     {head: String, constraint:&quot;foo literal&quot;}, \n     {head: Array, element:{head: Integer}}]\n</code></pre>\nAnd G[] is {head:Array, element: {head: Generic, name: &quot;G&quot;}}.<p>We could reasonably require that heads are all simple values, and then group types as such:<p><pre><code>    {String: [{head: String},\n              {head: String, constraint:&quot;foo literal&quot;}],\n     Array: [{head: Array, element: {head: Integer}}]}\n</code></pre>\nYou&#x27;d still have to try to match that generic parameter against all the possible Arrays, but you could add more levels of hashing.<p>The downside is, of course, it&#x27;s quite tricky to group types like this and prove that it returns the same results as checking all pairs, especially when you have a complex type system.')