Item(by='haberman', descendants=None, kids=[25241187, 25240546], score=None, time=1606592846, title=None, item_type='comment', url=None, parent=25239827, text='Makefiles operate at a low level of abstraction.  The Makefile abstraction is &quot;run this command when the output files don&#x27;t exist or are older than the input files.&quot;  You manually specify every tool to be run and all of its arguments.<p>These tools operate at a higher level of abstraction.  The BUILD file abstraction is something like &quot;I am declaring a C library with these sources and headers.&quot;  The build system then turns that into a set of commands to run.  This higher-level abstraction provides a bunch of compelling features:<p>- Reliability: it&#x27;s easy to write Makefiles that are fragile, for example one that works when run on a single CPU but fails when run with -j, because of undeclared dependencies. When the tool is in charge, it has more control and can sandbox each build step so that undeclared dependencies simply won&#x27;t be available in the sandbox.<p>- Reproducibility: similar to the previous point, it&#x27;s easy to write a Makefile that produces incorrect results with an incremental rebuild. For example, unless you implement your own header scanning (or manually list your header dependencies) &quot;make&quot; won&#x27;t know to rebuild a source file when a header changes. These tools can ensure that builds are reproducible and incremental rebuilds are always correct.<p>Besides that, working at a higher level generally means writing less code to accomplish the same task, and the code you do write is closer to expressing your actual intent compared with a Makefile.')