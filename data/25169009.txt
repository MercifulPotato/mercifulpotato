Item(by='suyjuris', descendants=None, kids=[25169340, 25169542, 25169460], score=None, time=1605956678, title=None, item_type='comment', url=None, parent=25168459, text='Instead of remembering the weighted sequence, you can also compute it implicitly as you go (when reading the number from left to right). Example:<p><pre><code>    8\n    ^ 8 (mod 7) is 1, remember that\n    85\n     ^ 1 · 10 (mod 7) is 3, and 3 + 5 (mod 7) is 1, remember that\n    853\n      ^ 1 · 10 + 3 (mod 7) is 6\n    8536\n       ^ 6 · 10 + 6 (mod 7) is 3\n    85362\n        ^ 3 · 10 + 2 (mod 7) is 4\n    853629\n         ^ 4 · 10 + 9 (mod 7) is 0\n</code></pre>\nHence 853629 (mod 7) = 0 and it is divisible by 7. The corresponding code would be<p><pre><code>    def modulo(number, k):\n        val = 0;\n        for digit in str(number):\n            val = (val * 10 + int(digit)) % k\n        return val\n</code></pre>\nOf course, you can apply the modulo within the intermediate calculations as well, so instead of multiplying by 10 you can e.g. multiply by 3 = 10 (mod 7) instead. The key idea is that you can go from one weight to the next by multiplying with 10 (mod 7), so if you sum some weighted digits you can update all the weights at once with a simple multiplication.<p>The advantage is that you only need a small amount of memory (a single number between 0 and 6), so this is a kind of general divisibility rule where you only have to do small calculations in your head.<p>If I may digress a bit into automata theory, this means that you can construct a finite state automaton that determines whether a number is divisible by 7 (or any other constant) by reading its digits from left to right. Additionally, if a finite state automaton can do something reading from left to right, there is another automaton doing the same thing but reading from right to left. This means that there is also a &#x27;simple&#x27; divisibility rule when starting with the least significant digit, though it may be a bit harder to find.')