Item(by='pron', descendants=None, kids=[25621805], score=None, time=1609679607, title=None, item_type='comment', url=None, parent=25621336, text='Rust, like C++ if not more, elevates certain technical details like lifetime, static vs. dynamic dispatch, partial evaluation, and sequential composition (&quot;default&quot; vs. async) to multiple layers of syntactic constructs (types, generics, macros). That focuses the language on accidental complexity, although some people do find that C++ design philosophy appealing (I would expect some high correlation between people who like Scala and people who like Rust as I would between those who don&#x27;t like either). Of course, it&#x27;s a matter of personal aesthetics, but I think that style is misapplied for low-level domains, putting a lot of effort into a veneer of high abstraction without actually providing it (you still have to think about these aspects, as you do in all low-level languages, and, much more importantly, it still requires changing client code when details change, as in all low-level languages -- i.e. <i>changing</i> a Rust program is not like changing a Scala program), doing, IMO, more harm than good.<p>As someone who does a lot of low-level development, before Zig I didn&#x27;t think any approach other than that of C or that of C++ was even possible. I don&#x27;t know if Zig will fulfil its promise, but its radical design, that&#x27;s unlike anything we&#x27;ve ever seen, sure offers a fresh perspective on things.<p>As to static guarantees -- they are never the point; they are a means to an end: writing more correct programs. That goal is just as valued by Zig as it is by Rust, Zig just tries to achieve it differently. Which achieves it better? It&#x27;s hard to know right now. I have little doubt that Rust could make things that are today written in C++ safer, but I have serious doubts whether it would be adopted in truly safety-critical domains, where C is king. I think Zig could be.')