Item(by='chubot', descendants=None, kids=[25487063], score=None, time=1608430581, title=None, item_type='comment', url=None, parent=25482410, text='Wow, great post!  I have the same complaints:<p>(1) Languages have gotten worse as distributed back ends have gotten more powerful.  The IBM JCL and XML references in this post were good!<p>(2) Workloads that currently run on such back ends could run on a single computer, or at least with many fewer resources.  This is one reason I got into shell in the first place!  I wrote some shell scripts that saturated 32 cores instead of using distributed systems.  In other words I try to avoid the &quot;COST&quot; or &quot;parallelizing your overhead&quot; problem.<p>We&#x27;re paying a huge productivity tax and in many cases not reaping the rewards.  I think a better better UNIX SHELL can help in the following ways:<p>(1) We need to bring the interactivity of Unix back to distributed systems.  We&#x27;re still in the days of &quot;IBM Job Control Language&quot; with Kubernetes config and similar kinds of &quot;declarative cloud configuration&quot;.  We need a flexible and efficient analogue of Bourne shell.<p>(2) Unix shell is already how you set up local development environments: Docker embeds shell; virtualenv changes your shell state, Ruby&#x27;s bundler, OCaml&#x27;s opam switch, etc.  We need to evolve this into first class and polyglot environments specified in shell.<p>Debugging distributed systems locally could be the norm, but it&#x27;s not.<p>The local topology should simply be a configured variant of the distributed topology, but it&#x27;s not.  I used to do this at Google with a trick of generating a shell script with BCL (Borg Config Language).<p>(3) A better shell should be able express configurations that evaluate to JSON, and also  statically validate them before pushing, to solve this problem.<p><i>XML, however, was universally rejected in favour of things like JSON, Yaml, HCL, Toml - all free of structure, with zero indication whether a computer would find your prose gibberish or the next Shakespeare play until you actually pushed your code to some test cluster.</i><p>I want <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;</a> to go in this direction, and there is already some progress.  (Feel free to contact me if this resonates with you.)  And I have a draft of a blog post about shell, distributed systems, and languages that I need to publish, based on these comments from a couple weeks ago:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25343716" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25343716</a><p>Those comments talk about the other problem with the cloud: that it locks you in to APIs!  We need the POSIX of distributed systems.  Kubernetes was trying to do that, but it&#x27;s not good enough.<p>Shell can solve this problem more economically: it expresses UNPORTABLE glue code to leave your application PORTABLE.  I did that with Oil&#x27;s continuous builds, and the Unix-y gg FaaS framework also appears to do that in a pretty nice way.')