Item(by='dragontamer', descendants=None, kids=[25674112], score=None, time=1610036126, title=None, item_type='comment', url=None, parent=25666830, text='On the one hand, this is a great &quot;brute force&quot; method to learn how one implementation of RAID6 could happen. This blogpost achieves understanding of error-correction in the 2-parity case through brute force alone, and that&#x27;s actually quite commendable.<p>On the other hand, its a very, very bad way to learn Reed Solomon codes. Reed Solomon codes &quot;in general&quot; are a concept that&#x27;s broader than just 2-parity symbols... and also broader than just &quot;protection vs erasures&quot;. Reed Solomon is designed to correct errors as well (a far &quot;harder&quot; computation than simply an erasure).<p>I&#x27;ve fortunately found a good &quot;ELI5&quot; version of Reed Solomon: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xE4jEKx9fTM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=xE4jEKx9fTM</a><p>That&#x27;s a very non-technical talk, but that talk gives the full concepts of &quot;Polynomial in Finite Field&quot; that Reed Solomon codes are based off of.<p>For a proper computer-based Reed Solomon code, you choose the GF(2^8) extension field for 8-bit symbols (Pararchive uses 2^16 for 16-bit symbols). Extension fields are extremely complicated to understand however, this will take a few days of Abstract Algebra study to understand how extension fields work.<p>But once you know how a finite extension field works, you then extend a polynomial into the extension field, and bam, you have Reed Solomon codes.<p>That is: a Quadratic equation can protect 3-data. All quadratic equations are ax^2 + bx + c, so any 3-points define a quadratic equation. Generate (x,y) coordinates on a graph as (0, data0), (1, data1), (2, data2).<p>Then, solve for a quadratic equation f(x) = ax^2 + bx + c.<p>Then, to generate parity, f(3) is your first parity symbol, f(4) is your next parity symbol, f(5) is the parity symbol after that. Etc. etc. Note in a 8-bit finite field, you can only go up to f(255) before &quot;looping back&quot; to f(0).<p>From there: 2-check symbols will protect against either 2-erasures or 1-error. So Quadratic Equation with 4-check symbols (aka: 4 &quot;other points&quot; of the quadratic equation passed with the data) can protect against 4 erasures... or 2-errors, or 2-erasures + 1 error.')