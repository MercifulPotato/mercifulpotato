Item(by='jeffbee', descendants=None, kids=None, score=None, time=1602623195, title=None, item_type='comment', url=None, parent=24769770, text='C++ doesn&#x27;t come out of the box with an allocator at all. Implementations have to provide it. But this article isn&#x27;t talking about the difference between, say, jemalloc and mimalloc. It&#x27;s talking about cases where you want to minimize calls to global operator new, or cases where you want to make a lot of allocations but you don&#x27;t want to have to delete anything. The latter is often a massive advantage in speed. For example if you need to use a std::set&lt;int&gt; within a scope, and it doesn&#x27;t escape that scope, it will be much faster to provide an arena allocator that allocates the nodes used by std::set, both because it will minimize the necessary calls to global new -- it may even eliminate them if you can safely use enough stack space -- and especially because there isn&#x27;t a corresponding deallocation for every allocation. You simply discard the entire arena at the end of the scope.<p>Fans of Java may rightly point out that garbage collection also has this property, but GC brings other costs. Nothing in Java even remotely approximates the performance of an STL container backed by an arena allocator.')