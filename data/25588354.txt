Item(by='kentonv', descendants=None, kids=[25589040], score=None, time=1609376647, title=None, item_type='comment', url=None, parent=25588089, text='&gt; Constrained embedded systems cover a broad range of things up to and including your phone.<p>No, modern phones are certainly not constrained in the way I meant, and I don&#x27;t think you could call them &quot;embedded&quot; either. The common programming languages used on phones are very memory-allocation-friendly.<p>&gt; There&#x27;s few things I hate to see more than a flat profile from memory allocation or cache misses.<p>I think you may be arguing a different point, or a different level of extremity of the point. Reducing memory allocation to optimize performance is a fine thing that everyone does. The person I was replying to, though, seemed to be asserting that libraries should completely avoid allocating memory for themselves.<p>&gt; The good news is that flatbuffers[1] is a reasonable replacement for most of my use cases. In particular being able to mmap() them directly is a wonderful thing that you can&#x27;t do with protobufs in addition to being very allocation sparse.<p>Yeah... I&#x27;m the author of Cap&#x27;n Proto, which has the same property, and predates Flatbuffers.')