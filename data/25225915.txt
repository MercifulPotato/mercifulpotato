Item(by='crazydoggers', descendants=None, kids=[25226451, 25226008], score=None, time=1606457280, title=None, item_type='comment', url=None, parent=25225844, text='Ok, well I agree with that assessment. I just don’t think the article has made the case that the methods he talks about simplify handling these things at the boundary in some special way.<p>There are numerous ways, even in dynamically typed languages to use abstraction to raise the level of such errors and handle them in a single place.<p>For instance let’s take ruby. Rails has a “.blank?” Function that wraps up handling empty strings, lists, nils, etc. So if I use that abstraction, I’ve raised up having to check all those issue in every function, instead now I need to ensure the “blank?” function does what’s its supposed to.<p>So there’s definitely value in abstraction, and in moving certain classes of errors up the layers in the application. And yes I can see how some fancy uses of type systems (in this case Haskell) can make this work. The grandparent article seems to leave it there.<p>This parent article though seems to muddle things with the idea that parsing can do even better, and that’s were I think the idea is half baked.')