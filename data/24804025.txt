Item(by='steveklabnik', descendants=None, kids=[24805364], score=None, time=1602875699, title=None, item_type='comment', url=None, parent=24803780, text='In my mind, and be aware of my bias here, these languages split up into three different categories:<p>* Has a GC, but you can remove it. This is Nim and D.<p>* Relies on pervasive refcounting. This is Nim if you choose that implementation, Swift.<p>* Has no GC. This is Zig and Rust. (Though obviously you can use refcounting in these languages, but it is as a library.)<p>While this focuses on a specific aspect of these langauges, I think it also represents their philosophies pretty well. Nim and D start from a &quot;what if we had a GC&quot; and then try to make things nicer down the stack. Rust and Zig are how nice can we go starting from nothing?&quot;<p>There are also additional factors that may or may not play in here, depending on what your needs are. Arguably, Rust is starting to break out of the &quot;niche language&quot; stage and move into the &quot;significant projects and is sticking around&quot; phase, whereas many of these other languages aren&#x27;t quite there yet. This can matter with things like getting help, package support... some people love the open frontiers of new languages, others want something more mature. <a href="https:&#x2F;&#x2F;nimble.directory&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nimble.directory&#x2F;</a> has 1,431 packages at the time of writing, <a href="https:&#x2F;&#x2F;crates.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;</a> has 48,197.')