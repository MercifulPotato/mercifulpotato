Item(by='theamk', descendants=None, kids=None, score=None, time=1608927328, title=None, item_type='comment', url=None, parent=25534918, text='If you have an idea where do OOMs come from, you can (and should!) use &quot;oom_score_adj&quot;&#x2F;&quot;oom_adj&quot; so that  OOM kills processes are not random. There are many interesting strategies here:<p>- Set your watchdog and logging to &quot;never kill&quot;. Set watchdog to reboot on OOM, after uploading error report. This way, if the system OOMs, you can log the problems to your logging server, and then watchdog will reboot the system to recover.<p>- If you have a &quot;UI&quot; process which can also eat all the memory, set it to &quot;kill me first&quot;. Yes, the UI will crash, but the rest of system will restart it, and your updater would still work.<p>- If you have separate resource-intensive process, you can set it to &quot;kill me first&quot; -- then the rest of the system can stay up and maybe even show a descriptive error message.<p>- The latter approach works pretty nicely for general systems. Is your OOM killer activating because your build system started too many gcc instances? run it with &quot;kill me first&quot; setting -- it inherits to children processes, so you only build processes would be killed, the rest of the system (UI, browser, etc..) would all stay alive.')