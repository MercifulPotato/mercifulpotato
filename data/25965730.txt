Item(by='anko', descendants=None, kids=[25970862], score=None, time=1611977494, title=None, item_type='comment', url=None, parent=25959657, text='I&#x27;m not the parent poster but I&#x27;ll have a go.  Please feel free to correct me if I&#x27;ve got parts wrong, I&#x27;m hoping to learn something too.<p>In other languages, lets say Erlang as an example, actors themselves do not have concurrency concerns.  The receive loop&#x2F;handler just executes everything as though it&#x27;s single threaded.  The code is very easy to reason about.  It also applies backpressure in that if your synchronous loop is blocked, your mailbox will fill up.<p>If you need concurrency, it&#x27;s done by talking to other actors, which can be processing on another thread under the hood.  But the thread part of it is managed and you are not dealing with threads per se, you just know that if you have multiple cores and you send a message to another actor, it can be scheduled to run on another core safely.<p>If you want to run a bunch of tasks in parallel, you could use a pool of actors up to around the number of cores you have, and the parallelism is at maximum the number of actors in the pool.<p>Sorry if i&#x27;m over explaining, I just wanted to set the stage.<p>One of the benefits of this arrangement is if something is going slowly you can order the list of actors by biggest mailbox and you can see where your bottleneck is.  And if you are using a lot of memory you can just order the actors by the memory usage and you can see where the big state lives.<p>With akka actors, instead of just dealing with the actors and actor pools, they suggest you make actors non-blocking.  The way you do this is with Futures.  Suddenly all the simplification of the actor model goes out the window.  It mixes an async programming style with an actor model that doesn&#x27;t need to be async! So you have the negatives of asynchronous programming and very few benefits of the actor model.  I realise<p>How do you identify the bottlenecks of the system? Maybe your execution context is full - actually I&#x27;d love to know how people debug their execution contexts in general.<p>Last I checked, execution contexts would spawn new threads as well, so not only are they heavyweight (compared to erlang processes) but you have the operating system schedule them instead of the thing that knows how to best schedule them which is your language runtime.')