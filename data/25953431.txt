Item(by='lmeyerov', descendants=None, kids=None, score=None, time=1611890696, title=None, item_type='comment', url=None, parent=25952669, text='It may make more sense when you see analysts writing &amp; sharing a lot of code sessions, especially via notebooks. Functional plotting ends up helping a lot! For big graph-y graphs, we made pygraphistry that way, which enables multi-cell flows like:<p>```<p>df = cudf.read_csv(&#x27;1GB.csv&#x27;).drop_duplicates([&#x27;user_ip&#x27;, &#x27;click&#x27;])<p>g1 = graphistry.edges(df, &#x27;user_ip&#x27;, &#x27;click&#x27;)<p>g1.plot()<p>g2 = g1.encode_point_color(&#x27;risk&#x27;, [&#x27;blue&#x27;,&#x27;yellow&#x27;,&#x27;red])<p>g2.plot()<p>g2.edges(cudf.read_csv(&#x27;file2.csv&#x27;)).plot() # reuse g2&#x27;s color settings<p>g1.edges(cudf.read_csv(&#x27;file2.csv&#x27;)).plot() # ... or just g1&#x27;s graph shape<p>```<p>Being able to &#x27;fork&#x27; plots and interactively swap in different data &#x2F; encodings is super great over the course of a session. You can always go back to an earlier one as you make progress. Likewise, you can rerun notebook cells and read them top-to-bottom without worrying too much.<p>So while we&#x27;re looking at some V2 additions, maybe supporting R, and updating some of the core (more automatic GPU goodness!)... we&#x27;re definitely keeping the compositional style.<p>Interesting nit: Libraries copying the original grammar of graphics can likely benefit from friendlier functional DSL presentation styles. As is, I think they make it much harder to read + write, undercutting much of the productivity potential.  I love the academic concept of making everything a composable value, but doing naked composition over a massive namespace of diverse types.. is super confusing to read + write.<p>Learning from pandas &amp; jquery, we ended up instead steering users to chaining for the typical case: `g.bind(...).edges(...).nodes(...).encode(...).plot()`. It&#x27;s functional so you can always do `g_intermediate = g...` and likewise still do first-class GoG-syntax-style things with them of you really want `f(g._bindings)`. However, those are the minor case, and people doing them make code harder to read + write:<p>-- Reading GoG code is confusing: In `x + f(y)`, often unclear what x, y, and f(y) are, and more so in dynamic languages like Python + R that they&#x27;re used in. In `g.bind(..).encode(...).plot(...)`, each composition is pretty obvious in the typical case, and you can always read back or do first-class in the atypical case.<p>-- GoG plot authoring is jarring: When doing `x + ...`, tab complete doesn&#x27;t get you far. If tab complete does somehow kick in, you are dealing with a big namespace dump. Instead, I see people  turn to google for almost every step! In contrast, table complete on `g.nodes(df)...` will pull up the most likely next settings to add, and then again for the arguments to fill into whatever command you pick.<p>GoG defaults to those for the typical case, vs atypical one, so a 2nd-class imperative API may be easier. But with chaining, we get functional composition without losing straight-line reading and tab-complete. Best of both worlds!')