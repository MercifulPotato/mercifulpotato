Item(by='Jtsummers', descendants=None, kids=None, score=None, time=1610563141, title=None, item_type='comment', url=None, parent=25765367, text='I think GP may have worded that poorly, and &quot;most compilers&quot; in your quoted portion would be better read as &quot;most other languages&quot;.<p>Taken this way, the sentence becomes something like: For computing, transistors are the lowest level of abstraction (they are literally the things doing the computing), Lisp and kin languages are at the extreme end of abstraction, and most other languages fit somewhere in between.<p>Though not entirely true (Lisps let you get pretty low level if you want), it&#x27;s a reasonable perspective if you look not at what the languages permit, but what they encourage. Forth encourages building your own abstractions from the bottom up. Lisp encourages starting with an abstract machine model and building up even higher levels of abstractions (same with most functional and declarative languages). C++ (for something in between) encourages understanding the underlying machine, but not necessarily to the degree that Forth does. Forths and Forth programs are often closely tied to a specific CPU or instruction set. C++ can be seen as abstracted across a particular machine model that&#x27;s typical of many modern CPUs but not with a direct tie to a specific instruction set (doing so constrains many programs more than necessary). And Lisp&#x27;s abstract model is (or can be) even more disconnected from the particular physical machine.<p>I&#x27;d put Haskell, SQL, or Prolog and languages at their level at the extreme end of abstraction before Lisp. Their abstract machines are even further from the hardware (for most users of the languages) than Lisp&#x27;s.')