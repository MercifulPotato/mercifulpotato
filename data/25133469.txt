Item(by='marcan_42', descendants=None, kids=None, score=None, time=1605676825, title=None, item_type='comment', url=None, parent=25107521, text='That is marketing terminology (because &quot;emulation is slow&quot;). Full static transpiling is not a solvable problem - you can&#x27;t actually take an x86 app, run it through some converter, and get an ARM app out. It&#x27;s just not a thing and it never will be (without cheating and, like, literally embedding an emulator in the app).<p>Anything less than that is emulation, and requires dynamic elements. All modern emulators use JIT, and caching the result is similar to AoT translation; plus JIT can be faster than AoT sometimes due to being able to take advantage of runtime profiling, and you can never guarantee ~full AoT translation of even binaries without self-modifying code without additional metadata (like a list of all branch destinations), so Rosetta cannot possibly claim it does that with full coverage. On top of that you need to add a level of indirection to all indirect branches, as you cannot statically change all function pointers in data structures (that&#x27;s an even <i>harder</i> problem). At that point you&#x27;re adding enough bookkeeping gunk to the translated code that it is no longer a straight translation, like Apple would want you to believe. JIT is binary translation too, so by Apple marketing standards, qemu, Dolphin, and basically every other modern emulator is also &quot;translation&quot;. Which is just not useful.<p>So everyone saying that &quot;Rosetta 2 is AoT translation&quot; as if that means it&#x27;s fundamentally better&#x2F;faster than other emulation technologies is just falling to marketing.<p>Whatever you call it, it&#x27;s not fundamentally different from any other emulator in a way that puts it in another class of technology. It is not straight converting x86 to ARM. That&#x27;s just not a thing and it never will be. The end result is that the CPU is going to be executing a series of translated basic blocks interspersed with code added by the translation to glue everything together, which is the same thing every JIT-based emulator does, and will have the same performance characteristics, and the fact that some of that work can be done ahead of time is not a fundamental difference.<p>If you want to look for reasons why Rosetta 2 is faster than other emulators, look for places where Apple cheated and <i>made their CPUs implement x86 things</i> like its memory consistency model. <i>That</i> can have massive gains. I bet if you port a decent JIT-based emulator to use that feature on M1, and compare it to Rosetta 2 for number crunching inner loops and such, you&#x27;ll find you can get very similar performance numbers out of it once the JIT cache is warm.<p>It&#x27;ll be interesting when people take a deep dive into specific things Rosetta 2 does.')