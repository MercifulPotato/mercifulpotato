Item(by='j-pb', descendants=None, kids=None, score=None, time=1609669489, title=None, item_type='comment', url=None, parent=25620774, text='It&#x27;s all about efficient range reads and seek operations.\nYou can compute set operations pretty efficiently using sorted indices that support a &quot;find next or greater&quot; operation.<p>For intersection, take the first value from the first set as the smallest candidate of the output set, then call call candidate := next(candidate) on each set, updating the candidate with the next smallest possible value, and adding it to the output set when a candidate was returned by all sets.<p>The algorithm is worst case optimal up to a log factor, and can even be extended to perform generic constraint programming and multiway joins as a subset of that.<p>Fascinatingly it&#x27;s related to the DPLL algorithm for sat solving.<p><a href="http:&#x2F;&#x2F;erikdemaine.org&#x2F;papers&#x2F;SODA2000&#x2F;" rel="nofollow">http:&#x2F;&#x2F;erikdemaine.org&#x2F;papers&#x2F;SODA2000&#x2F;</a><p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1404.0703" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1404.0703</a><p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1310.3314" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1310.3314</a><p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1203.1952" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1203.1952</a><p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1803.09930" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1803.09930</a>')