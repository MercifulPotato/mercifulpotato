Item(by='patrec', descendants=None, kids=None, score=None, time=1608942668, title=None, item_type='comment', url=None, parent=25533110, text='&gt; No we can&#x27;t, because what do people do in this scenario? They make a new commit that fixes the tests, but leaves a long chain of previous commits broken.<p>Same thing will happen with merges -- one can try to argue (as you have done) that with merges it will be less bad, because you may on average end up with fewer broken commits -- and I don&#x27;t think that is implausible. But that is basically just saying your existing way to bisect is not fully reliable and you fear using rebase would make it quantitatively noticeably worse. What I am saying is it <i>can</i> and <i>should</i> be fully reliable, and this is not theoretical either.<p>I enjoy discussing different workflows with people with a different outlook and experience and who have put a decent amount of thought into it, as you clearly have. But I still have to note that there is a certain irony here: you have something which by your own admission is not completely reliable; i.e. not all your merges in master have passed CI and you will have some (hopefully small) proportion of commits that you&#x27;ll need to manually bisect skip  because they are bad for one reason or other and you won&#x27;t know in advance. You are adamant that rebase-based workflows are bad (partly) because you fear that they will greatly exacerbate such problems and you don&#x27;t seem to think it&#x27;s practically possible to completely avoid them to start with.<p>But I am arguing from plenty of real-life experience with a workflow, which is incidentally rebase-based (but the same guarantees would hold just as well if I moved it to a purely merge based approach) where I a) know that every &quot;merge&quot; to master has been fully tested before it lands b) can reliably bisect over ~years of commits with a simple git alias, without having to ever manually bisect skip bad commits[+]. And by construction, not because I hope that devs will generally have tested their commits sufficiently manually or are diligent about fixing merge conflicts in a way that does not result in intermittent broken commits. So whilst several of your other reasons are perfectly valid (long-lived branches), you can maybe see why this one is a bit amusing to me.<p>&gt; (Also in a big enough codebase with enough collaborators it becomes impractical to require CI to pass against the absolute tip of your shared development branch before merging, because in the time it takes to run CI there will always have been more changes landing in that shared branch).<p>It&#x27;s not impractical at all, in fact if your company pays me for it I&#x27;m more than happy to set it up for you :)<p>Alternatively shoot me an email and I&#x27;ll be happy to explain the gist of it (including how to completely avoid the problem you mention above).<p>[+] Of course assuming nothing was broken at the meta level, e.g. no one accidentally temporarily misconfigured CI, so some stuff that should have been didn&#x27;t get tested.')