Item(by='Silhouette', descendants=None, kids=[24847710, 24847383], score=None, time=1603270518, title=None, item_type='comment', url=None, parent=24845893, text='<i>The fact that a developer can &quot;corrupt&quot; the database with non-atomic stuff is an hint to me that the database probably doesn&#x27;t have the right referential integrity constraints in place and probably is not normalized either. The relational model is built out of the box to keep a consistent state of the data and this is one of its main value propositions.</i><p>This is true when interpreted the right way, but I don&#x27;t think real world problems are always so tidy.<p>Let&#x27;s consider Standard Toy Example #17: The Bank Account Transfer. In a simplistic model, we might have a table of bank accounts in our database, and a second table of deposits. Constraints will guarantee that we can&#x27;t do things like creating a deposit for an account that doesn&#x27;t exist, but they won&#x27;t ensure that if we create a deposit of X in one account, we must also create a corresponding deposit of -X for some other account so we aren&#x27;t inventing or destroying money.<p>Of course, in a more realistic implementation, you&#x27;d never represent transfers between accounts as two separate stages like that, and if there is any single place to look up deposits into specific accounts it&#x27;s probably some sort of view or cache rather than the authoritative data. But rather like going from single-entry to double-entry bookkeeping, to avoid relying on something higher up our system to ensure consistency, we&#x27;ve had to restructure our whole data model and the schema implementing it. In a sense, this is still just normalising the data, but that&#x27;s a bit like saying implementing a word processor is, in a sense, just refactoring and extending a text editor.')