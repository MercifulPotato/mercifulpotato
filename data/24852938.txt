Item(by='arc776', descendants=None, kids=None, score=None, time=1603319254, title=None, item_type='comment', url=None, parent=24851797, text='Thanks for the links. Very interesting to read how you get around these tricky dynamic operations!<p>&gt; get threads that want to monkey patch to stop other threads and tell them to start checking for redefined methods<p>As an aside, this sort of reminds me of branch prediction at a higher level. A very neat way to speed up for the general case of no patching.<p>&gt; This is a great example because people said &#x27;surely... surely... there will always be some overhead to check for monkey patching - no possible way to solve this can&#x27;t be done&#x27; until people found the result already in the literature that solves it.<p>There is still overhead when patching is used though. If you don&#x27;t use the feature, you don&#x27;t pay the cost, however when monkey patching <i>is</i> used there is a very definite cost to rewriting the JIT code and thread synchronisation that compiled languages would simply not have.<p>I can see where you&#x27;re coming from here. If we can reduce all dynamic costs that aren&#x27;t used to nothing then we will have the same performance as, say, C. At least, in theory.<p>It would be certainly be interesting to see a dynamic language that can deoptimise all its functionality to a static version to match a statically compiled language. Still, any dynamic features would nevertheless incur an increased cost over static languages.<p>It&#x27;s the dynamism itself of Python that incurs the performance ceiling over static compilation, plus the issues I mentioned in my previous reply about boxing and cache pressures. However you&#x27;ve definitely given me some food for thought over how close the gap could potentially be.')