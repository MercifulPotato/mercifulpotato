Item(by='tom_mellior', descendants=None, kids=[25664330], score=None, time=1609952658, title=None, item_type='comment', url=None, parent=25657166, text='&gt; I cannot easily think of an example where changing the order of clauses (not &quot;goals&quot;) in a predicate definition prevents the program from &quot;runnign backwards&quot;.<p>It&#x27;s bad enough to use &quot;directions&quot; for what are properly called &quot;modes&quot;, but it&#x27;s positively counterproductive to say that anything in Prolog runs &quot;backwards&quot;. Prolog always runs top-to-bottom, left-to-right, and this is precisely why it&#x27;s easy to write nonterminating definitions. As a community, we are doing ourselves a disservice by claiming that anything can magically run &quot;backwards&quot;.<p>As for your question, the canonical example for clause ordering being a problem is where the incorrect order prevents generation of answers because a recursive clause precedes a non-recursive one.<p>Example:<p><pre><code>    xs([x | Xs]) :- xs(Xs).\n    xs([]).\n</code></pre>\nThis recognizes lists of xs:<p><pre><code>    ?- xs([x, x, x]).\n    true.\n</code></pre>\nBut it cannot generate them:<p><pre><code>    ?- xs(Xs).\n    ERROR: Out of local stack\n</code></pre>\nContrast with:<p><pre><code>    ys([]).\n    ys([y | Ys]) :- ys(Ys).\n\n    ?- ys(Ys).\n    Ys = [] ;\n    Ys = [y] ;\n    Ys = [y, y] ;\n    Ys = [y, y, y] .</code></pre>')