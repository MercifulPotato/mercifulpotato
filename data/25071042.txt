Item(by='mgechev', descendants=None, kids=[25071655], score=None, time=1605195928, title=None, item_type='comment', url=None, parent=25070528, text='Of course! I love chatting about incremental computations and approaches in different frameworks :)<p>You&#x27;re getting warnings at devmode (i.e. during ng serve) that you&#x27;ve modified a binding after it was checked. This is not related to the way we trigger change detection. The simplest example is:<p><pre><code>  @Component({\n    template: &#x27;{{ foo }}&#x27;\n  })\n  class AppComponent {\n    _foo = 0;\n    get foo() {\n      return this._foo++;\n    }\n  }\n</code></pre>\nThis is clearly unstable because every time we get the value of foo, we also increment _foo. What Angular does in devmode is to ensure developers are not hitting this issue.<p>This is not related to setTimeout and the APIs we patch with zone.js. The check just safeguards us to not get into such cyclic binding scenarios. We&#x27;ll be working on better explaining the error and the message in future releases.<p>DOMElement is untouched, we only patch APIs so that we can plug into the microtask queue and trigger change detection when it&#x27;s empty to ensure consistency between the model and the view.<p>In fact, one of the projects high on our priority list is to make Zone.js optional and provide alternative, ergonomic APIs to trigger the change detection and specify local component state. I am saying ergonomic APIs because this is already possible, just not ideal since we have to specify a noop zone when bootstrapping the app. Optional, because many developers love the current behavior and we want to keep it available.<p>And just, let me spent one more paragraph in explaining how the change detection works. Just want to show why is it that fast and with such a low memory overhead.<p>Each component has a template that we translate to JavaScript instructions. For example:<p><pre><code>  &lt;span&gt;{{ foo }}&lt;&#x2F;span&gt;\n</code></pre>\nWe will translate to something like (I&#x27;m writing the comment from my phone, some instruction names could be different in the CLI output):<p><pre><code>  if (mode &amp; creation) {\n    renderElement(&#x27;span&#x27;);\n    interpolation(ctx.foo);\n  } else if (mode &amp; update) {\n    interpolation(ctx.foo);\n  }\n</code></pre>\nThat&#x27;s a leaf component, but we can imagine how it works in more complicated hierarchies.<p>So when we trigger change detection we just invoke the template functions for the components in update mode. We update only the bindings that have changed, without allocating any additional data structures to do that.<p>Whether the framework is written to fit the language is mostly a subjective opinion.<p>Angular doesn&#x27;t go against the standard anywhere and does not introduce extra syntax on top of TypeScript. It also doesn&#x27;t add new semantic to already existing constructs.<p>In fact, to keep compliant is from a high priority to us. We constantly interact with different standardization bodies and keep up to date with standards.')