Item(by='ninkendo', descendants=None, kids=None, score=None, time=1611593437, title=None, item_type='comment', url=None, parent=25905166, text='Imagine trying to assign a unique number to every bit of data your program uses, including stuff like text, pictures, etc.  Such that some text that uses 100 bytes uses 100 numbers, a picture with 1,000,000 byte uses 1,000,000 numbers, etc.<p>You can just say &quot;Start at number 0 and create a new number for each bit of data&quot;, but then maybe that JPEG your program uses occupies the same set of numbers as the text you&#x27;re writing to.  So you need to make sure it&#x27;s all <i>unique</i>, and that each logical thing you&#x27;re storing gets its own unique set of numbers.  Easy enough, except data changes as your program runs, so every now and then you need to say &quot;ok there&#x27;s not enough space to store this thing, so I&#x27;m going to assign it a new number so that it doesn&#x27;t conflict with this other data I have.&quot;<p>That works well enough, except what if parts of your software do stuff like &quot;write value X to number 103820&quot;? Will that do what you want? Maybe that code is responsible for updating some text somewhere, but what if that text grew too big and moved somewhere else?  How do you know if the number it&#x27;s writing to is actually the right text?<p>What&#x27;s way worse, is that some of these numbers are used by the processor for bookkeeping on things like &quot;what was the last bit of code I was executing before I ran this code?&quot; and if you overwrite <i>those</i> numbers, you can cause the processor to do evil things.<p>That&#x27;s memory safety.  It&#x27;s the idea that, if you just let code write to arbitrary locations in memory, it&#x27;s very very difficult to do this safely.  The answer ends up being to have languages that simply <i>don&#x27;t let you do that</i>, and that&#x27;s a big step towards having safe code.  &quot;Safe&quot; languages instead only let you do things like &quot;append to this data&quot;, which will automatically move the data to another address if it&#x27;s too big.  But they won&#x27;t let you just write to arbitrary addresses.  Even &quot;Safer&quot; languages ensure that one thread can&#x27;t be in the middle of moving some data to a new address while another thread is trying to write to it, etc etc.<p>So to your question, it&#x27;s very much like painting in that regard.  If you start on one corner of the canvas and draw something way too big and don&#x27;t leave yourself enough room, you&#x27;ll paint over parts of the painting you wanted to keep.  Since programs are super dynamic, the problem of making everything has enough space to be represented in a real computer, ends up being kinda hard, and the way older languages are designed can sometimes make it nearly impossible.')