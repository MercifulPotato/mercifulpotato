Item(by='tannhaeuser', descendants=None, kids=[25505785], score=None, time=1608629948, title=None, item_type='comment', url=None, parent=25503800, text='It would appear to make sense to separate two things<p>- a service as isolated business logic with clean requirements process, ownership, SLAs, interfaces, testing, and build infra for maintenance<p>- a service as an endpoint you can access from most any environment (other services in whatever language, web apps)<p>The trick is to keep these two things apart and assign services to physical&#x2F;virtual nodes&#x2F;pods&#x2F;whatever as late as possible rather than making deployment decisions through choosing implementation techniques. Eg it&#x27;s not reasonable to expect scalability by deploying individual services to a large number of nodes with excessive granularity of services; having the option to deploy a called service on the same host as the calling service to have essentially no network overhead might make more sense. It&#x27;s also not reasonable to attempt to scale out services to a large number of nodes when your bottleneck is an RDBMS or other storage.<p>This was already very clear with 2nd gen SOA architectures like SCA (service component architecture) around 2007 or so, with options for binding implementations to remote protocols (SOAP) or locally via procedure calls, or both at the same time. This separation is notably absent from microservice architectures which always want to produce a pod or vm image as result artifact.<p>Now SOAP (and SCA and other SOA frameworks) also allowed transactions and auth context propagation; something that isn&#x27;t even on the radar of microservice-like approaches. The (many) ones I saw at customers at least only naively implemented the happy path, not allowing for two-phase commit or at least compensation services to be called on abort by an aggregating service.')