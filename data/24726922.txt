Item(by='rayiner', descendants=None, kids=[24727288, 24727004], score=None, time=1602218927, title=None, item_type='comment', url=None, parent=24726223, text='I really struggle to see what was &quot;brilliant&quot; about Judge Alsup&#x27;s opinion. After 30 pages of very careful analysis of the case law, his actual holding (at p. 35) simply begs the question. He states:<p>&gt; Much of Oracle’s evidence at trial went to show that the design of methods in an API was a creative endeavor. Of course, that is true. Inventing a new method to deliver a new output can be creative, even inventive, including the choices of inputs needed and outputs returned. The same is true for classes. But such inventions — at the concept and functionality level — are protectable only under the Patent Act.<p>This mixes up the functional aspects of designing methods with the stylistic aspects of API design. Consider something like a 3D Graphics API. Some decisions are functional--for example, minimize call overhead or maximizing batching opportunities. That should not be copyrightable. But a lot of other decisions are stylistic. They make the API more elegant, or orthogonal, or intuitive, but are not functional in and of themselves. For example, how to structure groups of functions for dealing with various kinds of buffers. Insofar as those stylistic decisions are expressed in literal code, that&#x27;s the domain of copyright.<p>&gt; The method specification is the idea. The method implementation is the expression. No one may monopolize the idea.<p>This is <i>ipse dixit.</i> How you view the &quot;idea&quot; depends on your generality. Direct3D and OpenGL have different ways of expressing the concept of creating a Z-Buffer. &quot;Creating a Z-Buffer&quot; is the &quot;idea.&quot; There are myriad method specifications that can express that idea.<p>&gt; To carry out any given function, the method specification as set forth in the declaration must be identical under the Java rules (save only for the choices of argument names). Any other declaration would carry out some other function.<p>This is glossing over a major logical leap. It assumes you already have a method with a given signature, and writing the declaration is a mechanical process of specifying what signature corresponds to the method implementation. But what if you design the API by writing the declarations first, and filling in the methods afterwards? (Which is very often how its done!) You can write a method to do a particular thing but give it many different specific signatures.')