Item(by='dragontamer', descendants=None, kids=[25260855, 25260617, 25260795, 25260961], score=None, time=1606780322, title=None, item_type='comment', url=None, parent=25244301, text='Raytracing is surprisingly simple if you already know trigonometry.<p>If you don&#x27;t know Trig... you&#x27;ll have to brush up on your math. But fundamentally, you project rays, you calculate if those rays hit an object (and if so, which object is &quot;in front&quot;, and therefore hit first). And finally, you apply BSDF functions (math formulas created by artists that specify how light bounces off of objects) to calculate where the light bounced to.<p>That&#x27;s it. The BSDF is an abstraction: there are many different models: one for metal, one for &quot;specular&quot; (&quot;shiny&quot; objects, like a marble), one for &quot;diffuse&quot; (&quot;soft&quot; objects like an egg), etc. etc. And an &quot;uber BSDF&quot; that kind of provides sliders for many different objects. (Invented by Disney: Roughness, Metalicness, Specularness, Diffuseness). But the BSDF itself is just an abstraction: where did the light bounce to? And different objects have different properties.<p>------<p>From there: making a <i></i>FAST<i></i> raytracer is the hard part. What kind of data-structures are needed to calculate intersections more quickly? Understanding the hardware (SIMD-cores, maybe even GPUs) to calculate BSDFs in parallel. Etc. etc. Lots of little things to learn and ultimately complicating the thing.<p>A professional raytracer would also have special code for the different kinds of objects in the scene.<p>True random path tracing takes too long. Biased techniques and quasi-random paths can make smoother images with less effort. Unbiased techniques shy away from such &quot;theoretically suboptimal&quot; optimizations. Denoising. Multithreaded, multi-computer, multi-GPU support. The feature sets goes on-and-on-and-on.<p>But if you want to just make &quot;a&quot; raytracer, without any care in the world about how fast (or slow) it is, then you easily can do that in one weekend. So give it a shot if you like.<p>-----------<p><a href="https:&#x2F;&#x2F;www.kevinbeason.com&#x2F;smallpt&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.kevinbeason.com&#x2F;smallpt&#x2F;</a><p>They brute-force an all-to-all check against all objects. There&#x27;s no oct-tree partitioning or BVH trees. The only shape supported are spheres of varying sizes (no squares, no triangles, no cubes. Just spheres). There are only three BSDF functions implemented (specular &quot;hard and shiny&quot;, diffuse &quot;soft and matte&quot;, and glass). This tiny program is inefficient as all heck, but hey... 99 lines of code is pretty spiffy. That&#x27;s all you really need for a raytracer.')