Item(by='otoolep', descendants=None, kids=[25878445, 25877240], score=None, time=1611351385, title=None, item_type='comment', url=None, parent=25876485, text='Hmmmm, that&#x27;s a different issue. :-)<p>Today the rqlite code deletes the SQLite database (if present) and then rebuilds it from the Raft log. It makes things so simple, and ensures the node can always recover, regardless of the prior state of the SQLite database -- basically the Raft log is the only thing that matters and that is <i>guaranteed</i> to be the same under each node.<p>The fundamental issue here is that Raft can only guarantee that the Raft log is in consensus, so rqlite can rely on that. It&#x27;s always possible the one of the copies of SQLite under a single node gets a different state that all other nodes. This is because the change to the Raft log, and corresponding change to SQLite, are not atomic. Blowing away the SQLite database means a restart would fix this.<p>If this is important -- and what you ask sounds reasonable for the read-only case that rqlite can support -- I guess the code could rebuild the SQLite database in a temporary place, wait until that&#x27;s done, and then quickly swap any existing SQLite file with the rebuilt copy. That would minimize the time the file is not present. But the file has to go away at some point.<p>Alternatively rqlite could open any existing SQLite file and DROP all data first. At least that way the <i>file</i> wouldn&#x27;t disappear, but the data in the database would wink out of existence and then come back. WDYT?')