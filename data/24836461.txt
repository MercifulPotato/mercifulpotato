Item(by='martinhath', descendants=None, kids=[24836689, 24837811, 24843250, 24838050], score=None, time=1603196564, title=None, item_type='comment', url=None, parent=24835357, text='This is a really great writeup! I was using Rust as my main programming language from some months before 1.0\nup until maybe early 2019. I have only written somewhere in between 100 and 1k lines of Zig, but \ngenerally feel that I agree with most of what&#x27;s being brought up here.<p>Here&#x27;s a mind dump:<p>&gt; Zig manages to provide many of the same features with a single mechanism - compile-time execution of regular zig code. This comes will all kinds of pros and cons, but one large and important pro is that I already know how to write regular code so it&#x27;s easy for me to just write down the thing that I want to happen.<p>This is a huge one for me, and I really don&#x27;t understand why Rust didn&#x27;t jump on this earlier.\nUsing the programming language for configs, generics, macros, and anything else that you&#x27;d want\nat compile time just seems like such a huge win, instead of having weird preprocessors-like systems,\nsome config file format with arbitrary limitations, and weird marcro-like systems that either\nhave crazy syntax (like `macro_rules!` in Rust), or that are way too limiting (like `const` functions in Rust).<p>Jon Blows language seem to take a similar stance as Zig; let&#x27;s see if it ever hits public beta.<p>&gt; On the other hand, we can&#x27;t type-check zig libraries which contain generics. We can only type-check specific uses of those libraries.<p>This is definitely a concern I have about this &quot;C++-like generics&quot;.\nMy experience with C++ suggests that this is bad, but on the other hand, improving even just error messages\nwould be such a day-night improvement, that I don&#x27;t really trust my judgement on this one.<p>&gt; Both languages will insert implicit casts between primitive types whenever it is safe to do so, and require explicit casts otherwise.<p>Is this really true? I seem to recall having to have plenty of `as usize` in my code when\nusing smaller integer types for indices, but maybe this has changed (or maybe I&#x27;m misreading what&#x27;s being said here).<p>&gt; In rust the Send&#x2F;Sync traits flag types which are safe to move&#x2F;share across threads. In the absence of unsafe code it should be impossible to cause data races.<p>This is probably Rust&#x27;s main selling point, because as far as I can tell, no other mainstream language comes even\nclose to getting static thread safe guarantees (up to your definition of mainstream).\nAs time goes on, however, I&#x27;m getting less and less excited about this, because most of my programs\nare not multithreaded, and the very few times that I need multiple threads, there is often\nvery obvious and small boundaries in between the threads.\nIt&#x27;s just not very interesting to me that I _could_ be writing programs with thousands of threads\nall jumping around without having to worry about data races, because I don&#x27;t really worry about it\nin the first place. But still, I as a Rust programmer, have to pay the price for this option being available.<p>&gt; Undefined behavior in rust is defined here. It&#x27;s worth noting that breaking the aliasing rules in unsafe rust can cause undefined behavior but these rules are not yet well-defined.<p>I&#x27;m not sure what to say about this, except that it&#x27;s surprising that there seem to be a\nlack of voices about this in the Rust community.\nHow can anyone comfortably write `unsafe` code without knowing what the rules are?\nEspecially when the compiler is so &quot;good&quot; at depending on the &quot;rules&quot;?\nI don&#x27;t understand.\nI have pretty limited experience with unsafe, but I have written some, and\nwas often confused about which bugs were my logic bugs and which were the compiler assuming \nI didn&#x27;t break some rule I didn&#x27;t know about.\nCombine this with a poor debugging story overall, and you have a pretty miserable experience programming.<p>Maybe this isn&#x27;t a problem in practice, or maybe all people succesfully writing `unsafe` code for libraries\nare also `rustc` veterans?<p>&gt; @import takes a path to a file and turns the whole file into a struct. So modules are just structs.<p>This is a very nice approach! I remember from earlier Rust that the module system was a real pain point\nfor beginners, and can also remember really struggeling with it.\nCuriously though, I also remember looking back, not understanding why anything was confusing about it.\nThis was also redone(?) at some point, and I think it&#x27;s nicer now.<p>&gt; In rust my code is littered with use Expr::* and I&#x27;m careful to avoid name collisions between different enums that I might want to import in the same functions. In zig I just use anonymous literals everywhere and don&#x27;t worry about it.<p>I&#x27;ve always been bothered by Rust&#x27;s inability to infer the `enum` type in a `match`;\nin other places Rust has no problems being automagick, and this is really very annoying to go around,\neither with `use Foo::*` before each match, or having it in file scope and hope for no collisions.\nZig seems to take exactly the approach I&#x27;d go for.<p>&gt; Re allocators<p>I think Zig&#x27;s stand on explicit allocators is very good; I&#x27;ve seen enough bad code in other languages\nthat allocates here and there for things that, very clearly, doesn&#x27;t need to be there.\nHaving the language be explicit about allocations makes it easier to stop and say &quot;hey wait a minute, is \nthis realy the way I&#x27;m supposed to do it?&quot;, but without having to jump through hoops \nif you _just_ want to allocate something somewhere (define a global allocator yourself).\nAnd, as a bonus, it&#x27;s easier to handle the allocations of other peoples code.<p>&gt; Zig has no syntax for closures.<p>I definitely need to write more Zig to find out whether this is a problem or not.\nI&#x27;ve written a lot of C++ lately, and while there _are_ closures available, I think I&#x27;ve only used them once. \nMaybe the reason for my comparatively heavy closure usage in Rust was that so many methods in the standard libray\ntook closures that you&#x27;re shephearded into making similar methods for your own types.<p>&gt; Zig&#x27;s error handling model is similar to rust&#x27;s, but it&#x27;s errors are an open union type rather than a regular union type like rust&#x27;s.<p>I really think the error story is why I prefer Zig to Rust now.\nThe giant error `enum` in Rust is definitely what I&#x27;d go with because it&#x27;s simply not feasible to\nmanually track which functions return what errors and making individual enums yourself,\neven though this is super easy for the compiler to do, like Zig shows.<p>Not to pick on anyone in particular, but sometimes it feels like many programmers think\nthat a program only consist of the happy path and that errors are somehow rare and not\nworth dealing with properly. Both Rust and Zig are huge helps to combat this mindset, but I do think\nthat Zig comes out ahead, simply by being less annoying to work with.\nAlso, while some people might say that `Result` just being a part of `core` and not a magic special language thing\nis cool, I do appreciate Zig&#x27;s usage of `?` since it&#x27;s way less typing for something that happens _all_ the time.<p>&gt; Zig&#x27;s compilation is lazy. Only code which is actually reachable needs to typecheck. So if you run zig test --test-filter the_one_test_i_care_about_right_now then only the code used for that test needs to typecheck.<p>I didn&#x27;t know this, but this is awesome!<p>&gt; Zig has absurdly good support for cross-compiling.<p>I&#x27;ve never understood why cross-compiling isn&#x27;t an out-of-the-box feature in all languages.\nDon&#x27;t you basically just have to target a different instruction set?\nWell, and a different executable format.\nBut still, compared to all of the other crazy things compilers are doing, \nthis seems very straight forward in comparison.<p>&gt; Zig has an experimental build system where the build graph is assembled by zig code.<p>See above. I really really really don&#x27;t understand why all languages doesn&#x27;t do this already.<p>&gt; In rust, blocks are expressions.<p>This is something I really like about Rust and a pattern I&#x27;ve used a lot, where I&#x27;d say<p><pre><code>    let some_thing = {\n        let foo = ...\n        let bar = foo.baz() + quiz();\n        ...\n        foo\n    };\n\n</code></pre>\nto avoid accidently using `bar` somewhere else. Granted, since Rust allows shadowing this isn&#x27;t really \na problem most of the time, but it&#x27;s definitely something I miss when writing C++.\nZigs version is somewhat verbose, but I&#x27;ll manage.<p>&gt; There is an in-progress incremental debug compiler for zig that aims for sub-second compile times for large projects. Based on progress so far, this is a plausible goal.<p>Andrew&#x27;s work on binary patching executables is really cool.\nI hope we&#x27;ll get to compile times this low, even for moderately sized projects.<p>&gt; real 23m27.475s<p>This is just sad. Despite all the work the contributors to `rustc` are doing, it just seems that\nthey are in a completely different league with respect to compile times than what I&#x27;d like.\nI hope the steady progess they&#x27;re making will either make some jumps, or continue for a while :)<p>&gt; Main points so far:<p>This is a great summary, and I think people reading it (or the whole post) will have a pretty good idea of\nwhere they stand re. the two languages.')