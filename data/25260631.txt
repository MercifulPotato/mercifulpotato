Item(by='barrkel', descendants=None, kids=[25260774], score=None, time=1606780754, title=None, item_type='comment', url=None, parent=25254515, text='Spurious exception specifications are the flip side of avoiding not telling the caller something might go wrong. It&#x27;s a fundamental tension and is unavoidable.<p>Failure modes are an abstraction violation; they&#x27;re a function of implementation. That&#x27;s what makes checked exceptions not work, at the end of the day. Information-carrying exceptions reveal implementation details. So a module author must decide between hiding details and wrapping everything up in module-specific exceptions that user code can&#x27;t actually use to make decisions most of the time, or expose implementation details that turn into a versioning problem over time.<p>There&#x27;s roughly two situations for error handling: near the leaf of the call tree, where you have enough context to deal with an error, and need to switch on error type and take compensating action; or near the root of the call tree, in the main loop, where you log errors and terminate requests etc. in a generic way (e.g. 500 response).<p>Exceptions aren&#x27;t ideal for the first situation but are great for the second. Error codes are adequate for the first situation - monadic error types (Result&lt;T&gt;, Either) are a bit better - but suck horribly for the second, because you need to manually unwind, writing boilerplate that should be automatic.<p>And at the limit, error types are isomorphic to checked exceptions, with the same problems, and more - error types introduce an aggregation problem, where multiple errors need to be joined together. You can still get that with exceptions too but it usually requires parallelism.')