Item(by='jacquesm', descendants=None, kids=[25526143, 25534737, 25526644, 25525820, 25529667, 25528846], score=None, time=1608792999, title=None, item_type='comment', url=None, parent=25516430, text='Before you start writing a whole chess engine I&#x27;d suggest you code up a couple of end-game combinations that are known wins so that you get a good idea of what works and what doesn&#x27;t for data structures and such. Once you can win king, knight, bishop against king reliably you&#x27;re ready for tougher stuff.<p>Some notes from past efforts:<p>- A simpler but much faster engine will beat a more complex engine any time because the advantage of another ply easily outweighs the advantage of some clever algo.<p>- A 10x10 board with an unreachable edge has some advantages when laid out as a linear array because it allows for much easier memory management (premature optimizations and all that...). On an 8x8 board laid out linearly the edges have no way of limiting piece movement but on a 10x10 you get that for free by putting an &#x27;impossible&#x27; value in the unreachable edge fields. Even a knight won&#x27;t be able to jump that effectively two field wide edge. This turns all legal moves for all pieces into a simple offset rather than a two dimensional affair.<p>- Optimization of engine code is much harder than optimization of the yield function.<p>- It is much better to not generate &#x27;bad&#x27; moves than it is to prune them away after a lot of extra work has been done. Colin Wrights&#x27; law: &#x27;You can&#x27;t make computers faster, you can only make them do less work&#x27; clearly applies here.<p>- memoization can bring <i>insane</i> speed gains.<p>Good luck!')