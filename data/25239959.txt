Item(by='klodolph', descendants=None, kids=None, score=None, time=1606592999, title=None, item_type='comment', url=None, parent=25239827, text='Make has a laundry list of problems:<p>- Cannot handle multiple outputs for a single rule<p>- Does not rebuild when flags change<p>- Make rules may contain implicit dependencies<p>- Slow for large codebases<p>- Does not understand how to build for multiple platforms, sucks for cross-compiling<p>- Recursive make sucks (job control does not work across recursive invocation boundaries)<p>- You must create output directories yourself<p>- You must create your own rule to clean<p>This adds up to a fragile &amp; slow build system, where you have to do a full rebuild to have a reasonable level of assurance that your build is correct—incremental builds aren’t safe.<p>There have been a few attempts to make a “better make” over the years like Jam, SCons, Ninja, Tup, etc. each with their own pros and cons.<p>The new generation of build tools—Bazel, Buck, Pants, and Please are all an attempt to <i>redesign</i> build systems so that the design is resistant to the flaws that plague Make build systems. You can use a shared cache (shared between different users) fairly easily, and you have reasonable assurance than incremental builds are identical to full builds (so your CI pipeline can move a lot faster, developers almost never have to &quot;make clean&quot; when they change things, etc).<p><i>Personally</i> I’m working on a project right now that uses Bazel (which is similar to Please) and is for an embedded system. It’s been a great experience, and I can pass a flag to Bazel to tell it to build for the embedded target using the cross compiler or for the native host--that makes it easy to share code between tools and the target system, and I can do things like write tests that run on both the target &amp; host. Anyone who does any cross-compiling is missing out if they are using Make—but, do note that setting up a cross-compiling toolchain in Bazel isn’t exactly a cakewalk.')