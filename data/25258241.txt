Item(by='skybrian', descendants=None, kids=None, score=None, time=1606766640, title=None, item_type='comment', url=None, parent=25256443, text='It&#x27;s essentially cultural. A fundamental assumption of the Go language, implementation, libraries, and community is that goroutines share memory. You don&#x27;t write concurrent Go code assuming that a Goroutine could arbitrarily disappear, so breaking this assumption will break things.<p>Lunatic is not like that:<p>&gt; Each Lunatic process gets their own heap, stack and syscalls.<p>Similarly, Rust code that uses threads and&#x2F;or async isn&#x27;t going to work in Lunatic (or at least won&#x27;t get the advantages of its concurrency model) without being rewritten using Lunatic&#x27;s concurrency primitives. The concurrency model is more like JavaScript workers or Dart isolates, though hopefully lighter weight.<p>I&#x27;m guessing that the Rust <i>language</i> might work well because move semantics assumes that values that aren&#x27;t pinned can be moved, and that&#x27;s a better fit for transmitting messages between processes. But there will probably be a lot of crates that you can&#x27;t use with Lunatic. If it became popular, it would be forking the community at a pretty low level. You&#x27;d have some crates that only work with Lunatic and others that use async or threads.')