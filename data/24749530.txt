Item(by='jcranmer', descendants=None, kids=None, score=None, time=1602454259, title=None, item_type='comment', url=None, parent=24748835, text='Not knowing the context of the quote, I can guess a few causes:<p>* Compiler optimizations mostly work on a per-function basis, so that the &#x27;n&#x27; in O(n) or O(nÂ²) is the size of a function and not the size of the entire codebase. Not all optimization algorithms are linear, and while good superlinear optimizations should have code threshold cutoffs, in practice these may be omitted. Function sizes follow something like a power law distribution, which means larger code bases contain larger functions that are more expensive to optimize.<p>* For C&#x2F;C++, you compile code by pasting all the header definitions into your translation unit, and feeding that to the actual lexer&#x2F;parser&#x2F;codegen. Larger projects are probably going to have correspondingly larger headers, and files will probably include more of them, so that the actual translation unit sizes are going to be larger even than the on-disk source files would indicate.<p>* This is more speculative, but larger projects are also probably likelier to blow out the various caches on your computer, so that the operations you figure are O(1) (such as hashtable lookup!) are actually more like O(lg N) in practice. And as you get larger projects that are less likely to fit any cache, the effect of the non-constant time becomes more apparent.')