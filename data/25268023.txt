Item(by='Fellshard', descendants=None, kids=None, score=None, time=1606846879, title=None, item_type='comment', url=None, parent=25266959, text='I think I see what you&#x27;re getting at, but let me point out why I still think it does something more than what Java exceptions allow:<p><pre><code>  let x = doRiskyThing();\n  match x {               &#x2F;&#x2F; Pattern match on x\n    Ok(y) =&gt; y.doThing(), &#x2F;&#x2F; Giving the result a different name clarifies what&#x27;s happening\n    Err(e) =&gt; ...\n  }\n  x.unwrap().doThing();   &#x2F;&#x2F; You can assume it&#x27;s Ok, but you explicitly risk the application panicking\n</code></pre>\nOf note, Result::unwrap is approximately the following:<p><pre><code>  match x {\n    Ok(y) =&gt; y\n    Err(_) =&gt; panic!()\n  }\n</code></pre>\nx is still a valid value for the duration, and is never uninitialized; and whether you handle each case in a match or unwrap, both success and failure are considered and responded to before moving on. The Java checked exception code does that as well, except that it is unclear whether `doRiskyThing()` is throwing the exception, or `x.doThing()`; it&#x27;s hard to reason about where the error originates from, and how much work was partially completed. In Java, the best way to circumvent this is - if possible - to keep try-clauses as tight as possible.')