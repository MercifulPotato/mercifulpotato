Item(by='Veedrac', descendants=None, kids=[24683972], score=None, time=1601862421, title=None, item_type='comment', url=None, parent=24682483, text='Here&#x27;s a simpler, but more technical, attempt at an explanation.<p>---<p><pre><code>    while (true) {\n</code></pre>\nTreat your initial 64 bit random value as a fixed point fraction in the range from 0 to just under 1.<p><pre><code>        u64 fract = random64();\n</code></pre>\nConvert it to a 128 bit type, still treating it as a fraction, and multiply it by another 64-bit nonzero integer, S. The result is a value between 0 and S (excluding S), with the fractional part in the lower 64 bits and the integer part in the upper 64 bits.<p><pre><code>        u128 upto_s = (u128)fract * (u128)s;\n        u64  fract_part = (u64)upto_s;\n        u64  int_part   = (u64)(upto_s &gt;&gt; 64);\n</code></pre>\nBecause we multiplied by S, the possible resulting fraction bits increase by S between each sequential random value. This affects the number of possible fractions for each integer part. For example, with S=3, you could pack like<p><pre><code>    . X . . X . . X . . X . . X . .\n</code></pre>\nor<p><pre><code>    X . . X . . X . . X . . X . . X\n</code></pre>\nThis is NOT the case if the number of possible fractions (here 2⁶⁴) is a multiple of S. We can therefore reject some of our possible fractions to make it a multiple of S. This can be done by rejecting the first 2⁶⁴ % s fractional values, and thus only accepting fractional values at least 2⁶⁴ % s.<p><pre><code>        # Faster early test to avoid modulo\n        # s &gt; (2⁶⁴) % s\n        if (fract_part &gt;= s) {\n            return int_part;\n        }\n\n        # 2⁶⁴ % s == (2⁶⁴ - s) % s == (-s) % s\n        u64 min_fract = (-s) % s;\n        if (fract_part &gt;= min_fract) {\n            return int_part;\n        }\n    }</code></pre>')