Item(by='cmroanirgo', descendants=None, kids=[25339077, 25337954], score=None, time=1607373248, title=None, item_type='comment', url=None, parent=25333319, text='NULL being passed in is not the only problem. Dangling pointers, coding mistakes by other team members and race conditions during initialisation can all contribute to this blowing up. Some argue (correctly) that it&#x27;s best to have it blow up, other that assertions are the way to go. I&#x27;m of the latter ideology. Make your debug build do assertions, but release code be crash proof by doing NULL checks.<p>There are several comments indicating the performance cost of a NULL check. Go and look at the disassembler and see the code. You should find that it equates to JZ, which at worst case costs 1 clock cycle. Am I incorrect?<p>So, another comment below mentioned 10 million deletions per second. Ignoring the fact that you should be using a double linked list at that point (like the kernel does), in a single threaded 2.4GHz CPU a 1 step opcode (JZ) equates to a bit over 4ms&#x2F;sec. With branch prediction, I expect to be far less.<p>So, the NULL check is almost free. Even on embedded systems, it&#x27;d still be a good idea to keep it in, to insulate yourself from flipped bits (eg, solar flares, or degrading memory) and coding mistakes elsewhere.<p>In these days of security research, I strongly advise for defensive code: it means that each function has had it&#x27;s edge cases thought about, which means the developer has spent time thinking about the stability of their program, which cannot be a bad thing. Don&#x27;t make your code a deliberate point of exploitation.')