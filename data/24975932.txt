Item(by='yawaramin', descendants=None, kids=[24977151], score=None, time=1604372785, title=None, item_type='comment', url=None, parent=24975475, text='If you mean ML (i.e. OCaml) functors, then to put it simply: they are the primary code abstraction mechanism in ML. ML doesn&#x27;t have inheritance and runtime dispatch, instead it uses functors which do static dispatch.<p>Simple example: in an OOP language you might have a Map&lt;K, V&gt; class for any type K, V where K must be an instance of an Ordered interface so that the map implementation can do efficient lookup.<p>In OCaml, you have a Map.Make(Ord : Ordered) functor which explicitly takes a module Ord as its parameter. The Ord module implements the key data type, which must support the Ordered interface. When you (statically) apply the functor, you get back a new module which specializes a map data type to work for the specific key type. E.g.,<p><pre><code>    module StringMap = Map.Make(String)\n</code></pre>\nThe String module implements the Ordered interface, so it can be used as the argument here. Now you can create and manipulate maps of strings to any values.<p>You might be wondering, what&#x27;s the payoff? It&#x27;s very similar to the payoff for interfaces--code abstraction. It&#x27;s just that it&#x27;s all statically resolved and highly efficient.')