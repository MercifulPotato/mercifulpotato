Item(by='sergeykish', descendants=None, kids=[24832618], score=None, time=1603135980, title=None, item_type='comment', url=None, parent=24828667, text='Perl and Lua have separate arithmetic and concatenation operators<p><pre><code>    1 + &quot;2&quot;\n    #3\n    1 - &quot;2&quot;\n    #-1\n    1 . &quot;2&quot;  | 1 ..  &quot;2&quot;\n    #&quot;12&quot;\n    1 . &quot;-2&quot; | 1 .. &quot;-2&quot;\n    #&quot;1-2&quot;\n</code></pre>\nPython and Ruby throw exception, use explicit type conversion and string interpolation<p><pre><code>    1 + &#x27;2&#x27;\n    Traceback (most recent call last):\n    TypeError (String can&#x27;t be coerced into Integer)\n    1 + &#x27;2&#x27;.to_i\n    #3\n    &quot;1#{&#x27;2&#x27;}&quot;\n    #&quot;12&quot;\n</code></pre>\nHardly any language is perfect, I have not encounter much of operator overload in ruby (nokogiri?) but I believe C++ got it bad.<p>One number type in Lua:<p><pre><code>    &gt; 0 | 0xffffffff\n    4294967295\n    &gt; 0 | 0xffffffffffffffff\n    -1\n    &gt; 0 | 0x7fffffffffffffff\n    9223372036854775807\n</code></pre>\nlimited but better than JavaScript:<p><pre><code>    0 | 0xffffffff\n    &#x2F;&#x2F;-1\n</code></pre>\nBigInt is an improvement<p><pre><code>    0n | 0xffffffffn\n    &#x2F;&#x2F;4294967295n\n    0xffffffffffffffffn\n    18446744073709551615n\n</code></pre>\nit is strict<p><pre><code>    1n - &quot;2&quot;\n    1 + 1n\n    Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions\n</code></pre>\nworks nice with string interpolation:<p><pre><code>    `${1n}`\n    &quot;1&quot;\n</code></pre>\nNumbers is a sane example. One can argue it was for good. How about `{} + []`? I believe I can disable this part in JavaScript engine and no one would notice. And misleading `object[key]` where it calls toString, sure I have not tried that in a decade but it is stupid. UTF-16:<p><pre><code>    &quot;&quot;[1] # there were emoji\n    &#x2F;&#x2F;&quot;�&quot;\n</code></pre>\nYou&#x27;ve said nothing about constructor oriented programming. Unique feature, I have not heard any other language adopted it yet. The post you&#x27;ve replied contents sketch for Ruby. Actually I&#x27;ve got it wrong — every JavaScript function is a closure (Ruby method is not closure) and Prototype method was a class method (not instance method), fixed but ugly:<p><pre><code>    def function(&amp;block)\n      Class.prototype.new.tap do |c|\n        c.define_method(:initialize, block)\n      end.instance_method(:initialize)\n    end\n\n    def function_(object, name, &amp;block)\n      object.class_eval do\n        define_method(name, &amp;block)\n      end\n    end\n\n    Person = function { |name|\n      @name = name\n    }\n    function_(Person.prototype, :name_) {\n      @name\n    }\n\n    john = new.call Person, &#x27;john&#x27;\n    puts john.__proto__ == Person.prototype\n    puts john.name_\n\n    def function__(object, name, &amp;block)\n      object.singleton_class.class_eval do\n        define_method(name, &amp;block)\n      end\n    end\n\n    function__(john, :name__) {\n      @name\n    }\n    puts john.name__\n</code></pre>\nBy the way, you can say &quot;Yes, I know JavaScript has some problems&quot;. It is not a secret, everyone knows.')