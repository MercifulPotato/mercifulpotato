Item(by='dastbe', descendants=None, kids=[25595681], score=None, time=1609439916, title=None, item_type='comment', url=None, parent=25591492, text='while this is a good overview, i think this article paints too rosy a picture of message queues, specifically<p>&gt; We can put as many messages as we want into the tube (let&#x27;s assume we have a infinitely long tube) at whatever speed is comfortable to us.<p>and<p>&gt; The receiver will never be impacted by our actionsâ€”they will pull out as many messages as they want at whatever rate is comfortable to them.<p>and<p>&gt; Neither the sender nor the receiver are concerned with how the other works.<p>First, I would argue that the sender and receiver still absolutely have to know how the other works, because your API contract is now the structure of all messages that enter the queue. You also need to be aware of the semantics of both client and receiver: if I receive a message I can&#x27;t process, can I get rid of it? Do I need to retry it forever? And as a sender, will my receiver retry this message or do I need to track success? In synchronous systems you have the opportunity provide clearer feedback in these scenarios, which help mitigate or at least share responsibility in mitigating poison pill scenarios.<p>It&#x27;s also the case that when you introduce a queue you&#x27;re adding an arbitrary buffer. During short transient outages this is usually ok, as your system has some slack somewhere at some time to drive down the pileup, but during persistent outages you can end up driving up a difficult to overcome buffer. And worse, in the event of time sensitive message a substantial amount of that buffer may be otherwise <i>useless</i>. Unless your receiver knows whether a message can be safely ignored, you can encounter outage scenarios that take hours or even days to recover from and exacerbate impact after recovery compared to if you just had no queue and shed load in the first place.')