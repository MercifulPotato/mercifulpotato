Item(by='Nursie', descendants=None, kids=[25917589], score=None, time=1611655871, title=None, item_type='comment', url=None, parent=25913979, text='&gt; In order for a piece of software to be exploitable, you need to have an input channel that is not isolated from the functionality<p>And prove that your input validation is correct for every possible value, and that under stress the system doesn&#x27;t start doing something weird, and there are no possible integer overflows that might cause something funny to happen and ...<p>&gt; For example, for all the C&#x2F;C++ code that I have seen that deals with web, only once I remember seeing a check on characters in the passed data being in the set of [0x10, 0x13, 0x20-0x7e], which should be the first check performed on any HTTP data passed to it<p>Unless it&#x27;s unicode of course, which it really should be these days if we&#x27;re talking about the web, and when really you want a unicode parsing library to validate, and then you&#x27;re reliant on that having no exploits, and anything of any significant complexity usually turns out to have some somewhere.<p>&gt; &quot;Between all the other mechanisms in place, like non executable stack&#x2F;heap, stack canaries, ASLR, and the tools like memcheck and valgrind, the possibility of you making an exploitable software is as low as coding it in a &quot;proven safe&quot; language&quot;<p>This is provably false though, and that&#x27;s part of the point of the article, even well looked-after software written by experienced people with an eye on security suffers from problems, and with unsafe languages there are classes of attack that are just not possible with safer languages. These keep on happening regardless of the apparent skill level of the practitioner. The author has been doing it for 25 years and doesn&#x27;t think they could do it reliably. I was a C programmer for 15 and I agree, past a certain level of complexity it looks like there just are going to be errors of this sort somewhere in your code.<p>Sure, programs written in &#x27;safe&#x27; languages are not bug-free or exploit-free, but for public-facing, networked code they do seem to be better as they eliminate a huge number of damaging attack types straight off.')