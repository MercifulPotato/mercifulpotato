Item(by='Lazare', descendants=None, kids=[25594804], score=None, time=1609435259, title=None, item_type='comment', url=None, parent=25593165, text='I also spent some time evaluating them, and came to the conclusion that KSUIDs (<a href="https:&#x2F;&#x2F;github.com&#x2F;segmentio&#x2F;ksuid" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;segmentio&#x2F;ksuid</a>) were strictly better than ULIDs.<p>The differences aren&#x27;t huge in practice, but the ULID spec has a couple of highly questionable choices. Specifically, according to the spec:<p>1. The first time you generate a ULID in a given millisecond on a node, you should fill in the random component randomly.<p>2. But if you generate more than one ULID per milliscond, subsequent ULIDs should use the first ULIDs random component and just increment the least significant bit.<p>3. If that would overflow, then you just can&#x27;t generate any more ULIDs that millisecond.<p>The goal is that ULIDs will be strictly sortable even when you&#x27;re generating multiple per millisecond...except for that to work, you&#x27;d have to only generate them in a single thread (or at any rate on a single node). If you&#x27;re just incrementing a numbers on a single node, then uh, why not just use an autoincrementing integer column in a DB? Of course, if you&#x27;re generating multiple IDs per millisecond, you&#x27;re probably using multiple nodes, and if you are, then wall clock skew means the IDs will never be strictly sortable. Except actually it&#x27;s even worse than that; even if you ARE only using a single node, your code probably can&#x27;t assume that every ULID it will ever encounter was generated in that way, so you <i>still</i> can&#x27;t rely on the sorting guarantee. Meanwhile, a compliant ULID generator has to have state and, if it&#x27;s going to be called in a multithreaded way, to deal with some complex race conditions, which makes it a lot harder to run.<p>Meanwhile, you could get 100% of the benefits and none of the drawbacks by just...using random bits for the random component every time.<p>Anyhow, the idea of slapping a timestamp and a random string of bits together is a good one. I just think the KSUID spec is a bit better thought out.')