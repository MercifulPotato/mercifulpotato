Item(by='GuB-42', descendants=None, kids=None, score=None, time=1609119304, title=None, item_type='comment', url=None, parent=25554955, text='&gt; Don&#x27;t use anything from STL that allocates memory, unless you don&#x27;t care about memory management.<p>The important part is &quot;if you don&#x27;t care about memory management&quot;.<p>In language benchmarks, C++ is often portrayed as less efficient&#x2F;slower than C. C++ is also commonly shunned when it comes to embedded software, especially on low performance chips. It doesn&#x27;t have to be! C++ is (almost) a superset of C, and generally, they use the same compiler backend, so your C code should compile on a C++ compiler and generate the same binary.<p>Now that you know you can write C++ running as efficiently as C, you can start to carefully add features that will keep the spirit and efficiently of C while making your life easier, or even improve performance. For example you may want to replace macros with templates, use proper objects instead of doing like stdio does with FILE*, use namespaces, etc...<p>That&#x27;s exactly what Orthodox C++ is about. It is C++ for those who want to write C. There is absolutely nothing wrong with STL containers and smart pointers and all the fancy stuff that make up modern C++, there is also nothing wrong with using languages that have heavy runtimes and garbage collectors, it is just not the use case Orthodox C++ is addressing.<p>I think that&#x27;s the good thing about the mess that is C++11 and beyond. You can pick what you want. You can stay low level and know exactly the memory layout of your program. Or you can choose not to have a single raw pointer and let it manage the memory for you.<p>Note: There are still a good reasons to use C over C++. A big one is that linkage is a lot simpler and more compatible in C. C++ compilers do name mangling to support things like namespaces and polymorphism and require the linker to understand their particular conventions, and you may need the right libstdc++ for your target. You also need to be aware of static initialization.')