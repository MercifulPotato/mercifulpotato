Item(by='beaconstudios', descendants=None, kids=[25934627], score=None, time=1611782893, title=None, item_type='comment', url=None, parent=25933698, text='the patterns can still be completely the same without OOP - pairing data and functions that operate on said data. enemy.damage() and Enemy::damage(enemy) are functionally and semantically equivalent. But in the latter case (where you separate data and code) you don&#x27;t need to worry about object assembly&#x2F;IoC, how to pass a reference to A all the way through the object graph to object B, composition over inheritance becomes the default (at least in my experience using TypeScript interfaces, YMMV with other languages). The benefits of OOP, primarily state encapsulation, stop looking like benefits when it turns out your state boundaries weren&#x27;t quite right.<p>Of course I&#x27;m biased as I went through the same &quot;procedural =&gt; OOP =&gt; case-by-case&quot; learning curve as the GP. But I ended up spending a lot of time trying to satisfy vague rules when using OOP - with procedural&#x2F;functional programming with schema&#x27;d data, I get to spend a lot more time on what I actually want to do. Not worrying about SRP, SOLID, object assembly, how to fix my object graph now that A needs to know about B, and so on.')