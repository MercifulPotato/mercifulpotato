Item(by='nendroid', descendants=None, kids=[24839262], score=None, time=1603153208, title=None, item_type='comment', url=None, parent=24832120, text='&gt;Yeah, I suspected that you and lerptime were the same person.<p>to get around the post limit. Keep it on the DL.<p>&gt;When you make such a statement, you sound like someone with fairly limited experience. In particular, from your example, I suspect that you&#x27;ve never worked in a multi-threaded embedded system. somethingToBeInSyncTo, done that way, means that any other thread holding a reference, holds a reference to the old value, while this thread has the new one. And updating running threads with new values on the fly is... problematic.<p>I find that you&#x27;re the one who seems inexperienced. My example is thread safe ... makeNewState is a combinator. It makes no mutations. Like IO, and mutations, the problems with threading happen with mutation. Thus, locks and other procedural commands used to deal with threading live in the void IO function.<p>We&#x27;re more referring to coupling functions with external data and mutations via objects. If you&#x27;re talking about synchronizing two threads, this again needs to be handled with parent IO function outside the logic of your pipeline combinators. You can still segregate logic away from threading and IO.<p>My combinator in this case is useable for your example case of synchronizing two threads. If you organized your code in ways where my combinator will be unusable than you have failed to decouple your logic away from threading, IO and mutation.')