Item(by='brundolf', descendants=None, kids=None, score=None, time=1603234134, title=None, item_type='comment', url=None, parent=24839275, text='Another large category of language UX issues is, ironically, the sugar that gets applied to the syntax. The classic example, but far from the only example, is auto-dereferencing: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;28519997&#x2F;what-are-rusts-exact-auto-dereferencing-rules" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;28519997&#x2F;what-are-rusts-...</a><p>Rust has many syntax features that can be described as &quot;Rust takes some common pattern that&#x27;s onerous to write and read, and automatically infers it for you under certain conditions&quot;. On its face this seems like a strict improvement: you can still be explicit if you want&#x2F;need to, or you can skip some boilerplate in certain cases.<p>But the problem comes when you&#x27;re trying to learn about the language. Because these UX &quot;optimizations&quot; are layered on fairly arbitrarily - not unlike actual compiler optimizations - they sometimes create a very confusing landscape to try and form a mental model around, in the same way that compiler optimizations can make it hard to understand what will and won&#x27;t make something faster.<p>This often plays out as:<p>1) You have some clean piece of code that does what you want<p>2) You add something innocuous to it<p>3) It no longer fits the sugar-pattern that the compiler was silently invoking underneath<p>4) You now have several sprawling errors because you&#x27;re expected to be explicit about something you didn&#x27;t have to be before<p>An inexperienced Rust programmer would (reasonably) assume those errors were caused by the thing that was added, and start trying to figure out what&#x27;s wrong with it. But that&#x27;s a red herring. The real issue, which is not indicated, is that a sugar-pattern was bailed out of.<p>I&#x27;m glad these shortcuts exist in some capacity: Rust is a complicated and fairly verbose language, and they make it less so. But I think they seriously damage the learning experience and early impressions that people form of the language. I&#x27;ve been using it for years and I still discover new quirks with this stuff that I didn&#x27;t know about, and incorrect assumptions I had about the language itself that were driven by these mysterious mechanisms.<p>What if rustc had a &quot;no-sugar&quot; mode that people could use until they&#x27;ve gotten a handle on what&#x27;s really going on? What if the language server somehow indicated inline when sugaring was being invoked?<p>Edit: A different way of phrasing the problem is that debugging is like navigating a landscape: there&#x27;s a locality to it. &quot;Did this change bring me closer to my goal, or further away from it? If closer, I&#x27;m probably on the right track, if further, probably the wrong one.&quot; Most languages mostly adhere to this idea of contiguous space-navigation. But these patterns in Rust are like constructing a maze across the landscape; there are cul-de-sacs and roundabout pathways you have to follow to get where you&#x27;re going. There&#x27;s also inconsistency about a given subject: you look at one piece of the terrain from a different angle, and it changes. It&#x27;s hard to form a coherent, generalized mental map because base truth is relative based on what direction you&#x27;re coming at it from. So over time instead of learning 2N concepts (lifetimes, references, iterators, boxes) you learn an NxN matrix of concepts (using references with boxes, using references with iterators, using lifetimes with iterators, etc...), because they interact with each other in unpredictable ways.<p>This may just deserve a whole blog post :)')