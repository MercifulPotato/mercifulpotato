Item(by='moonchild', descendants=None, kids=[25240806], score=None, time=1606597594, title=None, item_type='comment', url=None, parent=25239943, text='&gt;  The Makefile abstraction is &quot;run this command when the output files don&#x27;t exist or are older than the input files.&quot; You manually specify every tool to be run and all of its arguments.<p>&gt;  The BUILD file abstraction is something like &quot;I am declaring a C library with these sources and headers.&quot;<p>This is wrong.  Even ninja has generic rules.  Here&#x27;s an example of a minimal makefile:<p><pre><code>  OBJ = src&#x2F;a.o src&#x2F;b.o src&#x2F;c.o\n  libfoo.so: $(OBJ)\n          $(CC) -shared -o libfoo.so $(OBJ)\n</code></pre>\n&gt; When the tool is in charge, it has more control and can sandbox each build step so that undeclared dependencies simply won&#x27;t be available in the sandbox.<p>There&#x27;s no reason this shouldn&#x27;t be possible with make; it just hasn&#x27;t been implemented so.  Do bazel&#x2F;buck&#x2F;please actually do this?  As far as I know tup is the only tool that actually verifies inputs&#x2F;outputs of rules, and it needs FUSE to do so.<p>&gt; For example, unless you implement your own header scanning (or manually list your header dependencies) &quot;make&quot; won&#x27;t know to rebuild a source file when a header changes.<p>At least with GNU make, it&#x27;s very easy:<p><pre><code>  CFLAGS += -MMD\n  -include $(patsubst %.o,%.d,$(OBJ))\n</code></pre>\nTrue, it&#x27;s a bit of a footgun, but by no means difficult.<p>Make has problems, but the ones you listed aren&#x27;t they.')