Item(by='layer8', descendants=None, kids=[25974344], score=None, time=1612033947, title=None, item_type='comment', url=None, parent=25969976, text='The generic way to remove a cyclic dependency is by Dependency Inversion (not to be confused with Dependency Injection), so that a mutual dependency <i>A</i> &lt;–&gt; <i>B</i> is transformed into the noncircular set of dependencies { <i>A</i> –&gt; <i>BIntf</i>, <i>BImpl</i> –&gt; <i>BIntf</i>, <i>BImpl</i> –&gt; <i>A</i> }. That is, at least one node in the dependency cycle is split into interface and implementation, breaking the cycle.<p>Compilers for languages like C# and Java can deal with (seemingly) circular dependencies within a set of classes to compile, because when <i>A</i> uses <i>B</i> they only have to consider the interface (type signature) of <i>B</i>, not its implementation. (Cyclic dependencies <i>between</i> modules are still a problem, in particular for build systems.)<p>I&#x27;m not really familiar with F# (so someone please correct me if necessary), but in languages that use type interference to determine function signatures, one consequence is that the interface (type signature) of the function then depends on its implementation, so you can&#x27;t as easily invert the dependency as when you have explicitly declared type signatures.')