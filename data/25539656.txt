Item(by='eyelidlessness', descendants=None, kids=None, score=None, time=1608936380, title=None, item_type='comment', url=None, parent=25539463, text='I’m on mobile so forgive any syntax mistakes, but I’m talking more along the lines:<p><pre><code>    const createLea = (data) =&gt; ({\n        ...data,\n        id: (\n            data.id ??\n            data.name\n                .toLowerCase()\n                .replace(&#x2F;\\W+&#x2F;g, &#x27;-&#x27;)\n        ),\n    });\n</code></pre>\nNo mutation, no getters (function or implicit), dead simple to use, dead simple to reassign (just call the function again with the same data but provide a new `id` and super easy to understand at a glance (easier with types, but I digress).<p>&gt; prototype-based-like language<p>One of the benefits of the approach I describe is you’re no longer working in a prototype based language. I mean, of course you are, but you don’t have to care.<p>Edit: even on mobile I couldn’t stand the formatting.<p>Edit 2: since I mentioned performance in my original comment, I’d add that there are two benefits here (one real, one possible with JITs): getters and setters (and anything with Object.defineProperty) perform worse than regular values; if you program in this style, the JIT has an opportunity to recognize that your values are generally immutable and optimize object construction e.g. with the spread operator as persistent data structures the same way FP languages do.')