Item(by='Geminidog', descendants=None, kids=[25555924, 25555845, 25555880, 25555855], score=None, time=1609114006, title=None, item_type='comment', url=None, parent=25554478, text='I disagree with you and you&#x27;ve made a mistake. You&#x27;re the one under the illusion. I&#x27;ll explain.<p>I know what you&#x27;re getting at here. You just can&#x27;t put it in words. And because you can&#x27;t put it in words, you&#x27;re unable to see the big picture. To put it plainly you&#x27;re talking about this:<p>For a specific context how do we organize and modularize code to maximize reuse-ability for a uncertain future with uncertain requirements?<p>You think that this problem can&#x27;t be formalized. And this is basically what you&#x27;re trying to elucidate into words with your post. It&#x27;s that simple.<p>However, this is the exact problem I am saying is ripe for formalization.<p>This is what I&#x27;m talking about and you&#x27;ve missed my point.<p>Who says we can&#x27;t formally define what a module is? and who says we can&#x27;t formally define what it means for a module to be more re-useable? Who says we can&#x27;t formally define program requirements? From these axioms we can define a calculus that allows us in the best case to calculate the most optimal program and in the worst case at least be able to know whether one design is &quot;better&quot; than another design.<p>Instead what the industry does is write blog posts about a metaphor. Then give a bunch of examples of why that metaphor is cooler then some other design pattern. Then repeat the same thing every couple of years.<p>Let me frame it for you so that you can wrap your head around what I&#x27;m talking about. Given tic-tac-toe we can formally play the game in a way we can never lose. This is definitely not a design problem and one that can be calculated. Very easy to see why this is the case because of the limited primitives your dealing with in tic-tac-toe.<p>The &quot;problem domain&quot; defined within a computer is NO different. In computers You have a limited set of primitives in a rule based playing field: assembly language. The objective is not 3 in a row but whatever formal requirements your program has.  Within this problem space there is either one or several configurations of assembly instructions that will fulfill that problem domain according to a formal definition of &quot;optimal&quot;. That is the spirit of the formalization I&#x27;m talking about. A more complex tic-tac-toe problem.<p>The notion of what it means for an algorithm to be faster has been formalized. So if the problem domain was &quot;how do you sort a list of shoe sizes in the fastest way possible?&quot; then we ALREADY have a formal and definitive way to determine the best possible configurations of assembly instructions to achieve this goal. The problem is solved partially for speed. Picking a faster algorithm is no longer a design choice.<p>The next step is to formalize the notion of modularity and program organization and bring it out of the fuzzy realm of design and architecture and into a more formal realm where things are exactly defined. We came up with a number for speed (O(N)), who says we can&#x27;t come up with a number for modularity?<p>I don&#x27;t blame you for making this mistake. &quot;Luck&quot; itself use to be a design problem. Intuitively it&#x27;s very hard to think of the concept of &quot;luck&quot; as a measurement problem. It was utterly incomprehensible for a typical person to even visualize luck as something that can be calculated. It was only after the development of probability theory that people were able to see how it can be done, it is much harder to predict formal possibilities of a topic before the formalization has actually been done.<p>It&#x27;s the same thing for module organization. &quot;Design.&quot; so to speak<p>&gt;Architecture is just a disciplne of making your life suck less later. It&#x27;s not an easy discipline, and (clearly) not a<p>You can&#x27;t even define what it means to make you life &quot;suck less.&quot; Are you talking about algorithmic speed? Because that&#x27;s been formalized. Are you talking about less bugs? Because smaller error surface areas have been partially formalized with type theory and Rusts borrow checker...<p>Are you talking about organization of modules? Because if you&#x27;re talking about a formal way to organize modules, well that hasn&#x27;t been done. But don&#x27;t let that limit your mind into thinking it can&#x27;t be done.<p>Especially don&#x27;t let that limit your mind into falling under the illusion of thinking that all of these endless circles and design philosophies that go in vogue and out of vogue throughout the industry are actually doing something to improve the software as a whole. If you ever wanted a good example of history repeating itself software design is the perfect example.<p>In simple terms: the discipline of &quot;architecture&quot; is not well understood because it has NOT been formalized. At this point it&#x27;s borderline fraudulent to even call it a discipline. Call it a career title, sure, but don&#x27;t try to think of this stuff as anything on the same level as the sciences.')