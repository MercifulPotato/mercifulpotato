Item(by='joshuamorton', descendants=None, kids=None, score=None, time=1606638569, title=None, item_type='comment', url=None, parent=25243425, text='Fundamentally, bazel and make treat &quot;targets&quot; differently. A make target is an invokable thing. That&#x27;s about the extent of it. You have a dag of invokables, and invoking one will cause you to invoke all of its dependencies (usually, other people have discussed the limitations of make&#x27;s caching already).<p>But let&#x27;s look at how a rule is implemented in bazel[0]. Here&#x27;s a rule &quot;implementation&quot; for a simple executable rule[1]:<p><pre><code>    def _impl(ctx):\n        # The list of arguments we pass to the script.\n        args = [ctx.outputs.out.path] + [f.path for f in ctx.files.chunks]\n\n        # Action to call the script.\n        # actions.run will call &quot;executable&quot; with \n        # &quot;arguments&quot;, saving the result to &quot;output&quot;\n        # access to files not listed in &quot;inputs&quot; will\n        # cause errors.\n        ctx.actions.run(\n            inputs = ctx.files.chunks,\n            outputs = [ctx.outputs.out],\n            arguments = args,\n            progress_message = &quot;Merging into %s&quot; % ctx.outputs.out.short_path,\n            executable = ctx.executable.merge_tool,\n        )\n\n    concat = rule(\n        implementation = _impl,\n        attrs = {\n            &quot;chunks&quot;: attr.label_list(allow_files = True),\n            &quot;out&quot;: attr.output(mandatory = True),\n            &quot;merge_tool&quot;: attr.label(\n                executable = True,\n                cfg = &quot;exec&quot;,\n                allow_files = True,\n                default = Label(&quot;&#x2F;&#x2F;actions_run:merge&quot;),\n            ),\n        },\n    )\n</code></pre>\nThis is, admittedly, not easy to follow at first glance. Concat defines a &quot;rule&quot; (just like cc_binary) that takes three arguments: &quot;chunks&quot;, &quot;out&quot;, and &quot;merge_tool&quot; (and &quot;name&quot;, because every target needs a name).<p>Targets of this form have metadata, they have input and output files that are known and can be queried as part of the dag. Other types of rules can be tagged as test or executable, so that `blaze test` and `blaze run` can autodiscover test and executable targets. This metadata can also be used by other rules[2], so that a lot of static analysis can be done as a part of the dag creation, without even building the binary. To give an example, a rule like<p><pre><code>    does_not_depend_on(\n       name = &quot;check_deps&quot;,\n       src = &quot;:opensource_thing&quot;,\n       forbidden_deps = [\n           &quot;&#x2F;&#x2F;super&#x2F;secret:sauce&quot;,\n       ]\n    )\n</code></pre>\ncan be built and implemented natively within bazel by analyzing the dependency graph, so this test could actually run and fail before any code is compiled (in practice there are lots of more useful, although less straightforward to explain, uses for this kind of feature).<p>Potentially, one could create shadow rules that do all of these things, but you&#x27;d need to do very, very silly things like, off the top of my head, creating a shadow filesystem that keeps a file-per-make-target that can be used to query for dependency information (make suggests something similar for per-file dependencies[3], but bazel allows for much more complex querying). That&#x27;s what I mean by &quot;object-oriented&quot;. Targets in bazel and similar are more than just an executable statement with file dependencies. They&#x27;re complex, user-defined structs.<p>This object-oriented nature is also what allows querying (blaze query&#x2F;cquery&#x2F;aquery), which are often quite useful for various sort of things like dead or unusued code detection or refactoring (you can reverse dependency query a library that defines an API, see <i>all</i> direct users and then be sure that they have all migrated to a new version). My personal favorite from some work I did over the past year or so was is `query --output=build record_rule_instantiation_callstack`, which provides a stacktrace of any intermediate startlark macros. Very useful when tracking down macros that conditionally set flags, but you don&#x27;t know why, and a level of introspection, transparency, and debugability that just isn&#x27;t feasible in make.<p>[0]: <a href="https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;skylark&#x2F;rules.html" rel="nofollow">https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;skylark&#x2F;rules.html</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;bazelbuild&#x2F;examples&#x2F;blob&#x2F;master&#x2F;rules&#x2F;actions_run&#x2F;execute.bzl" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;bazelbuild&#x2F;examples&#x2F;blob&#x2F;master&#x2F;rules&#x2F;act...</a><p>[2]: <a href="https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;skylark&#x2F;aspects.html" rel="nofollow">https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;skylark&#x2F;aspects.htm...</a><p>[3]: <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;make&#x2F;manual&#x2F;html_node&#x2F;Automatic-Prerequisites.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;make&#x2F;manual&#x2F;html_node&#x2F;Automatic...</a>')