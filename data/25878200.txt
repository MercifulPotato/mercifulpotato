Item(by='graycat', descendants=None, kids=[25879137], score=None, time=1611361624, title=None, item_type='comment', url=None, parent=25876087, text='Maybe for some readers:<p>Likely GC abbreviates <i>garbage collection</i>.<p>Going way back, some programming languages have permitted <i>dynamic storage allocation</i>, that is, a programmer using that language could during execution of the program ask for <i>storage</i>, that is, bytes in main memory, to be <i>allocated</i>, i.e., made available for use.  Later the programming could <i>free</i> that storage.  E.g., early versions of the programming language Fortran did not offer dynamic storage allocation, but some programmers would implement their own, say, in a Fortran array.  Then for <i>pointers</i> to the allocated storage, just use a subscript on the array name.  The array might be in storage called COMMON which to the linkage editor was <i>external</i>, thus permitting all parts of the program to use dynamic storage.  The programming language PL&#x2F;I had versions of dynamic storage AUTOMATIC, BASED, and CONTROLLED.  The programming language C has storage allocation via the function MALLOC and freeing via FREE.<p>Well, first cut, intuitively can think of garbage collection (GC) as <i>automated</i> dynamic storage freeing.<p>In the case of the original post (OP) of this thread, what is going on is, in the .NET languages, C#, Visual Basic (VB), F#, etc., can, e.g., in a function, allocate storage, e.g., with the VB statement ReDim, likely use that storage, have flow control leave that function, leave the storage allocated, and, then, have garbage collection notice automatically when that storage will not be used again and free it, i.e., make it available again for allocation and use.  In addition, likely the code for some programming language features need at least dynamic storage and might use GC for freeing.<p>The broad idea of garbage collection is old, in several programming languages goes back decades.  E.g., in PL&#x2F;I, AUTOMATIC gave automatic storage freeing.<p>Why should .NET implement garbage collection, that is, why bother?  Otherwise sometimes programmers forget to do the garbage collection themselves resulting in allocated storage growing until it is too large.  One of the old examples was from cases of handling <i>exceptional conditions</i>; in some cases the code that got control did not have the data to <i>know</i> what storage should be freed.<p>GC has some challenges:<p>First, in a rich language, it can be not easy to know what storage should be freed. So, there can be some bugs in GC implementations.<p>Second, GC takes time, and maybe in some situations, that is, in some programs, takes too much time and results in, say, noticeably slower response time.  One place where GC tends to be unwelcome is <i>real time</i> programming where want the software to respond in no more than a few milliseconds to external events that occur at unpredictable times.<p>One of the main ideas for GC implementation is <i>reference counting</i> where the programming language compiler inserts extra code that, for each instance of appropriate cases of allocated storage, keeps track, say, just a count, of essentially how many variables in the code (for each thread of execution) might use, <i>reference</i>, the storage.  Then   for such an instance of storage when its reference count reaches zero, free the storage.')