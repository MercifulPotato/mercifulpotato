Item(by='loeg', descendants=None, kids=None, score=None, time=1611433966, title=None, item_type='comment', url=None, parent=25883935, text='&gt; The point is that non-blocking IO wants to abstract away the hardware, but the abstraction is leaky.<p>Why do you say it doesn&#x27;t match hardware?  Basically all hardware is asynchronous â€” submit a request, get a completion interrupt, completion context has some success or failure status.  Non-blocking IO is fundamentally a good fit for hardware.  It&#x27;s blocking IO that is a poor abstraction for hardware.<p>&gt; Most programs which use non-blocking IO actualy want to implement multitasking without relying threads. But that turns out to be the wrong approach.<p>Why is that the wrong approach?  Approximately every high-performance httpd for the last decade or two has used a multitasking, non-blocking network IO model rather than thread-per-request.  The overhead of threads is just very high.  They would like to use the same model for non-network IO, but Unix and unix-alikes have historically not exposed non-blocking disk IO to applications.  io_uring is a step towards a unified non-blocking IO interface for applications, and also very similar to how the operating system interacts with most high-performance devices (i.e., a bunch of queues).')