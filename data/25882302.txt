Item(by='valand', descendants=None, kids=None, score=None, time=1611410836, title=None, item_type='comment', url=None, parent=25881193, text='Good at compile-time, breaks at runtime. It is because TypeScript doesn&#x27;t want to diverge far from JavaScript. TypeScript compiles to JavaScript and if you give the wrong input you&#x27;ll end up with runtime errors.<p>Usually this happens with casting. Casting an `any` variable as `string` doesn&#x27;t do anything other than letting the compiler knows that it must be string. It doesn&#x27;t transform the variable and throw error when it is not string. This is a bit like casting struct pointer in C.<p>This usually happens at IO: `fetch`, `localstorage`, `fs.readFileSync`, etc. It can&#x27;t be solved purely with TypeScript. I used `io-ts` to mitigate this problem.<p>This is a good paradigm to adopt in TypeScript projects <a href="https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-validate&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-va...</a>.<p>Other than data type, brutally tweaking your tsconfig (and webpack or rollup, if you use them) can also cause errors in module resolution, which is not a nice thing.<p>TypeScript is almost revolutionary. The thing I wish to exist is a superset of TypeScript that allows Rust-like macro. It is super handful, super beautiful.')