Item(by='shepmaster', descendants=None, kids=[24674332, 24674338], score=None, time=1601752117, title=None, item_type='comment', url=None, parent=24672703, text='&gt; Long story short, yeah, there&#x27;s a lot of crates.<p>And I&#x27;d add one more to the pile: my [SNAFU] crate. It actually does what the author says they do by hand:<p>&gt; So, I just write the boilerplate and make my errors descriptive enough I don’t need a backtrace. When I want to get fancy I implement the built-in `Error` trait, which used to be kinda useless but is now more helpful. And in another five years it’ll still work just fine.<p>SNAFU is all about creating enums for each error case so that the hierarchy of types tells you exactly what and where the error came from. In my ideal usage, you don&#x27;t need a stacktrace or even origin line number &#x2F; file name because each specific combination of error is used only once.<p>The nesting of types within specific contexts gives what I like to call a &quot;semantic backtrace&quot;<p>Example usage:<p><pre><code>    #[derive(Debug, Snafu)]\n    enum Error {\n        #[snafu(display(&quot;Unable to read configuration from {}: {}&quot;, path.display(), source))]\n        ReadConfiguration { source: io::Error, path: PathBuf },\n    \n        #[snafu(display(&quot;Unable to write configuration to {}: {}&quot;, path.display(), source))]\n        WriteConfiguration { source: io::Error, path: PathBuf },\n    }\n    \n    type Result&lt;T, E = Error&gt; = std::result::Result&lt;T, E&gt;;\n    \n    fn example(path: &amp;Path) -&gt; Result&lt;()&gt; {\n        let data = fs::read_to_string(path).context(ReadConfiguration { path })?;\n        fs::write(data, path).context(WriteConfiguration { path })?;\n        Ok(())\n    }\n        </code></pre>\nThis creates the `Error` enum and implements `std::error::Error` for it, plus what I call <i>context selectors</i> to easily add on to fallible calls to help group them. Note that both SNAFU errors are caused by an `io::Error`, but the context in which the `io::Error` is created is vastly different.<p>&gt; for applications and libraries, respectively<p>I&#x27;ve yet to understand why people want to draw a line between these two cases. For me, the only difference is that the error type in a library needs to be conscious that it&#x27;s part of the public API. That&#x27;s why SNAFU can generate [opaque] error types<p>---<p>Other bonuses:<p>- Doesn&#x27;t require heap allocation (but can make of use it)<p>- Works in no-std environments<p>- Comes with extension traits for `Result` and `Option`, and feature flagged ones for `Future` and `Stream`<p>- Supports generic errors (types and lifetimes)<p>- Can create backtraces (either from the backtrace crate or the unstable `Backtrace` type in the standard library)<p>[SNAFU]: <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;snafu" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;snafu</a><p>[opaque]: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;snafu&#x2F;0.6.9&#x2F;snafu&#x2F;guide&#x2F;opaque&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;snafu&#x2F;0.6.9&#x2F;snafu&#x2F;guide&#x2F;opaque&#x2F;index.html</a>')