Item(by='monadic2', descendants=None, kids=None, score=None, time=1603267519, title=None, item_type='comment', url=None, parent=24845587, text='Typically, something like this: you do something stupid like use an alternative primary key scheme (which the database is agnostic about) and then your teammate accidentally omits a parameter of the primary key, deploys to production, the query misses all the indexes and causes an incident with downtime. You don&#x27;t see this problem quite as much when you&#x27;re staring at the schema itself and writing code against it.<p>More problems: default scopes causing large refactor pain, modular queries leading to accidental joins and index misses, models containing all of the combinations of models-to-be-rows, models-that-may-be-up-to-date, and models-that-have-already-been-deleted. I prefer explicit lifecycles to avoid semantic ambiguity when it comes to what data to expect where and wehen. Generally, all the places you would expect treating database queries as code against domain objects with different semantics than database tables.<p>Or, my personal least favorite game, &quot;spend three hours translating this performant query into horrendous, unreadable ruby that technically produces the sql you wanted all along&quot;. I&#x27;ve found this comes up repeatedly with aggregate queries and joins and window functions.<p>Hey ORMs have their place, but I don&#x27;t get the point of pretending it&#x27;s even equivalent to SQL when they were built with completely different intentions and constraints.')