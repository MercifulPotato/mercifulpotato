Item(by='sixdimensional', descendants=None, kids=None, score=None, time=1611954592, title=None, item_type='comment', url=None, parent=25961420, text='This is slightly perplexing.  I love the intention of this post.  Some thoughts..<p>I feel one could argue that there is a chicken-and-egg problem here.  Nobody could code anything without a reference to start from.  But, then, who developed the first language without a reference?<p>Ah, there - the start of something - those who invented the first programming languages - the very concept of &quot;stored programs&quot; as punches on a card, for example - assembly language, etc. - they did not have a reference.  They invented the reference.  But, it was also, by today&#x27;s standards - much &quot;simpler&quot; and a much &quot;smaller surface area&quot; - while probably quite technologically complex and difficult for those at the time.<p>But after that, everyone else, who didn&#x27;t invent the technology, but was rather using it.. was therefore - by definition - using a reference.  Standing on the shoulders of giants... how else to learn?<p>For instance, I learned BASIC coding first by studying other people&#x27;s examples - in magazines, by looking at code that came with my first compiler as samples, reading books.  Same way I learned Pascal and C++ - the tooling&#x2F;IDEs back then couldn&#x27;t &quot;help you learn&quot; with autocomplete.. you learned when you wrote something, and it either compiled or it didn&#x27;t.  You learned by using &quot;help&quot; or books or talking to people or looking at examples.<p>I&#x27;d argue that even those who invent most things today are inventing it at a higher level of abstraction, and therefore still looking at references for levels below the level of abstraction they work at.<p>So.. &quot;can you make a basic web app without googling&quot;?  Well, actually, yes, sure I can.  But that is because I learned HTML, CSS, JS (and supporting languages like Perl, PHP, etc.) when the surface area was still small - from the Internet itself, by looking at examples and reading things like the entire HTML specification when it was smaller.  Then I memorized it by doing it.. a lot.  Then things changed, but a lot of the basics are still possible to do today and still work.  That said - &quot;will that basic web app work in every browser platform or any every server&#x2F;OS platform that exists&quot;?  Well, if you stick to the true basics, possibly yes - but, this raises the question of technology and implementation variability and complexity.<p>I think the bigger question being posed here, isn&#x27;t the headline... it would be better to ask, &quot;does it matter if you can&#x27;t make a basic web app without Googling&quot;?  There, I think, is the point of the post - and - yes, it matters in a lot of ways.  But if you are coding for the web - presumably you are already using the web.. so.. perhaps that specifically is not as important as the next bigger question...<p>&quot;Has writing code for modern systems become so diverse and complex, and the surface area so large, that it is difficult to build systems?  Has the variability and diversity of our platforms become so large that it is difficult to build once&#x2F;deploy many with certainty?&quot;.  There again, I feel, is a much deeper and more interesting question.  This too can be answered simply - avoid complexity and choose simpler languages&#x2F;platforms that accomplish your goals, learn their surface area, and do your work.  But, this might be more difficult&#x2F;non-obvious to those just getting started - and there some good work could be done to make it more accessible.<p>And here we look to things, for example, like WASM - trying to build simple primitives that can work on nearly any platform, upon which many complex languages can live - engineering solutions to attempt at reducing complexity based on variability and diversity of platforms and implementations.<p>This question... surely relevant during this time of resurgence of &quot;low&#x2F;no-code&quot; platforms and in relation to what we might have once thought of as &quot;4GL&quot; (or beyond) programming languages and related implementations&#x2F;platforms.')