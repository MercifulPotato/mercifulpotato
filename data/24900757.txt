Item(by='leeter', descendants=None, kids=[24903065, 24902844, 24900965], score=None, time=1603743037, title=None, item_type='comment', url=None, parent=24898020, text='&gt; It was a political choice by Microsoft to drop 16 bit Windows support in 64 bit Windows. This is the limit of their famous backwards compatibility -- still impressive, though.<p>No... it wasn&#x27;t political. It was a deliberate design decision for technical reasons ( <a href="https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;winprog64&#x2F;running-32-bit-applications" rel="nofollow">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;winprog64&#x2F;run...</a> )\n HANDLEs on 64bit windows have 32bits that are valid whereas HANDLES on 32bit windows only have 16bits that are valid. So unless Microsoft wanted to completely negate the value of going to 64bit in the first place, e.g. expanding the limits on programs to be less restrictive, it was always going to have something to give.<p>Because 32bit code often &quot;thunked&quot;^1 in 16bit code they couldn&#x27;t really support it because even in 32bit mode HANDLEs still have 32bits of valid HANDLE. So a HANDLE passed to 16bit code wouldn&#x27;t round trip correctly due to truncation.<p>Nor is it like MS could emulate this like the OPs code does, because that would require rewriting applications that had already shipped from ISVs that don&#x27;t exist anymore or magically understanding when an application has 16bit code and needs to get fake HANDLEs neither of which is easy in reality. In the end it was easier to just ship a 32bit version of windows for those that still needed that support.<p>1^ This was only possible because FAR pointers in 16bit mode are still 32 bits and thus size of a pointer was in effect the same. So they could operate in the same address space. In 64bit mode this isn&#x27;t the case because there are no FAR pointers and segmentation.')