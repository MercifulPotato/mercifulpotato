Item(by='hardwaresofton', descendants=None, kids=None, score=None, time=1610895178, title=None, item_type='comment', url=None, parent=25809048, text='I don&#x27;t think I was out of touch (which I guess is always how it goes). The value propositions of Golang and Rust are pretty well understood at this point, and I think that if you want <i>abstraction power</i> the choice between them is clear.<p>Rust is hard, but it&#x27;s not harder than Haskell, and at a high level of abstraction it <i>can</i> be simpler than Golang has to offer in the stdlib, in the happy path with better results, and more safety. Again, this is the happy path case, but it&#x27;s not impossible, just hard&#x2F;unlikely -- Golang on the other hand can never achieve this level of simple interfaces built on abstraction because of the goals and design choices the language has made.<p>The original comment is this:<p>&gt;  Looking at such articles makes me feel we are going back in time rather than improving efficiencies for developers to build RESTful server. If you look at Ruby on Rails you can build the server shown here in one min that is scalable and backed with database. I know people will complain about speed of execution of language and framework but do you really care if you are not expecting Google like traffic.<p>My point was that Rust gives you the tools to write a rails&#x2F;sinatra (at a glance) library that in the happy&#x2F;simple path (which most regular CRUD backends are) can be simpler than Golang because the abstractions to make it simple are there, and speed will just about always be the fastest possible relative to quality of underlying code. Golang can (and does) provide similar, but it is always a step behind (on purpose) on the abstraction front. If you&#x27;re going to provide a carefully crafted interface that is very easy to use, it matters less that rust can have a really high barrier to entry (rails is valuable because you can be productive without being a ruby expert).')