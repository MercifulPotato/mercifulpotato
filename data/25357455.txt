Item(by='skissane', descendants=None, kids=None, score=None, time=1607512592, title=None, item_type='comment', url=None, parent=25357368, text='&gt; The reason in principle this might not work is that different distros and os&#x27;s trust different keys. Fedora trusts different keys than Ubuntu, than Arch, than macOS, etc.<p>Every distro has a keystore &#x2F; certificate store to which root can add whatever keys&#x2F;certificates they like. The only difference is in which keys&#x2F;certificates are present OOTB.<p>&gt; I don&#x27;t think this is necessarily the case. Even if you gain access to the server, HTTPS keys are usually stored in such a way that only root can read them, right? So if you only compromised a non-root account, you wouldn&#x27;t necessarily be able to read them (I might be wrong about this, I don&#x27;t do this kind of thing professionally).<p>The purpose of the key is to vouch for the integrity of the data. If I can change the data the key vouches at will, I&#x27;ve effectively compromised the key, even if I never gain access to the bytes of the key itself.<p>&gt; You&#x27;re probably right about this, but this is a great example of why you shouldn&#x27;t use the same key for both code signing and HTTPS.<p>If the CI pipeline has privilege both to (1) sign stuff with the code signing key (2) upload stuff to the HTTPS server, then even if the code signing key and the HTTPS key are different keys (which is the norm), compromising the CI pipeline is enough to effectively compromise both of them.')