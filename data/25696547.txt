Item(by='npongratz', descendants=None, kids=[25697969], score=None, time=1610163961, title=None, item_type='comment', url=None, parent=25694365, text='No need to use a loop around it, printf can take care of that pesky detail for you! To quote [0] (my emphasis):<p>&gt; To achieve full Turing-complete computation, we need a way to loop a format string. This is possible by overwriting the pointer inside printf() that tracks which character in the format string is currently being executed. The attacker is unlucky in that at the time the “%n” format specifier is used, this value is saved in a register on our 64-bit system. However, we identify one point in\ntime in which the attacker can always mount the attack. The printf() function makes calls to puts() for the static components of the string. When this function call is made, all registers are saved to the stack. <i>It turns out that an attacker can overwrite this pointer from within the puts() function. By doing this, the format string can be looped</i>.<p>&gt; An attacker can cause puts() to overwrite the desired pointer. Prior to printf() calling puts(), the attacker uses “%n” format specifiers to overwrite the stdout FILE object so that the temporary buffer is placed directly on top of the stack where the index pointer will be saved. Then, we print the eight bytes corresponding to the new value we want the pointer to have. Finally, we use more “%n” format specifiers to move the buffer back to some other location so that more unintended data will not be overwritten.<p>[0] <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;usenixsecurity15&#x2F;sec15-paper-carlini.pdf" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;usenixsecurit...</a>, Appendix B &quot;Printf is Turing-complete&quot;.')