Item(by='gpderetta', descendants=None, kids=[24692170], score=None, time=1601931257, title=None, item_type='comment', url=None, parent=24691349, text='I do not understand, why would there be a stack overflow? The &quot;context&quot; is saved (pushed) at the top of the suspended coroutine stack and restored (popped) when the coroutine is resumed (each coroutine has of course its own stack), so with a simple a-&gt;b-&gt;c-&gt;...-&gt;a cycle there is no issue.<p>In fact given swap_context_ex, yielding to the next ready task in the scheduler (and queuing the current task at the end of the queue) is trivial [1]. To simplify the code and the boundary conditions, I maintain the invariant that the ready queue always has at least one coroutine (the &#x27;idle&#x27; coroutine). Also note how the queue node is stack allocated directly on the suspended coroutine stack.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;gpderetta&#x2F;libtask&#x2F;blob&#x2F;master&#x2F;task.cpp#L149" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;gpderetta&#x2F;libtask&#x2F;blob&#x2F;master&#x2F;task.cpp#L1...</a> ; note that here   &#x27;swap_context_ex&#x27;  is called &#x27;callcc&#x27; as is conceptually very similar to scheme call-with-current-continuation.<p>edit: of course if you are not careful with swap_context_ex and keep pushing new functions to execute on a context without them ever returning to the (recursively) previous context, you can run out of space, but I haven&#x27;t found a case where this would happen in practice (not that I looked hard enough though).')