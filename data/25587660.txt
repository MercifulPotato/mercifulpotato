Item(by='WorldMaker', descendants=None, kids=[25587996], score=None, time=1609371475, title=None, item_type='comment', url=None, parent=25586995, text='&gt; Nah, you&#x27;re assuming too much. Protobuf was thrown together in a fairly ad hoc way by a couple (brilliant!) engineers (Jeff and Sanjay) to help make the Google search index protocol easier to maintain. The specific design decisions in Protobuf were not carefully tested or weighed against other possibilities. They just did something that worked well enough, and it worked well enough that it was rapidly adopted by the rest of the company. It was then too late to change anything.<p>That&#x27;s fair enough as a description of how the protocol was (not) designed that those sorts of trade-offs were not taken into account in the initial design.<p>However, it doesn&#x27;t entirely invalidate my assumption: search index protocol is pretty obviously a context&#x2F;scale that would have deeply favored more time&#x2F;cost-sensitive reads (need to get search results to users as fast as possible) and the time&#x2F;cost for writers less of a pressure (as writers for the index protocol could presumably be amortized with caching&#x2F;proxying&#x2F;throwing hardware at the problem). Whether that was an intentional &quot;optimization&quot; process or simply &quot;optimization evolutionary pressure&quot;, it does seem to me (as an entirely outside observer) like a natural trade-off optimization that ocurred at Google scale for protobufs that kept protobufs feeling &quot;well enough&quot; that they were essentially left alone and never optimized for something with different trade-offs (such as use cases that were more write than read-heavy).<p>Which it is still useful to know those sorts of &quot;optimization evolutionary pressures&quot; to answer questions like &quot;sure, it worked for Google, but will it work for me in this very different use case&#x2F;scale?&quot;')