Item(by='ohazi', descendants=None, kids=None, score=None, time=1610664259, title=None, item_type='comment', url=None, parent=25783152, text='What the hell, here are a bunch of half-baked ideas that I haven&#x27;t made time for because I&#x27;m lazy and stressed out and exhausted. Would love to hear if any of these sound interesting.<p>1. Designing a protocol for an amateur radio cellular network. This started out with some spread spectrum experiments and an interest in low-probability-of-intercept (below the noise floor) communication. The idea I have now is sort of a cross between APRS and DMR using modern modulation techniques. The network would consist of rooftop &quot;cells&quot; with internet connections, and mobile transponders that communicate with those cells. There&#x27;d be some sort of callsign or key based addressing scheme and IP-like network topology discovery. Everything will be authenticated. I&#x27;d love to have an encrypted mode, but this seems unlikely unless the laws change, which also seems unlikely.<p>2. Open-source firmware or gateware implementation of a USB PD controller that supports entering&#x2F;exiting alternate modes properly. Inspired by Kate Temkin&#x27;s LUNA project [1]. I got the impression that PD was out of scope for LUNA, at least for the time being, but it would be really nice to have both a USB and PD stack that could be integrated onto a small, inexpensive chip without the proprietary mess. The motivation for this was wanting to design a split keyboard with a USB Type-C cable connecting the two halves instead of the usual TRRS cable, and discovering that USB alternate modes are a horror show.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;greatscottgadgets&#x2F;luna" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;greatscottgadgets&#x2F;luna</a><p>3. Wi-Fi from scratch. This would essentially be a book (like Linux From Scratch) where you incrementally design the hardware needed to speak Wi-Fi, culminating in something that looks like Computer &lt;-&gt; Linux driver &lt;-&gt; FPGA &lt;-&gt; IQ modulator &lt;-&gt; antenna, allowing you to talk over 802.11g at one of the lower speed coding rates (BPSK or QPSK).<p>4. Firewalled IoT Hub. A Raspberry Pi that hosts an Wi-Fi AP for untrusted IoT devices. By default, clients on this AP can&#x27;t see each other and can&#x27;t access the Internet. The hub hosts a web interface on the primary network that allows you to send commands to your IoT devices, manage firmware updates, control network access rules, etc.<p>5. Discrete RISC-V CPU on a dinner-plate sized PCB, dressed up to look like a silicon die. Essentially Robert Baruch&#x27;s LMARV-1 [2] in Monster6502 [3] form-factor. It would be neat to be able to design the CPU in an HDL and then use a yosys backend that can synthesize it as a netlist of either discrete transistors or 7400-style logic. After seeing Robert&#x27;s design progress, this is starting to seem infeasible, but Olof Kindgren&#x27;s SERV core is pretty tiny and might just fit. Other people have already discussed doing something like this [4].<p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;RobertBaruch&#x2F;riscv-reboot" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;RobertBaruch&#x2F;riscv-reboot</a><p>[3] <a href="https:&#x2F;&#x2F;monster6502.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;monster6502.com&#x2F;</a><p>[4] <a href="https:&#x2F;&#x2F;twitter.com&#x2F;BruceHoult&#x2F;status&#x2F;1310747415075459073" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;BruceHoult&#x2F;status&#x2F;1310747415075459073</a><p>6. Low power Linux + Wi-Fi SoM. There&#x27;s a power consumption gulf between microcontroller and application processor based embedded systems, and no good options if you want to add Wi-Fi to a project, don&#x27;t want to consume a lot of power, and want a battle-hardened networking stack. I think a good solution to this problem might be to use a low-power application processor (like a Cortex-A7) and build a Linux system for it that is aggressive about sleep states and using DMA to transfer data from other parts of the system while the processor is asleep. The system would basically only wake up for mandatory housekeeping and to fire off network bursts. Like a Raspberry Pi, but instead of the default system image giving you a desktop, it&#x27;d give you a super minimal system that lends itself to running a single program with a standard, easy way to configure when to sleep&#x2F;wake, what to buffer up while asleep, and when to trigger network events.')