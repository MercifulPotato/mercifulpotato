Item(by='ordu', descendants=None, kids=None, score=None, time=1602311982, title=None, item_type='comment', url=None, parent=24733256, text='<i>&gt; You could easily have a synchronous http implementation which allows for printing to the console between receiving chunks of data from the network. And if you really didn&#x27;t want blocking to have a &quot;spinning&quot; activity indicator or something, you could still achieve it with threads.</i><p>One could do a spinning indicator, but not a label STALLED. To get this one need to restart read(2) every while, and there we come to implementation with complexity on par with async. Things become even more interesting if a program wants to process user input in async. UNIX-way is to send signals, but it is just plain ugly. dd from coreutils allows to use signals to trigger it to print progress, it is very inconvenient way to do it.<p>&gt; I think ultimately you&#x27;d have to decide based on the relative cost of including an entire runtime vs. just launching a second thread.<p>I&#x27;m not so sure. Runtime for user-space context-switching is very small. I did it for educational purposes at some time in the past with C. It is operation like save registers, switch stacks, restore registers and jump to another thread. If you have more than two threads, then you&#x27;d need some kind of structure to store all contexts and to decide which one to choose next. Add some I&#x2F;O code (like epoll) to track state of file descriptors, and you are done. One could do it without async, but it wouldn&#x27;t become much smaller, because it would be the same logic, just instead of stack switching program would recreate stack frames.')