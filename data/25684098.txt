Item(by='patrec', descendants=None, kids=None, score=None, time=1610109999, title=None, item_type='comment', url=None, parent=25674361, text='&gt; One other nicety I&#x27;d add that you don&#x27;t get from the Python stacktrace is the ability to inspect each frame to see the local bindings<p>No, you do get that. Even in the plain python interpreter you can do import pdb; pdb.pm() after an error to do post mortem debugging and walk up and down the stackframes and inspect or manipulate local variables. In ipython that happens automatically (if you run with --pdb) or after you type `debug` after an exception. And tooling for production stacktraces normally also captures local variables.<p>There are a bunch of additional niceties that Common Lisp has, such as turtles-most-of-the-way-down: you might eventually hit a foreign function call you cannot further inspect, but for most Common Lisp implementations almost everything is implemented in lisp. In python you a significant proportion are C extensions which are opaque to the built in debugger, although you can make gdb work. Also remote debugging is much more natural in common lisp.<p>Generally the stuff that is better about the debugging experience in python is in a way more superficial and the stuff that&#x27;s nicer in common lisp is much more fundamental, and yet, my experience is different than yours: the superficial stuff that python does well and common lisp does badly or simply less well matters more for overall productivity for most things I tend to do. This is although the debugger related stuff you can&#x27;t do as well with common lisp amounts more or less to minor friction whereas the stuff you can&#x27;t do with python is really hard to work around if you need it.<p>I think this is an object lesson on focussing on the (right) low hanging fruit.')