Item(by='naniwaduni', descendants=None, kids=None, score=None, time=1603264077, title=None, item_type='comment', url=None, parent=24843023, text='Sure. You could also multiply by 4, wasting <i>at worst</i> twice as much memory as optimal on pathological input.<p>But wait, why are you converting from utf-8 to utf-32? To iterate through? You don&#x27;t need to count your codepoints for that, you can just advance through your utf-8 linearly. To index into it? You might as well index into byte offsetsâ€”sure, that makes some possible indices invalid, but <i>so does the finite length of your buffer</i>.<p>And what are you doing with the codepoints anyway? utf-32 turns out to be <i>profoundly useless</i> for pretty much every concrete use case, because its whole appeal, that its code units map 1:1 to code points, presupposes that there&#x27;s <i>something you&#x27;d want to do with the codepoints</i>.<p>There isn&#x27;t. Code points are practically orthogonal to all of: user-perceived characters, user-perceived graphical symbols, grapheme clusters, text width. They combine arbitrarily in ways that you cannot infer without knowing the semantics of every possible code point. There is no linguistically sensible text operation you can do at the codepoint level. They are completely useless to you.<p>The worst part is, there are a lot of operations you can do with codepoints that <i>seem</i>, to cursory inspection, to do something you want. But they&#x27;re wrong, all of them, necessarily so, because you&#x27;re working at a level of abstraction that <i>does not have</i> the information needed to do just about anything correctly, but the cases that are broken are ones where none of your developers even know what the <i>correct</i> result should be.')