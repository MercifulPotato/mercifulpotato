Item(by='lmm', descendants=None, kids=[25533124, 25540322], score=None, time=1608857160, title=None, item_type='comment', url=None, parent=25526141, text='&gt; a) CI fails, because changes in master in the meantime make it so your branch now triggers a test failure or merge conflict whereas before it didn&#x27;t. We can ignore this, scenario, because nothing lands till<p>No we can&#x27;t, because what do people do in this scenario? They make a new commit that fixes the tests, but leaves a long chain of previous commits broken.<p>(Also in a big enough codebase with enough collaborators it becomes impractical to require CI to pass against the absolute tip of your shared development branch before merging, because in the time it takes to run CI there will always have been more changes landing in that shared branch).<p>&gt; 1. You don&#x27;t didn&#x27;t use rebase -x (why not, if you carefully test all individual commits on the feature branch?)<p>I&#x27;ve never known anyone to actually use -x. Maybe a very dedicated individual could, but there&#x27;s no way you&#x27;d be able to enforce it across a team (unless that team is in the habit of making feature branches that are just a handful of big commits - but in that case you might as well just squash-merge). Pulling changes from master and resolving any conflicts is already a frustrating interruption; making it take 20x longer is a non-starter.<p>People don&#x27;t carefully test all individual commits, but that&#x27;s ok. Even the most casual testing will catch when a commit simply doesn&#x27;t compile, and introducing a compilation error in manual code changes is much less common than introducing a compilation error when pulling changes from master. And in the worst case, an <i>isolated</i> non-compiling commit in history is not too much of a problem to skip when bisecting. The problem only comes when you have a long chain of non-compiling commits - which is exactly what rebasing tends to produce.')