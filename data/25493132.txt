Item(by='_ph_', descendants=None, kids=None, score=None, time=1608539512, title=None, item_type='comment', url=None, parent=25492366, text='&gt; In general it takes five times as much memory for a GC&#x27;d program to be as performant as one with explicit memory management.<p>In this blanket form, the statement is just wrong. Yes, with GC you need to have a larger heap space, as unreferenced objects will remain on the heap until collected and you want to have enough heap space so collections are infrequent enough, that a lot of objects can be collected (especially with generational GC, you want low survivor rates in the youngest generation).<p>However, how much space you want to reserve for that depends on many factors. Usually the extra space is proportional to the allocation and deallocation rates, not the total heap size. If you have lots of data on the heap which is long-living, this doesn&#x27;t count to the extra space. Which leads to the allocation behavior of your program in general. If you want best performance, your program shouldn&#x27;t blindly create garbage, but only, where it is needed. A lot of data can be stack allocated, so not counting towards the GC. And of course, you can have some amount of memory manually managed (depending on language), for bulk data. Be it entirely allocated outside the GCed heap or by keeping references alive to memory that manually gets reused. In all of these cases, this doesn&#x27;t really count towards the extra space calculation.<p>The programming language used plays a huge role in this and the paper you quoted uses Java, which is a quite allocation-happy language, so the heap pressure is higher and you need more extra space to be performant.')