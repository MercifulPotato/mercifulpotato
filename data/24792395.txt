Item(by='magicalhippo', descendants=None, kids=[24792794], score=None, time=1602788257, title=None, item_type='comment', url=None, parent=24789904, text='Well I mean you might need quite a number of random numbers  per second, in this case 32bit floats was what we used.<p>Even fairly trivial scenes can require over 20 random floats per sample and more complex scenes over 100. And you want to actually <i>use</i> those random numbers for calculating reflections, intersections etc. In the renderer I worked on the PRNG typically took at most 10% of total CPU time.<p>So assuming the above those 4GB&#x2F;s would translate into less than 5k samples&#x2F;sec, which would be considered quite slow.<p>Just to refresh my memory I just ran a quick test with a fairly simple scene. There&#x27;s 6 samples for the camera, at least 3 per path vertex up (depth 32) and another 2 per light (8 in this scene). There might be some more I&#x27;m forgetting but lets use that a lower bound. For this scene then that means 6  + 3 * 32 + 2 * 8 = 118 random numbers per sample. On a single core I got 14.04kS&#x2F;s, so that works out to at least 1.6M random numbers per second.<p>And this renderer was focusing more on physics and fidelity rather than speed. For animations and similar you&#x27;d need a renderer that&#x27;s at least an order of magnitude faster than the one I worked on.<p>For reading further you could try PBRT[1]. It&#x27;s a great book but not free. Luckily enough though the free chapter is about sampling and reconstruction so you can get a feel from that what is needed.<p>[1]: <a href="https:&#x2F;&#x2F;pbrt.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pbrt.org&#x2F;</a>')