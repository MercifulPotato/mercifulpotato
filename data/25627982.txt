Item(by='hardwaresofton', descendants=None, kids=None, score=None, time=1609735290, title=None, item_type='comment', url=None, parent=25619388, text='&gt; I don&#x27;t think declarative programming exists. I think it&#x27;s just a regular old program with a poorly defined interface. Moreover, I think the claims of idempotence are overblown to the point of near falsehood.<p>I think this really depends on how you define the term &quot;declarative programming&quot; -- pinning down a singular meaning and a singular interpretation is really hard. If we think about it like a spectrum, there&#x27;s a clear difference between ansible and terraform like there is with python and prolog. That&#x27;s &quot;declarative&quot; enough for me.<p>Idempotence is also really tricky and hard -- I&#x27;m not surprised most large codebases can&#x27;t handle it, but getting close is definitely worth something.<p>&gt; Declarative Infrastructure is really just Configuration Management applied to cloud infrastructure rather than operating system software. Neither have really solved anything, other than turning the management of complexity into a Sisyphean task. Forever pushing drifting state back up the hill.<p>While I agree on declarative infrastructure being configuration management applied to cloud infra (especially in the literal sense), I would argue that they <i>have</i> solved things. In the 90% case they&#x27;re just what the doctor ordered when compared to writing every ansible script yourself (or letting someone on ansible universe give it to you) -- and ansible actually supports provisioning! The thing with this declarative infrastructure push is that it&#x27;s encouraged the companies themselves to maintain providers (with or without the help of zealous open source committers), so now someone else is writing your ansible script and it has a much better chance of staying up to date.<p>&gt; Compare this to Immutable Infrastructure, where state never drifts. One never &quot;fixes&quot; a container once deployed, or a package once built and installed. One merely rolls back or upgrades. Any uncertainty is resolved in the build and test process, and in providing both all the dependencies and the execution environment.<p>People are often using these two concepts in tandem -- the benefits of immutable infrastructure are well known, and I&#x27;d argue that declarative infrastructure tools make this easier to pull off not harder (again, because you don&#x27;t have to write&#x2F;maintain the script that puts your deb&#x2F;rpm&#x2F;vm image&#x2F;whatever on the right cloud-thing).<p>&gt; I think eventually people will wise up to the fact that Terraform is just puppet for infrastructure. I think the real fix is to make the infrastructure less like an operating system and more like versioned packages. Install everything all at once. If anything changes, reinstall everything. Never allow state change.<p>Agreed, but I&#x27;m not sure this is very practical, and there&#x27;s a lot of value in going part of the way. There is a lot of complexity hidden in &quot;reinstall everything&quot; and &quot;never allow state change&quot;, and getting that going without downtime -- it requires the cooperation of the systems involved most of the time, and you&#x27;ll never get away from the fact that there is efficiency lost.<p>But again, we were talking about the scripts you&#x27;ll have to write -- in a world that is not yet ready for fully immutable infrastructure, it&#x27;s just a question of how you write the scripts, not whether an option exists that will prevent you from writing them all together (because there isn&#x27;t, and most things are not fully immutable-ready yet).')