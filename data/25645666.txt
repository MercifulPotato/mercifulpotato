Item(by='bluecalm', descendants=None, kids=[25649254], score=None, time=1609856029, title=None, item_type='comment', url=None, parent=25641815, text='&gt;&gt;If your new C program is faster than your old C++ program, then you may simply rename files from &quot;.c&quot; to &quot;.cc&quot;. Then, you have two C++ programs, one faster than the other.<p>While C++ isn&#x27;t an exact superset of C it&#x27;s close enough but it&#x27;s not the point. The debate is about how the languages are used. Otherwise you could always say &quot;yeah, use inline assembly and don&#x27;t use any abstractions with the exception of structs, pointers and arrays&quot;.<p>&gt;&gt;Available C++ hash table libraries have benefit of overwhelmingly more optimization attention than could be afforded on behalf of a single program, and they deliver that performance to all dependent programs.<p>They are also general purpose. When you have something specific to optimize you will always beat general solutions.<p>&gt;&gt;Every programming project is an exercise in practical economics: your strictly-limited available attention goes where you choose. The greater productivity of coding in a more powerful language frees up attention that may then be allocated to areas that would otherwise suffer neglect.<p>Sure. The debate is about what is faster though and then C++ is not faster than C but C is often faster than even slightly idiomatic C++ and much faster than C++ with all the modern features used frequently. You will get stuff done faster in a higher level language of course but that besides the point of debate which language is faster where performance matters.<p>&gt;&gt;Whatever amount of attention you devote to making code in a poor language work at all, you may spend a fraction of coding in a better language, and the balance on other beneficial uses, such as better performance.<p>I don&#x27;t agree C is a poor language. It&#x27;s quite a common view as well. A lot of people who are good at low level stuff prefer C to C++ because the language is simple, easy to read and easy to reason about. C is poor at some things, it&#x27;s fantastic for others. I personally love the language and it&#x27;s my choice for many weekend projects.<p>&gt;&gt;That the new program is faster than the old program reliably demonstrates that the old program was not so well optimized as you suggest. (Your comment elsewhere, that &quot;the whole project uses only [a] minimal set of C++ features&quot; reveals perhaps more than you intended.) One may surmise that the old program&#x27;s authors spent more of their limited attention on its effectiveness at playing chess than the latter program&#x27;s author needed to.<p>Stockfish is a big decade+ old and still heavily developed community project with tens of programmers contributing to it. A lot of attention was given to it and to optimizing specific parts of it. Still, it&#x27;s written in C++ in usual (although still very minimal) style and there is cost to it.<p>&gt;&gt;That the third, assembly-language program is faster still demonstrates that the previous programs left performance on the table.<p>Well, my experience is that people good at assembly run circles around very good C&#x2F;C++ programmers. I would go as far as to say that it&#x27;s hard to take anyone who doesn&#x27;t realize it seriously. There is just so many things you can&#x27;t do in C&#x2F;C++ even with today very smart compilers.<p>&gt;&gt;My experience is that it is not hard to double the speed of a typical program just by paying attention to cache and pipeline effects. Most likely, the asm coder just happens to know more about those effects, knowledge that could as well have been applied to the others. Most programs seem fast enough exactly until another, faster one comes along; then they are instantly slow.<p>You just don&#x27;t get it.\nStockfish is a program which depends on being fast. Making it fast is the number one priority. A lot of very smart people spent hundreds of hours optimizing small parts of it like the best way to generate chess moves in as few CPU cycles as possible, designing the hash table to minimize cache misses etc.<p>If you can make Stockfish 2x faster you would be considered the prophet of programming and your statues would be raised in cities around the world. Seriously, it&#x27;s not some average random code which you can make faster applying concept you happen to see on front page of Hacker News. We are talking about the code where performance matters. All the people working on such code know a lot about all the concepts you mentioned because they apply them day to day.<p>Anyway, CFish, asmFish and Stockfish are all open source projects. You can find them on Github. You can ask the authors why they think their stuff is faster if you are curious about it. I mean maybe it&#x27;s worthwhile to understand why someone chooses to do all the work to re-write a popular community project to C or asm. It&#x27;s a lot of difficult work. They might know something you don&#x27;t.')