Item(by='crazyloglad', descendants=None, kids=None, score=None, time=1604316009, title=None, item_type='comment', url=None, parent=24964011, text='Xorg is better, but not by much. On write-fail they setup an internal buffer ~16k and if that one is saturated it is closed (that + whatever the kernel has). The protocol&#x2F;packing is not that busy in the server to client direction so it lasts for quite a while.<p>The way the disconnect happens is interesting though, I am not certain enough about the threaded-IO implementation in regards to hotplug but a quick glance looks like if a hotplug occurs at the same time a client is disconnected the sparse allocation requirement of open() could get an input device confused as a client as it is cleaned up. The odds of that happening though :D<p>In the wayland code it looks like they tried to have a buffer strategy at some point, but then got too clever for their own good (epoll designs + asynch-OO projected over C is... yeah) and somewhere in &#x27;closure&#x2F;write&#x2F;buffering to lower #syscalls&#x2F;callbacks&#x27; landed in a long chain of error propagation and immediate kill.<p>The best way I found (hence using it) is to have memory mapped ring buffers and just have an atomic head-tail indicator. This makes file-descriptor transfers (DuplicateHandle from win32 fame is just so much prettier) messier, but it means that you can have a recovery strategy and see the backpressure buildup and rate-limit. Since it is mostly input events or &#x27;drag-resize&#x27; (and those can be merged) in that direction, silently dropping them and have mouse cursor &#x27;jank&#x27; is better than losing your work. If all else fails, the watchdog handle is pulled and the client is set to migrate to a fallback server (if set).')