Item(by='infogulch', descendants=None, kids=[25838528], score=None, time=1611087185, title=None, item_type='comment', url=None, parent=25836398, text='I feel like we will continue to run into these kinds of issues to the end of time unless can figure out: 1. How to precisely describe the properties we want the final system to have, 2. How to &#x27;compile&#x27; from a higher-level language&#x2F;layer into a lower-level language while maintaining all those properties. At the least this will require us to: 3. Define the precise semantics of each layer and enforce that every construction in and implementation of that layer to adhere to it strictly.<p>Properties like &quot;no private data is accessible until the user consents&quot;, &quot;the final result of the algorithm is independent of the order that messages are received&quot;, &quot;decryption must be constant-time and the program must not have any observable effect until the message is known to be verified&quot;, etc. Obviously these properties as stated are incomplete and imprecise, but that&#x27;s my point: we have to figure out how to make these kinds of statements precise enough.<p>Layers&#x2F;languages should verifiably maintain these properties through every translation via paths like: eula&#x2F;privacy policy, requirements, UX, UI, state machine, source code, AST, IR, ASM, machine code. Every one of these layers should have a well-defined execution model that is isomorphic with other layers, modulo metadata. For example: source code === AST [+ comment&#x2F;whitespace&#x2F;filesystem metadata], AST === IR [+ name&#x2F;desugaring&#x2F;applied-optimizations metadata]. All undefined behavior at every layer must be exterminated by definition or avoided by construction.<p>One problem is that we throw away too much metadata when moving between layers which makes the task of maintaining these properties through many layers extremely difficult. For example, trying to implement constant time algorithms in a high-level language is nearly impossible to hold over time (robust to changes in source and compiler) because the compiler&#x2F;optimizer has forgotten (or was never told) what parts must be done in constant time and to not use the partial results of the algorithm until it has completely finished. To implement this, all candidate implementation strategies and optimizations in the lower layer must be identified by whether they preserve constant time execution or not, and optimizer&#x2F;compilation unit (CU) boundaries inserted to prevent an over-eager optimizer for a non-constant-time CU to observe partial results. Etcetera for every other desirable property and every layer.')