Item(by='jiggawatts', descendants=None, kids=None, score=None, time=1601809041, title=None, item_type='comment', url=None, parent=24677366, text='Roughly speaking, you can do things like the following:<p><pre><code>    &lt;!-- The special XMLNS attribute binds a short alias to a long name --&gt;\n    &lt;p:parent xmlns:p=&quot;urn:some:unique:string&quot;&gt;\n        &lt;c:child xmlns:c=&quot;urn:some:other:child:name&quot; x=3 y=5&gt;\n            &lt;c:subchild&gt; &lt;!-- No need to repeat the fully qualified unique name --&gt;\n                &lt;p:tada&gt;You can even interleave!&lt;&#x2F;p:tada&gt;\n            &lt;&#x2F;c:subchild&gt;\n        &lt;&#x2F;c:child&gt;\n     &lt;&#x2F;p:parent&gt;\n</code></pre>\nNote that while this is possible to write by hand, typically namespaces are for documents generated and processed by tools. The XML Schema Definition (XSD) format has full support for namespaces, so you can define documents based on modular chunks. E.g.: you can &quot;import&quot; the SVG namespace into a diagramming XML document format namespace, but restrict its usage to only the child nodes of an &quot;img&quot; tag. Or MathML as the children of &quot;graph&quot; nodes. Both SVG and MathML can potentially import a shared &quot;font&quot; namespace. Or whatever.<p>In the XML Reader API, each element has a &quot;fully qualified&quot; name that includes the long namespace prefix. If you use the API correctly, your tool can handle nested documents, or gracefully ignore them if it&#x27;s appropriate.<p>The fiddly part is making this efficient, i.e.: avoiding a full string comparison against a long URI or URN. You typically have to &quot;register&quot; the namespaces you&#x27;re interested in, and the API gives you some sort of efficient token instead of a string to use from then on.<p>I&#x27;m not saying it&#x27;s <i>perfect</i>. Nothing is in XML. It was designed by committee, it brought too much of the legacy SGML baggage with it, but its namespace capabilities are a lot better than <i>nothing at all</i>, in much the same way that C# or Java don&#x27;t have perfect type systems, but they&#x27;re superior to loosely typed languages.')