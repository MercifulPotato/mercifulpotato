Item(by='itamarst', descendants=None, kids=[25957311], score=None, time=1611925661, title=None, item_type='comment', url=None, parent=25956502, text='I&#x27;ve been playing with PyO3 for prototyping, and wrapped some Rust code to see if it&#x27;s faster than Python. The experience was very much like using Boost Python (whcih these days has alternative with <a href="https:&#x2F;&#x2F;github.com&#x2F;pybind&#x2F;pybind11" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;pybind&#x2F;pybind11</a>). It&#x27;s _really_ easy to wrap code for Python, and it has nice APIs to ensure GIL is held. Being Rust, I&#x27;m much more confident I won&#x27;t suffer from memory unsafety issues which my C++ at the time did.<p>Now I&#x27;m starting to use it as part of the Python memory profiler I&#x27;m working on (<a href="https:&#x2F;&#x2F;pythonspeed.com&#x2F;fil" rel="nofollow">https:&#x2F;&#x2F;pythonspeed.com&#x2F;fil</a>), in this case to call in to the low-level Python C API which PyO3 includes bindings for in addition to its high-level API. This kind of usage is more like writing C, except with the benefit of having high-level APIs (for GIL holding, but also object conversion) available when I need it.<p>So basically you get safe, high-level, easy-to-use APIs, with fallback to low-level unsafe APIs if you need them.<p>Highly recommend trying it out.')