Item(by='acdha', descendants=None, kids=None, score=None, time=1610765656, title=None, item_type='comment', url=None, parent=25798920, text='&gt; You&#x27;re conflating the monstrosity of J2EE (which admittedly was a mess, and completely unrelated to Java itself) with the &quot;Java Language&quot; by which I mean the syntax of the language itself.<p>I&#x27;m not sure how well you can separate that: most people are going to hit those bumps when they get started, and they&#x27;re going to see an ongoing frictional cost against their productivity. Yes, there are some neat things in the language — especially newer versions — but there are a lot of people who would benefit a lot from, say, a “Java: the good parts” distribution which makes it easy to start a new project and evolve it, and then SEO it as much as possible so people get that advice rather than the 10+ year old stuff many web searches will have highly ranked.<p>I do think there&#x27;s an interesting alternate history where WebAssembly happened many years earlier in the form of Java byte-code. That would have lost a lot of the ability to read other people&#x27;s code but it would have had better performance earlier and a good story for language competition which has brought many good features to Java from other languages. Unfortunately, after around 1997 or so that really came down to Microsoft so it would have been VB or C# in any case.<p>XML is interestingly similar where the core language community charged ahead building ever more standards on top of it but assumed that its inevitability meant someone else would fix their … not great … tools, specs, and examples for them — and then were surprised when almost everyone abandoned them for easier tools. I always liked the idea of XPath but it&#x27;s effectively never moved past 1999 unless your world exclusively avoids libxml2, which wasted most of the hard work the standards group did.<p>One thing I think may be common about both of those is a big shift in how easy it is to build and ship development tools and programs: a 90s programmer had to live with what they got in a distribution to a much greater extent because you couldn&#x27;t count on everyone having an internet connection, a fast one, package management hadn&#x27;t happened much outside of the Linux&#x2F;BSD world, and new things required waiting for someone to write a book you could order, finding a local user group, asking in Usenet, etc. Warts in your language still mattered but less so since for many people it was easier to keep using something than switch. After the 2000s, though, I think a lot of people realized that the cost of switching was so low that they had to care about developer ergonomics a lot more unless they had something like the massive platform pull Apple had with Objective-C and Microsoft had with C#.')