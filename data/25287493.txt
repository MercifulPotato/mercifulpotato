Item(by='ahaferburg', descendants=None, kids=None, score=None, time=1606990555, title=None, item_type='comment', url=None, parent=25274094, text='You have other options. You could design your own bytecode, and write an interpreter. You could emit C, and use a C compiler. If you use LLVM, you also need to decide whether you want to link against LLVM and use the C++ API. Or you can use bindings for another language. Or you can emit IR as plain text, then feed that into the LLVM compiler.<p>I have done the latter, and would advise against it. The IR is powerful, but quite involved. The documentation is sometimes lacking. It&#x27;s an interesting project, but you probably won&#x27;t get far.<p>Linking against LLVM means you have to use their C++ interface, and every time you rebuild your compiler, it&#x27;s going to be slow, with all the templates they use. Your compiler will be a large executable (clang and zig are about 90 MB), and you&#x27;d have to rebuild that every time you change your compiler. I would hate having to do that in my spare time, which is why I went the other route.<p>LLVM is very powerful. There&#x27;s all these optimizations you get, and debug info. But it&#x27;s not free. The integration is going to be hard and you&#x27;ll have to spend quite some time on it.<p>The next time I would start a language project I would build an interpreter in a dynamic language, and possibly even use a parser generator. <a href="https:&#x2F;&#x2F;craftinginterpreters.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;craftinginterpreters.com&#x2F;</a> has a nice path laid out. Focus on what you actually want to do. Once you get somewhere, once you actually like your language, once you actually start a project in your own language, and have an actual need for more, you can write another compiler with more bells and whistles.')