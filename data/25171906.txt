Item(by='eyelidlessness', descendants=None, kids=None, score=None, time=1605985516, title=None, item_type='comment', url=None, parent=25157667, text='I know there’s a zillion libraries in this space by now (and so far I’ve found io-ts quite good), but I feel like there’s actually room for more, with some features currently missing from all of them. (So I’m working on one!)<p>The dynamic JS space uses things like JSON Schema because they provide documentation and enable runtime validation, in a similar way to libs like io-ts. But they also provide API&#x2F;network boundary documentation, as well as enable automatically generating client libraries (regardless of the client’s stack).<p>There’s a good opportunity for a library with all of these value propositions:<p>- simple, declarative, composable definition interface<p>- runtime validation&#x2F;decoding&#x2F;encoding<p>- DRY static type generation<p>- DRY standards-based documentation generation<p>There are (to my knowledge) no tools available providing all of those in one package. But I’ve built one (it was built on top of io-ts), so I know it can be done. But it was proprietary, for an employer, so I can’t share it.<p>But! I learned a lot in the process, and I’m building a new one. Zero dependencies, fundamentally a different design&#x2F;approach. But I’ll definitely be sharing it with HN when it’s ready.<p>Edit to add: another thing is that many of the tools that provide some subset of those goals (especially static types &lt;-&gt; JSON Schema tools) require is out of band code&#x2F;file generation (eg supply JSON Schema file input, get .d.ts file output, or vice versa). IMO this is additional DX friction and more error prone than the runtime&#x2F;compile time parity of the common TS libraries. So another goal for my project is that the default approach is to define one interface and have APIs available to access all the other representations in the same flow, with file generation a secondary concern if there’s a need&#x2F;desire.')