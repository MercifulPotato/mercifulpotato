Item(by='proverbialbunny', descendants=None, kids=None, score=None, time=1606927855, title=None, item_type='comment', url=None, parent=25271932, text='I have to push to get them hired sometimes.<p>Technically they&#x27;re infrastructure software engineers without the title, but most people don&#x27;t know what that is, so it can be easier to call them data engineers.  The company doesn&#x27;t give titles like that, they&#x27;re just &quot;the cloud people&quot; with a vanilla software engineer title.<p>Unless you&#x27;re a BI &#x2F; business analyst, there are probably software engineers that work with AWS &#x2F; gCloud at your company, who setup the database(s) and do the backend.  What you want to do is called an IT request, where you request they help out when you need to productionize.  It&#x27;s bad form for a data scientist or any other kind of researcher to have the keys to the live production servers.  While it can be fun to learn that stuff, there is a barrier of entry, specially monitoring software and unit tests.<p>This is more on the PM (or DPM (data project manager)) side but: <a href="https:&#x2F;&#x2F;www.datascience-pm.com&#x2F;domino-data-science-lifecycle&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.datascience-pm.com&#x2F;domino-data-science-lifecycle...</a> can give a good map of the process.  Many who do research are on their own, not apart of larger teams and are disconnected, so they don&#x27;t know what options they have.  Maybe that roadmap can help, depending on your situation.<p>When it comes to productionization, I&#x27;ve had too many years of software engineers rewriting my models and adding bugs left and right.  The second they want to rewrite it from a notebook into a py file (or equivalent language, usually Java), I get cautious.  I find the best process skips these issues and the software engineers will thank you for it:  Automate most of the productionization process.  Using notebooks as an example, python has libraries that can import notebooks, so you don&#x27;t have to copy paste code into a py file.  Instead an OOP wrapper (which they love) can be written with the interface they like.  They can do the IO like streaming data or batching or whatever.  They can do the unit tests and monitoring part.  What you can do is write the function calls inside of the interface.  Usually you want a .predict() method, similar to how ML algos work, but .run() is popular too.  Inside of that, put all of the functions from the notebook you want called and in what order.  In metaphor it&#x27;s like writing a header file in C or C++.  This py file will then import the notebook and call those functions.<p>The beauty of this is at least four fold: 1) no new bugs 2) no explaining how the model works, because you&#x27;re doing that part and 3) If you want to update the model, you can update the notebook and then no work needs to be done in the py file.  It&#x27;s importing the notebook, so it will import the changes.  It&#x27;s fully automated.  4) You can have EDA, plots, documentation, all that stuff that usually takes up 40-60% of the notebook, not be required to remove it, because it will not get called.<p>The only downside is that every cell in the notebook that the py file will call needs to be wrapped in a function.  However, this is a good idea by default, because you&#x27;ll get global variable type bugs when you run the cells out of order if your cells are not wrapped in a function, so to avoid that you&#x27;re probably already writing functions in your notebooks.<p>*Sometimes code has to go fast, and notebooks tend to use dataframes, which is fine for 99% of the work out there.  In that case, instead of having the software engineers rewriting my model, because of the problems mentioned above, I will instead 1) Write libraries in C&#x2F;C++ that accelerate parts of the notebook. And if that can&#x27;t be done I will 2) write the model directly while prototyping in a language like Rust, C, C++, or Java.  I&#x27;d rather write it than have someone port it.  Most will not do this, because it&#x27;s beyond the average researcher&#x27;s skill, but it alleviates so many problems, and I&#x27;m not afraid of statically typed languages.')