Item(by='phaedrus', descendants=None, kids=None, score=None, time=1601907020, title=None, item_type='comment', url=None, parent=24687287, text='Something I&#x27;ve found applying Value Oriented Design to C++ is that it often leads to freeing designs of arbitrary limitations that weren&#x27;t clear beforehand but in hindsight you realize, &quot;well, of course I should also be able to use it this (other) way.&quot;<p>For example I&#x27;m porting a parser engine, implemented in another language, to C++ and it wasn&#x27;t clear what the hierarchy of objects should be for the purpose of RAII (because there are circular dependencies) (the original implementation language was garbage collected).  The original implementation loaded a grammar file and directly created objects with pointers (originally, references) to other objects.<p>I introduced an intermediate layer where the file is first read into data structs which hold the integer values from the file.  So instead of objects pointing to objects, the links are implicit because of things having the same index.  The representation of the loaded grammar file is now copyable, moveable, immutable, etc.  A side effect is it&#x27;s trivial to tell whether the file loading code is correct or not when the result is just the same data with structure applied to it, rather than having the added dimension of determining whether a graph of objects are correctly relating to <i>each other</i>.<p>Then I construct the actual parser engine objects from the data representation structs.  True that didn&#x27;t in itself solve the RAII-hierarchy problem, but what it did do is make it easier to isolate that problem to just the domain of <i>how the objects are used</i> and not commingling that with the problem of <i>how the file is loaded</i>.<p>The epiphany I spoke of is that after this refactor, it became clear:  the file is arbitrary.  For testing, or for use of the parser with a grammar which does not change, I could dispense with the file load step and just encode the grammar directly in value-structs.<p>Why I think this is significant is that &quot;the way I was trained&quot; to think of making code like this unit-testable is to mock the file reading interface.  That&#x27;s a lot of work for something that&#x27;s only necessary because of an over-emphasis on objects and <i>behaviors</i> instead of thinking about data and <i>values</i>.')