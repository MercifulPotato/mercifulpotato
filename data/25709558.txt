Item(by='hardwaresofton', descendants=None, kids=None, score=None, time=1610250650, title=None, item_type='comment', url=None, parent=25708551, text='I don&#x27;t think any ML languages are going to be able to qualify for best language for fast development. They are a paradigm shift for too many developers, which means you&#x27;re going to pay a price getting up to speed.<p>Compilation time is generally <i>not</i> the bounding factor for development speed these days. Theoretically, compile time is zero for scripting languages so that&#x27;s at least one point against weighing compile time heavily. I think the key benefit of OCaml and other ML langauges over Rust right now is actually higher kinded types, dependent types, and things in that realm of abstraction -- which you&#x27;re probably <i>not</i> going to be using unless they&#x27;re built into some library you&#x27;re making use of, so the benefit is kinda moot there. Feels like the best power&#x2F;weight for abstractions in codebases is the typeclass (or Traits in rust), most of the stuff above that is not great for fast development unless it&#x27;s already in place.<p>And if we&#x27;re talking about ML languages, I&#x27;m firmly in the Haskell camp because I think it has a better ecosystem (more than any research language should), an incredibly good runtime system (they&#x27;ve got the best native+green thread implementation I&#x27;ve ever seen), and fantastic abstractions for working with shared memory (when you need that). The whole &quot;if it compiles, it works&quot; is generally true. No need for a holy war, but if OCaml is in the race for fast development (which means that ML is in the race), then I&#x27;d pick Haskell over it to start on ecosystem&#x2F;adoption, production readiness and features -- if you can manage to keep your developers from climbing the ladder of research-level abstraction.')