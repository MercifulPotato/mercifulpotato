Item(by='chowells', descendants=None, kids=None, score=None, time=1602546541, title=None, item_type='comment', url=None, parent=24760007, text='There&#x27;s a lot good in there, but the laziness section is missing one key insight still: you have to think of strictness in terms of evaluation dependency. For Int, (+) is strict in both arguments. That doesn&#x27;t mean throwing a + b someplace causes a and b to be evaluated. It means that after the expression a + b has been evaluated, both a and b have been evaluated (at least as long as the result is non-bottom). Since it&#x27;s a direct data dependency, you know a bit more. You specifically know a + b must evaluate a and b before it adds them.<p>That&#x27;s not necessarily true with all strict evaluation. You can use seq to create an evaluation dependency between two values that need not care about ordering. If c = seq a b, the when c is evaluated, both a and b will have been evaluated, and c will evaluate to the b. But there is explicitly no ordering there. The compiler may choose to evaluate either a or b first, by whatever metrics it wants.<p>It takes a lot of practice to get the hang of thinking about evaluation like this. But it&#x27;s the key to not having memory use problems in Haskell while also not breaking code with unnecessary strictness.')