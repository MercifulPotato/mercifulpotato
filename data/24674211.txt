Item(by='deathanatos', descendants=None, kids=None, score=None, time=1601754336, title=None, item_type='comment', url=None, parent=24672137, text='&gt; <i>HTTP&#x2F;2 and HTTP&#x2F;3 seem to be non-trivial to hand-roll. HTTP&#x2F;1 is a pretty simple request-reply design.</i><p>HTTP&#x2F;1 has enough edge-cases to balance that scale back out:<p>* chunked transfer encoding; there can be extensions with chunks<p>* trailers (headers that appear after the body)<p>* Expect &amp; 100-continue can mean &gt;1 &quot;response&quot; for a single request; also, you can&#x27;t process this header for a HTTP&#x2F;1.0 client, as it didn&#x27;t exist then. (And you can&#x27;t send it inadvertently to a &#x2F;1.0 server, as you&#x27;ll never get a 100-continue back!)<p>* HEAD is an absolute anomaly in terms of handling the response-body; you have to know you <i>sent</i> the HEAD, as the response will likely contain something like &quot;Content-Length: 100&quot; but there won&#x27;t be 100 bytes of body to follow.<p>* If you handle obs-folded headers, obs-folded headers. Though, they&#x27;re now an optional part of the specification, as they&#x27;re obsolete. (But in that case, one still has to correctly 400 the request.)<p>Some of these exist, of course, in some manner in HTTP&#x2F;2, but they&#x27;re often more straight-forward to parse due to the binary nature of the protocol.')