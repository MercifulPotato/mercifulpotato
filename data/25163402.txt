Item(by='10000truths', descendants=None, kids=[25163935, 25163881], score=None, time=1605897407, title=None, item_type='comment', url=None, parent=25162706, text='The whole <i>point</i> of FFI is that it&#x27;s a lowest common denominator - it&#x27;s a <i>foreign</i> function interface, meant for interop between two potentially wildly different runtimes, up to and including assembly language. That means it can&#x27;t rely on quirks like language-specific type information or bounds checking. The only thing that all runtimes on a machine are guaranteed to have in common is that they use the same set of memory and CPU registers, so that is all that FFI can use to define subroutine interfaces. Hence terms like &#x27;ABI&#x27;, &#x27;calling convention&#x27; and &#x27;memory layout&#x27;.<p>The good news is that whatever issue you have can probably be solved without resorting to FFI. There are plenty of other interop options - for example, if you control the library, you can use your operating system&#x27;s IPC mechanisms with an agreed-upon serialization format. Or, if your library and application are within the same ecosystem, you can use language-specific library management features such as Python&#x27;s import or Rust&#x27;s crates. FFI is a bit like C itself - if you&#x27;re reaching for it as a solution to your problem, then your finger is already on the trigger of the footgun.')