Item(by='jcranmer', descendants=None, kids=[25168392], score=None, time=1605940773, title=None, item_type='comment', url=None, parent=25167823, text='Is it really so hard to find instruction length in x86? State machines are associative, and therefore you can build a reduction tree for parallel processing of them. And the state machine itself isn&#x27;t too bad: it&#x27;s mostly prefixes, and figuring out if the opcode uses a ModR&#x2F;M byte (which most do) or has an immediate operand. And while x86 does have a nasty habit of packing multiple instructions into a single opcode (via specific register values in the ModR&#x2F;M byte), I believe all of them would share the same behavior in the immediate operand effects.<p>I suspect that in one pipeline stage, you could at least resolve the entire cacheline into the individual instruction boundaries that can be simultaneously issued into uops, if not having the entire instruction decoded into the hardware fields. You wouldn&#x27;t know if register 7 referred to a general purpose register, or a debug register, or an xmm reg, or whatnot, but you&#x27;d probably know that it was a register 7.')