Item(by='omazurov', descendants=None, kids=None, score=None, time=1608532383, title=None, item_type='comment', url=None, parent=25485679, text='<i>&gt; Shared mutexes are ruled out trivially, because as soon as one thread obtains the mutex, your worst enemy could simply never schedule that thread again.</i><p>Another possibility is that the thread dies while holding a mutex (or exclusively possessing a resource). It may seem like a stretch for shared memory systems, but not so much for distributed systems. Recovering the resource is not an easy task, especially considering the fact that recovering threads may also die or that the thread assumed dead all of a sudden returns to life. In my opinion, making a parallel system robust to that kind of malfunction goes far beyond what the industry considers acceptable as lock-free algorithms.\nI gave some thought to that scenario in my project Robusta [1]. I doubt it could be useful for any practical purpose but at least it works for a universal computational model.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;OlegMazurov&#x2F;Robusta" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;OlegMazurov&#x2F;Robusta</a>')