Item(by='PhantomGremlin', descendants=None, kids=[25102316], score=None, time=1605447758, title=None, item_type='comment', url=None, parent=25098616, text='<i>Therefore the memory controller had to keep track of when &amp; what was accessed?</i><p>It was much more simple than that.<p>A typical DRAM of the era had 128 rows (at least as externally visible; what&#x27;s inside is up to the DRAM implementer).<p>So in a higher end system the memory controller, about every 15 microseconds, would increment a 7-bit binary counter. It then would command all the DRAMs to simultaneously do a refresh cycle with this specific row address. This refresh took priority over normal read and write.<p>No need to optimize refresh by skipping it for rows which had recently been accessed. Just blindly refresh all 128 rows in sequence.<p>Internally a 16k bit DRAM would have 128 rows and 128 columns. Each time a row is read, all 128 associated columns are read in parallel. Then the contents of the selected single column are output. That&#x27;s what makes refresh work without consuming too much of the chips bandwidth. A refresh of a row results in all 128 columns of that row being refreshed.<p>It takes about 2000 microseconds to do 128 refreshes. That&#x27;s often what the DRAM chip was specified for. In reality the chips could often retain content for a minute at room temperature. It was when operating at the limit of 70C that refresh every 2 milliseconds became close to necessary.<p>Some microprocessors of the era, such as the Z80, had an internal 7 bit counter. The Z80 could be easily set up to send this 7-bit counter out to the DRAM after every instruction fetch.<p>So a Z80 system did something like this:<p><pre><code>   fetch an 8-bit opcode\n   refresh the next 1 of 128 rows of DRAM\n   fetch additional instruction bytes\n   complete the instruction\n</code></pre>\nSince a Z80 operated at about 2 MHz minimum and instructions completed in about 6 cycles, DRAM memory was being refeshed, once per instruction, at a much faster rate than the chips needed. There was no such thing as slow divide instructions. The worst case IIRC was about 12 or so cycles to complete an instruction.<p>The only downside to this sort of refresh is in systems that have more than one word width&#x27;s worth of chips. A normal read or write accessed a single word. Simple refresh accessed all DRAM chips in parallel. Much higher power consumption.<p>So, e.g. 16 K bytes of memory needed 8 DRAM chips. Whereas 64 K bytes of memory needed 32 DRAM chips. In a Z80 system, which read 8 bits at a time, only 8 chips would be active during normal read&#x2F;write but all 32 chips would be active in refresh.<p>A DRAM chip that was idle consumed a few mW of power whereas a DRAM chip that was being accessed or refreshed consumed a few hundred mW of power. So in a large system (hundreds of chips) you couldn&#x27;t take as simplistic an approach to refresh as the Z80 did.')