Item(by='aeturnum', descendants=None, kids=None, score=None, time=1604601354, title=None, item_type='comment', url=None, parent=24997496, text='Like many people here, I&#x27;ve worked on large python deploys for most of my professional career and have, over time, come to see python&#x27;s downsides more clearly.<p>I also wonder, thinking back over my experiences and reading others here, if we are mis-ordering how these things come to be. Maybe it&#x27;s not that python codebases are, for a given line count, worse than other languages. Maybe it&#x27;s that python allows teams to continue using practices that aren&#x27;t suited to their current scale longer than other languages. The reason that we all have seen hulking, monstrous, nearly unworkable python code bases is that most other languages would have already collapsed under the mismatch between approach and desired outcome.<p>I think we often approach software engineering as a puzzle - where you have a set of inputs (a too-large codebase, for instance) and a question of how to a better state. But programming projects are path-dependent creatures. Huge codebases must develop over time - they don&#x27;t spring out of the heads of developers fully formed. If you were a typed language and your engineers had a lower LOC output per-day, then of course your code base will be smaller. Is that better? You iterate more slowly, but the scale of your code is also more manageable. In my experience, the challenge of large python code bases comes from the context that you need to understand from the surrounding environment: what are all these objects, what are their objects, etc. Typed languages force you to carry around more context, so any given function is easier to read, but you can still write un-navigatable code.')