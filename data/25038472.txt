Item(by='pron', descendants=None, kids=[25039152], score=None, time=1604949033, title=None, item_type='comment', url=None, parent=25037794, text='Just to be clear, I am not saying that <i>very</i> restricted languages in some <i>very</i> restricted domains (such as configuration or hypertext) are not useful. I&#x27;m saying that in general purpose languages, restricting the programming language is not a generally fruitful avenue if analysis and correctness are the goal.<p>&gt; For example, with a strongly normalizing lambda calculus, I can prove intentional equality for any two functions<p>What&#x27;s the complexity of that?<p>&gt; You can construct the minimal FSM with the same behavior as once you&#x27;ve created<p>The complexity of that is more than linear <i>in the number of states</i>, that is usually at least exponential in the size of the program.<p>&gt; This means that I can prove e.g. that refactors that aren&#x27;t supposed to change behavior in fact don&#x27;t<p>But that&#x27;s often the case in Turing-complete languages, too. Moreover, the easy cases are usually not harder to detect in those languages.<p>Any benefits can&#x27;t be true <i>in general</i> because it is trivial to transform any program to an &quot;effectively equivalent&quot; FSM. A claim that could be true is that in restricted languages, many more programs people write happen to be easier to analyse than the programs they would have written to do the same thing in an unrestricted language. That&#x27;s certainly a very interesting empirical claim, but it requires empirical evidence.')