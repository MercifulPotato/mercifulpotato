Item(by='samjs', descendants=None, kids=None, score=None, time=1608136444, title=None, item_type='comment', url=None, parent=25444133, text='We talk about this in our design principles [1]. But I&#x27;ll give you a summary here too. We often use GitHub as an typical use case [2].<p>In GitHub you might be able to merge a PR in a repository because you are the repo owner, or you were invited to it. Or because you&#x27;re an organization admin, and the repo is in the same organization. (These are all common scenarios in b2b saas apps).<p>When a user attempts to merge a PR (or hits the API) you need to make that authorization decision based on what the application knows about the user.<p>So how do you allow the policy to access this information? Your options are basically: (a) you make it possible for the policy engine to independently lookup the data. You are now building a distributed monolith, since any change to the data requires updating both the policy engine and the application. (b) You send the relevant data into the policy decisions. Knowing what data you need to send to the policy is another form of coupling.<p>OPA is sort of a combination of (a) and (b). There is an API for sending authorization data to it, and you can also send data along with a request.<p>The problem is that the line between authorization and business logic is _so blurry_. Me being a member of a github org is fundamental application logic. But also crucial to making authorization decisions.<p>Because of this, traditionally people write this logic as a part of the application code. Normally a bunch of `if` statements. This is hard logic to abstract well in an app, because it&#x27;s normally a bunch of conditionals and a decision flow. Which it turns out prologs&#x2F;logic-based languages are great at solving (same conclusion OPA folks reached).<p>So given all this, the balance we wanted to strike was: decoupling the logic, but not the data. If your app already defines what a User is, what a Repository is, how a User becomes a Member of a Repository, then write your policy over those things, instead of re-implementing all of that logic elsewhere.<p>That being said, there are cases where the OPA-style decoupling works fine since there isn&#x27;t the same kind of business logic&#x2F;authz logic distinction. Or where the decision is being made over the entire input by default (things like checking terraform files, or other infra use cases).<p>[1] <a href="https:&#x2F;&#x2F;docs.osohq.com&#x2F;more&#x2F;design-principles.html#separation-of-concerns-but-not-data" rel="nofollow">https:&#x2F;&#x2F;docs.osohq.com&#x2F;more&#x2F;design-principles.html#separatio...</a><p>[2] <a href="https:&#x2F;&#x2F;www.osohq.com&#x2F;post&#x2F;building-the-github-authorization-model-using-oso" rel="nofollow">https:&#x2F;&#x2F;www.osohq.com&#x2F;post&#x2F;building-the-github-authorization...</a>')