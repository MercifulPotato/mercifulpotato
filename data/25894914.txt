Item(by='wegs', descendants=None, kids=None, score=None, time=1611516244, title=None, item_type='comment', url=None, parent=25888473, text='&gt; 1) If you&#x27;re writing anything that&#x27;s not a script with a few lines, and you care about your software not being terrible to maintain and change for other people in real production settings, typed languages wipe the floor with dynamic languages (excluding ecosystem moats, just judging the languages).<p>It&#x27;s sort of the other way around. Typed languages result in most code being better, but completely prevent some design patterns. I have yet to run into piece of Java code -- beyond the completely standard use-case of a database-backed e-commerce &#x2F; employee &#x2F; inventory web site -- which doesn&#x27;t go through one or two architectural contortions somewhere due to being forced into a specific paradigm.<p>The wins throughout the code from static take a back seat to the architectural contortions from not being able to express what you want.<p>Now, with incompetent developers, perhaps you want to prevent some design patterns, but those are workplaces I avoid like the plague.<p>&gt; Java was sold to managers as &quot;prevents cheap workers from making mistakes&quot;, but it was never about that and it&#x27;s mostly terrible at it.<p>What do you think it&#x27;s about?<p>I think that&#x27;s a fair sale. If you&#x27;re making a generic business system (you have things -- employees, inventory, customers, etc. you want to manage, which map 1:1 to objects, and which are exposed through a UX), it&#x27;s nearly perfect, and you&#x27;ll never hire qualified devs to work on those sorts of systems.<p>&gt; 3) I would say that&#x27;s a deceitful take, for only the absolute minority of systems have to care about scaling beyond a single server with failover (and a separate database if going with managed DB). For those systems that absolutely do care about horizontal scalability the answers should be absolutely obvious to any senior dev from the moment the requirements are stated. And for those cases where someone feels there may be a need for a complex scalability solution but there&#x27;s not an obvious case for it yet, development will most of the time be better off starting with the simple solution and selectively optimizing as needed, just don&#x27;t make it impossible to switch later down the road.<p>My experience -- having done a few successful startups and one or two failures -- is that it&#x27;s critical to plan for success down the road. A major mode of failure is that decisions made early prevent success down the line. The system doesn&#x27;t need to be scalable on day 1, but it absolutely positively needs to be designed for scale. The world is unpredictable, and you don&#x27;t know the moment you&#x27;ll hit exponential viral growth. At that point, you need to be able to refactor the system to hit scale virtually overnight. It doesn&#x27;t always happen, but if you don&#x27;t plan for it, it will never happen. It&#x27;s the successes that define your career (and your bottom line).<p>The way I tend to design systems, they tend to run on 1-3 servers on a random cloud provider (depending on level of failover), but they use abstractions mapping onto scalable architectures (e.g. generic key-value stores and similar). If I do need to scale, it&#x27;s a refactor away. A system I&#x27;m working on right now has an especially complex data pipeline. Thinking through scalability cost a few months time since it is complex, but without that, if we do hit scale, we&#x27;d hit a glass ceiling. As is, for now, we&#x27;re sitting on top of a non-scalable managed RDBMS. If we do hit scale, I can migrate seamlessly to a horizontally scalable setup. At that point, we&#x27;d need to grow the team several-fold (esp. dev ops), but if you&#x27;re scaling, that&#x27;s okay; it&#x27;s a fine problem to have.<p>I&#x27;ve advised startups, and ones which don&#x27;t think through the long-term (and not just scalability; total addressable market, monetization, architecture to target adjacent markets, etc.) almost always fail, and if they succeed, it&#x27;s by sheer, dumb luck.')