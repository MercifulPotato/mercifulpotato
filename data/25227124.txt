Item(by='nmadden', descendants=None, kids=[25227406], score=None, time=1606470929, title=None, item_type='comment', url=None, parent=25224840, text='&gt; I would certainly hope that a type &quot;checker&quot; returns a more detailed representation of a program than a parse tree - one in which all expressions are typed and ill-typed expressions cannot be represented.<p>Do you have an example of this? It is not my experience of compiler intermediate representations or ASTs that they have this property.<p>&gt; But since we all understand types and types can cover all the cases we&#x27;ve managed to find so far, I&#x27;d stick to types unless and until we can demonstrate a need for something else.<p>This doesn’t really argue with anything I wrote in the article. (Although I’d argue that nobody strictly “sticks to types” as their sole way to enforce correctness).<p>&gt; trying to put types on those APIs is the easiest way to see that they&#x27;re the wrong abstraction<p>I’m not sure I’d say it’s the easiest, but it certainly helps. I love Haskell as a language, primarily because it has a lovely set of well-designed abstractions. It’s clear the design of those abstractions were guided by types and benefit from that. Many of them remain good abstractions when translated to untyped languages.')