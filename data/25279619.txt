Item(by='jgraettinger1', descendants=None, kids=[25280573], score=None, time=1606933902, title=None, item_type='comment', url=None, parent=25279110, text='This is a solved problem, for a few years now. The basic trick is to publish &quot;pending&quot; messages to the broker which are ACK&#x27;d by a later written message, only after the transaction and all it&#x27;s effects have been committed to stable storage (somewhere). Meanwhile, you also capture consumption state (e.x. offsets) into the same database and transaction within which you&#x27;re updating the materialization results of a streaming computation.<p>Here&#x27;s [1] a nice blog post from the Kafka folks on how they approached it.<p>Gazette [2] (I&#x27;m the primary architect) also solves in with some different trade-offs: a &quot;thicker&quot; client, but with no head-of-line blocking and reduced end-to-end latency.<p>Estuary Flow [3], built on Gazette, leverages this to provide exactly-once, incremental map&#x2F;reduce and materializations into arbitrary databases.<p>[1]: <a href="https:&#x2F;&#x2F;www.confluent.io&#x2F;blog&#x2F;exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.confluent.io&#x2F;blog&#x2F;exactly-once-semantics-are-pos...</a><p>[2]: <a href="https:&#x2F;&#x2F;gazette.readthedocs.io&#x2F;en&#x2F;latest&#x2F;architecture-exactly-once.html" rel="nofollow">https:&#x2F;&#x2F;gazette.readthedocs.io&#x2F;en&#x2F;latest&#x2F;architecture-exactl...</a><p>[3]: <a href="https:&#x2F;&#x2F;estuary.readthedocs.io&#x2F;en&#x2F;latest&#x2F;README.html" rel="nofollow">https:&#x2F;&#x2F;estuary.readthedocs.io&#x2F;en&#x2F;latest&#x2F;README.html</a>')