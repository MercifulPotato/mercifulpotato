Item(by='jez', descendants=None, kids=None, score=None, time=1606083477, title=None, item_type='comment', url=None, parent=25175911, text='Another place where SIGSEGV handlers are common: showing backtraces and &quot;how to report a bug&quot; messages. For example here&#x27;s where it&#x27;s done in the Ruby VM:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;ruby&#x2F;blob&#x2F;5445e0435260b449decf2ac16f9d09bae3cafe72&#x2F;signal.c#L946" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;ruby&#x2F;blob&#x2F;5445e0435260b449decf2ac16f...</a><p>They have a bug report handler that shows a bunch of helpful information:<p>- the Ruby-level backtrace<p>- the stack of VM control frames (an internal data structure)<p>- the C-level backtrace (which Ruby implementation functions were running)<p>- which files had been required and loaded into memory<p>- what segments of memory are mapped and what aren&#x27;t<p>Another thing: it&#x27;s designed to work even when the program ran out of memory!<p>The sigaltstack(2) system call lets you preallocate a buffer that the kernel knows how to set up before it runs your SIGSEGV handler, so you can have just enough stack memory to compute and print all this debug info before the program ultimately crashes. Here&#x27;s that code, again in the Ruby VM:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;ruby&#x2F;blob&#x2F;5445e0435260b449decf2ac16f9d09bae3cafe72&#x2F;signal.c#L548-L561" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;ruby&#x2F;blob&#x2F;5445e0435260b449decf2ac16f...</a>')