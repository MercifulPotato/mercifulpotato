Item(by='segfaultbuserr', descendants=None, kids=None, score=None, time=1610140419, title=None, item_type='comment', url=None, parent=25690159, text='It&#x27;s rare for ntpd to step time forward, unless ntpd lost synchronization and the local clock has drifted beyond +&#x2F;- 128 ms by default. On a 7x24 production server, it&#x27;s very unlikely, time is always slewed. But a standard leap second implementation <i>requires</i> the addition or deletion of time via adjtimex()&#x27;s TIME_INS and TIME_DEL, it&#x27;s not adjusted gradually.<p>&gt; <i>&quot;oh, I&#x27;m more than one second behind now, I better start fuzzing and catch up&quot;.</i><p>No, ntpd would say, oh, leap second, now it&#x27;s the time to tell kernel to delete a second! And if the kernel&#x27;s negative leap second code path has a bug, kernel panics and everything crashes.<p>...Yes, you probably can force ntpd to ignore the leap second deletion and also force NTP to slew time only. This approach is similar to leap second smearing (which is considered a violation of standard but nevertheless an useful hack). But it requires manual configuration, by default the standard approach is used.<p>So the bottom-line is: Time will be forcefully stepped ahead by 1 second (which is an uncommon scenario on production server), and, it would not just be an ordinary step - it uses the operating systems normally untested negative leap second code path. I&#x27;m not sure what the consequences would be for various services, perhaps not much, but my worry is the interactions in a complex application can produce unexpected outcomes. Also, how many systems have implemented the negative leap second in the code path? And are they all tested?')