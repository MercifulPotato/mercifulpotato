Item(by='gugagore', descendants=None, kids=None, score=None, time=1610573801, title=None, item_type='comment', url=None, parent=25761502, text='Signed zeros are a tricky design choice, for sure...<p><a href="https:&#x2F;&#x2F;www.johndcook.com&#x2F;blog&#x2F;2010&#x2F;06&#x2F;15&#x2F;why-computers-have-signed-zero&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.johndcook.com&#x2F;blog&#x2F;2010&#x2F;06&#x2F;15&#x2F;why-computers-have...</a><p>I like this comment:<p>&gt; To other commenters: It’s important not to confuse floating point with mathematics. In floating point, both zeroes are considered to be exactly equal to zero, to each other. The redundant sign bit is “piggybacked” information which retains a sign across a series of multiplies or divisions, and it only affects downstream results in a few exceptional cases (eg dividing non-zero by zero, yielding inf or -inf). The behaviour has been standardized based on various pragmatic considerations, and will not always be consistent with evaluating infinitesimals in mathematics.\nI can see the reasoning that log(-0.0) should give the same exceptional result as log(-1). But bear in mind it can arise from something like log( -(a+b)) where a+b evaluates to 0. Whereas ((-a)-b) would be +zero. I.e the sign of the zero is generally not meaningful when the zero originally arises from a sum or difference. Indeed, in such cases, if you consider a and b to carry “rounding fuzz”, then the proper sign of a+b is indeterminate, and not correlated to the sign bit generated by the add. When zeroes are generated by underflow of mul or div, at least the sign is “correct”.')