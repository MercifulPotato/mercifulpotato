Item(by='beyondCritics', descendants=None, kids=None, score=None, time=1604740782, title=None, item_type='comment', url=None, parent=25012468, text='First i must correct terminology: The OP got the terms &quot;upcast&quot; and &quot;downcast&quot; the wrong way around. Assigning something to a more general variable is an upcast, rediscovering something derived needs a downcast. Upcasts are absolutely fundamental and always automatic in object oriented languages, downcast are possible at least in C++, but considered as bad style.<p>MAKE_UNIQUE &amp; MAKE_SHARED<p>The first problem discussed stems from a misunderstanding of the function make_unique&lt;T&gt;(<a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;memory&#x2F;unique_ptr&#x2F;make_unique" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;memory&#x2F;unique_ptr&#x2F;make_uni...</a>), which produces always an unique_pointer owning an object of type T, no matter what.\nPart of the story is, that the class &quot;Animal&quot;, has an defaulted copy constructor, this allows implicit conversion, which is considered as bad style. To mitigate i would suggest, to use the keyword &quot;explicit&quot; whenever possible, I have learned that it helps to prevent many, many surprises.<p>CAST TO A REFERENCE<p>This example program terminates surprisingly due to an unhandled &quot;std::runtime_error&quot; exception thrown from the Dog::breed() method. The reason is, that the auto type specifier uses function template type deduction rules, therefore in this case<p><pre><code>  const Animal&amp; animal\n  ...\n  auto dog = dynamic_cast&lt;const Dog&amp;&gt;(animal);\n</code></pre>\nthe variable &quot;dog&quot; is deduced to have the type &quot;Dog&quot;. This again happens unnoticed, since the class &quot;Animal&quot; implicitely copy constructs from derived classes.<p>TRICKY SHARED_PTR LAMBDA<p>A smart_ptr manages two(!) pointers of possibly different type and value, the &quot;managed&quot; pointer, which is shared by all instances and an additional &quot;owned&quot; pointer, private to every object instance. The owned pointer can be manipulated privately with the reset() method and will be referenced by the -&gt; operator. Hence the difference in behaviour if a copy or a reference of the original shared pointer is made.')