Item(by='bayindirh', descendants=None, kids=[25617519], score=None, time=1609620395, title=None, item_type='comment', url=None, parent=25615363, text='&gt; syslog-ng supports the systemd journal natively so you&#x27;d never see a difference from before if you don&#x27;t want to.<p>We use rsyslog with systemd and it works too, however it&#x27;s just another level of abstraction so, I&#x27;m not fond of piling stuff over and over. Binary logs&#x27; and journals&#x27; usefulness can be also debated. It of course brings some advantages to the table but, it doesn&#x27;t enable anything groundbreaking for me.<p>&gt; The principle is dogma that has held back Unix imo. It&#x27;s useful for simple CLIs but that is about it. By your definition the kernel itself goes against the principle.<p>Actually I don&#x27;t consider it dogma, because it has some very important results and corollaries. This principle reduces secondary complexity (glue logic, complexity required to do many things with one code base, etc.) greatly hence the software can be relentlessly optimized. grep, find, sed, awk, cut, head, tail, less all are extremely performant tools. I develop high performance scientific applications and making a tool accomplish more than a couple different functions either reduce performance (generalized algorithms) or increase size a lot (specialized functions for everything). Its refactoring, verification, maintenance gets complicated and expensive fast.<p>UNIX pipes and small optimized tools are much more useful beyond simple CLI commands and small scripts. Since the tools are fast, low memory footprint performance behemoths, you can build very fast and reliable machinery with them. You can even do data mining with them [0]. We have some impressive stuff running under the hood in our cluster which only use standard GNU utilities.<p>Also, tools like rsync and rdiff can lift much more than their size. They&#x27;re proverbial ants of data transfer and they also do one thing well. Same thing can be said for vi and nano too for text editing. Similarly, modern tools like Atom still shudder and die with a single big file while using extreme amounts of memory. OTOH, vi doesn&#x27;t even sneeze with files thrice as large.<p>Kernel doesn&#x27;t breach this principle either. It provides an interface between the hardware and software &amp; lives in its own space; that&#x27;s it.<p>&gt; systemd is a systems manager, it takes care of it during its entire lifecycle, keeping home directories portable is one thing it can do for you that is entirely optional but very useful, managing containers is another. These are however separate components - homed and systemd-nspawn respectively. It is not all rolled into a single &#x27;systemd&#x27;, this is a misrepresentation.<p>The problem with systemd is not purely technical. Also, I want to be clear that I&#x27;m not a die-hard systemd critic. The technical side can be summarized as &quot;Hey! This thing is complicated, developed very fast and can bring some (stability and security) problems back during its teething. Please be careful&quot;. Other side is social and can be summarized as &quot;Hey! You&#x27;re developing this, but you&#x27;re not listening to us and pushing your opinions down to us using your power. This dangerous in every aspect. We can develop this together to something better but, you don&#x27;t listen to us.&quot;.<p>Also I want to remind that, parallel sysV-init was pretty fast machinery and was very manageable.<p>I&#x27;m aware that systemd is modular. I&#x27;m not using more than half of it right now and I&#x27;m happy this way. One of the problems with systemd is opaqueness. When systemd overtakes a part of the system with its module, it&#x27;s very hard to discover it. Disabling the module and using an older or alternative approach is also not straightforward sometimes. As a result, systemd feels like an overzealous octopus with no indication of its intention. Holding everything it can reach with a death-grip and requiring some serious strength to pry it off.<p>With a better communication and feedback loop, we&#x27;d be in a very different place. Maybe systemd would be the same systemd but, without the unproductive rock-throwing, flaming &amp; shouting.<p>Linux is evolving like every other software or anything in life, but some ground principles are much more valuable than they seem. Throwing them away and labeling them as dogma just because they&#x27;re old is considered harmful and dangerous.<p>[0]: <a href="https:&#x2F;&#x2F;adamdrake.com&#x2F;command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html" rel="nofollow">https:&#x2F;&#x2F;adamdrake.com&#x2F;command-line-tools-can-be-235x-faster-...</a>')