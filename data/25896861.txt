Item(by='skissane', descendants=None, kids=None, score=None, time=1611527491, title=None, item_type='comment', url=None, parent=25892029, text='&gt; partitions inherently overlap the parent block device. You would need to carefully track exactly which portions of the device are in use, or your solution is useless (it doesn&#x27;t protect &#x2F;dev&#x2F;sda when &#x2F;dev&#x2F;sda1 is in use)<p>I think this could be addressed by the idea of a &quot;parent block device&quot;. So &#x2F;dev&#x2F;sda1 is mounted, then its parent &#x2F;dev&#x2F;sda would be classified as mounted, but &#x2F;dev&#x2F;sda2 would not be (assuming there is no partition mounted there.)<p>I&#x27;m sure one could work something out that would work for device-mapper, LVM, etc as well<p>&gt; Secondly, the Linux kernel has a very strong backwards compatibility guarantee<p>What about a sysctl knob? Turn it on, you get this new behaviour, turn it off, you get the backwards compatible behaviour. Each distribution can decide what to default it to. If it defaults to off in Linus&#x27; tree, that should satisfy his backwards compatibility concerns.<p>&gt; With your idea, many disk management programs will be broken.<p>There would need to be some escape hatch, e.g. an ioctl, to allow unsafe writes. And disk management programs would have to be patched to invoke that escape hatch. A distribution wouldn&#x27;t ship the sysctl as defaulting to on until it had patched all the disk management programs in that distribution. And, if you download a third-party tool, either its developers have patched it to use that ioctl, or else you can just temporarily turn off the sysctl knob while you use it.')