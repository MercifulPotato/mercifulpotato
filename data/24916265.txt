Item(by='s-tear', descendants=None, kids=None, score=None, time=1603871148, title=None, item_type='comment', url=None, parent=24915731, text='I’ll do you one better; I’ve managed to use my highly advanced engineer body to birth a “pure recursive hashing algorithm”.<p>def MY_HASHING_ALGORITHM(s):\n     return s<p>To answer your question; In theory, yes. In practice highly unlikely. Hash _functions_ attempt to store arbitrary inputs in unique indices within some dimensional space. This is predominantly achieved through performing some math against the Unicode (think integer) representation of said input (think string).<p>It may surprise you to find out that most hashed data structure implementations closely model how we think of Arrays&#x2F;Lists. The result of the hash function is the index where we “put” your “value”; when you attempt to “get” that “value” again we use the same hash function to find where in memory we initially “put” that “value”.<p>With regard to data structures; good hash functions avoid “collisions”, a collision is when multiple unique inputs to your hash function result in a non-unique output. Given that hash functions are designed around avoiding this we must understand that to accommodate even moderately large data-sets a by-product of most hash functions is a seemingly arbitrary, mostly unrecognizable and likely numerical value.<p>But I still haven’t answered your question; and I won’t; there’s a stupid mathematical way (depending on the function) to quickly answer this question but I think doing some curious investigation on your own behalf will provide you with more benefit.<p>So I’ll leave you with a couple of questions:<p>What are the most common hash functions?\nHow can I implement them in my language of choice?\nHow can I generate millions of “inputs” and verify each of their corresponding “outputs”?<p>By then, you should be close to or in possession of your answer.')