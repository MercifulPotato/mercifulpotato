Item(by='teraflop', descendants=None, kids=None, score=None, time=1604957914, title=None, item_type='comment', url=None, parent=25039929, text='In fact, that&#x27;s exactly how Python implements UNARY_NEGATIVE: <a href="https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;v3.9.0&#x2F;Python&#x2F;ceval.c#L1538" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;v3.9.0&#x2F;Python&#x2F;ceval.c...</a><p>If you look a bit further down in the original article, you&#x27;ll see that the BINARY_ADD instruction does something similar. It pops (a pointer to) the first operand, and modifies (a pointer to) the second one in-place.<p>Semantically, it makes sense to define operations as popping the operand(s) and pushing a result, for simplicity. But there&#x27;s no reason the interpreter has to actually be implemented that way, as long as the observable behavior is the same.<p>In any case, I wouldn&#x27;t be surprised if an extra push&#x2F;pop ended up having very little performance impact. The compiler might be able to optimize away the pointer increment&#x2F;decrement instructions, and if not, the stack pointer is pretty much guaranteed to be in the L1 cache.')