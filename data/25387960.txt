Item(by='dbcurtis', descendants=None, kids=[25389405], score=None, time=1607706318, title=None, item_type='comment', url=None, parent=25387610, text='One way to think of it is to split the &quot;compiler&quot; problem into three big pieces. 1) Front-end, 2) back-end, 3) tooling.<p>Front end is lexing, parsing, building the AST (in whole or just keeping pieces of it around), semantic analysis. When that is done, you can say &quot;Yup, valid program.  It is possible to generate code.&quot; So, to your question, yes.  Those techniques from the course are 100% in play.<p>Back-end is turning the AST into something you can optimized and generate code from.  (Sometimes there is a &quot;middle-end&quot; in there....) High-level optimizations, low level optimizations, memory allocation, register allocation.<p>Tooling is everything that keeps your life from being miserable as a user -- starting with debug symbols and these days people expect library and package management, etc, etc.<p>So if you are interested in exploring the Next Great Syntax or some semantic problems that can be re-written into C, then doing a C-front is a great way to do that.  Let the C compiler handle all the really-really-really-hard back-end issues for you, and avoid all that distraction.  But.... expect that getting debug symbols from your spiffy language into the ready-to-link object file is going to be, as they say, &quot;non-trivial&quot;.  So... great for experiments and a great learning exercise, but it&#x27;s hard to do a production compiler that way.')