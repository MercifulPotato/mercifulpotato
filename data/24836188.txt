Item(by='sergeykish', descendants=None, kids=[24838570], score=None, time=1603193715, title=None, item_type='comment', url=None, parent=24828538, text='I have not claimed JS is the weirdest. But I have not claimed &quot;Normally C++&#x2F;PHP&#x2F;Ruby&#x2F;Python devs don&#x27;t really encounter these notorious problems, for many years now&quot; either.<p>Eigenclass (singleton_class) explained in another thread. I have not encountered Pythons for&#x2F;else [1] yet.<p>Right, typeof null exposed by Microsoft IE 2 (?). Web is many times bigger now yet even such a small mistake is not fixed.<p>I have issue + of being concatenator, I prefer string interpolation, separate operators. Implicit type conversion often does not make sense spoils a lot<p><pre><code>    [] * 2\n    &#x2F;&#x2F;0\n    foo = {}\n    bar = {}\n    foo[bar] = 1  &#x2F;&#x2F; just throw please\n    Object.keys(foo)\n    &#x2F;&#x2F;[&quot;[object Object]&quot;]\n</code></pre>\n&gt; they could also silently fail as well.<p>But they don&#x27;t. If only these rules were defined as library. I am sure it would be ditched long ago. Actually this may be argument in favor of operator overloading in JavaScript, the way to fix it.<p>&gt; Foo being an instance of function is MUCH more honest<p><pre><code>    class Foo\n    end\n\n    Foo.send(:initialize)\n    TypeError (already initialized class)\n    # wrong one\n \n    Foo.instance_method(:initialize).call\n    NoMethodError (undefined method `call&#x27; for #&lt;UnboundMethod: Foo(BasicObject)#initialize()&gt;)\n    # does not allow unbound\n\n    Foo.new\n</code></pre>\nnew constructs an object and calls initialize. Same in JavaScript<p><pre><code>    function Foo () {\n      console.log(this)\n    }\n    new Foo\n    &#x2F;&#x2F; Foo {}\n    Foo()\n    &#x2F;&#x2F; Window\n</code></pre>\nIt kind of make sense â€” new creates an object of <i>constructor.prototype</i> and calls <i>constructor</i>. I can&#x27;t see how it is MUCH more honest than if new creates an object of <i>prototype</i> and calls <i>prototype.constructor</i>. By that logic Object.create is not honest<p><pre><code>    Object.create(Object.prototype) &#x2F;&#x2F; expects [[Prototype]] not constructor\n    Object.create(null)\n</code></pre>\nAnd even if it was<p><pre><code>    foo = {}\n    bar = Object.create(foo)\n    bar.__proto__ === foo \n    &#x2F;&#x2F;true\n    bar.__proto__.__proto__ === Object.prototype\n    &#x2F;&#x2F;true\n    bar.__proto__.__proto__.__proto__ === null \n    &#x2F;&#x2F;true\n\n    class Foo {}\n    class Bar extends Foo {}\n    bar = new Bar \n    bar.__proto__ === Bar.prototype \n    bar.__proto__.__proto__ === Foo.prototype\n    bar.__proto__.__proto__.__proto__ === Object.prototype\n    bar.__proto__.__proto__.__proto__.__proto__  === null\n</code></pre>\nI don&#x27;t need constructor except in new, otherwise I use it <i>only</i> to access prototype. Absence of languages adopting this approach confirms its usability issues.<p>&gt; This is even more true because you are looking at the primitive rather than the function object which contains the primitive.<p>Could you please expand this part? &quot;Primitive&quot; has specific meaning in JavaScript.<p>[1] <a href="https:&#x2F;&#x2F;book.pythontips.com&#x2F;en&#x2F;latest&#x2F;for_-_else.html" rel="nofollow">https:&#x2F;&#x2F;book.pythontips.com&#x2F;en&#x2F;latest&#x2F;for_-_else.html</a>')