Item(by='dustractor', descendants=None, kids=[25394604, 25394561], score=None, time=1607737536, title=None, item_type='comment', url=None, parent=25386098, text='<a href="https:&#x2F;&#x2F;arstechnica.com&#x2F;gadgets&#x2F;2016&#x2F;09&#x2F;an-os-9-odyssey-why-do-some-mac-users-still-rely-on-16-year-old-software&#x2F;" rel="nofollow">https:&#x2F;&#x2F;arstechnica.com&#x2F;gadgets&#x2F;2016&#x2F;09&#x2F;an-os-9-odyssey-why-...</a><p>There are apparently some DNA sequencer machines that only interface with older macs.  The linked article is just as an &#x27;exhibit A&#x27;... It doesn&#x27;t go into the technical details as to why that is so.  I can&#x27;t find the article on why virtualization is difficult for this case but it was very interesting.\nCooperative multitasking (mac system 5, system 6, system 7 ish era)  meant that the running task had the responsibility to yield.  If the task was something like &#x27;sample the value of x instrument register every 10 ms&#x27; (or something like that) then it could do the quick maths based on the base system clock rate and know exactly how many cycles to sleep between each sampling.  In other multitasking scenarios where the os has it&#x27;s own things it wants to do, the program cannot deterministically know how many cycles to sleep.  What if the process will be arbitrarily delayed or interrupted, so some samples are taken 17 clocks apart and some samples are 19?  With the priority being JITTER FREE, it doesn&#x27;t help if the os thinks, ahh i have a million clock cycles this second, and only 1000 things to do, I&#x27;ll just do some housekeeping... so there are background processes using bus resources, network interrupts, etcetera, all batched up and dispatched because the os thinks it has time to procrastinate this one task that just wants to sleep and sample a register and sleep... but sleeping for EXACT duration.')