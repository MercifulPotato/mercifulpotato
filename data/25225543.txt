Item(by='dragonwriter', descendants=None, kids=None, score=None, time=1606451143, title=None, item_type='comment', url=None, parent=25222281, text='&gt; I find that many articles written about Haskell, Erlang and Elixir seem to have no meaning outside of their own narrow domain; they try to present some solutions as some universal insight which is applicable to all languages. In fact, they seem to revolve around solving problems which the language itself created and only exist in that language.<p>I don&#x27;t find that to be the case often; Haskell articles, specifically, often have solutions to problems that static typing brings to the fore (they usually exist without it, but are less obvious without static typechecking and the solution approaches are sometimes different) and may present solutions that require a type system more powerful than is typically available outside of Haskell (though they are usually translatable to a weaker type system with some loss of safety.)<p>In fact, I&#x27;ve learned a lot applicable to programming in languages like Python, Ruby, JavaScript, and C# from learning a bit of (and reading articles focussing on) each of Haskell, Clojure, Erlang, and Elixir. Most paradigms can be applied productively in most languages if you are familiar with the paradigm and target language (though they&#x27;re are definitely things that depend on being on one side or the other of the static&#x2F;dynamic divide.) And even workhorse languages these days tend to be multiparadigm to start with, so learning techniques from the languages where a paradigm has been most fully explored and is most naturally expressed is often a good source of understanding to apply in other languages when that paradigm is the right choice.<p>&gt; A lot of these trendy languages seem to be on a futile mission to try to automate away some of the complexity of building software<p>All languages higher level than raw machine code exist for primarily that purpose (and, for that matter, the design of modern machine instruction sets itself does some of that, too.) That isn&#x27;t limited to “trendy” languages, which probably just means popular ones that are outside of your particular zone of preference established through familiarity.')