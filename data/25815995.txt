Item(by='zemo', descendants=None, kids=None, score=None, time=1610923386, title=None, item_type='comment', url=None, parent=25809301, text='<p><pre><code>    func (db *actualStoreImplementation) GetTask(t *Task) error {\n        if (t.ID != 0) {\n            &#x2F;&#x2F; query by ID, mutate the parameter, return nil\n        }\n        if (t.Tag != &quot;&quot;) {\n            &#x2F;&#x2F; query by tag, mutate the parameter, return nil\n        }\n        return ErrWhatever\n    }\n</code></pre>\nusually I have some other package that defines all of the types that can appear on the wire (which I often call `wire` because `proto` is taken by protobuf), define some exported interface in that package with an unexported method so that no other packages can define new types for that interface, and then have a method on my db structs that returns the wire types, like this:<p><pre><code>    func (t Task) Public() wire.Value {\n        return wire.Task{\n            &#x2F;&#x2F; explicitly generate what you want\n        }\n    }</code></pre>')