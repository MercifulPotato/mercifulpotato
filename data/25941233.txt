Item(by='ddragon', descendants=None, kids=None, score=None, time=1611839052, title=None, item_type='comment', url=None, parent=25940180, text='That example in Julia would look the exact same since it&#x27;s a very simple example with just one object&#x2F;struct and only one version of each function (so it doesn&#x27;t even need function overloading, let alone multiple dispatch), which is also why it might not be a good example against Python OOP, even though I&#x27;m inclined to agree, since it doesn&#x27;t even need single dispatch (which if needed can be achieved by functools.singledispatch in Python).<p>The difference would start when you get later a different entity like for example an Organization. Now you have to either create a save_items_org (and check which one it is to choose the correct method) or you add the same check to save_items(Union[Client,Organization]...) and all other methods. If you had used the object then it would be client.save_items() or org.save_item(). Using functools.singledispatch or Julia, save_items(org...) and save_items(client...) will work like the object version and dispatch without trouble and keep as concise as the object version.<p>Now, the difference with Julia, is that Python&#x27;s native dispatch capability ends here. If you now want a method to link Users with Users, Users with Organizations and Organizations with Organizations (sorry for the weird usecase, I don&#x27;t want to add more types) you can just implement in Julia a link(Users, Organization), link (Organization, Organization), link(User, User) and any combination and whatever combination of User and Organization you receive it will dispatch to the correct version (while in Python you&#x27;ll be forced to do the runtime check with an if to choose the implementation). For example the product operator (*) in Julia has around 300 implementations for all kinds of combinations of arguments, and the compiler makes it extremely fast by inferring and doing static dispatch.')