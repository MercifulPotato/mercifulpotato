Item(by='wahern', descendants=None, kids=None, score=None, time=1603923797, title=None, item_type='comment', url=None, parent=24922816, text='Lua is not uncommon on embedded devices, even the slow industrial kind, as opposed to &quot;embedded&quot; devices with desktop- and server-class processors.<p>Independent of fancy algorithms, GC complexity, cost, and latency are straight-forward functions of the number of managed objects. It&#x27;s not uncommon to use a &quot;glue&quot; language like Lua in a manner where the runtime only juggles a small number of objects, which in turn encapsulate and manage most of the application data independent of the garbage collector. Even in applications with complex, cyclic object graphs (i.e. the ones were GC makes sense), you can usually push the problematic edges into a small number of GC&#x27;d objects. Language GC (mark &amp; sweep, reference counting, etc) can at least in principal provide a zero marginal cost benefit.<p>Java, JavaScript, and Python reflect poorly on the usability of GC because they&#x27;re extremely object heavy and weren&#x27;t designed with embedding in mind. Scalars and aggregates didn&#x27;t figure prominently into their design, including C FFI (to the extent C FFI was even a consideration of their original language semantics). And they&#x27;re too liberal with heap allocation in both their semantics and implementation, inducing unnecessary object churn.')