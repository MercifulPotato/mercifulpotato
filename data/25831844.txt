Item(by='knorker', descendants=None, kids=[25831988, 25839117, 25833558, 25832336], score=None, time=1611051303, title=None, item_type='comment', url=None, parent=25831125, text='The downside to that more &quot;not idiomatic Go&quot; example is that you lose useful stack traces, and it complicates contexts (timeouts, credentials, tracing, etc… etc…).<p>For this reason the article I would say is also suboptimal, and is non-idiomatic. It&#x27;s something you&#x27;d do in other languages, but should be avoided in Go.<p>In my opinion you should just start a goroutine. The goroutine could block on a semaphore&#x2F;channel to limit concurrency, but there&#x27;s nothing <i>inherently</i> more costly about having the goroutines themselves be the queue instead of like the article having a list.<p>Yes, it&#x27;ll probably take a bit more memory to create a goroutine than to add to a list, but almost always I&#x27;ll take that to get more correct behavior.<p>But also, your suggestion doesn&#x27;t handle the requirement &quot;Calling the service should not block the caller&quot;, does it?<p>The article overengineered, by far. You don&#x27;t need infrastructure for this. It&#x27;s just:<p><pre><code>  for work := range workGenerator() {\n     go process(work)\n  }\n</code></pre>\nto limit concurrency, create a semaphore and just block either before starting goroutine (thereby blocking caller):<p><pre><code>  sem := sync.NewSemaphore(runtime.NumCPU())\n  for work := range workGenerator() {\n    work:=work\n    sem.Acquire(1)\n    go func() {\n      defer sem.Release()\n      process(work)\n    }()\n  }\n</code></pre>\nOr in the goroutine, to not block the caller:<p><pre><code>  sem := sync.NewSemaphore(runtime.NumCPU())\n  for work := range workGenerator() {\n    work:=work\n    go func() {\n      sem.Acquire(1)\n      defer sem.Release()\n      process(work)\n    }()\n  }\n</code></pre>\nYou don&#x27;t need the infrastructure from the article and, as I described, it&#x27;s actually hurting.')