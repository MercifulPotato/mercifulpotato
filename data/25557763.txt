Item(by='Someone', descendants=None, kids=[25558857], score=None, time=1609145934, title=None, item_type='comment', url=None, parent=25557411, text='If Sun would have picked a ‘real’ CPU, I doubt it would have been x86 (did they even sell any of them at the time?)<p>Also, picking a real CPU is only worth it for running on that CPU, and that particular one. If they had picked x86 in 1996, they wouldn’t even have supported MMX.<p>In a platform-independent design, using n registers in the virtual CPU is only a good idea for n = 0 (i.e. a stack machine, as in the JVM, .NET CLR and Web Assembly) and n = ∞ (as in LLVM).<p>If you pick any other number your platform-independent code needs to handle both the case where the number of op real registers is smaller (so you need to have a register allocator) and the case where it is larger (there, you could just ignore the additional registers, but that means giving up a lot of performance, so you have to somehow figure out which data would have been in registers if the CPU had more of them).<p>Why write and optimize both of these complex problems, if you can pick a number of registers at either end of the scale, and spend all your resources on one of them?<p>And that’s even more true for x86-64, which doesn’t have a fully orthogonal instruction set, has I don’t know how many ways to do vector instructions, none of which allow you to clearly express how long the vectors you’re iterating over are (making it hard to optimally map them to other CPUs or newer vector instructions), has 80-bit floats, etc.<p>There’s a reason Google stopped work on <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Google_Native_Client" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Google_Native_Client</a> in favor of Web Assembly.')