Item(by='HiJon89', descendants=None, kids=None, score=None, time=1606887060, title=None, item_type='comment', url=None, parent=25272519, text='For some context, S3 used to provide read-after-write consistency on new objects, but only if you didn&#x27;t do a GET or HEAD to the key before it was created. So this access pattern is all good:<p><pre><code>  PUT new-key 200\n  GET new-key 200\n</code></pre>\nHowever, this access pattern would be unreliable:<p><pre><code>  GET new-key 404\n  PUT new-key 200\n  GET new-key 200&#x2F;404\n</code></pre>\nThis last GET could return a 200, or it could return a cached 404. Unfortunately, Maven uses this access pattern when publishing maven-metadata.xml files, because it needs to know whether it should update an existing maven-metadata.xml file or create one if it doesn&#x27;t exist yet. So when publishing a new version, it does something like this:<p><pre><code>  GET com.example&#x2F;example-artifact&#x2F;1.0-SNAPSHOT&#x2F;maven-metadata.xml 404\n  PUT com.example&#x2F;example-artifact&#x2F;1.0-SNAPSHOT&#x2F;maven-metadata.xml 200\n</code></pre>\nAnd then downstream builds would try to resolve version 1.0-SNAPSHOT, and the first thing Maven does is fetch the maven-metadata.xml:<p><pre><code>  GET com.example&#x2F;example-artifact&#x2F;1.0-SNAPSHOT&#x2F;maven-metadata.xml 404\n</code></pre>\nSo when publishing a new version, you could get a cached 404 and fail loudly. However, when updating an existing maven-metadata.xml file you could silently read an old maven-metadata.xml, and end up using an out-of-date artifact (which is even more concerning). Here&#x27;s what one of the maven-metadata.xml files looks like:\n<a href="https:&#x2F;&#x2F;oss.sonatype.org&#x2F;content&#x2F;repositories&#x2F;snapshots&#x2F;org&#x2F;openapitools&#x2F;openapi-generator-core&#x2F;5.0.0-SNAPSHOT&#x2F;maven-metadata.xml" rel="nofollow">https:&#x2F;&#x2F;oss.sonatype.org&#x2F;content&#x2F;repositories&#x2F;snapshots&#x2F;org&#x2F;...</a><p>Because updating an existing object in S3 didn&#x27;t have read-after-write consistency, we could have a publishing flow that looked like:<p><pre><code>  GET com.example&#x2F;example-artifact&#x2F;1.0-SNAPSHOT&#x2F;maven-metadata.xml 200 (v1)\n  PUT com.example&#x2F;example-artifact&#x2F;1.0-SNAPSHOT&#x2F;maven-metadata.xml 200 (v2)\n</code></pre>\nAnd then downstream builds would fetch the maven-metadata.xml:<p><pre><code>  GET com.example&#x2F;example-artifact&#x2F;1.0-SNAPSHOT&#x2F;maven-metadata.xml 200 (v1)\n</code></pre>\nSo downstream builds could read a stale maven-metadata.xml file, which results in silently using an out-of-date artifact.<p>We ended up just switching to GCS because it was relatively straight-forward and gave us the consistency guarantees we want.')