Item(by='psykotic', descendants=None, kids=[24904670], score=None, time=1603766053, title=None, item_type='comment', url=None, parent=24901853, text='With your IDE example you need the full parser and type checker to be &quot;tolerant&quot;. For recursive-descent parsing, there isn&#x27;t much to say about theory. You try to pick reliable synchronization points and prevent cascading errors. Here&#x27;s the classic example:<p>In a statement-oriented language like C#, synchronizing to the next statement upon finding an error by scanning for a semicolon token is a good place to start. (Statements like &#x27;if&#x27; with nested statement blocks as arguments have their own sync logic.) Aside from having reliable sync points, statements (unlike expressions) don&#x27;t have a type that you need to propagate, so you don&#x27;t usually have to worry about cascading errors in the type checker from skipping a faulty statement. That said, if you skip a faulty statement that was the sole reference to a local variable, that might get flagged as an &#x27;unreferenced variable&#x27; warning. It&#x27;s often a good idea to disable sensitive warnings (and some errors) for the rest of the function as soon as an error is found.<p>Probably the most important sync point is at the level of symbol declarations. Even if a function&#x27;s body is totally botched up, as long as you could successfully resolve the function&#x27;s signature (name, parameter types and return type) you don&#x27;t get cascading errors from other functions that reference that function. Resyncing to top-level declarations is so important that if you&#x27;re designing the syntax it&#x27;s worth having a dedicated declaration keyword (especially for functions) which is only valid at top level. That way you have a reliable sync point even if everything else is out of wack (unbalanced braces, etc). Something like Go&#x27;s &#x27;func&#x27; keyword is close enough: it can appear in function literals and function types as &#x27;func&#x27; followed by &#x27;(&#x27; but &#x27;func&#x27; followed by a name is only valid in top-level declarations.<p>Fine-grained error recovery for expressions is the biggest problem from both a parsing and type checking perspective. There aren&#x27;t any reliable expression sync points in a C#-like language and you need to fabricate best-effort types for the faulty expressions (with an &#x27;error&#x27; type as a fallback) and make sure that the various operators for combining expressions have heuristics so you don&#x27;t get spurious cascading errors. It generally involves numerous special cases to good results. If you have a choice in the matter, don&#x27;t worry about expression error recovery: report the error, sync to the next statement and go for the lower-hanging fruit instead. In my experience it isn&#x27;t worth it in a statement-oriented language.<p>If you want to eliminate as many spurious warnings&#x2F;errors like this as possible during error recovery, you do end up adding many special cases over time. But it&#x27;s an incremental process and you can get good results immediately with basic recovery techniques.<p>Various comments:<p>On the lexer side of things, if you get to design the syntax it helps to avoid multi-line lexemes in the common cases. That&#x27;s why I cringed a little when I learned that Rust&#x27;s &quot;...&quot; string literals are multi-line. It&#x27;s fine to have multi-line lexemes like &#x2F;* ... *&#x2F; comments in C and &quot;&quot;&quot;...&quot;&quot;&quot; string literals in Python but make the default choices be single-line lexemes like &quot;...&quot; and &#x2F;&#x2F; ... so you can sync to the newline.<p>A benefit of a syntax with indentation-defined block structure is that you don&#x27;t need to rely on balanced grouping tokens like { ... }, so it&#x27;s easy and reliable to sync to the outer block levels. (In Python there&#x27;s a caveat that the lexer suspends indentation tracking when the ([{ nesting level is nonzero, but it&#x27;s still a robust heuristic even when recovering from an error in a nested state.) In particular, if you require top-level declarations to be at column 0 this avoids the need for dedicated keywords for reliable declaration resync. Then the only thing you have to worry about are unbalanced multi-line lexemes gobbling up chunks of your programs.<p>While I talked about error recovery, a lot of these syntactic properties help with fast symbol indexing. E.g. it&#x27;s easy to write a fast symbol indexer when you can just sync to &quot;\\n&lt;letter&gt;&quot; for top-level declarations and otherwise only need to worry about rare multi-line lexemes. This lets your outer scan loop avoid the byte-at-a-time bottleneck.')