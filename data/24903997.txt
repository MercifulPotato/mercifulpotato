Item(by='psykotic', descendants=None, kids=None, score=None, time=1603766053, title=None, item_type='comment', url=None, parent=24901853, text='With your IDE example you need the full parser and type checker to be &quot;tolerant&quot;. For recursive-descent parsing, there isn&#x27;t much to say about theory. You try to pick reliable synchronization points and prevent cascading errors. Here&#x27;s the classic example:<p>In a statement-oriented language like C#, synchronizing to the next statement upon finding an error by scanning for a semicolon token is a good place to start. Aside from the robustness of having a sync token like the semicolon, statements (unlike expressions) don&#x27;t have a type that you need to propagate, so you don&#x27;t usually have to worry about cascading errors in the type checker from skipping a faulty statement. That said, if you skip a faulty statement that was the sole reference to a local variable, that might get flagged as an &#x27;unreferenced variable&#x27; warning. It&#x27;s often a good idea to disable sensitive warnings (and some errors) for the rest of the function as soon as an error is found.<p>Probably the most important synchronization point is at the level of symbol declarations. Even if a function&#x27;s body is totally botched up, as long as you could successfully parse the function&#x27;s signature (name, parameter types and return type) you don&#x27;t get cascading errors from other functions that reference that function. Resyncing to top-level declarations is so important that if you&#x27;re designing the syntax it might be worth having a dedicated declaration keyword (especially for functions) which is only only legal at top level. That way you have a reliable sync point even if everything else is botched (unbalanced braces, etc).<p>Error recovery for expressions is the biggest problem from both a parsing and type checking perspective. There aren&#x27;t any reliable sync points in a C#-like language and you need to fabricate types for the faulty expressions and make sure that the various operators for combining expressions have heuristics so you don&#x27;t get spurious cascading errors. It generally involves numerous special cases to good results. If you have a choice in the matter, don&#x27;t worry about expression error recovery: report the error, sync to the next statement and go for the lower-hanging fruit instead.<p>If you want to eliminate as many spurious warnings&#x2F;errors like this as possible during error recovery, you do end up adding many special cases over time. But it&#x27;s an incremental process and you can get good results immediately with basic recovery techniques.')