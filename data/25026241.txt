Item(by='dmitriid', descendants=None, kids=[25026272], score=None, time=1604848579, title=None, item_type='comment', url=None, parent=25025738, text='&gt; Firstly, GraphQL does not allow for infinite recursion; it is literally not possible to do infinite recursion in GraphQL<p>It&#x27;s literally impossible to do infinite recursion anywhere because it&#x27;s physically impossible to write down an infinite recursion.<p>However, if you look at the very example you provide on that page, you will see what I mean by infinite recursion. Moreover, you link to the Apollo page which <i>literally</i> has this example:<p>--- start quote ---<p>This circular relationship allows a bad actor to construct an expensive nested query like so:<p><pre><code>  query maliciousQuery {\n  thread(id: &quot;some-id&quot;) {\n    messages(first: 99999) {\n      thread {\n        messages(first: 99999) {\n          thread {\n            messages(first: 99999) {\n              thread {\n                # ...repeat times 10000...\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  }\n</code></pre>\n--- end quote ---<p>Is 10000 infinite? No. Does it illustrate my point? Yes. Have you missed the point? Also yes.<p>&gt; Secondly, it&#x27;s extremely easy to add a GraphQL validation rule that limits the depth of queries<p>1. This statement is not even remotely true <i>in general sense</i><p>2. It is not the default behaviour of any GraphQL implementation (because it&#x27;s inherent in GraphQL)<p>3. The &quot;extremely easy&quot; solution for this particular case relies on an external package that needs to be added on top of something else. In your case it&#x27;s not even added to postgraphile. It&#x27;s added as an extra middleware to some other graphql library.<p>And that covers only one dimension: potentially infinite recursion. The other dimension is potentially unbounded complexity. For which the following is true:<p>1. It&#x27;s inherent in GraphQL<p>2. Is not even solved by PostGraphile, except in an experimental paid package<p>3. The primary mode of mitigating this is disallowing arbitrary queries by providing only a whitelists of allowed queries (so, basically falling back to REST)<p>So in the end you end up piling more and more complexity on top of other complexities to arrive at a whitelist of allowed queries, ... which is basically just poorly implemented and over-engineered REST (well, REST-ish).<p>Honestly, no idea why you&#x27;re fighting the facts of life that you yourself even document on your own product&#x27;s pages.')