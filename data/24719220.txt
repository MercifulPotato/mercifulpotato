Item(by='jlokier', descendants=None, kids=None, score=None, time=1602166277, title=None, item_type='comment', url=None, parent=24718827, text='You are correct that memory allocation takes place to <i>implement</i> the FP, and you could call that a state mutation.  The underlying computer mutates RAM.<p>But that&#x27;s not what FP people mean by state.<p>RAM is an implementation detail.  (You don&#x27;t even strictly need RAM to compute.  But that&#x27;s another conversation.)<p>In your example, one part of the state is the list [1,2,3].  That isn&#x27;t mutated when the program runs.  It&#x27;s passed around.  The implementation probably passes it by reference - a pointer to the list - but actually the programmer can&#x27;t tell and doesn&#x27;t care if it&#x27;s copied or passed by reference.  There&#x27;s no visible difference, when values can&#x27;t be mutated.<p>The other part is [2,3,4].  As the program runs, it will be allocated in <i>new</i> memory, and from the programmer&#x27;s point of view, it&#x27;s as if the value [2,3,4] <i>always existed</i>, just waiting to be looked at.  When it does look, that&#x27;s always the value it&#x27;s going to find, so in a very meaningful sense, that value is already there.<p>It&#x27;s not usually allocated and stored in RAM until the program looks there, but it <i>could be</i>, it makes no difference from the perspective of the FP programmer.  (In some implementations it actually might be.  If you called map(f,[1,2,3]) twice it might &quot;rediscover&quot; the value already existing in RAM on the second call and use that.)<p>And the [1,2,3] might get freed at some point.  But that only happens when it&#x27;s not being &quot;looked at&quot;.  It gets forgotten then.  (Or in an exotic implementation if there&#x27;s still a reference to it, the memory containing the value might be freed, and it might be reallocated and recalculated when it&#x27;s looked at again later.  All invisible to the FP programmer.)<p>For your generator example, the implementation might create a state variable to implement it, or it might not.  Either way it&#x27;s hidden from the pure FP program, and it&#x27;s as if the list [2,3,4] is just there, waiting to be looked at.  Some implementations won&#x27;t use a stateful generator like you&#x27;d think in Python though.  They may instead represent the list as having a lazy tail: [2,3,lazymore...] where lazymore... is a placeholder in the list in RAM, which represents the part of the list which hasn&#x27;t been looked at yet.  This is lazy evaluation.  The lazymore... is completely invisible to the pure FP program, because the act of looking at it (to do something useful) causes it to be replaced with the &quot;real&quot; calculated value, [4] in this case.  Only those &quot;real&quot; values are visible to the program.<p>Overall, in the pure FP programming model, it&#x27;s as if all the <i>values exist already and never change</i>, and they are determined by the FP expressions from other values which also never change.<p>The only &quot;effect&quot; is an implementation detail, triggered by the the act of looking at values to see what they already are, which converts lazy placeholders into useful values.  The equivalence between lazy placeholder and useful value is so well hidden in pure FP that the implementation is free to do things like calculate values before they are needed or even if they are never needed, and to discard some values (putting the placeholder back) and recalculate them again later whenever it feels like.  Yet to the pure FP programmer, it&#x27;s always the same values.<p>The underlying <i>implementation</i> will allocate, free, move values around in memory, and perform lazy evaluation as its way of &quot;looking at&quot; values as requested.  But those are all implementation details which are hidden from the pure FP programmer, and the details will vary between different implementations too.  In practice there&#x27;s still debugging and timing and memory usage visible, but not to the FP program (except through &quot;cheating&quot; non-pure FP escape hatches), and we think of those as part of the implementation, separate from the FP programming model.')