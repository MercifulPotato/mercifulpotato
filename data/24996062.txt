Item(by='chrismorgan', descendants=None, kids=[24999877, 25000553, 24996073, 24996580], score=None, time=1604557125, title=None, item_type='comment', url=None, parent=24979129, text='I suspect that a lot of the inconvenience of modelling non-linear problems in Rust actually doesn’t come down to ownership semantics alone, but the combination of ownership semantics <i>and the low-level memory model</i>. However, I don’t have any solid evidence to support this, because ownership semantics have only really been implemented with the low-level memory model, because the low-level memory model strongly benefits from it (memory safety; it more closely matches how computers work internally at that low level) and GC languages don’t <i>need</i> ownership semantics, and people don’t generally restrict things without cause (and ownership semantics are definitely a restriction).<p>My thesis here is that Rc&lt;RefCell&lt;_&gt;&gt; and similar are an effective escape hatch to ownership semantics, but they’re much less convenient than a garbage-collected type in a scripting language specifically because of the language’s low-level memory model. A GC language with ownership semantics might be able to obviate RefCell, which is the cause of Rc&lt;RefCell&lt;_&gt;&gt;’s inconvenience.<p>I’d be interested to see experimentation with ownership semantics in languages with higher-level memory models (which broadly means GC languages). My thesis could turn out to be quite wrong, and I haven’t worked out all the details of how the combination would work (especially I’m hazy on parts of removing RefCell, which is pretty critical), but I think it could be worth some research—ownership semantics for its own sake, rather than ownership semantics for memory safety.<p>&gt; <i>10. Getting used bypassing the borrow checker to reduce fighting implies people have just found a way to cope with the constraints it imposes.</i><p>Here’s the thing, though: it’s not just about finding a way to <i>cope</i> with the constraints it imposes; it’s also about <i>thriving within</i> the constraints it imposes, because it stops you from doing problematic things and guides you in the path of better designs much of the time (though non-linearity can definitely be a problem; it’s not all buttercups and daisies). When I work in JavaScript, I spend half the time missing ownership semantics, occasionally feeling downright miserable because ownership semantics would have made a problem far easier or less dangerous. Remember what I said about ownership semantics for its own sake rather than ownership semantics for memory safety? Yeah, most of the time I love Rust’s ownership semantics for the modelling rather than the memory safety.')