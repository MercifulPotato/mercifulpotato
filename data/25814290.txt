Item(by='morelisp', descendants=None, kids=None, score=None, time=1610913297, title=None, item_type='comment', url=None, parent=25811554, text='&gt; Using global state is certainly not idiomatic Go.<p>Unfortunately it&#x27;s not this simple (and probably multi-idiomatic).<p>Go definitely adopts more global state than other languages; I don&#x27;t know any other language that offers a default-global HTTP client <i>and server</i>. Now, part of that is because Go&#x27;s stdlib goes out of its way to make these <i>appear</i> stateless even though they are not - and this is good, even if you (often rightly) don&#x27;t use the default ones.<p>But I think a lot of people saw those carefully engineered APIs and instead ran with &quot;globals are OK in Go!&quot; Lots of packages have global-level configuration properties - some of this is a hacky replacement for DI e.g. most logger injection. Well, OK, I can support&#x2F;tolerate some of that because DI in these cases is usually a hacky replacement for real AOP language support. But some of it just shouldn&#x27;t be global. e.g. Gin debug vs. release vs. test mode should be a setting on the <i>Engine</i>.<p>And then you get into really bad stuff - I don&#x27;t know why but it <i>is</i> common to to have a global sql.DB, or sarama.AsyncProducer, or whatnot. A lot of novice Go developers - anecodotally predominately skewed towards previous PHP users, I think because they are not used to have really global variables - use a global for anything concurrency-safe. And this has ended up in a lot of low-quality tutorials&#x2F;examples&#x2F;SO questions so I don&#x27;t see it going away any time soon.')