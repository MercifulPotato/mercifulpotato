Item(by='PeterisP', descendants=None, kids=None, score=None, time=1608063386, title=None, item_type='comment', url=None, parent=25426006, text='The big gap is that it&#x27;s not that compilers optimize on &quot;having UB&quot; but rather on &quot;having a <i>potential</i> for UB&quot;.<p>It&#x27;s <i>not</i> about places where &quot;undefined behavior has been proven by the compiler&quot;, it&#x27;s about all the many places in completely correct code where (as far as the compiler can reason) the code <i>might</i> have UB but should not if it is correct code.<p>The question is about what to do when the programmer has written a completely correct program that lacks UB. The current approach is to assume that it actually does lack UB and that the code path that would contain the UB is unreachable (though in a manner that the compiler can&#x27;t prove). The other approach is to insert run-time checks in every such place, which is a heavy performance hit as there are many such places (e.g. every integer addition).<p>Requiring programmers to eliminate every place in a C program that has a potential for UB is not feasible - cleanly proving for every every integer increment and every pointer dereference that the input data can&#x27;t cause UB is impossible in the general case, and assuming that all of these <i>can</i> cause UB and pushing warnings means that every second line of perfectly correct code will have a warning that you can&#x27;t fix, because the code is correct as-is.')