Item(by='em500', descendants=None, kids=[25408647, 25407097], score=None, time=1607868163, title=None, item_type='comment', url=None, parent=25405850, text='You&#x27;re right, that should be<p><pre><code>      awk -F, -v OFS=, &#x27;{print $4+$7, $0}&#x27; foo.csv  |  sort -n -k1 -t, |  cut -f2- -d,\n\n</code></pre>\nExplanation:<p><i>awk -F, -v OFS=,</i> sets the input and output column separator to comma, <i>&#x27;{print $4+$7, $0}&#x27;</i> outputs the sum of column 4 and 7 before the rest of the line.<p><i>sort -n -k1 -t,</i> sorts the file numerically on column 1, with comma separator.<p><i>cut -f2- -d,</i> removes column 1, with comma separator.<p>This is of course not robust for general CSV files, but I don&#x27;t think OPs <i>marcel</i> is either. A robust solution requires a proper CSV parser.<p>The biggest warts I see in the classic unix solution is that all the tools use different flags for the field separator.<p>edit: if you know that the csv doesn&#x27;t contain tabs, you can omit some flags for a more concise<p><pre><code>    awk -F, -v OFS=&#x27;\\t&#x27; &#x27;{print $4+$7,$0}&#x27;  foo.csv | sort -n -k1 | cut -f2-\n</code></pre>\nsince <i>sort</i> and <i>cut</i> default to tabs&#x2F;whitespace as separators. If you&#x27;re unsure about the contents of the CSV, you <i>really</i> need a proper CSV parser.')