Item(by='striking', descendants=None, kids=[25797747, 25797807], score=None, time=1610751279, title=None, item_type='comment', url=None, parent=25797357, text='I gave you an upvote because I think you don&#x27;t deserve to go negative just for raising some of these concerns. Still, I&#x27;m going to examine some of them.<p>With regards to variables, the best way to hack around this issue is to 1) always use `local` when declaring a variable and 2) set `_G`&#x27;s metatable to raise an error if you try to create a new key, which prevents accidentally using globals like you&#x27;ve inadvertently discovered is the default behavior. This is this way because it is I guess simpler than teaching someone how declarations work, but it obviously leads to a pretty immediately bad situation for anyone who wants to do more programming than setting a global constant. It harkens back from when Lua was basically a TCL-like.<p>Copying a table is generally unnecessary, if you never mutate the table to be cloned. Just set the __index metatable property of a new table to a reference to the table to be cloned. Ta-da, you have inherited the previous table. Not giving you an immediate, easy way to do this forces you to come to terms with copying not always being the right solution. It&#x27;s not great, and the language offers no pointers to those who want to get a thing done, but it isn&#x27;t the worst choice.<p>Not providing increment operators is a design choice, one that simplifies the metatabling for operators. Only having one case for addition, and not having to worry about increment &#x2F; incremental assignment, means people creating metatables that override operators have a good experience. This is one of those times where power users are given the advantage at the cost of the less experienced, and I share your implied concern in feeling the inconsistencies in who is favored by which language features.')