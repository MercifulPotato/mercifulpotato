Item(by='tptacek', descendants=None, kids=[24721223], score=None, time=1602170810, title=None, item_type='comment', url=None, parent=24719387, text='Perhaps compared to Python, Ruby, and vanilla ES6; there is a class of epsilon-from-typo bugs that modern statically typed languages catch and that force rigorous Python and Ruby shops to waste time writing vast batteries of tests for the most banal functionality in their codebase (&quot;does this setter set?&quot;).<p>Moving from one of those languages to a modern statically typed language can come with a feeling that your programs tend to run successfully as soon as they compile --- certainly they do more often than they would in Ruby. Because the compiler is doing some of that testing work for you. It&#x27;s a good feeling.<p>But it hasn&#x27;t been my experience that the extra rigor in Rust&#x27;s model produces the same boost from Java or Go; in fact, my first-run experience with Rust is generally <i>less</i> reliable than Go; there are a few <i>more</i> things that can go wrong with a Rust program and slip by the compiler.<p>Which is what you&#x27;d expect; Rust isn&#x27;t garbage collected, so the programmer has to do the garbage collection, and every program is responsible in some sense for designing and implementing that part of its own runtime. There are things you can get wrong there that GC&#x27;d languages don&#x27;t make you bother trying to get right. And, of course, if you take the time to get your per-program runtime <i>really</i> right, there&#x27;s a performance gain to be had from doing so. It&#x27;s all tradeoffs.')