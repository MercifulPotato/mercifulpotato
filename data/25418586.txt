Item(by='Asooka', descendants=None, kids=[25422586, 25420069, 25418925], score=None, time=1607959574, title=None, item_type='comment', url=None, parent=25418182, text='I suspect it will come with some really big caveats. For instance what you wrote shouldn&#x27;t compile, because i&#x27;s storage duration doesn&#x27;t extend to the end of the guard block. If you write<p><pre><code>    guard {\n        int i;\n        for (i=0; i&lt;n; i++) defer foo(i);\n    }\n</code></pre>\nI would expect foo(n) to be called n times. That is, variables won&#x27;t be captured, it would work literally as if you wrote &quot;foo(i)&quot; n times at the end of the guard block. It&#x27;s a footgun, but everything in C is a footgun and this behaviour is not surprising to me as a C developer.<p>So I expect the implementation would be<p>1. If a defer block references variables which do not live to the end of the guard block, the program is malformed (compiler error).<p>2. Compile each defer block as if it was written at the end of the guard block. What order the defer blocks are stored in is implementation-defined<p>3. Put a pointer on the stack each time a defer statement executes pointing to the compiled defer statement.<p>With this each defer statement is just a few bytes of overhead added to the stack and you can do it in a loop, though it may not do what you expect if you come from Go. For the example I expect the compiler to emit code similar to:<p><pre><code>    struct defer_node {\n        void **label;\n        struct defer_node *next;\n    };\n    struct defer_node *defer_start=0;\n    int i;\n    for (i = 0; i &lt; n; i++) {\n        struct defer_start *defer_new = alloca(sizeof(struct defer_node));\n        defer_new-&gt;label = &amp;defer_stmt0;\n        defer_new-&gt;next = defer_start;\n        defer_start = defer_new;\n    }\n    \n    while (defer_start) {\n        goto *defer_start-&gt;label;\n    defer_stmt_exit:\n        defer_start = defer_start-&gt;next;\n    }\n\n    return;\n    &#x2F;* or break; or continue; whatever is appropriate for the enclosing block *&#x2F;\n\n    defer_stmt0:\n    foo(i);\n    goto defer_stmt_exit;\n</code></pre>\nThis makes defer more or less just a mechanical transformation of code that can be expressed with existing C primitives and without requiring dynamic memory. I think it would be a good addition to C&#x27;s structured programming elements.')