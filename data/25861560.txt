Item(by='titzer', descendants=None, kids=None, score=None, time=1611250593, title=None, item_type='comment', url=None, parent=25857845, text='A lot of compilers for functional languages do exactly that. Each intermediate representation of the program is expressed as an algebraic datatype and each phase is a transformation from one (immutable) IR to another. A simple compiler might be 3 to 5 such IRs, but a more complex compiler might be dozens of passes.<p>The problem is that dozens of passes means dozens of copies. Compilation gets quite slow. It&#x27;s not clear how to make a really fast compiler that has to do so much copying.<p>All of the compilers that I have worked on, except the toy compilers in grad school, used complex, mutable, and ultimately graph-based IRs. Controlling exactly the memory representation of the IR is important when a compiler does a lot of inlining and other optimizations, because a design mistake here can mean the IR for a compilation unit gets enormous and compilation time goes superlinear.<p>I designed the core of V8&#x27;s optimizing JIT and these issues are really important for an industrial compiler.')