Item(by='joshmn', descendants=None, kids=[25105734], score=None, time=1605478391, title=None, item_type='comment', url=None, parent=25102009, text='Rails makes it really easy to do something 10 different ways to get the same result. Unfortunately, most of which aren&#x27;t the most performant way. In my 10 years of building Rails apps of all different sizes, and seeing some very mature apps in production, this is the most common culprit I&#x27;ve seen.<p>I currently work on a rather large Rails app for a site that most of us here use. A common pattern for our performance pitfalls are things like this:<p><pre><code>  Tag.all.map(&amp;:name)\n</code></pre>\nversus<p><pre><code>  Tag.all.pluck(:name)\n</code></pre>\nUsing `#map` will instantiate a `Tag` object and do all the slow(er) metaprogramming to get you the syntactic sugar that makes interacting with an ActiveRecord object a treat. It does this, and then you only hit `#name`, completely wasting all that effort.<p>`#pluck` will change the SQL from `select * from tags` to `select tags.name from tags` and never instantiate a `Tag` object, instead short-circuiting and directly fetching the resulting SQL rows â€” which comes back as an array. It&#x27;s something along the lines of:<p><pre><code>  ActiveRecord::Base.connection.exec_query(Tag.select(:id).to_sql)\n</code></pre>\nAnother one I see:<p><pre><code>  ProgrammingLanguage.where(tag_id: @user.tags.select(&amp;:language_tag?).map(&amp;:id))\n</code></pre>\nversus<p><pre><code>  ProgrammingLanguage.where(tag_id: @user.tags.select(:id).where(type: &#x27;LanguageTag&#x27;))\n</code></pre>\nThe first example loops over the loaded `@user.tags`, loads them if they&#x27;re not already `#loaded?`, selects ones that are `type == &#x27;LanguageTag&#x27;`, only to grab the `#id`.<p>The second example joins the two resulting SQL statements and calls `#to_sql` on the second statement, building one query from two queries.<p>Are these times when the first example would be preferred? Yeah, plenty! If your result is already `#loaded?`, then you probably don&#x27;t need to hit the database again. But for this example and the ones I&#x27;m stumbling across while getting our company up-to-speed on &quot;good ways&quot;, these are the the commonalities.<p>Save for only very recently, the company I work for hasn&#x27;t put emphasis on real-world Ruby&#x2F;Rails skills, instead &quot;if you can code at a high level for any language, we think you can make reasonable contributions to our codebase.&quot; This has lead to hiring skilled developers that just don&#x27;t know that there&#x27;s a more preferred way of doing things in Rails for different contexts.<p>Double-edged sword, really.')