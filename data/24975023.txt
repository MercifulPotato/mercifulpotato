Item(by='ImprobableTruth', descendants=None, kids=None, score=None, time=1604363038, title=None, item_type='comment', url=None, parent=24966225, text='If you&#x27;re fine with &#x27;stupid&#x27; refinement types in the form of subset types without coercion, not only do you get them &#x27;for free&#x27; from the core type theory without introducing another language element, I personally also think they&#x27;re quite intuitive. Using a subset type of non-zero nats or providing a proof that the argument isn&#x27;t zero to define a &#x27;proper divsion&#x27; just &#x27;makes the most sense&#x27; in my opinion, but that may just be ultimately down to personal taste.<p>I really do think though that no single part of dependent type theory is actually all that complex. It&#x27;s not as simple as TLA+, but there&#x27;s nothing really hard about it till you start proving.<p>And I&#x27;m not saying that all this is feasible right now, but I&#x27;m fairly certain that this is at least fundamentally possible. You can&#x27;t &#x27;truly&#x27; separate specifications from proofs in dependent type theory, but you also definitely don&#x27;t need to really understand how to write actual proofs to write even complex specifications in it. All of this of course depends on stronger automation for a good subset (possibly by also integrating strongly with other provers), but I don&#x27;t think that&#x27;s a total pipe dream (though I am definitely personally biased on this).<p>&gt;The type system in Java or Haskell cannot be used as a sound mathematical foundation, so whatever I call those things it would mean something quite different from maths functions<p>I&#x27;m just talking about the &#x27;well-behaved&#x27; subset, but let me go at this from another angle.<p>If Lean tomorrow introduced a Sort Omega to type universes, the set of programs that you can write wouldn&#x27;t change. It&#x27;s essentially just a syntactic change. Would that really be enough to make you say that these are functions now while they previously weren&#x27;t?<p>&gt;But I wonder, in Agda, is `id id` some object even when a specific universe cannot be inferred? If so, how does Agda avoid Russel&#x27;s paradox?<p>If you quantify over a universe, a constraint gets introduced as part of the type checker. These constraints can be viewed as a graph that is checked for cycles, so not having a specific universe isn&#x27;t an issue.')