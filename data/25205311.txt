Item(by='Someone', descendants=None, kids=None, score=None, time=1606270871, title=None, item_type='comment', url=None, parent=25205218, text='<i>“A reference counting strategy would be more efficient in processor utilization compared to garbage collection as it does not need to perform processor intensive sweeps through memory identifying unreferenced objects. So reference counting trades memory for processor cycles.”</i><p>I think it’s the reverse.<p>Firstly, garbage collection  (GC) doesn’t identify unreferenced objects, it identifies referenced objects (GC doesn’t collect garbage). That’s not just phrasing things differently, as it means that the amount of garbage isn’t a big factor in the time spent in garbage collection. That’s what makes GC (relatively) competitive, execution-time wise. However, it isn’t competitive in memory usage. There, consensus is that you need more memory for the same performance (<a href="https:&#x2F;&#x2F;people.cs.umass.edu&#x2F;~emery&#x2F;pubs&#x2F;gcvsmalloc.pdf" rel="nofollow">https:&#x2F;&#x2F;people.cs.umass.edu&#x2F;~emery&#x2F;pubs&#x2F;gcvsmalloc.pdf</a>: With only three times as much memory, the collector runs on average 17% slower than explicit memory management)<p>Secondly, standard reference counting (RC) in a multi-processor system is inefficient because modifying reference counts requires expensive atomic instructions.<p>Swift programs spend about 40% of their time modifying reference counts.')