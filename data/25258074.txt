Item(by='kllrnohj', descendants=None, kids=None, score=None, time=1606765722, title=None, item_type='comment', url=None, parent=25257892, text='ARM vs. x86 is <i>mostly</i> irrelevant and far over-focused.<p>The main big factor in why the ARM-based M1 is able to have such great instructions per clock is due to the fixed-length instructions making it easier for Apple to have made a very wide CPU core front-end.<p>Think trying to apply a parallel map to an array vs. a linked-list. It&#x27;s easier to spawn off 8 jobs in parallels if just getting the right data isn&#x27;t dependent on previous work. x86&#x27;s variable-length makes that front-end decoding in parallel more complex.<p>Then thanks to that high IPC, Apple can keep the clock speeds lower while hitting the performance target they are going for. By keeping the clocks low, power is then also low. Nothing all that special or unique there, the power draw at 3ghz on an M1 is right in line with what you&#x27;d expect an equivalent x86 CPU at around 3ghz as well.<p>Beyond that there&#x27;s basically no major difference that really matters, and no &quot;inherent&quot; power efficiencies or advantages of any kind, either. If AMD or Intel manage to make an 8-wide x86 CPU core, then you&#x27;ll see that power efficiency advantage of the M1 vanish overnight. Similarly, Apple is currently the only one making ARM CPU cores that are wider than the typical x86 core is, which is why nobody else has impressive ARM CPUs.<p>ARM has some advantages in that it just doesn&#x27;t have the history &amp; legacy that x86 does, but then that&#x27;s also a disadvantage because legacy software also is very much a thing. What the future holds nobody <i>really</i> knows. At the end of the day what matter is how a CPU performs, not what instruction set it runs.')