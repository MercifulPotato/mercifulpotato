Item(by='tom_mellior', descendants=None, kids=[24874689], score=None, time=1603487638, title=None, item_type='comment', url=None, parent=24872752, text='&gt; There&#x27;s no theoretical difference between phis and basic block parameters.<p>I question this claim. Don&#x27;t basic block parameters allow you to do interesting stuff also at <i>split</i> points, not only at <i>join</i> points?<p>For example:<p><pre><code>    if (x == 0) {\n        y = 2 * x;\n    } else {\n        y = 3 * x;\n    }\n</code></pre>\nIn SSA form this is:<p><pre><code>        if (x == 0) jump B1 else jump B2\n    B1:\n        y1 = 2 * x\n        jump join\n    B2:\n        y2 = 3 * x\n        jump join\n    join:\n        y = phi(y1, y2)\n</code></pre>\nYou need conditional constant propagation to realize that y1 must be 0.<p>But with basic block arguments you could do this (improvising notation on the spot):<p><pre><code>        if (x == 0) jump B1(0) else jump B2(x)\n    B1(arg1):\n        y1 = 2 * arg1;\n        jump join(y1)\n    B2(arg2):\n        y2 = 3 * arg2;\n        jump join(y2)\n    join(y):\n        ...\n</code></pre>\nBasically, as soon as information becomes available (x is 0 along some path), that is explicit in the IR. Realizing that y1 is 0 only takes simple, non-conditional sparse constant propagation. You might not call that a &quot;theoretical&quot; difference (what theory are we talking about?), but it does give you a simple way to access information that is not explicit in SSA form.<p>In effect this latter representation is something like Static Single Information (SSI) form: <a href="https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;viewdoc&#x2F;summary?doi=10.1.1.1.9976" rel="nofollow">https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;viewdoc&#x2F;summary?doi=10.1.1.1.9...</a>')