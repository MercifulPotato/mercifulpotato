Item(by='Someone', descendants=None, kids=None, score=None, time=1607466487, title=None, item_type='comment', url=None, parent=25351592, text='I don’t think so, either, but the only time a cycle can be introduced is if one modifies an object to make it point to a younger (created later in time) object.<p>In some languages, that’s relatively rare because modifying objects after they are created is rare; immutable objects can be part of cycles, but they can’t be the cause of cycles. That may be enough to make the overhead of cycle detection small.<p>I guess one could keep track of those ‘dirty’ links, and use them to avoid having to detect cycles in most cases.<p>It might be enough to add a single bit to each object-to-object pointer indicating “this reference was set after construction of the object” (could be an unused bit in a virtual address, or the least significant bit, so it wouldn’t introduce memory overhead).<p>With such bits, at first sight, one would only have to check for cycles when P references a _possibly_ younger Q, and destruction of some object (indirectly) decreases P’s ref count to 1. However, things probably would get hairy when objects may have many outgoing and&#x2F;or incoming pointers (consider a set of 3 objects each referencing the other two).<p>I’ll go and read the referenced paper (<a href="https:&#x2F;&#x2F;researcher.watson.ibm.com&#x2F;researcher&#x2F;files&#x2F;us-bacon&#x2F;Bacon01Concurrent.pdf" rel="nofollow">https:&#x2F;&#x2F;researcher.watson.ibm.com&#x2F;researcher&#x2F;files&#x2F;us-bacon&#x2F;...</a>) to see how it handles this.')