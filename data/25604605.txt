Item(by='lmilcin', descendants=None, kids=None, score=None, time=1609520453, title=None, item_type='comment', url=None, parent=25604357, text='Good protocols are usually made in layers. You would typically want to have some state machine describing lower part of application protocol on which you build higher level of your application protocol, composed of specific functions.<p>This way you can modify functionality without necessarily touching low level implementation.<p>I can give an example.<p>I have worked with credit card terminals and I have implemented entire application from scratch.<p>There is a protocol to communicate between the terminal and the acquirer&#x27;s system (ISO 8583).<p>This protocol specifies a flow and format of messages. For example, if you send a transaction request, you will get a response. If you don&#x27;t get a response you may or may not retry it, etc. If you send a transaction advice (ie. transaction has already happened) you must be retrying sending it until you get a response, but every retransmission after first must include a bit that says it is retransmission. If the request or advice has been sent and transaction was cancelled, you need to be sending cancellations until you get an acknowledgement.<p>Now, all those messages have a huge amount of fields that change regularly as requirements change, but the basic flow of the protocol is fairly constant and has been constant for many years.<p>I have implemented the protocol as a tree of state machines telling the application what to do based on events and I believe the code has not been touched in over 10 years even though the application was in constant development.')