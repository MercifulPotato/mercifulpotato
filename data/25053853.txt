Item(by='alexgartrell', descendants=None, kids=[25055714, 25054481], score=None, time=1605053051, title=None, item_type='comment', url=None, parent=25051177, text='Can you provide more context on why you feel that&#x27;s true (or even possible)?<p>For the last few years, I managed the Container Runtime group at Facebook. My experience has been:<p>1. `if (has_capability(..., X)) { ... }` gets put into code pretty haphazardly in a way that&#x27;s not necessarily super well structured. Once it&#x27;s there, it&#x27;s ABI, and you&#x27;re screwed if you want to iterate on it. That&#x27;s why cap_sys_admin is &#x2F;almost&#x2F; root.<p>2. If you wanted to do the right thing from the jump (e.g. for bpf itself), you&#x27;d have to add a new capability. This is a <i>heavy</i> lift for something that might not actually get any traction. It requires changing a bunch of common tools, and you likely end up breaking a bunch of applications.<p>3. Debugging capability failures is a pain in the ass. We ended up building and deploying capability tracing infrastructure just to figure out what people are actually using.<p>4. For gradual roll outs of enforcement&#x2F;changes, you need the flexibility to warn first, enforce second. We did large scale monitoring of all such changes to make sure we didn&#x27;t break the workloads.<p>5. Even if you nail all of the above, the ability to make finer-than-capability-grained decisions (i.e. binding to port 20 or 80 is okay but not port 22) is really valuable.<p>I&#x27;m all for kernel abstractions that just work and solve all problems for all people, but I think the overwhelming trend has been towards kernel interfaces that provide a lot of flexibility and then more opinionated libraries&#x2F;tools that kind of let us have our cake and eat it to (io_uring =&gt; liburing, bpf =&gt; libbpf, btrfs =&gt; btrfstools).')