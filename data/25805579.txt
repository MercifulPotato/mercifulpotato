Item(by='jrockway', descendants=None, kids=[25810983, 25806602, 25810509, 25805778, 25806241], score=None, time=1610831790, title=None, item_type='comment', url=None, parent=25805158, text='Good introduction.  A few thoughts:<p>1) Be careful with locks in the form &quot;x.Lock(); x.DoSomething(); x.Unlock()&quot;.  If DoSomething panics, you will still be holding the lock, and that&#x27;s pretty much the end of your program.  (&quot;x.Lock(); defer x.Unlock(); x.DoSomething()&quot; avoids this problem, but obviously in the non-panic case, the lock is released at a different time than in this implementation.  Additional tweaking is required.)<p>Generally I don&#x27;t like locks in the request critical path because waiting for a lock is uncancelable, but in this very simple case it doesn&#x27;t matter.  For more complicated concurrency requirements, consider the difference between x.Lock()&#x2F;x.Do()&#x2F;x.Unlock vs. select { case x := &lt;-ch: doSomethingWithX(x); case &lt;-request.Context().Done(): error(request.Context().Err()) }.  The channel wait can be cancelled when the user disconnects, or hits the stop button in the error, or the request timeout is reached.<p>2) Long if&#x2F;else statements are harder to read than a switch statement.  Instead of:<p><pre><code>   if(foo == &quot;bar&quot;) {\n      &#x2F;&#x2F; Bar\n   } else if (foo == &quot;baz&quot;) {\n      &#x2F;&#x2F; Baz\n   } else {\n      &#x2F;&#x2F; Error\n   }\n</code></pre>\nYou might like:<p><pre><code>   switch(foo) {\n   case &quot;bar&quot;:\n     &#x2F;&#x2F; Bar\n   case &quot;baz&quot;:\n     &#x2F;&#x2F; Baz\n   default:\n     &#x2F;&#x2F; Error\n   }\n</code></pre>\nThese are exactly semantically equivalent, and neither protect you at compile-time from forgetting a case, but there is slightly less visual noise.  Worth considering.<p>3) I have always found that error handling in http.HandlerFunc-tions cumbersome.  The author runs into this, with code like:<p><pre><code>   foo, err := Foo()\n   if err != nil {\n      http.Error(w, ...)\n      return\n   }\n   bar, err := Bar()\n   if err != nil {\n      http.Error(w, ...)\n      return\n   }\n</code></pre>\nBasically, you end up writing the error handling code a number of times, and you have to do two things in the &quot;err != nil&quot; block, which is annoying.  I prefer:<p><pre><code>   func DoTheActualThing() ([]byte, error) {\n      if everythingIsFine {\n          return []byte(`{&quot;result&quot;:&quot;it worked and you are cool&quot;}`), nil\n      }\n      return nil, errors.New(&quot;not everything is okay, feels sad&quot;)\n   }\n</code></pre>\nThen in your handler function:<p><pre><code>   func ServeHTTP(w http.ResponseWriter, req *http.Request) {\n      result, err := DoTheActualThing()\n      if err != nil {\n         http.Error(w, ...)\n         return\n      }\n      w.Header().Set(&quot;content-type&quot;, &quot;application&#x2F;json&quot;)\n      w.WriteHeader(http.StatusOK)\n      w.Write(result)\n   }\n</code></pre>\nIn this simple example, it doesn&#x27;t matter, but when you do more than one thing that can cause an error, you&#x27;ll like it better.')