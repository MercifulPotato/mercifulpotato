Item(by='the_duke', descendants=None, kids=None, score=None, time=1602863458, title=None, item_type='comment', url=None, parent=24799659, text='It&#x27;s important to note that Nix(OS) is really 3 things:<p>A functional language, a package manager and an operating system.<p>I switched all my desktops and laptops to NixOS at the beginning of the year, and I&#x27;m starting to use introduce it at multiple companies for data science &#x2F; ML work environments with full reproducibility and Kubernetes bare metal deployments.<p>Main benefits:<p>* pure build system<p>* extremely easy way to set up and switch between custom environments with their own sets of dependencies (nix-env, nix-shell)<p>* nix (the package manager) is cross-platform and works on MacOS and other Linux distros (although that&#x27;s not always smooth sailing...)<p>* Ephemeral environments that are quickly set up and torn down, like the `nix-shell --packages vlc --run &quot;vlc <a href="https:&#x2F;&#x2F;dash.nixcon.net&#x2F;dash&#x2F;master.m3u8" rel="nofollow">https:&#x2F;&#x2F;dash.nixcon.net&#x2F;dash&#x2F;master.m3u8</a>&quot;`<p>* (mostly) fully reproducible OS and user environments<p>* patching and&#x2F;or locally building dependencies without ending up with a messy system<p>I can now finally get a (almost) 100% reproducible user environment including hardware configuration (kernel modules, disks, ...), installed packages, configurations, ...<p>home-manager [1] even enables declarative configuration of things like VS Code&#x2F;Vim&#x2F;Firefox plugins, and provides statically typed configuration options for many applications. The package repo is also very comprehensive.<p>For manually managed servers that aren&#x27;t just bootstrapped from VM&#x2F;cloud images the benefits are also wonderful.<p>It&#x27;s definitely not all smooth sailing though:<p>* There is documentation, but it&#x27;s spread across a lot of pages, disorganized and sometimes quite outdated or incomplete. I often have to read the source code - which is also mostly undocumented.<p>* Running unpackaged software:  you can&#x27;t just download binary releases and run them, unless they are fully statically linked (like most Go binaries). Instead you either have to whip up a package definition, or manually try to get the  binary working (eg with patchelf)<p>* The language is somewhat quirky. As often the case with such niche languages, documentation and tooling are very subpar and debugging is not exactly a joy. I wish Nix was built on a more common language with good tooling around it. I bet it would be quite a bit more popular, due to the lower barrier of entry. You get used to it though if you are willing to put in some effort.<p>* Package ecosystem: the package repo is really comprehensive, but maintainership for some less popular ones is not  up to Arch + AUR levels. Also the auditing for a lot of the packages is very limited. For any security critical environments or server deployments I would definitely limit myself to a hand full of core packages and&#x2F;or be prepared for manual auditing. I wish the repo was split up more like Arch into core and community, with different guarantees for auditing and maintenance. (the Flakes effort will hopefully help here quite a bit)<p>All in all Nix is great though, and it&#x27;s impressive how stable and featureful the ecosystem has become, despite being somewhat of a niche &quot;product&quot;.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;nix-community&#x2F;home-manager" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;nix-community&#x2F;home-manager</a>')