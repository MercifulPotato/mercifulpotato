Item(by='smasher164', descendants=None, kids=[25761244, 25757457], score=None, time=1610497543, title=None, item_type='comment', url=None, parent=25755731, text='There isn&#x27;t any evidence to suggest this. Slow compilation speed is mostly a consequence of priorities. See <a href="https:&#x2F;&#x2F;nikic.github.io&#x2F;2020&#x2F;05&#x2F;10&#x2F;Make-LLVM-fast-again.html" rel="nofollow">https:&#x2F;&#x2F;nikic.github.io&#x2F;2020&#x2F;05&#x2F;10&#x2F;Make-LLVM-fast-again.html</a> and <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;45q90s&#x2F;is_anything_being_done_to_remedy_the_soul&#x2F;czzmbt1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;45q90s&#x2F;is_anything...</a>.<p>Sure, there are some language features that can make optimizations pathological complex, but for the most part if compilation speed isn&#x27;t continuously tracked and strictly enforced against new changes, you inevitably regress into a slower compiler.<p>For instance, the Go community is highly sensitive to compilation speed. Although the Go compiler is SSA-based like LLVM, it&#x27;s very selective about the optimizations applied. The Go compiler tracks and benchmarks each phase of the compiler release-to-release to identify major regressions.')