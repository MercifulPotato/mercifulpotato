Item(by='steveklabnik', descendants=None, kids=[24755861], score=None, time=1602516277, title=None, item_type='comment', url=None, parent=24754734, text='Some people describe this split as &quot;type deduction&quot; vs &quot;type inference,&quot; that is, C++ has deduction, Rust has inference.<p>Here is the gist of it. Inferring types in C++ (and languages with type deduction) basically looks like this:<p><pre><code>  auto a = something;\n</code></pre>\nHere, the type of a is determined by the type of something. The left hand side determines the type of the right hand side.<p>In Rust (and languages with type inference), inferring types can look like that:<p><pre><code>  let a = something;\n</code></pre>\nbut it can also &quot;go backwards&quot;:<p><pre><code>  let a = 5; \n  let b: u64 = a;\n</code></pre>\nHere, a will be a u64, because you later assign it to something of type u64, and so the compiler can &quot;work backwards&quot; to infer this. (In my understanding, it does not literally work backwards, but it feels like it.)<p>To see how this plays out in your parent&#x27;s comment, I adapted the code from: <a href="https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;cpp&#x2F;auto-cpp?view=vs-2019" rel="nofollow">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;cpp&#x2F;auto-cpp?view=vs-20...</a><p><pre><code>    #include&lt;vector&gt;\n    \n    void func(std::vector&lt;int&gt; &amp;vect) \n    { \n       vect.push_back(30); \n    } \n       \n    int main() \n    { \n        std::vector&lt;int&gt; vect; \n        vect.push_back(10); \n        vect.push_back(20); \n       \n        func(vect); \n       \n        return 0; \n    } \n</code></pre>\nYou can&#x27;t say &quot;auto vect;&quot; there, or else gcc will say &quot;error: declaration of &#x27;auto vect&#x27; has no initializer&quot;.<p>But in Rust, you can write:<p><pre><code>    fn func(vect: &amp;mut Vec&lt;i32&gt;) {\n        vect.push(30);\n    }\n    \n    fn main() {\n        let mut vect = Vec::new();\n        \n        vect.push(10);\n        vect.push(20);\n        \n        func(&amp;mut vect);\n    }\n</code></pre>\nno type annotation on &quot;let mut vect&quot; there; it can see that you eventually pass it to func, and that&#x27;s enough to infer the type. (For completeness, the line would be &quot;let mut vect: Vec&lt;i32&gt; = Vec::new();&quot; if you wrote out the type.')