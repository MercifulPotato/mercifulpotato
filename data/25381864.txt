Item(by='partialstate', descendants=None, kids=None, score=None, time=1607656514, title=None, item_type='comment', url=None, parent=25381591, text='Hi, I&#x27;m Tristan (@TristonianJones), the lead of the CEL project here at Google which has a few core maintainers as well as a number of regular contributors:\n<a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;cel-spec&#x2F;blob&#x2F;master&#x2F;MAINTAINERS.md" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;cel-spec&#x2F;blob&#x2F;master&#x2F;MAINTAINERS.m...</a><p>Macros are considered an optional feature of the language because they can: \na) easily be disabled, \nb) have no dedicated syntax beyond that defined for core CEL.<p>CEL supports subsetting and extension which means you can actually turn off built-in features in order to guarantee a sort of maximal compute &#x2F; memory impact that an expression might have while still augmenting the core feature set in order to tailor it to your use case.<p>Bounded iteration is possible via macros, and such iterations can be nested; thus, you can have high polynomial time expressions, but only if you choose to permit them and many use cases (like IAM Conditions) don&#x27;t. This is different from OPA Rego or HashiCorp Sentinel in that these features are baked into the syntax and impossible to turn off with 100% certainty.<p>Since you can&#x27;t declare functions or variables within CEL, the environment of an expression (the variables and functions it can use) is completely controlled by the host process. The environment acts like a sandbox of sorts, but one specifically chosen by the application and not a general purpose mechanism like a hypervisor or sandbox like WebAssembly.')