Item(by='HelenPark', descendants=None, kids=[25678762, 25676696, 25675838], score=None, time=1610046862, title=None, item_type='comment', url=None, parent=25659071, text='TL;DR: this code should&#x27;ve never passed audit. I&#x27;ve found numerous problems, but I&#x27;ll focus on the attack that lets someone successfully manipulate a ciphertext and have it successfully decrypt as something else. While the audit report says &quot;Boxcryptor is not enforcing integrity [of ciphertexts],&quot; this attack can let an adversary decrypt a (short) ciphertext, given a padding oracle. This company should&#x27;ve never rolled their own crypto in response to Authenticated Encryption, which has been solved, if you just use a pre-existing library.<p>I&#x27;m surprised that this code has a &quot;successful&quot; audit. The cryptography _protocol_ that is implemented in the linked github repo (<a href="https:&#x2F;&#x2F;github.com&#x2F;secomba&#x2F;boxcryptor-single-file-decryptor" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;secomba&#x2F;boxcryptor-single-file-decryptor</a>) has several flaws (in addition to having some bad code practices that I&#x27;ll skip over since this repo is supposed to only document the encryption protocols).<p>First, the authors&#x27; problems appear to stem from their choice to manually implement an unusual (and inefficient) construction of the Authenticated Encryption primitive. Authenticated Encryption is the most common crypto primitive that people when they say &quot;they want encryption.&quot; It&#x27;s placed front-and-center in libsodium, ring, mundane, tink, monocypher, and every modern cryptography library that I&#x27;ve seen, since it is such a common operation. Modern Authenticated Encryption constructions include: AES-GCM, (X)ChaCha20-Poly1305. While there exist others, the industry has converged on these two as the standard.<p>These block cipher modes did not emerge for no reason. The cryptography community has steadily iterated on what the default should be when somebody asks, &quot;how can I encrypt my file.&quot; We&#x27;ve arrived at these constructions, in particular, because previous constructions have had security flaws.<p>The authors of this repo have chosen to use the following protocol (for decryptDataPBKDF2):<p>1. Derive two keys (KE, KH) from a password string using PBKDF2. KE is the encryption key used with AES, and KH is an HMAC key (used for multiple purposes, which is problematic).\n2. Read the AES-CBC initialization vector, IV. Read the AES-CBC ciphertext, C.\n3. Check HMAC(KH, C) == the tag in the file.\n4. Output AES-CBC-DECRYPT(KE, IV, C) with PKCS#5 padding.<p>The core of the problem is that, while they use the HMAC to check that the ciphertext is authentic (which is a bit odd, given that they seem to claim that authenticity shouldn&#x27;t matter), they never check that the IV is authentic (it&#x27;s never computed in the HMAC).<p>The way that AES-CBC decryption works, for first 16-bytes of the decryption is AES-BLOCK-DECRYPT(KE, first 16 bytes of C) XOR IV. As a result, if the IV isn&#x27;t authenticated (which it&#x27;s not), then any bit that the attacker flips in the IV will flip the corresponding bit in the ciphertext. Because PKCS#5 padding is used, given a padding oracle, an adversary could decrypt messages under 16 bytes in length.<p>The moral of the story is DO NOT ROLL YOUR OWN CRYPTO! Rolling your own crypto can be fun and educational and informative, but DON&#x27;T DEPLOY IT!<p>This bug should not have arisen, because the GitHub link in this blog post should&#x27;ve been to <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;tink" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;tink</a> or <a href="https:&#x2F;&#x2F;github.com&#x2F;jedisct1&#x2F;libsodium" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;jedisct1&#x2F;libsodium</a> or some library like them.')