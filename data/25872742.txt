Item(by='scottlamb', descendants=None, kids=[25872887, 25873096, 25876341, 25873208, 25874063, 25873531, 25872871], score=None, time=1611331110, title=None, item_type='comment', url=None, parent=25871605, text='It looks like this layers Raft on top of SQLite. I don&#x27;t like when systems replicate high-level changes like &quot;update users set salary = salary + 1000 where ...;&quot; Instead, I prefer they replicate low-level changes like &quot;replace key&#x2F;block X, which should have contents C_x, with C_x&#x27;&quot;.<p>Why? Imagine you&#x27;re doing a rolling update. Some of your replica are running the newer version of SQLite and some are running the older version. They may not execute the high-level query in exactly the same way. For example, in the absence of an &quot;order by&quot; clause, select results&#x27; order is unstated. So imagine someone makes a mutation that depends on this: &quot;insert ... select ... limit&quot;. (Maybe a dumb example but it can happen anyway.) Now the databases start to diverge, not only in underlying bytes and implementation-defined ordering but in actual row data.<p>I worked on a major distributed system that originally replicated high-level changes and switched to replicating low-level changes for this reason. We had a system for detecting when replicas didn&#x27;t match, and replication of high-level changes was the biggest reason for diffs. (Hardware error was the second biggest reason; we added a lot of checksumming because of that.)')