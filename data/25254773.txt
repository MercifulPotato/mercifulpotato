Item(by='superzadeh', descendants=None, kids=None, score=None, time=1606750354, title=None, item_type='comment', url=None, parent=25254746, text='ohhh, that&#x27;s a tough one. @StateObject is definitely making things easier, but the trick we&#x27;ve used for now (weâ€™re still targeting iOS 13) is to wrap ViewModels in @State in a parent view, and pass it down to your view as an @EnvironmentObject.<p>When the subview changes&#x2F;re-renders, your ViewModel stay the same on the parent view and is not recreated as it is a @State; and your subview can still listen to @PUublished changes.<p>We&#x27;ve made a generic wrapper for it, and we use almost everywhere:<p><pre><code>  struct ViewModelWrapper&lt;V: View, ViewModel: ObservableObject&gt;: View {\n    private let contentView: V\n    @State private var contentViewModel: ViewModel\n\n    init(contentView: @autoclosure () -&gt; V, vm: @autoclosure () -&gt; ViewModel) {\n        self._contentViewModel = State(initialValue: vm())\n        self.contentView = contentView()\n    }\n\n    var body: some View {\n        contentView\n            .environmentObject(contentViewModel)\n    }\n  }</code></pre>')