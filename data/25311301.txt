Item(by='tehlike', descendants=None, kids=None, score=None, time=1607137293, title=None, item_type='comment', url=None, parent=25311202, text='The blog mentions ORM, but it actually has nothing to do with orms, if you read it closer.<p>1. ID generation is generic problem. You can go two ways about it, one is letting your DB handle&#x2F;generate it, and one handling it at application level. Your ORM can do it, or they may not. TypeORM&#x2F;Sequelize are primitive ORMs compared to hibernate&#x2F;nhibernate, but ORM could be a place where you can handle ID generation, or you can handle it in your business code.<p>2. .NET has nothing to do with it, if you want to extract information out of it, it applies to any language, concepts are programming concepts.<p>3. At the time i suggested HiLo &gt; Comb &gt; UUIDv4 and i actually gave my rationale. These days i choose sequential uuid&#x2F;comb instead, mostly because i don&#x27;t care about readable ids.<p>On HiLo:\nIf you want mostly sequential human readable numbers, instead of using DB generated identity, it&#x27;s smarter to use a simple algorithm like HiLo algorithm. Hi&#x2F;Lo is High + Lo referring to bucketization of the numbers. Hi goes from 0...infinity, Lo goes from 0 to bucketsize-1.<p>The basic idea is, if you have an application (or a distributed system for that matter), you preallocate id ranges to each node instance in your application. \nBucket size: 128\nInstance 1: Hi=0, Lo=0\nInstance 2: Hi=1, Lo=0<p>Instances assign ids based on the following formula: Hi * bucketSize + (Lo++);<p>This means instances can assign ids from 0...127 and and 128 ...255 on their own, without hitting database. When they run out of their range, they make a new query and increment Hi parameter stored in database.<p>Applications assigning ids without hitting database is important. Think of the following scenario:\nIf you have Order + Order Details, you can send all the inserts in one go if the order id is preassigned. Otherwise, you have to insert the order, get the id, then insert the order details with order id you just obtained.<p>On Comb creates less fragmentation in the database. I actually put a small bit of image there that simply shows what happens if you insert thousands of records with id=uuid4 vs comb. One of the tables will be more fragmented. the other will be significantly less..<p>UUIDv1 is structured as [low bits of timestamp, mid bits of timestamp, high bits of timestamp....] which means first bits of uuid moves faster than middle&#x2F;higher bits, which is very problematic for the fragmentation.<p>Feel free to ping me on email if you want to talk more:\ntehlike@gmail.com<p>I was a contributor on NHibernate around 2008.')