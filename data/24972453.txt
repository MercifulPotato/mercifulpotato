Item(by='pron', descendants=None, kids=[24972918], score=None, time=1604347147, title=None, item_type='comment', url=None, parent=24970322, text='&gt; OK. Show me.<p>Here is a simple specification: write a program that, given a positive even integer, returns two prime integers, whose some is the input, and never fails to do so. Start with a formal statement of the requirement, and derive a program that provably satisfies it. Decompose your program however you like.<p>&gt; Then I derive the code to make the tests pass from the specification<p>Do you use predicate transformers all the way from a high-level spec to each and every line in a 1MLOC distributed and interactive system, with management consoles, reports and ten-thousand users per server?<p>&gt; A mathematical formalism does not require algorithmic automated checking to exist.<p>It most certainly does. That is the literal meaning of &quot;formal&quot; in formal logic&#x2F;method&#x2F;synthesis&#x2F;verification. A formal logic has a proof theory made of inference rules. It means that conclusions are reached by manipulation of the syntactic <i>form</i> -- hence <i>formal</i> -- <i>without</i> use of any mathematical intuition. Alan Turing then showed that a proof system can always be described as a Turing machine, and that formal = mechanical. There is a <i>huge</i> gap between informal mathematical reasoning and formal reasoning. I believe I&#x27;ve seen someone mention an exponential blowup in proof size of formal proofs compared to mathematical proofs.<p>&gt; Obviously no human discipline is infallible and I still make mistakes, but I make far fewer mistakes than I would using the typical sloppy approach most programmers use.<p>There&#x27;s a very, very wide gap between &quot;disciplined&quot; and formal. I am all for disciplined and for using formal methods in various places. End-to-end formal derivation&#x2F;verification, i.e. from high-level spec to code, in a scalable, feasible manner, is yet to be achieved.')