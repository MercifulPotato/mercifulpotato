Item(by='ben509', descendants=None, kids=None, score=None, time=1603345724, title=None, item_type='comment', url=None, parent=24852758, text='I&#x27;m not entirely settled on that.<p>My working approach is if you&#x27;re writing a compiler, it wants to have an unambiguous grammar and shouldn&#x27;t even attempt recovery. If input doesn&#x27;t parse, the compiler can recommend (or just run) the linter. That keeps the common case fast and simple.<p>The linter&#x2F;fixer can have a relaxed syntax specifically designed to handle messy code and suggest corrections. That comes from a philosophy of treating error correction and user assistance as a separate task.<p>But that&#x27;s an approach I&#x27;m taking because I want to get a reference implementation together as quickly as possible. It&#x27;s definitely not how modern IDEs work.<p>JetBrains GrammarKit uses a PEG[1] because they need strong support for error recovery[2] using hints. Another interesting library is Tree-sitter[3]; it does incremental parsing keeping an AST constantly up to date for you.<p>Relevant to this whole discussion, GvR wrote a series on PEG parsers[4] in which he starts out by writing one by hand and then shows how to write one that accepts a grammar.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;Grammar-Kit" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;Grammar-Kit</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;Grammar-Kit#attributes-for-error-recovery-and-reporting" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;JetBrains&#x2F;Grammar-Kit#attributes-for-erro...</a><p>[3]: <a href="https:&#x2F;&#x2F;tree-sitter.github.io&#x2F;tree-sitter&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tree-sitter.github.io&#x2F;tree-sitter&#x2F;</a><p>[4]: <a href="https:&#x2F;&#x2F;medium.com&#x2F;@gvanrossum_83706&#x2F;peg-parsing-series-de5d41b2ed60" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@gvanrossum_83706&#x2F;peg-parsing-series-de5d...</a>')