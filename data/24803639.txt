Item(by='lmilcin', descendants=None, kids=[24806848], score=None, time=1602873167, title=None, item_type='comment', url=None, parent=24803267, text='1.<p>So, Linked Lists vs Arrays is tough and situation specific. What I look from candidate is general understanding of the problem instead of just blindly saying &quot;linked lists are faster for insertions and deletions&quot;.<p>Believe or not, ArrayList are faster for most real life examples (or can be made much faster).<p>Basically (not very precisely but describes it pretty well), for Linked List to be faster than Array List you need an index (or some other way to locate an entry like when you iterate over the list and already have the reference) or perform most operations at both ends.<p>Against popular knowledge, ArrayList is faster in any random access (read, insert or delete) requiring first linear search to locate the entry or insertion place. Why writes is faster even if you have to move heaps of memory to insert something in the middle of array is because searches are so much more expensive for Linked List.<p>Linear search through <i>unindexed</i> Linked List is horribly inefficient compared to ArrayList for many reasons. First, the data is less dense due to references. Then to access next element you need to read pointer from memory and dereference it and this is rather expensive compared to incrementing a pointer which is what you get to get to next element in array list. Then if you have large data structure that was result of random writes it will have rather random layout in memory in case of linked list meaning you will be jumping all over memory and not making good use of prefetching or sharing cache lines. Having CPU prefetch next pages as you iterate through the ArrayList is incredible speedup (but you can get linked list arranged roughly the same way in memory but it can be complex). Then the fact that it is easy to parallellize linear search on array list but not possible on linked list. If the array list can be kept sorted you can do other search strategies (like binary search) but that doesn&#x27;t work with linked list. The list is long.<p>Linked list will be faster if you require insertions and deletions to be fast AT BOTH ends. If you need to insert at the beginning of the ArrayList but not at the end, just reverse the order.<p>It is possible that you can iterate over the list and do operations on elements (for example, delete it). You use the fact that you already have the reference to the location in in that case Linked List may be much faster than Array List.<p>2.<p>Virtual Memory. Because each process has their own memory translations. Basically, userspace pointer does not point to physical memory directly. Instead, every process has their own namespace and same pointer values have different meaning in different namespaces. Those namespaces are then dynamically mapped to physical memory and the Operating System is responsible for keeping the mapping and constantly feeding it to CPU whenever CPU executes userspace code and finds a pointer for which it does not have mapping.<p>CPU keeps Page Table and a buffer of mappings (it is called TLB -- translation lookaside buffer, you may have heard the name). When it gets a pointer to map to physical memory it looks at the page table, when it can&#x27;t find in page table it refers to lookaside buffer and if it can&#x27;t find the information necessary it momentarily interrupts to the operating system. This is normally completely invisible to the program unless somebody is doing some microbenchmarking and then can see it as unexplained artifacts and cause some chuckles from people who really know the stuff.<p>It is possible to map region of same physical memory or file to the same userspace range of addresses (for example using mmap or when using shared libraries). In this case it is possible to make multiple processes have pointers with same values to dereference to same physical memory address.<p>Old operating systems that did not have concept of virtual memory were basically open world where a process could access everything. Then the concept of Virtual Memory was introduced but the separation was not enforced in other way because just the fact that single page of physical memory was only mapped from single memory space made it pretty good enforcement (at the time).<p>3.<p>Java is exclusively pass by value. The values are primitives or references. It is pass by value because the variable in Java holds either a primitive or a reference and when a function is invoked, instead of passing reference to the variable, the value of the variable is copied. Meaning if you have Object a = x; function_call(a); then you are sure than nothing that happened in function_call(a) could modify the variable a. In pass by reference language the the function_call(a) would pass reference to a and this could allow function_call(a) to modify the variable a.<p>4.<p>You can have multiple programs listening on different protocols. For example, you can have one program listening on TCP port and another on UDP. There is I think some new facility in Linux that allow even more functionality but I am not up to date with it.<p>5.<p>Volatile ensures ordering of operations around reads writes to the volatile variable is not changed by VM or CPU and also ensures that any writes and reads are directed to main memory (at least on systems with more than one L3 cache, ie. with more than one CPU).<p>On most CPUs this happens by a special fence instruction. I am not very familiar with JVM internals so I don&#x27;t know how this is exactly done (but I expect special instruction, too).<p>6.<p>Breakpoint is an instruction that is inserted by the debugger directly into machine code of the running program (bytecode in case of Java program). In case of native program this instruction causes an interrupt that causes CPU to stop the program and wake up Operating System. The operating system then passes control to the debugger (which had to first make appropriate setup for this to happen) and then debugger decides what to do depending on the action debugger user wanted to execute.<p>The way the instruction is inserted is usually interesting by itself. Depending on environment, either some space is kept in the function so that it can grow to accommodate the new instruction or the code of the function is copied somewher else with the new instruction and all references to the function are mapped to point to the new copy of the function machine code. I don&#x27;t know how this is exactly achieved in Java.')