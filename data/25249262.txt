Item(by='skissane', descendants=None, kids=[25249756], score=None, time=1606693924, title=None, item_type='comment', url=None, parent=25246258, text='&gt; The short lived and of limited scope OS&#x2F;2 subsys was for binary compat, but given the origin and NT and the similarities of some techs it is not surprising<p>They could have used a more classic NT environment subsystem architecture for WSL1, it would have mostly worked. The primary reason they didn&#x27;t was performance, and to a lesser extent compatibility.<p>Unix systems create lots of short-lived processes, because processes on Unix are relatively cheap. By contrast, NT processes are much heavier weight. This is part of why the POSIX subsystem &#x2F; Interix &#x2F; SFU &#x2F; SUA and Cygwin too always have had performance problems. Introducing a new lightweight process concept, the picoprocess, helped get over the performance issue. But these new lightweight processes can&#x27;t be allowed to make arbitrary NT syscalls, which rules out the classic NT environment subsystem implementation pattern - have DLLs which make NT syscalls instead of e.g. OS&#x2F;2 syscalls.<p>If they&#x27;d followed the classical Windows NT environment model, they would have enhanced NT to be able to load ELF executables and then shipped their own libc.so which made NT syscalls. That would have worked fine for most apps which don&#x27;t make Linux syscalls directly, but would have had worse performance than WSL1 had. It also would have meant more work for them, since they&#x27;d be emulating not just the syscall layer but the libc layer too. (They could have sped things up by reusing the GNU libc code; to do that, they would have had to have open sourced most of the code of their subsystem, which would have probably been a positive overall, but I&#x27;m not sure how feasible that would have been given internal Microsoft politics around open source.)<p>To support the minority of apps which make Linux syscalls directly, bypassing libc, they needed something in the kernel to intercept the SYSENTER&#x2F;SYSCALL&#x2F;INT 0x80. They could have redirected it back to user mode for handling in their libc.so. That would have worked, it just would have been slower than WSL1 is. (And WSL1 already has enough performance issues, that performance was one of the main motivators for switching to the new architecture in WSL2.)')