Item(by='Twisol', descendants=None, kids=None, score=None, time=1609138425, title=None, item_type='comment', url=None, parent=25556440, text='Personally, I&#x27;m nursing a thesis that the study of concurrency is fertile ground for a formalization of modular design. Where parallelism is the optimization of a software system by running parts of it simultaneously, concurrency has much more to do with the assumptions held by individual parts of the program, and how knowledge is communicated between them. Parallelism requires understanding these facets insofar as the assumptions need to be protected from foreign action -- or insfar as we try to reduce the need for those assumptions in the first place -- but I expect that concurrency goes much further.<p>Concurrent constraint programming is a nifty approach in this vein -- it builds on a logic programming foundation where knowledge only increases monotonically, and replaces get&#x2F;set on registers with ask&#x2F;tell on lattice-valued cells. LVars is a related (but much more recent) approach.<p>A different approach, &quot;session types&quot;, works at the type system level. Both ends of a half-duplex (i.e. turn-taking) channel have compatible (dual) signatures, such that one side may send when the other side may receive. Not everything can be modeled with half-duplex communications, but the ideas are pretty useful to keep in mind.<p>I try to keep my software systems as functional as possible (where &quot;functional&quot; here means &quot;no explicit state&quot;). But there are always places where it makes sense to think in terms of state, and so I try to model that state monotonically whenever possible. At least subjectively, it&#x27;s usually a lot simpler (and easier to follow) than unrestricted state.<p>(Note, of course, that local variables are local in the truest sense: other programmatic agents cannot make assumptions about them or change them. Short-lived, local state is as good as functional non-state in most cases.)')