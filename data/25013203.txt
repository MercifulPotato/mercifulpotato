Item(by='jeff-davis', descendants=None, kids=None, score=None, time=1604722971, title=None, item_type='comment', url=None, parent=25008587, text='The problem with analogies is that software is fundamentally new.<p>It&#x27;s not debt where you can just pay it off after the launch. It&#x27;s not a mess where a cleaning crew can have it taken care of in a day or a week. It&#x27;s not a structure that will collapse because you added one too many storeys.<p>Software takes all the guardrails off of complexity. A swiss watch is a mechanical masterwork, but the complexity is limited because you have to fit the gears into a limited space. Everything else we deal with has some kind of pushback on complexity, with the <i>possible</i> exception of biological systems that take millions of years to change.<p>Software can grow in complexity with no obvious bound. You can tackle any one particular bug with an extra branch to say &quot;don&#x27;t let this happen&quot;. But a gigabyte of branches is a hell of a lot of complexity.<p>Software engineering is an attempt to wrangle that complexity through all kinds of strategies from &quot;architecture&quot; (another poor analogy) to type systems and OOP and FP and the actor model and everything else.<p>Technical &quot;debt&quot; is really the mismanagement of complexity. It&#x27;s hard to understand the costs because the costs are inherently unknown unknowns. If you mismanage complexity, then all estimates are meaningless because at any point you could hit a never-ending fractal of problems. It might be completely intractable to add any significant new feature.<p>Developers want to ship features, call it a job well done and take some time off for Christmas. When working with technical debt, no matter how smart the developer is, it&#x27;s really just luck of the draw who hits a fractal of problems and never finishes and who doesn&#x27;t and converges on a solution (and when it&#x27;s bad enough, the latter just never happens).')