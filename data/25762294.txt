Item(by='quietbritishjim', descendants=None, kids=[25762523], score=None, time=1610548016, title=None, item_type='comment', url=None, parent=25760069, text='&gt; In C [enumeration constants] are of type int, C++ they are of the enumeration type itself.<p>&gt; ... C and C++ have different rules for implicit conversion from an to these types, so you better avoid using them [in function parameters]<p>Correct me if I misunderstood, but don&#x27;t these differences cancel each other out? For example:<p><pre><code>    &#x2F;* In header file *&#x2F;\n    enum Foo { FOO_A, FOO_B };\n    void bar(Foo f);\n    \n    &#x2F;* In code *&#x2F;\n    bar(FOO_A);\n</code></pre>\nIn C, FOO_A is an integer, but it&#x27;s implicitly convertable to Foo so the call to bar is fine. In C++, int cannot implicitly convert to type Foo, but FOO_A is already of type Foo to begin with, so the function call is still fine. (In fact the call to bar() would in a .c or .cpp file so is allowed to be different between the two languages anyway.)<p>Edit: Another oddity in the article: If you want a function to work with a small number of different types, you would surely use simple function overloading rather than function template specialisation. In general it&#x27;s a mistake to use function template specialisation, and there&#x27;s certainly no need to use it here.')