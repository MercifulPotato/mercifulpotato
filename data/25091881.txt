Item(by='josephg', descendants=None, kids=[25092129, 25092018, 25092218], score=None, time=1605356465, title=None, item_type='comment', url=None, parent=25091648, text='The point of the article is how if you want the filesystem API to write data safely, <i>you</i> need to jump through a lot of hoops. (Which, spoilers: most developers don&#x27;t do. And even developers who try really hard often get it wrong because the APIs are so awful and poorly documented. Hence the ever present spectre of data corruption.)<p>According to the article, if I use ext4 with journaling and have a file with &quot;a foo&quot; and write &quot;bar&quot; at position 2, possible resulting states are: &quot;a foo&quot;, &quot;a boo&quot;, &quot;a bao&quot; or &quot;a bar&quot;. This is the best scenario - without journaling, I can also end up with uninitialized junk.<p>The authors of the filesystem APIs consider this to be correct behaviour. But I can&#x27;t think of <i>any</i> use case for this nonsense behaviour. Real data, in every file on your computer is structured. And structured files simply can&#x27;t handle this kind of data corruption. Maybe this API has slightly higher throughput, but by the time you&#x27;ve peppered your code with fsync() calls to make it correct, you&#x27;ve killed performance. And working around <i>that</i> takes whole philosophies of threading and thousands of lines of code.<p>I want that write call to either complete completely or fail completely. Actually, I want more than that - for a bunch of successive write calls touching multiple files to collectively succeed together or fail together. Which is not what the article is saying.<p>&gt; Its like saying, well software just shouldnt have bugs<p>The kernel shouldn&#x27;t have bugs in its filesystem. We don&#x27;t tolerate bugs in the scheduler, or in OpenSSL or in the CPU. If Postgres randomly corrupted its database every month or two, we would fix the bug. Or call it broken and use something else. If SQLite can implement transactions on top of the current filesystem APIs, then obviously its possible to put that behaviour in the kernel. And in the kernel, that code would be easier to optimize, and would be useful everywhere.<p>If it was a simple bug, we would fix it. The problem is that the bug is that we have the wrong abstraction. Why do we have the current filesystem API? The story I heard is it was written by some intern at Berkeley decades ago who thought it would be neat to have files and network streams use the same API. We know more now, and its past time to fix the mistake.<p>&gt; Thats why all the FS as database efforts in the early 2000s like Longhorn failed.<p>I don&#x27;t buy the cynicism. Just because microsoft overengineered longhorn (and successfully shipped TxF btw), doesn&#x27;t mean the problem is unsolvable.')