Item(by='lmm', descendants=None, kids=[25355041], score=None, time=1607476010, title=None, item_type='comment', url=None, parent=25348003, text='&gt; There were no real transactions, no ensured consistency<p>Which is the right way to do it, because transactions don&#x27;t extend into the real world. If you need to wait for the consequences of a given event, wait for the consequences of that event. Otherwise, all you really care about is all events happening in a consistent order. It&#x27;s a much more practical consistency model.<p>&gt; and no referential integrity<p>The problem with enforcing referential integrity is how you handle violations of it. Usually you don&#x27;t really want to outright reject something because it refers to something else that doesn&#x27;t exist yet, so you end up solving the same problem either way.<p>&gt; There was also no authentication or authorization, because a default-configured deployment of Kafka from Confluent happily neglects such trivial details.<p>Pretty common in the database world - both MySQL and PostgreSQL use plaintext protocols by default. Properly-configured kafka uses TLS and&#x2F;or SASL and has a good ACL system and is as secure as anything else.<p>&gt; It was a nightmare to code against once you left the fantasy world of functional programming nirvana and encountered real requirements. It meant pushing a whole series of concerns that isolation addresses into application code... or not addressing them at all.<p>My experience is just the opposite - ACID isolation sounds great until you actually use it in the real world, and then you find it doesn&#x27;t address your problems and doesn&#x27;t give you enough control to fix it yourself. It&#x27;s like when you use one of those magical do-everything frameworks - it works great until you need to customise something slightly, then it&#x27;s a nightmare. Kafka pushes more of the work onto you upfront - you have to understand your dataflow and design it explicitly - but that pays off immensely.<p>&gt; It was a GDPR nightmare.<p>Really? I&#x27;ve found the exact opposite - teams that used an RDBMS had to throw away their customer data under GDPR, because even though they had an entry in their database saying that the customer had agreed, they couldn&#x27;t tell you what the customer had agreed to or when. Whereas teams using Kafka in the way you describe had an event record for the original agreement, and could tell you where any given piece of data came from.')