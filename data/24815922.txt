Item(by='sergeykish', descendants=None, kids=None, score=None, time=1603002763, title=None, item_type='comment', url=None, parent=24814741, text='That is simply not true, io language is prototype based yet it is simple to reason about, fix for JavaScript:<p><pre><code>    Object = Object.prototype\n    Function = Function.prototype\n</code></pre>\nThat&#x27;s how most dynamic languages work, no need for explanations, obvious assertions:<p><pre><code>    Object.__proto__ === null\n    Function.__proto__ === Object \n\n    object = new Object.constructor\n    object.__proto__ === Object\n    object.constructor === Object.constructor\n    object.toString === Object.toString\n\n    object.private = function () { return &#x27;hello&#x27; }\n    Object.shared  = function () { return &#x27;world&#x27; }\n    Object.constructor.static = function () { return &#x27;!&#x27; }\n</code></pre>\nIt shows hidden complexity — what does instanceof mean?<p><pre><code>    &#x2F;&#x2F; Object instanceof Function\n    Object.constructor.__proto__.constructor === Function.constructor\n    &#x2F;&#x2F; Object instanceof Object\n    Object.constructor.__proto__.__proto__.constructor === Object.constructor\n    &#x2F;&#x2F; Function instanceof Function\n    Function.constructor.__proto__.constructor === Function.constructor\n    &#x2F;&#x2F; Function instanceof Object\n    Function.constructor.__proto__.__proto__.constructor === Object.constructor\n</code></pre>\nWhy would anyone want this? Lets get rid of .constructor on both sides:<p><pre><code>    Object.constructor.__proto__ === Function\n    Object.constructor.__proto__.__proto__ === Object\n    Function.constructor.__proto__ === Function\n    Function.constructor.__proto__.__proto__ === Object\n</code></pre>\nNow it is obvious — constructor is a Function, Functions __proto__ is Object. JavaScript programmers jump through &quot;.prototype&quot; hoops which should not be exposed.')