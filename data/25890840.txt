Item(by='jorangreef', descendants=None, kids=None, score=None, time=1611483429, title=None, item_type='comment', url=None, parent=25890701, text='I wrote this for Node.js, which is a native binding in C, exposing cross platform functionality: <a href="https:&#x2F;&#x2F;github.com&#x2F;ronomon&#x2F;direct-io" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;ronomon&#x2F;direct-io</a><p>Although if it&#x27;s a new project and you&#x27;re used to C, I would recommend also taking a good look at Zig (<a href="https:&#x2F;&#x2F;ziglang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;</a>), because it&#x27;s so explicit about alignment compared to C, and makes alignment a first-class part of the type system, see this other comment of mine that goes into more detail: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25801542" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25801542</a><p>Something that will also help, is setting your minimum IO unit to 4096 bytes, the Advanced Format sector size, because then your Direct IO system will just work, regardless of whether sysadmins swap disks of different sector sizes from underneath you. For example, a minimum sector size of 4096 bytes will work not only for newer AF disks but also for any 512 byte sector disks.<p>Lastly, Direct IO is actually more a property of the file system, not necessarily the OS (e.g. Linux), so you will find some file systems on Linux that return EINVAL when you try to open a file descriptor with O_DIRECT, simply because they don&#x27;t support O_DIRECT (e.g. a macOS volume accessed from within a Linux VM) so that should be your way of testing for support, not only the OS.')