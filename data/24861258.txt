Item(by='vlovich123', descendants=None, kids=None, score=None, time=1603390371, title=None, item_type='comment', url=None, parent=24858456, text='I love using cap&#x27;n&#x27;proto to store configurations. It&#x27;s really slick.<p>+ Type safe since you define the schema for every part of your configuration.<p>+ Ridiculously easy to read&#x2F;understand (writing has a small ramp curve to build the muscle memory).<p>+ Type system is very flexible &amp; rich (lists, maps, unions), supports generics (for built-in &amp; custom types) &amp; everything is neatly composable (including constants that reference constants).<p>+ The config compiles down to a minimal binary file.<p>+ You can have arbitrary configurations in 1 file (you compile a specific constant to a file so each configuration you want is just 1 constant value you define in the schema).<p>+ The binary file can be converted back to text using standard cap&#x27;n&#x27;proto tools so it&#x27;s easy to double-check the config you&#x27;re deploying.<p>+ Perfect backward&#x2F;forward support for the configuration as long as you follow the rules (similar to protobuf&#x2F;flatbuffers) since you have to define the schema for your constants.<p>+ Loading the config file from any data source (disk, network) is trivial and for on-disk usages you could mmap the struct to get even better performance (only the parts of the config you access would get paged in).<p>+ Supports a variety of languages. While the RPC stuff has a bit less adoption, the parts needed for configuration should be available in the most popular languages (I think the only missing language generator is Swift).<p>The only negatives are:<p>- You do have to define the schema for your config<p>- There&#x27;s a single upfront cost to integrate cap&#x27;n&#x27;proto into your build system if you&#x27;re not using CMake.<p>Neither feel like prohibitive negatives though. If you&#x27;re looking at strong typing, why not go all the way &amp; make sure that your entire config has a strongly typed structure to it? Not just that some field is an int also that there&#x27;s certain specifically named fields &amp; that accessing these fields in a strongly-typed languages will result in build errors if you forgot to change something.')