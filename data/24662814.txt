Item(by='salawat', descendants=None, kids=[24663108], score=None, time=1601648120, title=None, item_type='comment', url=None, parent=24661909, text='As a user, you&#x27;re missing details, and completely misunderstand several abstractions.<p>For instance, gtk and qt are not desktops. They&#x27;re ui toolkits. Bunches of widgets that can be composed to cobble together a UI.<p>That&#x27;s completely separate from the topic under discussion, which is mode of application delivery. FlatPak involves using namespacing and containers to &quot;spin up&quot; a virtual system with only visibility into those slices of the overall host needed to run the program.<p>This is good because it at least keeps unfamiliar software constrained somewhere predictable, but poor because often it won&#x27;t use OS host libraries, which are generally kept the most up to date, and worst of all, enforces a complexity and debuggability tax where one has to have an intimate understanding of what is going on &quot;in the box&quot; if something goes wrong.<p>Other ways mentioned are the distro model, whereby distributions maintain repository ecosystems and make decisions with regard to FHS compliance, system tooling, update pipeline, etc..., and use those to support their user base.<p>There is the original &quot;compile and stage it yourself&quot; crowd, who basically concentrate on reproducible build capabilities, but tend to lack in automatic dependency resolution.<p>There&#x27;s the Mac way, which isn&#x27;t terrible. It tracks and designates places for libraries, Frameworks, and Applications, and has a lot of automated and well integrated ui-tooling which makes the user experience of software install easy, but it&#x27;s just another paradigm you have to track when trying to write portable software.<p>There&#x27;s static linking, which delivers executables that are entirely self-contained, but tend to be bigger memory footprint-wise, each have an upgrade path separate from every other executable, and benefit not at all from dynamic linked libraries on the host system.<p>Then finally, there is dynamically linked executables. They&#x27;re small, commonly reused code is loaded once in memory you have the additional complexity of the linker to be aware of, but you can update the entire system&#x27;s audience of a particular library at the same time... Which can be a double-edged sword given how the maintainer scripts the install or sets up their system&#x2F;build environment.<p>Personally, I just sidestep the issue myself by digging into and learning about software I use on a regular basis with disassembly tools, and treat all of my systems the way a good farmer treats their livestock. Distant reverence, but with a careful eye as to whether there is something wrong, and a hard fought for willingness to kill something and start from scratch. It&#x27;s the only way I&#x27;ve found to be truly safe and resilient in an environment where everyone optimizes for their own particular definition of convenience.<p>(My definition of convenience is a minimum difficulty in troubleshooting what might be wrong, so I favor fewer abstractions as that entails less Tower of Babel to wade through).<p>Full disclosure: my approach generally would classify me as a bit of a curmudgeon in the industry as I still approach computers as being analogs of physical machines. There is a healthy corpus that revels in abstraction, but I&#x27;m not really one of them. I like to have a ballpark understanding of what the artfully arranged beach sand is doing. Adding more abstractions or having the computer do things itself is generally not something I strive toward as it almost always comes with an unacceptable increase in the overall complexity inherent to navigating the Gulf between how I and everyone else thinks the system works and how it actually does.<p>More than anything else, in my experience, keeping that Gulf small leads to better overall satisfaction from a lay User. YMMV.')