Item(by='christianalfoni', descendants=None, kids=[24752665, 24755565, 24753218, 24752818], score=None, time=1602492177, title=None, item_type='comment', url=None, parent=24750620, text='Hi there and thanks for the feedback on &quot;Why even choose this&quot;. Will update the front page!<p>But to answer your question.<p>The main reason Overmind and its predecessor Cerebral (<a href="https:&#x2F;&#x2F;cerebraljs.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cerebraljs.com&#x2F;</a>) was developed is application insight. The complexity of what we build on the web these days is way beyond the scope of what our brains are able to comprehend. What effects are triggered and what state changes are made is difficult to infer reading code and using low level debugging tools. Basically understanding what actually happens when you open the browser and interact with the application. So the main reason Overmind should catch your interest is its debugger. It is not there just to debug errors, it is there to constantly give you a mental image of the whole application at the abstraction level of the application itself.<p>The second reason Overmind was developed is to reduce the amount of concepts of APIs required to get going with an application. Most developers, arguably, think about code imperatively. &quot;I have this thing I want to do, let me just do it&quot;. That is why Overmind has a base concept of an &quot;action&quot;, where you can access any state, effects and other actions you have defined in your application... and just do it. This, arguably, lowers the threshold of understanding and scaling up your app. When you get into concepts related to time complexity Overmind provides operators. When you get into concepts related to state complexity Overmind provides statemachines and statecharts. It is important to understand that Overmind does not let you just free wield state changes. You can only run state changes in actions and unlike Mobx you can use async code as normal. The state changes are bound to the action execution itself, again creating a more straight experience with less concepts to learn.<p>The third reason is TypeScript. We have all felt the pain of Redux boilerplate and with TypeScript it does not become better. Overmind has the goal for you to spend as little effort as possible telling TypeScript about your application, it should just understand it. Basically help developers move to TypeScript by gaining as much benefit as possible with as little typing as possible.<p>Now, Overmind was not built to send a message that mobx-state-tree and redux are bad solutions. It is intended to be a healthy alternative in the ecosystem showing that controlled mutability is a valid approach and hopefully be an inspiration that we can push visual tooling way beyond what we are doing currently.<p>To get more details on controlled mutation VS value comparison (immutability) I wrote an article here: <a href="https:&#x2F;&#x2F;itnext.io&#x2F;updating-uis-value-comparison-vs-mutation-tracking-9f6fe912dd9a" rel="nofollow">https:&#x2F;&#x2F;itnext.io&#x2F;updating-uis-value-comparison-vs-mutation-...</a>')