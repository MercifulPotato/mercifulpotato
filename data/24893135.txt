Item(by='tikhonj', descendants=None, kids=None, score=None, time=1603690975, title=None, item_type='comment', url=None, parent=24892520, text='&gt; <i>But will the formalisms actually help you when the job you’re doing has insufficient achievable precision (eg finding market fit for a website)?</i><p>In my experience, this is <i>exactly</i> the problem Haskell&#x27;s core abstractions—monads among them—help with!<p>What do you need when you&#x27;re trying to find product-market fit? Fast iteration. What do Haskell&#x27;s type system and effect tracking (ie monads) help with? Making changes to your code quickly and with confidence.<p>Haskell provides simple mathematically inspired tools that:<p>1. Make clean, well-factored code the path of least resistance.<p>2. Provide high-level, reusable libraries that keep your code expressive and easy to read at a glance <i>despite</i> the static types and effect tracking.<p>3. Give you guardrails to change your code in systematic ways that you <i>know</i> will not break the logic in a wide range of ways.<p>If I had a problem where I&#x27;d need to go through dozens of iterations before finding a good solution—and if libraries were not a consideration—I would choose Haskell over, say, Python any day. And I say this as someone who writes <i>a lot</i> of Python professionally these days. (Curse library availability!)<p>Honestly, Haskell has a reputation of providing really complicated tools that make your code really safe—and I think that&#x27;s totally backwards. Haskell <i>isn&#x27;t</i> safe in the sense that you would want for, say, aeronautical applications; Haskell programs can go wrong in a lot of ways that you can&#x27;t prevent without extensive testing or formal verification and, in practice, Haskell isn&#x27;t substantially easier to formally verify than other languages. And, on the flipside, Haskell&#x27;s abstractions really <i>aren&#x27;t</i> complicated, they&#x27;re just <i>different</i> (and <i>abstract</i>). Monads aren&#x27;t interesting because they do a lot; they&#x27;re interesting because they only do a pretty small amount in a way that captures repeating patterns across a really wide range of types that we work with all the time (from promises to lists to nullable values).<p>Instead, what Haskell does is provide <i>simple</i> tools that do a &quot;pretty good&quot; job of catching common errors, the kind of bugs that waste a lot of testing and debugging time in run-of-the-mill Python codebases. This makes iteration faster rather than slower because you get feedback on whole classes of bugs immediately from your code, without needing to catch the bug in your tests or spot the bug in production.')