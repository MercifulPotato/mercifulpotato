Item(by='mcqueenjordan', descendants=None, kids=[25044595, 25043957, 25042477, 25045252, 25042219, 25042073, 25042347], score=None, time=1604970716, title=None, item_type='comment', url=None, parent=25024901, text='It&#x27;s my own weird little take, but I&#x27;ll share it.<p>In my experience, simple concurrency is easy. Confused concurrency is exceptionally hard.<p>I think about this in the same way I think about C++. C++ is quite nice, if your teams limit themselves to a reasonable subset of the language. But it can become an absolute monster of cumbersome complexity, if these guardrails go away.<p>Concurrency feels the same. If you take a certain view on concurrency, which is &quot;do it as simply as possible, don&#x27;t break certain rules, don&#x27;t try to be too clever,&quot; I find it fairly straightforward to reason about.<p>At the same time, 9 out of 10 of the hardest things I&#x27;ve debugged have always been nasty, awful concurrency bugs. The reason it was so hard? The concurrency was complicated, interwoven, assumption-laden, and absolutely impossible for anyone to reason about. Implicit contracts between calls required entire whiteboards of non-trivial state to understand, and even then, with all that work, it was a needle in a haystack.<p>I guess I would just say: It doesn&#x27;t have to be hard. It&#x27;s only hard if you don&#x27;t respect it from the beginning.')