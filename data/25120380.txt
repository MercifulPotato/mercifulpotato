Item(by='nanoscopic', descendants=None, kids=None, score=None, time=1605588953, title=None, item_type='comment', url=None, parent=25119451, text='I agree that adding error checking at every possible error location and then passing up those errors is tedious, but it is a direct result of Golang essentially being a &quot;modern C&quot;.<p>In the case you describe it sounds like it was particularly painful due to the multi-threaded nature of the software.<p>You didn&#x27;t call it out directly but I feel like the inability of Golang to do polymorphism makes it more difficult.<p>If the result of something is simply a message, and that message can be either a normal data type or an error, then you don&#x27;t need to always additionally return an optional error. This is why I prefer the idea of message passing languages over direct procedural languages.<p>It is still possible to do this somewhat in Golang using channels and&#x2F;or queues, channels can tend to get clogged and freeze up in my experience.<p>I&#x27;ve had good experiences using Mangos ( Golang nanomsg implementation ). If you use inproc queues, you can do multi-threading in a language portable way. Then, if you decide to replace a processing component with something other than Golang, it is relatively easy to do so.')