Item(by='mumblemumble', descendants=None, kids=[25571714, 25575426], score=None, time=1609253180, title=None, item_type='comment', url=None, parent=25565281, text='&gt; The state that you do have is generally called out more visibly.<p>You see, this is the exact opposite of what I was discovering in this codebase. Sure, in Haskell, you have an IO monad that effectively puts bright blinking lights and klaxons over all the state, and a compiler that forces you to use it. But the vast majority of functional-style code is not written in a language like that. It&#x27;s written in a language like Scala or Clojure or JavaScript that allows you to sneak a side effect into any portion of the call tree. And, by being several layers deep in the call tree, it&#x27;s <i>not</i> visible. It&#x27;s hidden, and, when it&#x27;s being done in the context of a generally functional idiom, it&#x27;s downright pernicious.<p>You hit the nail on the head in your comment further up. I did find my mutable variables. My epiphany after seeing this code is that, in a language where the only thing that can enforce true purity (as opposed to simply trying to avoid mutable variables as a general rule) is programmer discipline, the natural equilibrium point is code that still every bit as riddled with state. It just delegates the management of that state out to Redis or whatever.<p>Discipline is a good enforcement strategy for small individual projects. It&#x27;s possibly also a good one for open source projects. I don&#x27;t believe it can work for corporate team projects, because social factors at play generally won&#x27;t allow it to work. There will always be some business constraint that prompts people to take shortcuts.')