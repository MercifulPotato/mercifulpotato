Item(by='WorldMaker', descendants=None, kids=None, score=None, time=1608593502, title=None, item_type='comment', url=None, parent=25499101, text='&gt; It isn&#x27;t synchronous, it only looks so.<p>Ah, all the more dangerous then.<p>I appreciate that throwing promises is a clever flow control hack and that y&#x27;all have proven it to be a useful micro-optimization, at least in current V8. But my experience tells me that I&#x27;d rather a junior developer write incorrect async&#x2F;await code than accidentally introduce a synchronous dead-lock. Async code that looks synchronous can mask synchronous code that should be async much easier.<p>&gt; However, they do leave us the ability to use sync I&#x2F;O in the cases where it makes sense<p>async&#x2F;await don&#x27;t stop you from doing that either. The .NET CLR&#x2F;BCL has a lot of optimizations in place today for fast-pathing synchronous Task&lt;T&gt; (and now ValueTask&lt;T&gt;) code. As Promises become more and more common in the JS ecosystem it should be expected that more and more such optimizations will arrive in JS engines &quot;tomorrow&quot;.<p>Even if we don&#x27;t feel like we can expect such optimizations soon, server side code is obviously easier to scale for the application developer and less needful of such micro-optimizations, and I think adds more weight to my gut instinct that explicitly async (async&#x2F;await) code on server side would possibly be one good way to make a distinction between client and server-side only code.')