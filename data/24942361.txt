Item(by='gwbas1c', descendants=None, kids=None, score=None, time=1604067152, title=None, item_type='comment', url=None, parent=24940650, text='&gt; Is Rust web yet?<p>Only if you REALLY need it, like if you&#x27;re embedding a web server into an existing Rust service. Otherwise, it&#x27;s going to be very time consuming to do things that are straightforward in other languages.<p>(TLDR: A Rust++, or &quot;Objective Rust&quot; that simplifies some memory issues could make Rust web ready.)<p>For the past few months, my occasional hobby has been trying to learn Rust. BUT, I&#x27;ve also spent a considerable amount of time getting up to speed in NodeJS.<p>Regarding running Rust in the browser with WebAssembly: I&#x27;ve spent <i>DAYS</i> trying to figure out how to hook callbacks into the DOM cleanly. I basically went through the &quot;Game of Life&quot; walkthough, (<a href="https:&#x2F;&#x2F;rustwasm.github.io&#x2F;docs&#x2F;book&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rustwasm.github.io&#x2F;docs&#x2F;book&#x2F;</a>), and then ported all of the JavaScript sides into Rust. Trying to make registering a callback from the DOM as clean as implementing a button click handler in C# is just a nightmare.<p>The problem is that Rust just isn&#x27;t good for complicated object graphs. This is where almost any language that&#x27;s garbage collected, or uses some form of automatic reference counting, shines. And, if you&#x27;re building a &quot;normal&quot; web application, Rust isn&#x27;t going to have tangible performance advantage over Java &#x2F; C# &#x2F; NodeJS &#x2F; Python. (Meaning, if you aren&#x27;t running at Google Scale, there&#x27;s no tangible performance advantage for Rust.)<p>Part of what happens in Rust is that it&#x27;s very hard for a struct to reference itself so it can register event callbacks. You&#x27;re forced to either make all users of the struct use reference counting, or you have to encapsulate a reference counted type used with callbacks. In a garbage collected language, this kind of hurdle isn&#x27;t needed. In reference counted languages, registering event handlers just requires a weak reference to yourself to avoid cyclic loops. This is because GC &#x2F; ARC languages assume the same memory model for all objects; which isn&#x27;t the case in Rust.<p>Anyway, to make Rust easier to work with, it needs a way to trade some of the raw, &quot;0-cost-abstraction&quot; advantages for the advantages that come with GC &#x2F; ARC languages. Need raw performance? Use pure Rust. Just need to get it done? Use a higher-level syntax.')