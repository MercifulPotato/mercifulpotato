Item(by='andrewzah', descendants=None, kids=[25975102], score=None, time=1612057047, title=None, item_type='comment', url=None, parent=25974826, text='&quot;If you&#x27;re just launching, your focus should not be on performance or how easy it is to dockerize but to figure out who your user really is.&quot;<p>I agree here but I should note that my main focus is spending less time debugging errors at runtime and in production, and avoiding errors in the first place. This is primarily why I use rust.<p>&quot;Not sure the verboseness of either golang or rust&quot;<p>Verbosity has nothing at all to do with implementing good, robust code. You could do it in python, rust, or another language. With certain languages you don&#x27;t have to spend time writing guard code because it&#x27;s handled natively by the compiler, type system, or both.<p>&quot; dynamically typed languages (arguably) makes it easier to change things,&quot;<p>They make it easier to change things, not necessarily correctly. With modern IDEs refactoring is not an issue.<p>&quot;Many have imagined and built valuable stuff in interpreted, dynamically typed languages before you, by being more focused on overall structure and making sure it&#x27;s strict and resilient. One really doesn&#x27;t have to search far for successful applications that are certainly way beyond 1000 LoC and still iterate pretty quickly for their size.&quot;<p>I am aware of this, but I can&#x27;t help but wonder if they would be able to iterate much more quickly knowing that the compiler and type system eliminate entire classes of bugs. Sure, you might be able to get to running code a little bit faster, but if you have to spend time guarding it and debugging runtime errors... is it really faster?<p>===<p>There seems to be this mindset that being fledgling startup means no time for silly things like types or compilation, etc, only iteration. If one actually does their market research and figures out who their users are and what they want, one should be able to iterate just as quickly in i.e. golang or another compiled language with a healthy ecosystem.<p>I have not worked at a FAANG company or a company even remotely the size of those companies, but I have created and maintained somewhat large ruby on rails codebases. Debugging runtime errors became my bane, especially when I could not guarantee that the persons writing the ruby code were following modern practices (or any practices at all). Not that I think compilers are perfect, but they -do- catch so many errors, some of which may have made it into runtime.')