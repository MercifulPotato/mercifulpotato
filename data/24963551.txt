Item(by='andy_threos_io', descendants=None, kids=None, score=None, time=1604274185, title=None, item_type='comment', url=None, parent=24960108, text='The article brings up some good points, but there are several misconception.\nYou can&#x27;t compare normal user program execution with operating system kernel code execution. Total different beasts.\nThere are reasons, that most operating system kernels are written in C and assembly. And also there is a reason why kernel code seldom use any FPU or SIMD instructions beside saving and restoring the FPU and SIMD context on context switch for user threads. ( The size of the SIMD registers in byte x86_64 SSE (256)  x86_64 AVX (512) x86_64 AVX-512 (2048))<p>Ex. You don&#x27;t want your interrupt server code use any FPU&#x2F;SIMD instructions, as you don&#x27;t want to save and restore the register file for the FPU&#x2F;SIMD registers for the kernel code. It&#x27;s just takes to much time. And there are other architectural execution penalty on some CPUs when using large SIMD instruction codes.<p>We measured simple operating system functions, like page clear with SIMD, and it&#x27;s just does not worth it even if we only use SIMD instructions in that function and save&#x2F;restore only the necessary SIMD registers.<p>Also heavy inter operation between low level assembly and higher level system code ( C ) are essential in kernel. You have to be able to handle the same structures in assembly and C without any misalignment and misaddressing. ( we use special macros to write down kernel structures, that are used in both assembly and C, all of the assembly files are C preprocessed)<p>And there are other several issues with OS kernel codes (handling special registers, changing address spaces (virtual), invalidating&#x2F;flushing caches (specially on ARM), managing any kind of exception (hard and soft,  page fault, invalid instructions etc. ), real-time handling, kernel context handling if any, etc.).')