Item(by='kristoff_it', descendants=None, kids=[25801601, 25801173], score=None, time=1610757361, title=None, item_type='comment', url=None, parent=25798473, text='I wouldn&#x27;t use this analogy as an everyday tool, but in reply to the comment above, if we really <i>have</i> to give the &quot;Go&quot; role to either Zig or Rust, I&#x27;d choose Rust for the main reason that, while you can certainly come up with a lot of abstruse abstractions, the language ultimately wants to keep you away from certain tools that would otherwise be considered core to a systems programming language. I&#x27;m of course referring to the restrictions that ensure safety at the expense of being able to implement some kinds of algorithms (in a &quot;safe&quot; way).<p>Go in may ways has the same approach: stop developers from doing potentially damaging things (according to Go&#x27;s definition of what&#x27;s &quot;potentially damaging&quot;), which I guess is one of the reasons why the creators decided to remove pointer arithmetic and add a garbage collector.<p>Zig wants to keep the language small, but the programmer is expected to have access to all kinds of advanced tools, in a way that I don&#x27;t see neither Go nor Rust consider acceptable.<p>In Zig you can use `undefined` to avoid initializing memory, do all kinds of pointer arithmetic, and while you can&#x27;t overload operators, you can use comptime to concoct all kinds of static&#x2F;dynamic dispatch schemes, the only limit is just that they can&#x27;t masquerade as basic operations.<p>Of course you can do all these things in Rust unsafe, and same in Go  with cgo, but the point is not what you can or can not do, it&#x27;s what the language guides you towards, and the only potentially damaging thing that Zig tries to prevent you from doing, is making code hard to understand for readers.')