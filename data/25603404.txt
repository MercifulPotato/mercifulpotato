Item(by='amw-zero', descendants=None, kids=[25608632, 25604474, 25605565, 25605117], score=None, time=1609510674, title=None, item_type='comment', url=None, parent=25602615, text='This is only true when considering a specific software design that implements the state machine. I&#x27;d say the most popular way to define a state machine in code is how Xstate does it: <a href="https:&#x2F;&#x2F;github.com&#x2F;davidkpiano&#x2F;xstate" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;davidkpiano&#x2F;xstate</a>. You define your states, and then you define your inputs, and then you map out every single transition between states.<p>This is probably the most inefficient way to design a state machine. There&#x27;s a simple mathematical explanation for that. If we agree that a state diagram is a directed graph consisting of N nodes, then there are N^2 possible transitions (that&#x27;s the definition of a completely connected graph). This means there&#x27;s a large space of possible transitions relative to the number of states, which means there&#x27;s a high probability that you will have to modify lots of transitions when modifying the state machine itself.<p>In this article, this author is sharing several alternative designs for state machines, which don&#x27;t look like they suffer from exactly the same problem. I&#x27;m most familiar with TLA+, where you describe a state machine simply with one logical predicate: the &quot;Next&quot; state relation. This is the most powerful way I&#x27;ve found to define state machines, and modifying one function to entirely change the behavior of the state machine is very easy in practice.')