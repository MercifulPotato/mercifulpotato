Item(by='dnautics', descendants=None, kids=[25009164, 25010090], score=None, time=1604677110, title=None, item_type='comment', url=None, parent=25007045, text='I&#x27;m currently actively working on a typechecking system for elixir (three packages: <a href="https:&#x2F;&#x2F;github.com&#x2F;ityonemo&#x2F;selectrix" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;ityonemo&#x2F;selectrix</a> for compile-time interface, ..&#x2F;mavis for type logic, and ..&#x2F;mavis_inference for performing type inference on compiled code).<p>The chief difficulties I am running into are:<p>1) How to do intersections on functions and maps (this is in the article):<p>f(integer) -&gt; integer is not usable as f(any) -&gt; integer<p>2) not all of the erlang bytecode instructions are well documented<p>3) I still haven&#x27;t figured out how to deal with circular dependencies at the module level.<p>Erlang makes this easy in these ways:<p>1) compiled module structure is simple and the way branching works makes the mechanics of type inference trivial.<p>2) erlangs concurrency makes dealing with, for example in-module dependencies trivial<p>3) there are only a handful of types in erlang so, aside from functions, their subtyping relationships are very straightforward.<p>Elixir makes this easy in these ways:<p>1) Typechecking structs can be more straightforward than records.<p>2) Writing a composable type logic (mavis) is super easy with elixir&#x27;s protocols<p>3) I built (and am refining) a very easy dsl that makes creating and testing logic for the beam opcodes less of a hair-tearing experience:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ityonemo&#x2F;mavis_inference&#x2F;blob&#x2F;main&#x2F;lib&#x2F;type.inference&#x2F;opcodes&#x2F;gc_bif.ex" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;ityonemo&#x2F;mavis_inference&#x2F;blob&#x2F;main&#x2F;lib&#x2F;ty...</a>')