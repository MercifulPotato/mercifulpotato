Item(by='mikelevins', descendants=None, kids=[25626211, 25628454], score=None, time=1609706072, title=None, item_type='comment', url=None, parent=25622943, text='As I said elsewhere, when I say &quot;repl-driven programming&quot;, I do not mean &quot;programming in a repl window&quot;, or &quot;programming at a command shell&quot;. I&#x27;m talking about the runtime&#x27;s read-eval-print loop, not the UI&#x27;s repl window.<p>When I&#x27;m working, there is little or no migrating of code from the repl buffer to a file because it&#x27;s already all in a file. I almost always work in a file. I write snippets in a file, send them to the repl with a keystroke, and build up the world incrementally as I discover what it needs to be. As the contents of the file get larger and more complicated, I move things around and organize them. It&#x27;s a conversation <i>with</i> the repl, not an editing session <i>in</i> the repl <i>window</i>.<p>I don&#x27;t consider any Clojure tools I know of to constitute a proper repl-driven environment, precisely because the language and runtime lack support for the kinds of programming and debugging that I&#x27;ve taken for granted for decades. If I can&#x27;t inspect and edit and redefine <i>everything</i> in the runtime, it&#x27;s not the full, proper set of tools.<p>I&#x27;ve written a good bit of Clojure code, and I&#x27;ll happily do it again if I need to do something that isn&#x27;t convenient in, say, Common Lisp, but I consider it an acceptable alternative to things like Haskell and Scala and F# and Swift, not an attractive alternative to Lisp and Smalltalk.<p>I do occasionally need to restart a Lisp environment because of some gnarly breakage I&#x27;ve committed, but it&#x27;s pretty rare. Moreover, killing and restarting my favorite lisps takes about--wait, let me check--okay, a second and a half to kill a live app in staging and have it back up, fully-functioning.')