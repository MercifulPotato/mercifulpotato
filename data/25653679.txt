Item(by='mamcx', descendants=None, kids=[25653703], score=None, time=1609896147, title=None, item_type='comment', url=None, parent=25650907, text='I tried many things for making sync work across devices. I tried GUIDs, and partitioning ranges of ints, and several versions of it.<p>But what worked amazing?<p>Use NATURAL keys (or their hash) + version field. That is all you need most of the cases. It make sync far easier, easier to trace stuff (thanks to version), immune to problems of timestamps (some computers have their cloks wrong). In short:<p><pre><code>    struct Order {\n        code: String, &#x2F;&#x2F;natural key\n        version:usize\n    }\n\n    struct Location {\n        code: Hash &#x2F;&#x2F;hash of city + country\n        city:String,\n        country:String,\n        version:usize\n    }\n</code></pre>\nNatural keys are global if well defined. In some places where it is not obvious, hashing the whole row and put a nice encode is the same.<p>This also will reveal when something TRULY need a guid or similar. For example, for invoices in my country the law demand partition of ranges with certain characteristics (ie: INV-1-XXX in machine 1, INV-2-XXX in machine 2).<p>Add another id:i64 become redundant most of the time. If your Order.code is duplicated or whatever it will be the same problem with or without an extra id:i64, so is better to deal with the problems of the ACTUAL data when is need and not mask it with other stuff.<p>The downside is that the key become repeated in JOINS (like in InvoiceLine) but honestly all rdbms handle triggers, and it actually become very nice to see the Order.code in the child relations (far easier to correlate).')