Item(by='8fingerlouie', descendants=None, kids=[24753244], score=None, time=1602498383, title=None, item_type='comment', url=None, parent=24752132, text='The problem with C++ is, or was when i worked in embedded 20 years ago, that resources are constrained. Memory is limited, so tight control over call stacks are needed. We had a maximum call stack depth of 7 in our GSM handsets, and with C++ (and everything else object oriented) it is very hard to make that guarantee. Inheritance adds multiple calls that are &quot;not needed&quot;.<p>Most of the embedded platforms of old will be 16 bit, and as soon as somebody upgrades them to 32 bit (or more), the problem will most likely vanish. Then the next problem arises. Most embedded platforms are governed by strict regulations (mobile phones, medical, automotive, etc) and requires thorough testing. Even if you upgrade your hardware (and if the current, cheap, 16 bit hardware works, why bother ?), you do not want the challenge of rewriting 20-30 years of code in a new language.<p>In many cases you&#x27;re looking at 30+ years of development by 50-100 developers, and while the code itself probably hasn&#x27;t grown by a factor 30, chances are that the system evolved from a small system where core business was understood by &quot;everybody&quot; into a behemoth where only a few developers&#x2F;architects actually understand everything , and everybody else just understands what their little corner does.<p>Many people mistakenly think embedded means small, which is often far from the truth. I used to make sortation devices, and the total codebase for a single sortation device would often reach 1GB of C source code. Around 750MB was &quot;common code&quot;, but the last 250MB would be customer customization.<p>A GSM handset in the late 90&#x27;s had about 350MB C source code, with the majority of it being protocols (GSM, Edge, Bluetooh, SMS&#x2F;EMS&#x2F;MMS, WAP). The lower level ones of those have mostly been replaced by hardware these days, only to have the UI take up much more code.<p>It&#x27;s essentially the same problem that keeps COBOL in this world. Newer and (probably) better languages exist, but COBOL has a massive codebase, and while &quot;edge&quot; systems are easy to replace, at some point you&#x27;re left with &quot;core business&quot; which has been running as a patchwork of COBOL programs for 50 years. There&#x27;s no easy way to do it, and you need to rewrite everything.')