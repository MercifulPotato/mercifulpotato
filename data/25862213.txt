Item(by='kazinator', descendants=None, kids=None, score=None, time=1611253799, title=None, item_type='comment', url=None, parent=25861458, text='The .end() occurs because the approach taken procedural construction via a &quot;linear&quot; path. And that&#x27;s because that maps nicely to the chained.function().syntax(). That gets ugly if the terms have multiple arguments.<p><pre><code>   (S (NP (N DOG))\n      (VP (V KICKS))\n      (NP (N MAN)))\n</code></pre>\nbecomes:<p><pre><code>   (S DOG.N().NP()\n      KICKS.V().VP()\n      MAN.N().NP())\n</code></pre>\nso far not bad, but now we deal with S, that now becomes a method of DOG.(N).(NP).<p><pre><code>   DOG.N().NP().S(KICKS.V().VP(),\n                  MAN.N().NP())\n</code></pre>\nThe main connective S is now buried in the middle. We start with DOG, a fourth-level leaf element, make a N out of it, the NP, and now we start a sentence construction, where we bring in other parts. The structure reveals the evaluation order, not the actual structure.<p>BTW, the TXR Lisp version of this syntax is a tad more readable:<p><pre><code>   DOG.(N).(N).(S KICKS.(V).(VP)\n                  MAN.(N).(N))\n</code></pre>\nEven when we have obj.fun(arg) as a given, we should at least move the parenthesis before the function: obj.(fun arg).')