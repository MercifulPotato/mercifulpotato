Item(by='jnxx', descendants=None, kids=None, score=None, time=1603283030, title=None, item_type='comment', url=None, parent=24846876, text='What&#x27;s also good is that one can combine cargo with Guix as an OS&#x2F;multi-language package manager, for example when other tools or C libraries (say, alsa-lib) are needed. Guix provides currently 15,000 packages including many rust packages (<a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;packages&#x2F;R&#x2F;page&#x2F;21&#x2F;" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;packages&#x2F;R&#x2F;page&#x2F;21&#x2F;</a> ), and uses of course cargo for building rust packages. The reason why I think this is the right way to do it is because in big  , quickly-moving projects, the only comfortable way out of dependency hell is to use a Linux distribution with checked-to-work dependencies, or one is damned to the task of building a distribution oneself, and a checked distribution of packages is precisely what Guix provides.<p>Because own, or project-specific package recipes, which contain dependency and build instructions, can just be added to the public package definitions (<a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;blog&#x2F;2018&#x2F;a-packaging-tutorial-for-guix&#x2F;" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;blog&#x2F;2018&#x2F;a-packaging-tutorial-for-guix...</a>), this allows to deterministically and hermetically build multi-language projects on top of a very solid base. And for testing with another version of a C dependency (say, alsa-lib 1.1.9), one just needs a branch with another version number in the build recipe.')