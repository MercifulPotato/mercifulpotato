Item(by='dasyatidprime', descendants=None, kids=[25303270], score=None, time=1607094265, title=None, item_type='comment', url=None, parent=25302385, text='You don&#x27;t store the scrambled key, you store the sequential-looking key and expose the scrambled key externally. That avoids things like easy key-sequence probing&#x2F;inference from the outside, but means you don&#x27;t take the hit of an index with random-looking keys.<p>I&#x27;ve done something similar for weakly-secured spendable tokens in the past, packing some orderly lookup state into 64 bits and then exposing the Speck64&#x2F;32. That application was actually backed by an object-array sort of storage with numeric indices, so I stored something like object ID, timestamp, and sequence number, and then looked up the right property on the object at validation time. (If I needed strongly-in-the-crypto-sense unguessable IDs for security, I wouldn&#x27;t do this without doing more research&#x2F;analysis, since a database-wide key feels like it could be a weak point; compare how peppering is used for password storage in conjunction with salting but not as a replacement. Someone else probably already knows that answer.)<p>(Edit to add cross-reference: ah, looks like tmpyt in another comment claims that YouTube used to do this but then switched away because of the “knowing the small key lets you enumerate everything” loophole.)')