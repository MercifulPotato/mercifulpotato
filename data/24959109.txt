Item(by='Taniwha', descendants=None, kids=[24959193, 24959619, 24961493, 24960662], score=None, time=1604235053, title=None, item_type='comment', url=None, parent=24958925, text='They got the riscv code slightly wrong (but the instruction count correct).<p>(puts on chip designer&#x27;s hat) Essentially the ARM&#x2F;x64 case turns the load memory address calculation into a 4-input adder (so 2 layers of adders) and maybe a couple of extra gates because there are multiple addressing modes. Riscv&#x27;s equivalent is a 2-input adder. Those get into a critical cache (and TLB) access path and that limits how fast your CPU&#x27;s core clock can be (or forces you to split that path into 2 clocks).<p>Essentially that&#x27;s part of the whole RISC idea - simple means faster - you can run your core clocks faster if the decode (and address calculations etc etc) are simpler - getting rid of lots of addressing modes was a big part of the original RISC movement. I think all 4 of those riscv instructions are 16-bit ones so they may even fit into the same space as the 2 ARM ones (haven&#x27;t hacked on ARM for a while)<p>BTW chances are that that x86_64 mov instruction is not being devolved into more than one internal uOp (might be two if they separate off the address calculation into it&#x27;s own uOp)')