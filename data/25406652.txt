Item(by='__s', descendants=None, kids=[25406839, 25410420], score=None, time=1607868645, title=None, item_type='comment', url=None, parent=25406540, text='Unless you compile your program with movfuscator: <a href="https:&#x2F;&#x2F;github.com&#x2F;xoreaxeaxeax&#x2F;movfuscator" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;xoreaxeaxeax&#x2F;movfuscator</a><p>Or you decide to execute code on The Fungus: <a href="https:&#x2F;&#x2F;www.bedroomlan.org&#x2F;hardware&#x2F;fungus" rel="nofollow">https:&#x2F;&#x2F;www.bedroomlan.org&#x2F;hardware&#x2F;fungus</a><p>I also recall reading a paper that got into implementing a GC on silicon for a graph rewriting based architecture<p>WebAssembly is if&#x2F;else blocks. There&#x27;s a potential future where it gets implemented directly as a CPU ISA (albeit it&#x27;d likely involve some dynamic translation, but the CPU may decide to have SSA as its internal representation)<p>It&#x27;s important to understand there&#x27;s a real distinction between semantics &amp; implementation. Otherwise you risk emulating your implementation when some new hardware comes out (say GPUs, or Quantum computers, or out of order CPUs working backwards to create something like SSA for register renaming&#x2F;pipelining, or cmov)<p>See also the debates over C code being executed in the C abstract machine for optimizers while programmers rely on implementation of the end result. But in a language without undefined &#x2F; implementation-defined behavior you won&#x27;t have these ways of having the program self observe its implementation')