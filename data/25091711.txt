Item(by='the8472', descendants=None, kids=[25092055, 25091903], score=None, time=1605354258, title=None, item_type='comment', url=None, parent=25091243, text='&gt; Because fsync() is so coarse<p>You can do some work in advance with sync_file_range. fsync is still needed to write out the metadata, but it&#x27;ll have to do less work and you may be able to get better pacing and backpressure that way.<p>&gt; Then the fcommit() call would atomically flush the locally buffered changes to the filesystem. If an error happened, the API should guarantee that the final state either contains all changes or none of them.<p>Many existing filesystems simply cannot support such an API because they&#x27;re not journaling or CoW.\nAnother issue might be that multiple transactions could overlap and be of unbounded size, so now you would need MVCC, exclusive locking or the ability for the kernel to provide feedback to userspace that it will immediately rollback the transaction due to resource limits or conflicts. This suddenly looks more and more like a database than a posix filesystem.<p>There are many use-cases that don&#x27;t need such hard guarantees and want throughput, minimal overhead and latency instead. Lazy writes that the kernel can flush to disk whenever it feels like provide a lot of the performance that we take for granted when working with large amounts of data.<p>&gt; And it would remove the perennial, justified anxiety database engineers carry that they&#x27;re doing something subtly wrong without even knowing.<p>I think the postgres&#x2F;fsync error saga raised awareness of that and there were some proposals how to provide a better error channel to userspace.')