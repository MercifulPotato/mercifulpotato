Item(by='eyelidlessness', descendants=None, kids=None, score=None, time=1611796093, title=None, item_type='comment', url=None, parent=25936099, text='Every single build tool I still use. They’re either trash or constrained by trash. The “easy to use” tools are typically the hardest to use because they make everything that happens either totally opaque or incredibly difficult to introspect. Basically none of them follow the principles that are otherwise idiomatic for their platform (example: I cannot name a single JS-target build tool which is type safe or even validates configs before execution; I certainly can’t think of one that’s generally stateless or promotes composition). They all tend to rely on wildly unknowable magic to work around platform inadequacies.<p>If it sounds like I have a better approach in mind, I sure do. My main stacks are TypeScript on Node &amp; Browser. Tools for these builds could easily be type safe by being built with TS as an assumption, and easily debuggable by being piped in stages just like a normal Unix chain. This doesn’t have to be wildly inefficient, the type system knows enough to determine what can be processed concurrently, and intermediate build products could be virtual without hitting the FS.<p>A naive approach just to prove this out would disregard those efficiency considerations and just literally pipe a series of builds with existing tools, each one taking the previous product as input.')