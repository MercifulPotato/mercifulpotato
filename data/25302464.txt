Item(by='jerf', descendants=None, kids=[25302654, 25303618, 25304017, 25304943], score=None, time=1607091832, title=None, item_type='comment', url=None, parent=25302181, text='I don&#x27;t think &quot;task cancellation&quot; is quite the major difference you think. If you model it as thread A wants to cancel thread B, then while threading means that A runs and cancels B, but B may need some time to catch up, the async world has the problem of thread A running at all to cancel B, if B is having a problem that requires cancellation. It&#x27;s &quot;obvious&quot; and &quot;safe&quot; until it doesn&#x27;t happen at all.<p>This is a pervasive problem with the async&#x2F;await model. As it scales up the probability of something failing to yield when it should and blocking everything else continually goes up as the code size increases, and then the whole model, correctness, practicality, and all, just goes out the window. While it is small for small programs, and it the scaling factor often isn&#x27;t that large, it is still a thing that happens. Entire OSes used to work that way, with the OS and user processes cooperatively yielding, and what killed that model is this problem.<p>Also, I&#x27;m writing a lot of code lately where I can peg multiple cores at a time, with a relatively (if not maximally efficient) language like Go; having to also write it as a whole bunch of OS processes separately running because my runtime can only run on one core at a time is a non-starter, and &quot;async&#x2F;await&quot; basically turns into a threading system if you try to run it on multiple cores in one system anyhow.<p>These two fatal-for-me flaws mean it&#x27;s a non-starter for a lot of the work I&#x27;m doing anyhow, regardless of any other putative advantages.<p>(As I mentioned, I&#x27;m using Go, but if you want to see a runtime that <i>really</i> has the asynchronous exceptions thing figured out, go look at Erlang. Having a thread run off into never-never-land and eating a full CPU isn&#x27;t fun, but being able to log in to your running system, figure out which it is using a REPL, kill just that thread, and reload its code before restarting it to fix the problem, all without taking down the rest of your system is not an experience most of you have had. But it can be done!)')