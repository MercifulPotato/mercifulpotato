Item(by='Fellshard', descendants=None, kids=[25266959, 25264183], score=None, time=1606786743, title=None, item_type='comment', url=None, parent=25260489, text='I believe the difference is that you resolve the error at the same point where you resolve a successful result, making it impossible for a reader of the function to, for example, assume that you can access a value after an exception was thrown.<p><pre><code>  MyType x = null;\n\n  try {\n    x = doRiskyThing();\n    x.doThing();\n  } catch(CheckedException e) { ... }\n\n  x.doThing();\n</code></pre>\nThis code makes it unclear where the exception is sourced from, and makes it seem like you can use `x` even in a failure scenario. In Rust, however:<p><pre><code>  match doRiskyThing() {\n    Ok(x) =&gt; x.doThing(),\n    Err(e) =&gt; ...\n  }\n</code></pre>\nHere, it&#x27;s clear where `x` is available and valid. You could even have the error path panic and merely return `x` if you wanted to use it later on in the method (borrow rules permitted, etc.)<p>A model that fits this more closely in Java is &#x27;try-with-resources&#x27;.')