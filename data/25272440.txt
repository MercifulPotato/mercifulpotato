Item(by='dasyatidprime', descendants=None, kids=None, score=None, time=1606874363, title=None, item_type='comment', url=None, parent=25270477, text='I haven&#x27;t looked at QEMU&#x27;s TCG much, but I doubt it would be a <i>good</i> choice for bytecode formats even if you could bash it into doing something useful as <i>part</i> of a backend. I&#x27;d expect it to be optimized for hardware-CPU-alike machine instructions, whereas BEAM is Bogdan&#x27;s Erlang <i>Abstract</i> Machine. See <a href="https:&#x2F;&#x2F;blog.erlang.org&#x2F;a-brief-BEAM-primer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.erlang.org&#x2F;a-brief-BEAM-primer&#x2F;</a> which points to <a href="https:&#x2F;&#x2F;github.com&#x2F;erlang&#x2F;otp&#x2F;blob&#x2F;master&#x2F;lib&#x2F;compiler&#x2F;src&#x2F;genop.tab" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;erlang&#x2F;otp&#x2F;blob&#x2F;master&#x2F;lib&#x2F;compiler&#x2F;src&#x2F;g...</a>. If you look into how some of those are implemented, just as one example, the integer arithmetic operations handle automatic promotion to bignums—not something you&#x27;d find on a conventional CPU, but not uncommon in HLL bytecode. So you&#x27;d still have most of the implementation to do—and if you punt and hardwire all of those to runtime library calls, you&#x27;re almost back in threaded-code land anyway; you really want to take specialization opportunities etc. into account…<p>I also don&#x27;t know of any other HLL JITs that use TCG, which seems like weak evidence that it wouldn&#x27;t be a win.')