Item(by='domenicd', descendants=None, kids=[24813867], score=None, time=1602969127, title=None, item_type='comment', url=None, parent=24813351, text='Mostly. See <a href="https:&#x2F;&#x2F;tc39.es&#x2F;ecma262&#x2F;#sec-additions-and-changes-that-introduce-incompatibilities-with-prior-editions" rel="nofollow">https:&#x2F;&#x2F;tc39.es&#x2F;ecma262&#x2F;#sec-additions-and-changes-that-intr...</a> for a comprehensive list of backward-incompatible changes in the spec.<p>Using that list to answer your question is a bit tricky, since it also includes backward-compatibility breaks with newer features. But, e.g.,<p>&gt; In ECMAScript 2015, ToNumber applied to a String value now recognizes and converts BinaryIntegerLiteral and OctalIntegerLiteral numeric strings. In previous editions such strings were converted to NaN.<p>and<p>&gt; In ECMAScript 2015, the Date prototype object is not a Date instance. In previous editions it was a Date instance whose TimeValue was NaN.<p>sound like backward-incompatible changes to a JS 1.1 behavior.<p>Another notable example is the formalization of function-in-block semantics, which broke compatibility with various implementations in order to find a least-bad compromise everyone could interop on. I&#x27;m not sure if JS 1.1 even had blocks though, much less functions in blocks...')