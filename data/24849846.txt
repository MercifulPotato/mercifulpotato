Item(by='jchw', descendants=None, kids=None, score=None, time=1603300139, title=None, item_type='comment', url=None, parent=24849410, text='OK. I think some people mistook me as making a value judgement about C++. This is not true, I am merely saying I have doubts that Rust has had a serious impact on C++ design (yet; if it does it will start showing up soon, though.) If you don&#x27;t believe me please carefully reread my comments; I really wasn&#x27;t trying to say anything overall good or bad about C++, just observation about trajectory.<p>My personal opinions on C++ are not very positive, but it&#x27;s a language I literally grew with. My experience is that C++ code very gradually became more stable and less buggy. The thing is, some of that is just improved discipline, some of it is static analysis, etc. But a lot of it, is genuinely C++0x&#x2F;C++11 and features that built on top of this.<p>So the idea that Rust showed up and suddenly C++ cared about safety? I don&#x27;t really see it. I think C++ developers started caring about safety and then Rust showed up because of that.<p>P.S.: While the borrow checker and ownership semantics is really cool, I think a programming language&#x27;s ecosystem and the &#x27;best practices&#x27; it lends itself well to have a greater impact that people completely miss. Rust, Go, Zig are all clearly trying to foster a culture of writing more correct and complete programs. Error handling doesn&#x27;t just feel like a couple control flow mechanisms you can use, but a <i>responsibility that you have</i>. Modern C++ is getting better probably more because of this than any committee; although I really wish the Expected type would&#x27;ve gone somewhere, since I feel Rust&#x27;s `Result&lt;...&gt;` type and Go&#x27;s multiple-return with `error` are being proven right as ways to handle errors robustly even with their caveats. (I&#x27;ve heard Zig&#x27;s error handling is really cool too, but I haven&#x27;t had a chance to write a serious Zig program. I&#x27;ll get to it soon.)')