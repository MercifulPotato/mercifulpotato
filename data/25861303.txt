Item(by='kazinator', descendants=None, kids=None, score=None, time=1611249348, title=None, item_type='comment', url=None, parent=25861017, text='A DFA-based regex engine will spit out an optimal state machine if you give it a regex which just combines all your inputs with the disjunction:<p><pre><code>   0xC0D3|0xC0FD|...|0xBEEF\n</code></pre>\nFor example, NFA-DFA subset construction algorithm will implicitly figure out that every branch starts with 0x, and so the initial state will have only a single transition out of it on the character 0, and the next state on the character x.<p>If we feed it every 16 bit hex string from 0x0000 to 0xFFFF, it should reduce to just 7 states:<p><pre><code>  S0 -[0]-&gt; S1 -[x]-&gt; S2 -[01234569789ABCDEF]-&gt; S3 ...\n</code></pre>\nWhat you need is just a way to convert the compiled DFA to a regex, which you could then take in place of the original catenation. The transitions on multiple characters have to be intelligently converted to readable classes like [0-9A-F].<p>Now suppose we feed it every 0xXXXX string except 0xFFFE.\nWhat that simply means is that the last state transition will not include the F character. In that state, if the next input character is F, the machine errors out.<p>I&#x27;m sure there are issues with this idea that have to be solved. It&#x27;s a famous fact of DFA construction that a case insensitive match like &quot;[Ff][Oo][Oo]...&quot; leads to an exponential explosion of states.')