Item(by='valenterry', descendants=None, kids=[25586080], score=None, time=1609343892, title=None, item_type='comment', url=None, parent=25582295, text='&gt; This is just not a true statement - and that was the point of the original thread - the original paper on futures had them implemented transparently and able to be passed down into library code not expecting futures. It&#x27;s also how Haskell&#x27;s par works today. So it demonstrably can be implemented.<p>Okay, technically you are right - however it changes the semantics of the program. I admit that I didn&#x27;t mention this constraint though.<p>&gt; Great... but you&#x27;ve rewritten the library code with &#x27;two separate functions instead of one.&#x27; My original point was &#x27;because it means existing code that expects a T cannot accept a Future&lt;T&gt;&#x27; and you&#x27;re proving that back to me so hard that you&#x27;ve accepted you need to completely rewrite the code to do it!<p>&gt; Yes this is a problem with transparent futures, as is the ordering issue you raised. But I wasn&#x27;t arguing they didn&#x27;t have their own issues.<p>I don&#x27;t disagree with any of that. However, what you originally said:<p>&gt; &gt; Are you saying that generics on futures are bad?<p>&gt; Yes - because it means existing code that expects a T cannot accept a Future&lt;T&gt;, which is the colouring problem being discussed.<p>And you imply that transparent futures are better than the ones with generics. So where we disagree is on what is worse. I am convinced that the problems (and there are certainly a lot of unknowns) you introduce with transparent futures is much worse than the performance you might gain in certain cases and the easier syntax in many cases.')