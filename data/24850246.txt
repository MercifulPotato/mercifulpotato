Item(by='dragontamer', descendants=None, kids=None, score=None, time=1603302422, title=None, item_type='comment', url=None, parent=24849835, text='Lets say that some codebase is using a custom bitonic sort (a highly-parallel, SIMD sorting algorithm) instead of a standard library sort.<p>So you have:<p><pre><code>    array&lt;Foo&gt; myFunc(Baz b){\n      someArray = bar(b);\n      bitonicSort(someArray);\n      return someArray[0:2]; &#x2F;&#x2F; Return the top 3 elements after sorting\n    }\n</code></pre>\nSo we&#x27;re trying to test myFunc(). We have dependencies on bar() and bitonicSort(). There may be hidden dependencies on Baz class functions (maybe bar() calls Baz.func()).<p>Now we have a variety of mocking strategies. We could mock the Baz class. We could mock bitonicSort(), we could mock bar() function.<p>But does such mocking really make our testing life easier? I argue it doesn&#x27;t. Our unit test really should just be written as the following:<p><pre><code>    Baz initializeBaz(){\n      &#x2F;&#x2F; A consistent initialization across many\n      &#x2F;&#x2F; different tests\n    }\n\n    void unitTest(){\n      Baz b = initializeBaz();\n\n      array&lt;Foo&gt; a = myFunc(b);\n      assert(a.size() == 3);\n      assert(a[0] == Foo(1, 2, 3)); \n      assert(a[1] == Foo(4, 5, 6)); \n      assert(a[2] == Foo(7, 8, 9)); \n    }\n</code></pre>\nEasy peasy. No mocking needed. Compare now if we mocked out the Baz class, or the bitonic-sort method. It just becomes an unwieldy mess.<p>There&#x27;s no need to overthink things. Maybe have 2 or 3 different, reasonable, instantiations of Baz. If a bug is discovered in the future, create a Baz that represents that bug.<p>If bitonicSort isn&#x27;t working correctly, its not our job (as writers of myFunc()) to care about bitonicSort&#x27;s correctness. We are allowed to <i></i>assume<i></i> correctness upon our dependencies. It is also NOT our job to test bitonicSort. If we happen to catch a bitonicSort bug, that&#x27;s good... but remember that bitonicSort will have unit tests of its own.')