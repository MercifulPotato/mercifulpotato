Item(by='theamk', descendants=None, kids=[24737286, 24737378, 24737556], score=None, time=1602305688, title=None, item_type='comment', url=None, parent=24736634, text='Pascal&#x2F;Delphi do not use regular object files, instead they have DPU&#x2F;TPU files which both contain parsed headers and object code.<p>Those files are not compatible between major versions, so this probably means they are designed to make them as easy to parse as possible, and map closely to internal compiler structures. This means including a unit is way faster than re-parsing the unit&#x27;s text.<p>Additional speculation: those DPU files might contain a copy of relevant definition (like names of fields, sizes and offsets). This means if you have &quot;program&quot; which uses &quot;my_unit&quot; which uses &quot;high_level_comms&quot; which uses &quot;Handle&quot; defined in &quot;low_level_comms&quot;, then definition of &quot;Handle&quot; could be copied directly into my_unit.DPU. So when you compile &quot;program&quot;, and it includes &quot;my_unit&quot;, all you need to read is &quot;my_unit.DPU&quot;. You do not care about total size of &quot;high_level_comms&quot; and &quot;low_level_comms&quot; files.<p>Unfortunately, in C&#x2F;C++, when people &#x27;#include &lt;iostream&gt;&#x27;, they can now use &quot;std::plus&quot;, &quot;mbrtowc&quot; and &quot;timer_getoverrun&quot;. Which means including high-level modules has to bring tens of thousands of lines in translation units.\n(Yes, impl pattern, well-designed interfaces, forward declarations can fix this, but few people bother. Stdlib certainly does not)')