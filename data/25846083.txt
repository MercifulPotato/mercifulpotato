Item(by='geocar', descendants=None, kids=None, score=None, time=1611148909, title=None, item_type='comment', url=None, parent=25845583, text='&gt; memory allocation failure or a network connection being down, sometimes the best context to handle that error is the outermost function A() and not C().<p>If you need the memory (or disk space) to do something, what else can you really do but wait for memory to be available? The system might just be busy, or the user might have some files they can move if prompted (multitasking systems are the norm these days!). There exists a chance memory starvation is the result of contention, in which case someone needs to give up, rollback and try again (i.e. the B() in your example), but it&#x27;s much more likely that memory -- say the user asks to load a 500gb file in 50gb of ram -- that memory will never become available in which case what can you do but abort and tell the user to try something else?<p>What I like to do on error is signal the error and wait to be handled by <i>some other process</i> that can tell the difference between the above policies (by say, interrogating the system or a human operator). And I do mean wait. If the controller tells us to unwind, we unwind to that restart point, which might be as simple as returning an error code. If you&#x27;re vaguely familiar with how CL&#x27;s condition system works, this should sound familiar, but it&#x27;s also what &quot;Abort, Retry, Fail?&quot; used to mean.<p>&gt; Sometimes handling the error is orthogonal to how a nested call tree is structured. It depends.<p>On this I agree, but maybe a little bit stronger: I think for errors like this and for domain errors, an ideal error handling strategy is <i>always</i> orthogonal to how the nested call tree is structured (as above). Programming errors are another story -- if you make a lot of programming errors, you almost certainly want what marcus_holmes suggests.')