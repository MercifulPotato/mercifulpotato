Item(by='codeflo', descendants=None, kids=[25800156], score=None, time=1610755928, title=None, item_type='comment', url=None, parent=25797025, text='It&#x27;s a bit unfortunate that an article titled &quot;Why Zig when there is C++, D and Rust&quot; mentions a lot of features that are shared by Zig, C++, D or Rust, not always giving credit or explaining how Zig solves these problems better.<p>Point by point:<p>- No hidden control flow: Linus Torvalds used to argue for C over C++ for similar reasons. I think it&#x27;s a valid point for some kinds of systems programming. IMO, the argument is a lot stronger for features like destructors (C++) or Drop (in Rust) because those are truly hidden. At least the + sign is visible, and experienced C++ devs read it as a function call anyway.<p>- No hidden allocations: This is just a library design choice in C++ and Rust, not baked into the language. The standard libraries of those languages usually favor convenience over the last bit of flexibility and performance. At least in the case of C++, there&#x27;s an ecosystem of libraries like the EASTL that make different choices.<p>- No standard library: That&#x27;s fully supported in common C++ compilers and Rust. If Zig goes beyond what those languages offer, which it might, then the article should probably explain how.<p>- Error handling: &quot;Zig is designed such that the laziest thing a programmer can do is [...] properly bubble errors up.&quot; That&#x27;s also true for exceptions. Presumably, Zig doesn&#x27;t have exceptions. This could be explained, and contrasted with Rust&#x27;s monadic approach to error handling.<p>- Compatibilty with C: That doesn&#x27;t tell me much, because C++, D and Rust all have excellent C compatibility.<p>- Package manager: Great! Both Rust and D also have one, so this might mainly be a point in contrast to C++?<p>- No metaprogramming: I looked up how Zig treats format strings. It looks like it&#x27;s possible for functions to have &quot;compile time arguments&quot;, and there are some rules around compile-time evaluation of if statements and inlineable loops [1]. At first glance, there might be some parallels to D&#x27;s metaprogramming capabilities, which also has static ifs and loops, but I don&#x27;t know if that mechanism is as powerful. It certainly looks elegant, but to me, it clearly is a kind of metaprogramming, not &quot;no metaprogramming&quot;.<p>Having said all this, I&#x27;m very happy that there are more languages in this space now.<p>Maybe at this point, the best strategy for a project like Zig is to address Rust head-on in comparisons like this. It&#x27;s very unlikely that someone reads this article in 2021, is looking for a new systems language and isn&#x27;t also considering Rust.<p>[1] <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;#Compile-Time-Expressions" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;#Compile-Time-Expre...</a>')