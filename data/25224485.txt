Item(by='fefe23', descendants=None, kids=[25228358, 25224571, 25227187, 25224666], score=None, time=1606436190, title=None, item_type='comment', url=None, parent=25222243, text='I don&#x27;t think io_uring and ebpf will revolutionize programming on Linux. In fact I hope they don&#x27;t. The most important aspect of a program is correctness, not speed. Writing asynchronous code is much harder to get right.<p>Sure, I still write asynchronous code. Mostly to find out if I can.\nMy experience has been that async code is hard to write, is larger, hard to read, hard to verify as correct and may not even be faster for many common use cases.<p>I also wrote some kernel code, for the same reason. To find out if I could.\nMost programmers have this drive, I think. They want to push themselves.<p>And sure, go for it! Just realize that you are experimenting, and you are probably in over your head.<p>Most of us are most of the time.<p>Someone will have to be able to fix bugs in your code when you are unavailable. Consider how hard it is to maintain other people&#x27;s code even if it is just a well-formed, synchronous series of statements. Then consider how much worse it is if that code is asynchronous and maybe has subtle timing bugs, side channels and race conditions.<p>If I haven&#x27;t convinced you yet, let me try one last argument.<p>I invite you to profile how much actual time you spend doing syscalls. Syscalls are amazingly well optimized on Linux. The overhead is practically negligible. You can do hundreds of thousands of syscalls per second, even on old hardware. You can also easily open thousands of threads. Those also scale really well on Linux.')