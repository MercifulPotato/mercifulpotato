Item(by='hhas01', descendants=None, kids=[24846542], score=None, time=1603270455, title=None, item_type='comment', url=None, parent=24841296, text='<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gradual_typing" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gradual_typing</a><p>Also, TBH, types are kind of the wrong answer to the question. The question should be: How do we make the language efficiently <i>expressive</i>? For my money, that means defining constraints primarily on the code’s main interfaces, which a given constraint may be a combination of traditional generics, dependent types, and&#x2F;or declarative run-time checks on input&#x2F;output values. (e.g. Eiffel comes to mind.)<p>For instance, in my kiwi language I can define an argument as:<p><pre><code>    list (whole number (0, 100), 4, 4)\n</code></pre>\nWhich is to say a 4-item list, where each item is an integer between 0 and 100. And since I don’t want to type all that every time I can give that constraint a descriptive name:<p><pre><code>    define type (CMYK color, list (whole number (0, 100), 4, 4))\n</code></pre>\nI can even include user documentation in that definition so the whole lot’s self-describing.<p>Kiwi’s very late-bound and interpreted, so its constraints are implemented solely as run-time coercions with optional bounds checks; nothing fancy. But the semantics are quite well formalized so a linter could be implemented as an assistant authoring tool for users, and if you can implement a linter then you can implement a type checker; and so on.<p>What matters is that the language has a formal mechanism by which it can guarantee that a given value will always satisfy one or more user-defined requirements; and whether those requirements are checked at compilation, execution, or some combination is secondary to that. How rigorous the user makes these declarations, and if&#x2F;where she makes them, is entirely up to her.<p>Remember, the goal of any language is to please its <i>users</i>. Not the machines it runs on, nor the designers who created it. And users’ needs are not constant, not even across the development cycle of a single program, so a language that cannot adapt to those users’ changing requirements as it goes has already failed its first hurdle.<p>..<p>Perhaps if authors of existing languages like Python and C put less effort into chasing the constantly-diminishing returns of post-hoc micro-optimizations, and more into thinking how to design the next generation of languages so as to carry forward the good characteristics of their predecessors minus their original already-painted-themselves-into-a-corner limitations, we might actually have languages that tick all the boxes by now.')