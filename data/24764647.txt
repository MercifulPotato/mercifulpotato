Item(by='nickjj', descendants=None, kids=[24767441], score=None, time=1602590164, title=None, item_type='comment', url=None, parent=24763082, text='&gt; In the case of SNS, mock a message with the correct SNS signature, or go one layer deeper, stub out SNS validation logic.<p>SAM already provides a way to mock out what SNS would send to your function so that the function can use the same code path in both cases. Basically mocking the signature. This is good to make sure your function is running the same code in both dev and prod and lets you trigger a function in development without needing SNS.<p>But the problem is locally invoking the function with the SAM CLI tool is the trigger mechanism where you pass in that mocked out SNS event, but in reality that only works for running that function in complete isolation in development.<p>In practice, what you&#x27;d really likely want to do is call it from another local service so you can test how your web app works (the thing really calling your lambda at the end of the day). This involves calling SNS publish in your service&#x27;s code base to trigger the lambda. That means really setting up an SNS topic and deploying your lambda to AWS or calling some API compatible mock of SNS because if you execute a different code path then you have no means to test the most important part of your code in dev.<p>&gt; In the case of Postgres, you could use an ORM that supports SQLite for dependency-free development but at a compatibility cos<p>The DB is mostly easy. You can throw it into a docker-compose.yml file and use the same version as you run on RDS with like 5 lines of yaml and little system requirements. Then use the same code in both dev and prod while changing the connection string with an environment variable.<p>&gt; Thatâ€™s not exactly a knock against serverless itself, is it?<p>It is for everything surrounding how lambdas are triggered and run. But yes, you&#x27;d run into the DB, S3, etc. issues with any tech choice.')