Item(by='ljackman', descendants=None, kids=[25304549], score=None, time=1607100094, title=None, item_type='comment', url=None, parent=25300233, text='`Async`&#x2F;`await` or something like Kotlin&#x27;s `suspend` are great language features for certain domains in which a developer needs to manage blocking system calls: in lower-level languages such as Rust or C, you probably don&#x27;t want to pay for a lightweight &quot;task runtime&quot; Like Go&#x27;s or Erlang&#x27;s. They bring not only a scheduling overhead but also FFI complications.<p>However, for application languages that can afford a few extra nicities like garbage collection, I fail to understand why the stackless coroutine model (`suspend` in Kotlin) or `async`&#x2F;`await` continue to be the developer&#x27;s choice. Why do languages like Kotlin adopt these features, specifically?<p>Manually deciding where to yield in order to avoid blocking a kernel thread seems outside of the domain of problems that those using a _higher level_ language want to solve, surely?<p>The caller should decide whether to do something &quot;in the background&quot;. And this applies to non-IO capabilities too, as sometimes pure computations are also expensive enough to warrant not blocking the current task.<p>Go and Erlang seem to have nailed this, so I&#x27;m glad Java is following in their footsteps rather than the more questionnable strategy of C# and Kotlin. (Lua&#x27;s coroutines and Scheme&#x27;s `call-with-current-continuation` deserve an honourable mention too.)')