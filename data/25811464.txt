Item(by='throwaway894345', descendants=None, kids=[25819796], score=None, time=1610897559, title=None, item_type='comment', url=None, parent=25810154, text='I think you’re probably trying to make a substantial point but you seem to be mistaken about several things with respect to Go and polymorphism and interfaces such that I can’t figure out what your actual, substantial point is.<p>&gt; Go is a bad language for metaprogramming<p>You’re absolutely right here.<p>&gt; There is no &quot;either-or&quot; data type in Golang. That&#x27;s why.<p>Correct here too, Go doesn’t have sum types. If you want sum types, you have to emulate them via interfaces. But I don’t see how that relates since all of this DI stuff seems to be dynamically typed anyway (errors at runtime) assuming you’re not taking a codegen approach anyway.<p>&gt; In C, you just make a struct, have a type present in the struct, and then cast the struct pointer to extended object types to gain additional functionality.<p>I don’t understand what you’re trying to do here. First of all, this only works for the first field (and obviously isn’t memory&#x2F;type safe).<p>&gt; In Golang? Well... no. You are essentially forbidden from doing any simple casting or extension. You are essentially stuck with hardcoding the crap out of everything or making your own vcall like system build out of Golang types... which you can&#x27;t really use in the way you want unless you use reflection.<p>As a general rule of thumb you can do almost anything in Go that you can do in C if only by delving into the unsafe package; however, “unsafe” is almost never necessary—interfaces typically suffice. You certainly can emulate inheritance if you don’t care about type-safety, just like in C. Unfortunately I can’t say more until you clarify your objective.<p>&gt; What I can&#x27;t understand is why anything thinks that Golang does support polymorphism. They admit it themselves. They are working on it. Only the new alpha test versions have a solution for it. The current released version is not polymorphism no matter how much you want to fucking label it that way.<p>I think you must mean some other word because interfaces are the canonical example of polymorphism and Go has the best interfaces in the business. :) I’ve never heard the Go maintainers claim they lack polymorphism (Go does lack type-safe <i>generics</i> and <i>sum types</i>, but so does C). In an earlier post you argued that interfaces weren’t polymorphism because they don’t let you modify the underlying data, which is patently false—this is the whole point of interfaces. In Go:<p><pre><code>    var r io.Reader &#x2F;&#x2F; nil\n    r = someFile &#x2F;&#x2F; *os.File\n    r = stringReader &#x2F;&#x2F; *strings.Reader</code></pre>')