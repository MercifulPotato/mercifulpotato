Item(by='simongray', descendants=None, kids=None, score=None, time=1608124682, title=None, item_type='comment', url=None, parent=25441899, text='The main issue with Clojure is probably its tight integration with the various host platforms. When you get a stack trace in Clojure&#x2F;ClojureScript, you basically get a Java or JavaScript stack trace, so there is some expectation of familiarity with the host platform. If you already have some experience with the host, then this shouldn&#x27;t be a big issue, but it&#x27;s a dealbreaker for some people.<p>Another issue has to do with startup time. The Clojure application bootstrap process is relatively slow, i.e. start-up might take 1 second, so it&#x27;s great for server applications, but less great for Android apps or other CLI scripts that expect require instant startup. It has been approached in different ways, e.g. compiling Clojure with Graalvm native image or using ClojureScript instead of JVM Clojure. The latest solution is Babashka which provides a variant of Clojure specifically for writing CLI scripts.<p>Otherwise, Clojure is an excellent language which both modernises Lisp syntax significantly and implements a very well thought out standard library for doing functional programming. There are many great features, but the standout ones are probably the persistent data structures (which syntactically act both as data structures and functions) and parallelism&#x2F;concurrency support. It&#x27;s also very natural to do interop with the host platforms (Java, JS, .NET) and the data-oriented style of programming makes communication between backend (Clojure) and frontend (ClojureScript) extremely simple. So it&#x27;s pretty much the perfect full-stack language for information systems. I would take a look at the rationale: <a href="https:&#x2F;&#x2F;clojure.org&#x2F;about&#x2F;rationale" rel="nofollow">https:&#x2F;&#x2F;clojure.org&#x2F;about&#x2F;rationale</a>')