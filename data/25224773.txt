Item(by='contravariant', descendants=None, kids=None, score=None, time=1606439527, title=None, item_type='comment', url=None, parent=25221710, text='I see, it&#x27;s an interesting line of thought but I think trying to move type checking into the grammar is fundamentally a bad idea. You don&#x27;t want to mix grammar and semantics because that&#x27;s not how people think about code.<p>That said I agree that it is interesting to see what the &#x27;parse, don&#x27;t validate&#x27; approach to type checking would be, but I think it should still take place on the type level.<p>And I think this leads you towards interfaces, though perhaps we can improve interfaces by embracing the idea. Taking C# as an example interfaces basically ensure that if the type check succeeds then the function will be given an object that supports the methods of the interface <i>and only the methods of that interface</i>. Even further the methods and fields names of the interface can <i>conflict</i> with the fields and method names of the object but the type checker &#x27;resolves&#x27; those conflicts and essentially returns a &#x27;parsed&#x27; object with the right methods.<p>Unfortunately this doesn&#x27;t yet allow for arbitrary conditions (explicitly). Provability is always going to be an issue so let&#x27;s say we fix that by dynamic type casts. Then I think the behaviour we want is essentially an interface defined by a function<p>IMyInterface parse(MyObject: MyType)<p>where the constructor of IMyInterface enforces some checks and an object implements the interface if it defines an implementation of &#x27;parse&#x27;.<p>Now we only need a language to support this. Maybe we can persuade the Julia guys? They seem to like this kind of type-polymorphism based aproach.<p>Edit: Just checked, apparently they <i>have</i> implemented it, it&#x27;s just called &#x27;convert&#x27;.')