Item(by='anonytrary', descendants=None, kids=[25458128, 25457902], score=None, time=1608186921, title=None, item_type='comment', url=None, parent=25452989, text='I love using hooks because you can write extremely terse code, but the magical rules are almost not even worth it. Hooks are not robust to reactive code patterns. There&#x27;s no reason why hooks couldn&#x27;t have been implemented as a dynamic graph that forgets&#x2F;learns which render calls have been subscribed to the current computation graph. Overall, it&#x27;s a poor design, but it is very expressive if you know what you are doing. For example, a typical reactive function would be able to handle conditional reactive dependencies:<p><pre><code>  const myReactiveComputation = () =&gt; {\n    if (getReactiveValue() &gt; 5){\n      console.log(getOtherReactiveValue());\n    }\n  }\n</code></pre>\nWhen getReactiveValue() returns something &lt;= 5, the reactive computation should automatically unsubscribe from getOtherReactiveValue, since that value changing no longer as any implications on the result of the reactive computation. Once getReactiveValue() changes to something &gt; 5, the computation re-subscribes to getOtherReactiveValue. It&#x27;s not hard to implement this if you&#x27;re modeling your computation graph correctly. Unfortunately, hooks was implemented to depend on call-order, which makes absolutely no sense. This leads to actually <i>more</i> verbose constructs such as:<p><pre><code>  useEffect(() =&gt; {\n    if (iWantToRunThis(){\n      ...\n    };\n  }, [])\n</code></pre>\nThis is better expressed as:<p><pre><code>  if (iWantToRunThis()) useEffect(() =&gt; {...}, []);\n</code></pre>\nBut alas, this is prohibited by hooks because of how they were implemented.')