Item(by='lmm', descendants=None, kids=None, score=None, time=1608079215, title=None, item_type='comment', url=None, parent=25430421, text='&gt; That&#x27;s unspecified behavior, not undefined behavior. Unspecified behavior can literally do anything or nothing at all, including aborting the program nondeterministically. That effectively forbids invocation of UB for the programmer since you can&#x27;t reason about the program after it&#x27;s invoked, unless you&#x27;ve verified your implementation has actually defined the behavior for you (despite not being required to). That&#x27;s quite different from unspecified behavior where the implementation is required to pick some sane behavior (often among a set of acceptable behaviors) and stick with it in a self-consistent manner.<p>It&#x27;s very hard to make trapping an acceptable implementation for unspecified behaviour while allowing the implementation to do the usual kind of reordering, so the standard doesn&#x27;t try. That&#x27;s the original intention behind e.g. null pointer dereference being undefined behaviour - implementations should be permitted to make null pointer dereference trap, but should also be permitted to reorder or optimize out pointer dereferences.<p>&gt; Implementers already have to implement canonicalization for equality comparisons<p>No they don&#x27;t - they can just make comparison return false for pointers of different types or from different segments. Canonicalisation is not the only way to do equality-comparison!<p>&gt; and they already have to implement casting to uintptr_t too<p>But the result of that isn&#x27;t required to have the same comparison semantics as pointers. E.g. if some of your pointers are aligned and you internally represent those without trailing zeroes (like the JVM does) and use that as the integer cast, then some different types of pointer end up casting to the same int, which is fine. But the standard requires those pointers to not compare equal as pointers, so you can&#x27;t implement pointer comparison like that. (Well, you <i>can</i> implement &gt;= and &lt;= like that, <i>because</i> those comparisons are undefined behaviour. But you&#x27;ll have cases where a &lt;= b and b &lt;= a but a != b).<p>&gt; You want to linear-search in a list and want equality to work for that? Well I want to binary search in an array&#x2F;BST and need comparisons to work for that.<p>Look, I&#x27;m not saying I agree with the standards committee here, I&#x27;m saying that it&#x27;s a plausible compromise position for them to have taken. Not being able to do equality comparisons would be way more limiting for users than not being able to do relational comparisons. Having to implement relational comparisons would have been a bit more work for implementers than only having to implement equality comparisons.')