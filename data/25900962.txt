Item(by='Twisol', descendants=None, kids=None, score=None, time=1611564675, title=None, item_type='comment', url=None, parent=25900693, text='Adapting your example to a component of a real project I&#x27;m working on:<p><pre><code>    JsonParser&lt;Customer&gt; customerP\n      = productP\n      . field(&quot;customer&quot;, productP\n        . field(&quot;name&quot;, stringP),\n        . field(&quot;address&quot;, productP\n          . field(&quot;street&quot;, stringP)\n          . field(&quot;zipCode&quot;, stringP)\n          . field(&quot;town&quot;, stringP)\n          . map(uncurry3(street -&gt; zipCode -&gt; town -&gt;\n              new Address(street, zipCode, town))))\n        . map(uncurry2(name -&gt; address -&gt;\n            new Customer(name, address))));\n</code></pre>\nThis is a parser, not a serializer, but hopefully it&#x27;s clear how this approach can be applied in the other direction. (I still have the analogous code on a branch somewhere, but the parsing logic needed a cleanup more, and sooner.)<p>Some of the uncurried function stuff can be cleaned up with dedicated wrappers for `BiFunction` and whatnot. And of course, the address parser could be extracted out if we want to unit test it separately.<p>I don&#x27;t find the code I give above to be any worse than the code you gave (for that matter, I don&#x27;t have the same &quot;yuck&quot; reaction to the C# example, either). I much prefer not needing extra data types that only serve to configure analogous translation code.<p>We can keep going back and forth, addressing the concerns we have about each other&#x27;s approach, but it ultimately comes down to preference.')