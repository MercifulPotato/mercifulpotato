Item(by='smichel17', descendants=None, kids=None, score=None, time=1606757307, title=None, item_type='comment', url=None, parent=25254515, text='What about this middle ground? These are my thoughts, very curious whether there are languages doing this &amp; if so, what the real world problems are.<p>1. Statically typed.<p>2. Unchecked exceptions by default. IE, implicit bottom on every type.<p>3. Optional checked exceptions. Implementation could be `checked` keyword (e.g. `checked fun foo() throws XyzError {}`), or a generic type, or something else depending on the language. In order to mark something as checked, it must catch all exceptions from unchecked values it touches.<p>4. The compiler infers exceptions types when possible. So, if a regular unchecked function (`fun bar() {}`) only calls checked functions (foo from above), the compiler will carry the information about what can be thrown (XyzError) up the chain, even if there is no explicit signature. This way if another function (`checked fun baz() {}`) calls bar(), then it only has to catch or declare the XyzException, rather than all exceptions generically.<p>Finally, and to tie this all together: as a matter of style, reserve exceptions for actual unexpected errors. To use an example from downthread, a JSON parsing library should not be throwing parsing errors, it should be returning a Maybe&lt;Parsed, Error&gt;. Why? Because the library cannot determine whether the error is unexpected. If you&#x27;re using it to parse user input, then yes, you&#x27;re going to frequently encounter invalid data, and this should be part of your normal control flow, not something that can crash your application at runtime (you may want to log the event, maybe with a stack trace, but without interrupting normal operations). On the other hand, say you&#x27;re parsing JSON from your database, (also, why are storing json in your db? But bear with me..). And invalid json means data corruption, which means your db is fubar. Then, it&#x27;s fine to throw, because in that case you&#x27;re operating on state that you assumed to be impossible, and your program behavior is now undefined.<p>The key point here is that <i>exceptions are useful as a safety valve for early termination in the case of invalid assumptions.</i> That&#x27;s a <i>subset</i> of all error handling. If you try to force all error handling into the same paradigm and the same level of reliability, you&#x27;re going to have awkward edge cases.')