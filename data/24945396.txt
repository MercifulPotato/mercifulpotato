Item(by='todd8', descendants=None, kids=[24946022, 24945887], score=None, time=1604082620, title=None, item_type='comment', url=None, parent=24943546, text='Early LISP implementations used dynamic scope. This means that non-local references in a function search for the variable&#x27;s binding in the call chain: if A calls B then when B uses nonlocal variable x it refers to the x in A, not necessarily the x that belongs in the lexical parent of B as seen in the source code.\n(Unlike C, Algol&#x2F;Pascal&#x2F;LISP can all define functions inside of other functions. These nested function definitions introduce lexical non-local scopes.)<p>Dynamic scoping is easier to implement than lexical scoping. With lexical scoping, the run-time must incorporate some mechanism to find the stack frame of a lexical parent (as seen in the program&#x27;s source code) to access a nonlocal variable&#x27;s value. In dynamic scoping the run-time can just follow the stack frame order (starting at the top) to find a nonlocal variable&#x27;s binding.<p>Early LISP used dynamic scope. Scheme had lexical scope from the beginning. Common Lisp had both mechanisms and programs can use both.<p>The implementation of recursion also has to address proper access to nonlocal variables in functions that are values themselves and are passed as arguments to other functions. Do these functions access the nonlocal variables based on their call location or their lexical location in the source code? These problems with functions as arguments are known as the upward and downward funarg problems. Knuth wrote the <i>man-boy</i> program to test Algol 60 implementations in these areas.<p>Another complication for implementors of Algol 60 was parameter passing by-name, which is neither by-value nor by-reference. I don&#x27;t recall any other well known language that has subsequently made that non-intuitive (to me) choice. I believe that Algol 68 abandoned call by-name, but it&#x27;s been 25 years since I looked at the Algol 68 standard.')