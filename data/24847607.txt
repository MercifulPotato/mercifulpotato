Item(by='JHonaker', descendants=None, kids=None, score=None, time=1603286667, title=None, item_type='comment', url=None, parent=24846797, text='Julia is dynamic. I&#x27;ve described this before, but the type annotations are used for multiple dispatch, not for static type checking.<p>The quick example of why this is powerful is multiplication:\n    # Assume you only have addition defined<p><pre><code>    # Quick and dirty baseline\n    function *(l::T, r::T) where {T&lt;:Int}\n        out = 0\n        while l &gt; 0\n            out += r\n            l -= 1\n        end\n        out\n    end\n\n    # Great, now let&#x27;s say you have a data type, rational numbers:\n    struct Rational{T&lt;:Int} \n        numerator::T\n        denominator::T\n    end\n\n    # And you want to define multiplication on rational numbers\n    *(l::Rational, r::Rational) = Rational(l.numerator * l.numerator, l.denominator * l.denominator)\n\n    # Cool, but multiplying Ints by rational number should also be defined\n    *(l::Rational, r::Int) = Rational(l.numerator * r, l.denominator)\n    *(l::Int, r::Rational) = *(r, l)\n</code></pre>\nThe reason this is so cool, and why, yes it&#x27;s still dynamic,\nis that I can call x * y on two variables, x and y, of which I know nothing about. The most specific method defined which matches their type will be called to handle it. If there isn&#x27;t one defined, that&#x27;s obviously a method error just like in your favorite other language!')