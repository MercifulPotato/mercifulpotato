Item(by='lalos', descendants=None, kids=[25567876], score=None, time=1609211031, title=None, item_type='comment', url=None, parent=25565938, text='&#x2F;&#x2F; stateful impl<p>class foo{\n    enum current_operator;<p><pre><code>    init() { current_operator = ADD }\n\n    evalOp(int a, int b){\n        if (current_operator == ADD) return a + b;\n        else if (current_operator == MULTIPLY) return a * b;\n    }\n\n    setOp(enum op){ current_operator = op; }</code></pre>\n}<p>&#x2F;&#x2F; pure impl<p>class bar{<p><pre><code>    evalOp(enum op, int a, int b){\n\n        if (op == ADD) return a + b;\n        else if (op == MULTIPLY) return a * b;\n    }</code></pre>\n}<p>In the first case, evalOp is not pure since one has no idea on what is the current_operator set as. In the second case it is pure since the operator is part of the input.<p>Purity refers to reproducibility, as in no matter what else is going on, that function will always behave the same. You can have pure functions in OOP based languages, but in practice devs just default to managing state and having weird behavior depending on outside state of a given function.<p>As a side note, and since you mention runtime performance cost: if you implement a dummy generic cache layer and you have pure functions you will have an easier time than having stateful impls. In this case, that cache layer must have the ability to introspect into foo, but in bar that cache layer just keeps track of input and that&#x27;s it.')