Item(by='sbergot', descendants=None, kids=[24894927, 24896620], score=None, time=1603709828, title=None, item_type='comment', url=None, parent=24894380, text='You comment is interesting. In the first sentence Lisp is a good solution against complexity. In the second one it is not.<p>A good litmus test for complexity is the following: as a developer analysing software in order to understand &amp; modify it, how many lines of code do I have to read in order to grasp what is going on and what can I do to solve my problem?<p>In my opinion this is the main goal of a good software architecture. The advantage of lisp is that I can create a DSL like library that precisely describe my domain. The issue is that because macros can have dramatic effects on the final program, I have to check carefully all of them in order to understand a piece of code. This and the inability to look up quickly what fields are inside an object or the exact api of a function.<p>A common base language and static types are the best tools I know to create useful boundaries. Another way is to split the software but this comes with other issues.<p>The use of the term &quot;powerful&quot; might be a bit misleading. Powerful is good. Here powerful refers to &quot;easy metaprogramming&quot;. Metaprogramming is something you need in an ecosystem, but you need to hide it a bit so that you only use it when you really need it. I find the lisp community a little bit too proud of their metaprogramming capabilities.')