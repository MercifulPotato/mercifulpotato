Item(by='steerablesafe', descendants=None, kids=[25844535, 25845101], score=None, time=1611136464, title=None, item_type='comment', url=None, parent=25833557, text='&gt; It really shows how conditioned an entire community can be when they find the statement “given a list x, the first item in x is x[1], the second item in x is x[2]” to be unnatural.<p>It&#x27;s not unnatural, but it&#x27;s not natural either. It&#x27;s just that 1-based indexing aligns with natural language conventions better. It also matches with some math conventions for matrices and vectors, but those don&#x27;t have to use 1-based indexing either to work. I learned linear algebra with abstract &quot;index sets&quot; (I), where <i>I</i> can be {1, 2, 3, .., n}, {x,y,z}, {0,1,2}, whatever.<p>Programming in 0-based indexing means way less +-1 adjustments on boundaries. Division&#x2F;modulus also works way better with 0-based indexing, so flattening multi-dimensional arrays is more easily expressed too.<p>In the end it&#x27;s just a convention, it shouldn&#x27;t matter too much. My money is still on 0-based indexing, as it lends itself to less errors and cognitive load when you get used to it. I used both extensively.<p>Tangential: conventions that are more &quot;natural&quot; are usually not actually natural, but just align themselves to other conventions better. Of course it&#x27;s always good if conventions align, but sometimes it&#x27;s inconsequential. Also there are situations where we can&#x27;t make all conventions align.<p>An other little pet-peeve of mine is people calling big-endian more natural than little-endian, where there are actually different competing conventions:<p>1. Usual way of printing memory content from lower address to higher address from left to right (think hexdump).<p>2. Usual way of writing down numbers from left to right from most significant digit to least significant digit.<p>3. Expressing the value of the number from the byte array elements (\\sum_0^(width-1) byte[n] 256^n for little-endian, \\sum_0^(width-1) byte[n] 256^(width-n-1) for big-endian)<p>Big-endian aligns better with the combination of 1 and 2. Little-endian aligns better with 3.')