Item(by='scrollaway', descendants=None, kids=None, score=None, time=1608751918, title=None, item_type='comment', url=None, parent=25520210, text='Honestly I don&#x27;t really know how to summarize it. Django templates have a ton of gotchas. They have the dumbest safeguards, too, such as preventing you from using variables beginning with underscores.<p>Jinja templates at least let you use normal python syntax in the tags. You can easily do something like {{ items.filter(&quot;books&quot;)[:5] }} â€” in Django, you would have to write a special accessor or template tag to call filter(&quot;books&quot;) as it doesn&#x27;t let you specify arguments to function calls, and you&#x27;d use the awful |slice:&quot;:5&quot; to slice it.<p>But more than anything else, Django templates are not just untyped, they are untypeable. You can&#x27;t really validate them. Best you can do is try to compile them in a CI job see if anything fails. Not to mention that the way you&#x27;re outputting HTML essentially arbitrarily anywhere in the page means there is no way for the editor &#x2F; tools &#x2F; even yourself to know if some piece of code is syntactically or semantically valid in context. Got a list_item.html with a naked &quot;&lt;li&gt;{{ item }}&quot; inside? Why the fuck not! Could even be raw css or js outside a tag in your template, could be valid in some includes, invalid in some others. Everything goes. You can&#x27;t even know whether a template is in use, as it&#x27;s completely arbitrary code that calls these template inclusions, via string filenames (which therefore can be included however you want).<p>It&#x27;s impossible to create these problems with react&#x2F;typescript. And react heavily encourages code reuse: creating reusable components that are as small as possible. Django templates encourage <i>copy-pasting</i>.')