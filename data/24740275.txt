Item(by='alkonaut', descendants=None, kids=None, score=None, time=1602349402, title=None, item_type='comment', url=None, parent=24739810, text='I’d only advocate using GC’d languages as a general (ie covering as many use cases as possible in <i>one</i> language - this isn’t even necessarily a good idea to begin with!) where it’s easy to dodge it. For example it must be easy and reasonably idiomatic controlling what is and isn’t heap allocated.<p>Obviously all languages are a tradeoff between ergonomics and performance, but it should be easy and idiomatic to use the back doors. Using mutation in F#  or stack allocation in C# doesn’t feel like swimming upstream. If the language offers a comfortable experience for the 80-90% case and a not-terrible experience for the rest, that’s very good. If the “back door” is e.g. JNI or being forced to use SoA when you wanted AoS in Java that’s not very impressive.<p>I grabbed the 10-20% number of “programs that need mutation” out of my behind obviously, but it <i>is</i> highly subjective.')