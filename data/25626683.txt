Item(by='eyelidlessness', descendants=None, kids=None, score=None, time=1609720158, title=None, item_type='comment', url=None, parent=25625670, text='I think we’re <i>almost</i> on the same page (heh). Pagination may still make sense for a variety of reasons. Even if there’s no meaningful sever optimization gain, clients may benefit from a reduced response size (mobile, expensive data plans, low power devices). That sort of thing is where ensuring consistency (for the sake of brevity I’ll repeat, at a point in time, but there are other ways to allow clients to negotiate this) at the request level over multiple requests is useful, even if the underlying data is changing much faster than the client is consuming it.<p>It’s worth noting here that this isn’t just applicable to paginated lists. It can also be used where you want to let the client optionally, concurrently access related resources. It can be used for client-side concurrent transactional writes. It’s a barrel of monkeys.<p>For what it’s worth, I wouldn’t assume their volume of traffic was necessarily the reason the data was in such flux. It could be (and I strongly suspect) that their popularity algorithm just stinks (eg weighting 100% of 1 view over 90% of 100 views). Even so, a snapshot in time is probably a much easier lift&#x2F;gain for a flailing algorithm than really digging into the data and analytics to get an optimal stable sort without it:<p>1. Take a snapshot of the query and throw it in a dumb cache.<p>2. Rate limit cache key creation rather than cache hit requests.<p>3. Throw the caches out (and repopulate if reasonable) every [vaguely not gonna break the bank age duration].<p>4. Forget about any further optimization unless you reallllly need it.<p>5. Document the problems with the suboptimal solution, have a retro so your junior devs can develop better instincts, get them onto the next user story.<p>6. Put a “should we improve this” on the backlog of backlogs.<p>7. Profit.')