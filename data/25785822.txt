Item(by='millstone', descendants=None, kids=[25786052], score=None, time=1610674780, title=None, item_type='comment', url=None, parent=25783633, text='CMake tackles the unsexy challenge of cataloging every compiler on every platform. If things seem easier in Go, it&#x27;s in part because Go mostly stays in its sandbox. Where Go interoperates, it&#x27;s worse than CMake.<p>For example, Go&#x27;s build system for C (cgo) is configured by stitching together environment variables and magical comments:<p><pre><code>    &#x2F;&#x2F; #cgo CFLAGS: -DPNG_DEBUG=1\n    &#x2F;&#x2F; #cgo amd64 386 CFLAGS: -DX86=1\n    &#x2F;&#x2F; #cgo LDFLAGS: -lpng\n    &#x2F;&#x2F; #include &lt;png.h&gt;\n    import &quot;C&quot;\n</code></pre>\nAs bad as CMake is, that is even worse. Imagine making that stuff portable!<p>CMake has major problems (package management and language, as you say) but I don&#x27;t know of any other tool that solves the problem that CMake solves.<p><a href="https:&#x2F;&#x2F;golang.org&#x2F;cmd&#x2F;cgo&#x2F;" rel="nofollow">https:&#x2F;&#x2F;golang.org&#x2F;cmd&#x2F;cgo&#x2F;</a>')