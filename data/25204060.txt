Item(by='sangel', descendants=None, kids=[25204869, 25204765], score=None, time=1606259018, title=None, item_type='comment', url=None, parent=25203424, text='The table looks like this:<p>Column 1            Column 2<p>start-text1        start-text2<p>&lt;intermediate&gt;    &lt;intermediate&gt;<p>last-hash1       last-hash2<p>You only store the start text and the last hash for each column. &lt;intermediate&gt; consists of a mix of passwords (&quot;text &quot;) and hashes. To see how they are computed, let us narrow our attention to a single column.<p>text1<p>&lt;hash-1&gt;      computed using H(text1)<p>&lt;text-2&gt;      computed using R_1(hash-1)<p>&lt;hash-2&gt;      computed using H(text-2)<p>&lt;text-3&gt;      computed using R_2(hash-2)<p>last-hash   computed using H(text-3)<p>Each column will look like that. I&#x27;m using &lt;stuff&gt; to denote things that are not stored. H is the hash function you are creating the rainbow table for. R_1, R_2, etc. are the reduction functions. Each column uses the same hash function and reduction functions but uses a different starting text.<p>Note that in a rainbow table that consists of k columns, there is no need to recompute hash&#x2F;reduction functions for each chain. Instead, the attacker computes R_last(target-digest), and checks that against all the endpoints (last hash) of all column. If it matches any endpoint, then that chain likely has the corresponding password. Otherwise, compute R_last(H(R_second_to_last(target-digest))), and compare the result with all endpoints. Rinse and repeat. In the worst case, you have to compute as many hash&#x2F;reduction functions as there are rows (regardless of the number of columns since all columns use the same hash and reduction functions).')