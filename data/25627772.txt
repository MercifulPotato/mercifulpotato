Item(by='jerf', descendants=None, kids=[25636545, 25627963], score=None, time=1609732186, title=None, item_type='comment', url=None, parent=25625113, text='&quot;Is there any good literature or patterns on supporting dumps in the tens of millions or larger?&quot;<p>The two main things you need are: 1. HTTP is a streaming protocol. You don&#x27;t need to fully manifest a response in memory before you send it. If your framework forces that, bypass it for this particular call. (If you can&#x27;t bypass it... your framework choice is now a problem for you.)<p>2. You presumably have some sort of JSON encoder in your language. As long as it doesn&#x27;t have some sort of hard-coded &quot;close the stream once we send this JSON&quot; behavior (and if so, file a bug because a JSON encoder has no business doing that), all you have to do is ensure that the right bytes go out on the wire. You, again, don&#x27;t have to fully manifest the reply in memory before you encode it. Something like:<p><pre><code>    stream.Write(&quot;[&quot;)\n    needComma = False\n    for item in toBeSerialized:\n        if needComma:\n            stream.Write(&quot;,&quot;)\n        json.Write(stream, item)\n        needComma = True\n    stream.Write(&quot;]&quot;)\n</code></pre>\nA lot of times when you&#x27;re emitting gigabytes of JSON it&#x27;s still in lots of little chunks where each individual chunk isn&#x27;t a memory problem on its own, so doing something like this can be very memory-efficient, especially if &quot;toBeSerialized&quot; is itself something like a cursor coming out of a DB where it itself is not manifesting in memory. (Newlines are also a good idea if your JSON encoder isn&#x27;t naturally doing it already; helps debugging a lot for very little cost.)<p>JSON objects can be more annoying; you may need to manually deserialize one and that&#x27;s more annoying. Protip: Whenever possible, use the JSON encoder in your language; there is no shame or anything in using the JSON encoder to emit strings corresponding to the keys of your object. Much like HTML, you need to be very careful writing things directly to the stream; it really always should go through the encoder. I even send constant strings through the encoder just to make the code look right.<p>The last little tidbit is that the HTTP software stack will tend to fight you on the matter of keeping long-lived connections open. There can be a lot of places that have timeouts you may want to extend. If this gets too big you may need to do something other than HTTP. You may also need to consider detecting failures (hashing or something) and the ability to restart. (Although don&#x27;t underestimate modern bandwidth and the speed you can iterate through SELECT <i>-type queries; definitely check into the virtues of just retrying. 10GB&#x2F;year of extra bandwidth and processing power is still cheaper than a developer even </i>designing* a solution to that problem, let alone implementing and testing it.)<p>Oh, and if you can use HTTP, be sure you&#x27;re gzip&#x27;ing. It&#x27;s dirt cheap nowadays on the CPU; only in extreme situations of bandwidth abundance and CPU shortage can it be worth skipping. My rule-of-thumb on JSON shrinking is about 15:1. CSVs don&#x27;t quite shrink that much but they still shrink down pretty well.')