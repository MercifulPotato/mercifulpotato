Item(by='inopinatus', descendants=None, kids=[25175932, 25176264], score=None, time=1606032015, title=None, item_type='comment', url=None, parent=25175184, text='The language mostly refers to them as &quot;singleton classes&quot;, because logically speaking there is exactly one of them for every object.<p>Every Ruby object is an instance of its singleton class.  Even when it appears to be an instance of, say, &quot;File&quot; or &quot;Hash&quot;, their true individual identity is their singleton. Hence with:<p><pre><code>    class Foo; end\n    foo = Foo.new\n</code></pre>\nthen<p><pre><code>    foo.singleton_class            #=&gt; #&lt;Class:#&lt;Foo:0x00007ff6cc195ee0&gt;&gt;\n    foo.singleton_class &lt; Foo      #=&gt; true\n    foo.is_a?(foo.singleton_class) #=&gt; true\n    foo.singleton_class.ancestors  #=&gt; [#&lt;Class:#&lt;Foo:0x00007ff6cc195ee0&gt;&gt;, Foo, Object, Kernel, BasicObject]\n</code></pre>\nMost significantly, this class is where any per-object method is actually contained, hence:<p><pre><code>    class Foo\n      def self.hello\n        42\n      end\n    end\n\n    Foo.hello #=&gt; 42\n    Foo.singleton_class.instance_methods(false) #=&gt; [:hello]\n</code></pre>\nThere are three things worth observing that, once fully absorbed, helped me understand all this more instinctively:<p>1. All Ruby methods are the instance methods of a class.<p>2. What we call <i>class methods</i>, such as Foo.hello above, are technically <i>instance methods of the singleton class of a Class object</i>. But that&#x27;s something of a mouthful, so we say <i>class method</i> instead.<p>3. Extending an object with a module is, by definition, including that module in the ancestors of its singleton.')