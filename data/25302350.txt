Item(by='pron', descendants=None, kids=None, score=None, time=1607091031, title=None, item_type='comment', url=None, parent=25302181, text='* Java offers both user-mode and kernel threads. You pick at creation, and can even plug your own scheduler.<p>* Loom&#x27;s virtual threads are completely scheduled in library code, written in Java.<p>* FFI that bypasses the JDK and interacts with native code that does either IO or OS-thread synchronization is <i>extremely</i> rare in Java.<p>* Cancellation is the same for both.<p>Also, IMO, coordination is simpler for threads than for async. Where they differ is in their choice of defaults: thread allow scheduling points anywhere except where explicitly excluded; async&#x2F;await allows scheduling points nowhere except where explicitly allowed. Putting aside that some languages have <i>both</i>, resulting in few if any guarantees, threads&#x27; defaults are better for correct concurrency. The reason is that correctness relies on atomicity, or lack of scheduling points in critical sections. When you explicitly exclude them, none of your callees can break your correctness. When you explicitly allow them, any callee can become async and break its caller&#x27;s logic. True, the type system will show you where the relevant callsites are, but it will not show you whether there is a reliance on atomicity or not.<p>Async&#x2F;await does, however, make sense for JavaScript, where all existing code already has an implicit assumption of atomicity, so breaking it would have broken the world. For languages that have both, async&#x2F;await mostly adds a lot of complexity, although sometimes it is needed for implementation reasons.')