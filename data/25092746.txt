Item(by='the8472', descendants=None, kids=None, score=None, time=1605367032, title=None, item_type='comment', url=None, parent=25092459, text='&gt; But its not concurrently accessed memory - unlike memory you often want filesystem operations to run asynchronously.<p>Well, but it is. Files can be opened multiple times and file descriptors can be shared between any number of processes and threads. mmap, atomics and msync also give you granular access.<p>Most people might not use it that way, but the thing is that it <i>can</i> be used that way. Just like RAM can be accessed randomly from many threads but higher-level languages limit what you&#x27;re allowed to do concurrently. It&#x27;s the same fast-but-unsafe-guts, use safe abstractions thing.<p>&gt; I&#x27;m thinking about the 95% of applications out there which want to use the filesystem to save user data to disk<p>Those 95% of the applications aren&#x27;t necessarily those doing 95% of the write IO though. Looking at the activity on my system then most of the write traffic is a) logging (including messaging) b) firefox occasioally showing 1GB&#x2F;s places.sqlite spikes (hah) c) temporary files d) docker e) p2p storage.<p>For logging O_APPEND&#x27;s atomicity promise may be good enough. I don&#x27;t think text editors need transactions either, they only need file-level atomic replace which can be handled by a single library function. Such functions should be available in more libraries, I can agree with that.<p>&gt; Why should the kernel maintain an API for this? Because the default, obvious way people use the filesystem should be correct.<p>Why the kernel and not libc? Or some other userspace lib for that matter.<p>&gt; I&#x27;d be happy for an argument that the posix filesystem is too low level to be used to directly store user data.<p>That might be a matter of perspective. open&#x2F;write&#x2F;close is perfectly fine if all you do is move 100s of RAW photos from your SD card to your file server. There&#x27;s no rewrite-in-place happening, it&#x27;s a one-time thing that at worst would leave you with one incompletely copied file if the PC crashes shortly after copying. And the SD card wasn&#x27;t a bastion of reliability anyway.\nDocker layers and containers are quite discardable and I wouldn&#x27;t even mind if they had 0 durability.\ngit, sqlite and postgres already seem to be doing the right thing.\nWhether document processing software does, I don&#x27;t know but I assume they put some effort into it with all their autosaving features. But, as mentioned above, all they really need is nicer standard libs not a new kernel API.\nThat doesn&#x27;t leave that many things I deem critical.\nPerhaps it is a little annoying if some of the configuration text files of various GUI applications get lost in a crash but on the other hand I wouldn&#x27;t want them to fsync my preferences every time I tick a checkbox so I&#x27;d only want atomicity but not synchronous durability.<p>&gt; - Most programmers don&#x27;t even bother to use fsync. Anything which starts with &quot;you can solve the trivial problem of saving a file in this super complex way&quot; is a nonstarter and will almost never be used.<p>If people can&#x27;t even be bothered to fsync then why would they be bothered to wrap IO into a transaction? After all APIs still would have to continue to work in non-transactional mode for performance and backwards-compatibility reasons so there would be no pressure on people to use transactions.<p>Maybe this also is a documentation problem since many developers don&#x27;t seem to be aware of the non-durable-by-default behavior and different steps needed to get atomicity or durability. Man pages and standard libraries lack a high level overview of filesystem semantics. Some of it is noted in fsync() for example but not in rename()')