Item(by='damnyou', descendants=None, kids=None, score=None, time=1610932095, title=None, item_type='comment', url=None, parent=25811310, text='Thanks for the thoughtful response. I spent a bit of time thinking about it, and thank you for that as well.<p>So, I think you&#x27;re right about a result type being isomorphic to checked exceptions, for the reasons you laid out. If you compare it to Rust, what ends up happening is similar -- many libraries return an error type that&#x27;s a union of all their dependencies&#x27; error types, and binaries end up using an &quot;everything&quot; anyhow::Error type in the end. <i>However</i>, I think where sum types in general end up working and checked exceptions don&#x27;t are:<p>1. Sum types don&#x27;t encourage a mix of checked and unchecked exceptions the way Java does. Translating from Rust, all exceptions that are meant to be handled by regular users are checked. The only exceptions that are unchecked are broken invariants (panics), which usually end up being handled either through aborting the program or through some sort of top-level restart logic. You could write Java in that style but it&#x27;s not the ecosystem&#x27;s convention.<p>2. Sum types are more general than checked exceptions: they can be used to express nulls and business logic as well. I suspect checked exceptions would have worked better if Java also had nullable and non-nullable types, because nullability is such a common source of errors.<p>3. You&#x27;re right that you can drop an error on the floor with sum types as well, just like an empty catch block with exceptions. But that just doesn&#x27;t happen nearly as often in practice, because result types form a closed set. With checked exceptions, in practice you often end up with a method throwing both checked and unchecked exceptions, and the same syntax is used to handle both. I think checked and unchecked exceptions are fundamentally very, very different and mixing the two is a mistake.<p>Once again, thank you for your response.')