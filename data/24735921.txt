Item(by='nickm12', descendants=None, kids=None, score=None, time=1602291915, title=None, item_type='comment', url=None, parent=24730749, text='So the main thing that clicked with Brazil was really understanding how to use versionsets effectively to model software stacks and in particular thinking about a package&#x27;s dependencies as part of its public interface.<p>A common anti-pattern I saw at Amazon was for some team to need some functionality, see a package in the &quot;live&quot; version set that had it, and grab it without thinking about how that package&#x27;s dependencies aligned with their application&#x27;s. Teams also frequently used the wrong dependency type (runtime, build, test). Things will &quot;work&quot; if you declare a test dependency as a runtime dependency, but you are setting yourself up for unnecessary version conflicts down the road (you can have multiple versions of a package in your test dependency closure, but not your runtime dependency closure).<p>As for what I missed at the company with the monorepo there were two things: The first was that there was no way to deploy a version of the code that was exactly the same as what was in production plus some patch. The deployment system could only deploy the tip of the master branch, so if you needed to patch in prod you were going to bring with it all the other changes that had landed on the master branch, for better or for worse. There is no reason that a monorepo has to have this problem, though, it was a limitation of the deployment system.<p>The main thing I didn&#x27;t like about the monorepo though was that it was next to impossible for me to track the changes that were relevant to me. In Brazil, every package is its own git repo and it&#x27;s very straightforward to just list the git history of a package and see what has changed. In the monorepo 99% of the change in the git history were completely irrelevant. Also, twice they needed to rewrite the history of the entire repo to expunge some secret that had accidentally been committed years ago. All the hashes changed and it was very disruptive.<p>So what&#x27;s good about Brazil is that it gives you the advantages of a monorepo without all the source code literally being in the same repo. It&#x27;s also good because you can maintain multiple versions of the same package together and migrate different consuming apps separately. What&#x27;s not so great about Brazil is that there is really a subtle art to factoring your software into packages and version sets and most times you get it wrong in a way that leads to seemingly unnecessary pain. The fact that you don&#x27;t have to update all consumers together means that its really easy to just not update consumers and you pay the price for that eventually. There&#x27;s another big pain point with Brazil which is that it was traditionally difficult to import open source software from open-source repositories (NPM, PyPy, Maven, etc.). This has gotten much better in recent years and there are efforts to improve it even more.')