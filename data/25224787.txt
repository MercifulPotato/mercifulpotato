Item(by='lathiat', descendants=None, kids=None, score=None, time=1606439706, title=None, item_type='comment', url=None, parent=25224714, text='This is 100% a problem I was working on for a customer recently. nproc specifically does not currently check your CFS CPU cgroup quota, i.e. you may have 12 active cores but only a budget of 4 CPUs worth of CPU time. This can be an issue.<p>It would be ideal to have a standard utility or library that would also check that.<p>If you want to understand more about these problems this article has some good background, although they fixed a real bug in the scheduler here the background will give you the general idea and it&#x27;s still a problem to some extent if all of those threads&#x2F;processes are trying to contend on a single shared lock.. which is precisely what happens with multi threaded Python programs (they sometimes contend on the GIL) that use data science modules which do a lot of processing in C without the GIL lock held and only take it occasionally. However the problem comes if you have 12 threads consuming your 4 threads worth of CPU time they&#x27;ll end up block for 5-10 or more milliseconds at a time where they may well be holding that lock and preventing the other threads from running.<p>You may then ask why not reduce the CPU set for those containers, the problem is there is no way (at least currently) to say &#x27;this process can only run on 4 CPUs, but any of them&#x27;. You have to reduce the CPU set down to 4 specific CPUs and now if all containers scheduled to those specific 4 CPUs are busy you will be losing time to those other containers when a different 4 CPUs may be totally idle. It would be nice to advance the scheduler to support such a concept without using the quotas specifically.<p>As a final side note.. LXD cheats here. It uses &#x27;lxcfs&#x27; to bind mount onto &#x2F;proc&#x2F;cpuinfo and modifies the output to only show the number of CPU cores you actually have. Which suffices for most programs.')