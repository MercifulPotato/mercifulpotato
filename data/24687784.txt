Item(by='dnsmichi', descendants=None, kids=None, score=None, time=1601906275, title=None, item_type='comment', url=None, parent=24686700, text='Hi, Developer Evangelist at GitLab here. I would say, it depends on the workflow, unfortunately there is not right or wrong here. I&#x27;ll try to share some situations of my development experience in the past years, also as Git&#x2F;GitLab trainer:<p>## Squash<p>I often start in a feature branch with a new proof of concept, or other code which is persisted in several commits. Sometimes I&#x27;ll iterate on a few things, like testing a change in a GitLab CI yaml, and checking whether it works. Or a different compiler flag to enable faster package builds. Or a refactored function which needs to run all the e2e tests to prove the performance gain.<p>These changes may, or may not work. When they do not work, I&#x27;ll reset the commits - either soft to keep the changes, or hard to throw away the attempt. This follows a changed history and force push into the remote branch. In case of a shared branch, message colleagues with &quot;git fetch &amp;&amp; git reset --hard origin&#x2F;branchname&quot;.<p>Within pair programming sessions, we often left with commits like &quot;Add REST API HTTP server, WIP 2&quot; in branches and depending on the availability, either one of us continued. At a certain point in development time, we decided to squash and amend the commits. Sometimes not all of them, as rebase&#x2F;squash also allows you to do the following:<p>c1 s \\<p>c2 s &#x2F;<p>c3 p<p>c4 s \\<p>c5 s &#x2F;<p>Which squashes c1+c2, leaves c3, and squashes c4+c5 again. You can navigate into this on the CLI with &quot;git rebase -i HEAD ~5&quot;.<p>## Rebase&#x2F;Merge<p>Short-lived branches which are quickly merged back to the main branch shouldn&#x27;t cause problems with a broken deployment. In case you get a task assigned where the main branch is far beyond (say, 100 commits or more), it may be the case that<p>- Branch and merge request works fine, CI&#x2F;CD pipelines are green\n- Changes in the main branch which affect your feature.<p>These changes can be<p>- Function interfaces renamed, or not existing. Easy to fix upon rebase, build&#x2F;run does not work anymore.\n- Runtime changes, for example, queries take longer roundtrip due to a refactor. Your feature only takes the old behaviour into account, and increases the runtime complexity. Or it consumes 10x memory resulting in OOM crashes later.<p>The last change may not be immediately visible, as it involves staging environments and application performance monitoring results.<p>### Merge without Rebase<p>If said changes occur, and the rebase did not happen, the green CI&#x2F;CD MR is merged back to the main branch. Depending on the releases, you either roll into production, or after days&#x2F;weeks&#x2F;months, a new release is cut.<p>At that point, the regression may be seen in the main branch, and cause delayed analysis and debugging. Often times on-call alerts and all the debug fun which may lead to burnout (been there myself).<p>### Merge Request with Rebase<p>During the final review, and prior the merge, the changes are rebased against the latest base in the main branch, to see if they compile or any other influences.<p>A rebase puts the existing commits onto a new commit base, which influences the calculated checksums. Therefore all commits are newly generated, the author date is preserved with changing the commit date.<p>### Merge Commits<p>There are different opinions on them. One of them is to always rebase the MR and then do a merge with a commit. Rationale: Even without GitLab&#x2F;GitHub&#x2F;etc. you can reliably see the git graph on the CLI or with other visualization tools.<p><a href="https:&#x2F;&#x2F;gitlab.com&#x2F;dnsmichi&#x2F;dotfiles&#x2F;-&#x2F;blob&#x2F;main&#x2F;.gitconfig#L6" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;dnsmichi&#x2F;dotfiles&#x2F;-&#x2F;blob&#x2F;main&#x2F;.gitconfig#...</a><p>I&#x27;ve recently seen the possibility to reference a PR&#x2F;MR to a commit as the merge-from-branch reference, without the dedicated merge commit. This can be handy to avoid it, with using GitLab&#x2F;GitHub&#x2F;etc. to store this detail in their database. It also is a vendor lock-in in a way, that the native &quot;git clone&quot; does not provide this information for you in Git&#x27;s database.<p>That being said, I used to dislike merge commits. With enriched details, and CLI work, I now prefer them again. Git commits as datasource are valuable, and they can be shown&#x2F;parsed in any environment.<p>### Rebase, Merge, ... large environments?<p>This can of course get more complex, with fast moving main branches and lots of merges which depend on each other, and should not reach the main branch. Instead, you&#x27;d want them to be queued and tested. We experience that at GitLab quite often, and have created so-called &quot;Merge Trains&quot; which ensure that all MRs in such a queue&#x2F;train are taken into account: <a href="https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;ci&#x2F;merge_request_pipelines&#x2F;pipelines_for_merged_results&#x2F;merge_trains&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;ci&#x2F;merge_request_pipelines&#x2F;pipeli...</a><p>## A personal note: The best merge&#x2F;rebase strategy is nothing without tests<p>I&#x27;ve been working on a monitoring tool in the past which includes distributed environments, and often needed to fix bugs with memory leaks or other performance issues in multi-threaded scenarios. Things you do not see immediately when the MR&#x2F;PR is green. There was one commit which caused a OOM crash after 3 days of runtime, but only in cloud environments with &gt;100 satellite nodes.<p>The turnaround was to bisect all the commits, and run each of them in production for 3 days until the crash occurred. IIRC we had 1,200 of them to do in a binary search.<p>Now the question is:<p>- Fewer squashed commits\n- More development history<p>In this case, fewer commits would have unveiled the error sooner. The resulting commit would be larger and harder to debug &amp; fix though.<p>In the end, it did not really matter. The thing which would have helped: There was no reliable test environment coupled to CI, CD which ensured to run specific commits &amp; MR&#x2F;PR in dedicated scenarios and alert of breaking changes soon enough - before the release happens.<p>## Conclusion<p>One thing which greatly helped: Looking how others do it, Open Source projects and customer success stories and webinars, online training sessions. Even though you may not adopt the workflows, trying them out is a good way to learn. For instance, &quot;trunk based development with feature flags&quot; is something different to well-known branching models for me, I needed to try them out first to change my opinion. They are indeed useful for certain scenarios.<p>While committing changes, and keeping them throughout un-squashed MRs, I always remember that I will be highly likely debugging the changes later on. Or someone who finds the MR reviewed by myself, documenting every thought or idea in a commit or MR comment can help.<p>Some more tips and exercises are discussed in an OSS training I created in the past: <a href="https:&#x2F;&#x2F;github.com&#x2F;NETWAYS&#x2F;gitlab-training&#x2F;releases&#x2F;tag&#x2F;v2.5.2" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;NETWAYS&#x2F;gitlab-training&#x2F;releases&#x2F;tag&#x2F;v2.5...</a>')