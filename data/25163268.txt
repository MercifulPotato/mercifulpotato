Item(by='qalmakka', descendants=None, kids=None, score=None, time=1605896654, title=None, item_type='comment', url=None, parent=25161466, text='Yes, I mostly agree with you, but I think that if we look closely to how programming languages have evolved over the years, we can more or less define them into &quot;generations&quot; i.e. periods where certain concepts have more or less dominated the interest of the community and have dictated how software and languages in general are designed.<p>These are usually linked with one or several languages springing out and becoming popular, either by embracing new paradigms or by strongly rejecting a mainstream concept whose usefulness have been cast into doubt either by the industry or the community.<p>Outside these periods, the overall interest tends to stagnate while the newer languages become stable and gain mainstream acceptance. In such a situation, a new contender must either find itself a niche, by covering very specific needs in very effective ways, or it must compete in mindshare in order to justify itself among the newest big names (i.e. any new compiled, strong typed and memory safe language nowadays is almost forced to compare with Rust and I dare say Zig).<p>That&#x27;s what I meant with &quot;market saturation&quot;: I think the stagnant landscape of the 00s, dominated by classic, OOP languages, gave birth to a huge wave of &quot;safe&quot; languages in the 10s, many of which share similar concepts and ideas; I think we&#x27;re now in a moment where some of these have made a name for themselves and have been established as mainstream, serious solutions (see Rust or Go), requiring newer contendents to be really innovative in order to capture mindshare and not be considered &quot;me too&quot; languages.<p>These are, obviously, just my two cents; I really love compiler development and language design, and I think we should always support new languages and the work people do towards the goal of designing better languages and improving existing ones.')