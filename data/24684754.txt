Item(by='hardwaresofton', descendants=None, kids=None, score=None, time=1601875139, title=None, item_type='comment', url=None, parent=24684116, text='And this is where the squinting comes in! As far as I&#x27;m concerned the differences are mostly implementation details. As far as the idea of deploying small, relatively self-contained chunks of functionality I think serverless is a revisit of the principles of CGI. I&#x27;ve actually given at tiny presentation on this if anyone likes to read my view in depth[0] which I think fully explains my stance. Huge grain of salt though -- I wasn&#x27;t <i>there</i> when all this happened, and I only caught the end of the cgi-bin era.<p>&gt; The thing that fastcgi brought over cgi-bin was that an application process could be left open to communicate with the server, where-as cgi-bin model required spawning a new process for each request.<p>Absolutely (I read&#x2F;skimmed the article, and this was brought up) -- serverless functions are the same here, because it also allows for machines to stay running for some indefinite<p>&gt; If one reads the AWS Lambda docs, they&#x27;ll see the execution context[1] has a similar behavior. AWS will spin up new instances, but these instances will serve multiple requests, via a fairly custom &quot;function&quot; interface defined for various runtimes (but which is actually, typically an http interface). There is a standard HTTP api for runtimes to use to retrieve function invocations[2].<p>&gt; With FastCGI the front end server uses a socket to push request messages to app servers, which replies in order. Where-as with Lambda &amp; it&#x27;s above mentioned runtime API, the runtime is retrieving requests from Amazon at it&#x27;s pacing, &amp; fulfilling them as it can. So there&#x27;s a push vs pull model, but in both cases, the application server is talking a fairly custom protocol to the front-end server.<p>This is one of the reasons I said &quot;serverless functions&quot; instead of Lambda. While AWS happens to specify their operational semantics that way, there is no need for anyone else to. While improvements are necessary I still think this is fairly close to FCGI, and FCGI could absolutely serve as a &quot;serverless&quot; provider implementation.<p>Needless to say, how long you keep around the process, or how you checkpoint restore (criu[1] is very interesting, for anyone who&#x27;s never seen it) and move processes are all implementation-specific in my mind.<p>[0]: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;mrman&#x2F;talks&#x2F;raw&#x2F;master&#x2F;dist&#x2F;2019&#x2F;04&#x2F;mercari-backend-meetup.pdf" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;mrman&#x2F;talks&#x2F;raw&#x2F;master&#x2F;dist&#x2F;2019&#x2F;04&#x2F;merca...</a><p>[1]: <a href="https:&#x2F;&#x2F;criu.org&#x2F;Main_Page" rel="nofollow">https:&#x2F;&#x2F;criu.org&#x2F;Main_Page</a>')