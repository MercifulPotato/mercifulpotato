Item(by='jolmg', descendants=None, kids=None, score=None, time=1602948681, title=None, item_type='comment', url=None, parent=24806538, text='&gt; It happens with or without bracketed paste mode on (using the &quot;enable-bracketed-paste&quot; option in ~&#x2F;.inputrc).<p>~&#x2F;.inputrc is the readline library&#x27;s configuration file. The &quot;enable-bracketed-paste&quot; option in it doesn&#x27;t affect vim nor the terminals. What it does is turn on the <i>recognition</i> of Bracketed Paste Mode escape sequences for programs that use readline, like bash.<p>&gt; the newlines were replaced with semicolons<p>I can&#x27;t reproduce. After setting that option in ~&#x2F;.inputrc, bash puts multi-line pastes in a single prompt, but it keeps the newlines, not replace them. This is bash 5.0.18(1). Are you sure you&#x27;re not confusing the semicolons that are really there and thinking they were newlines before?<p>In any case, a behavior like that would have to be done by the shell, not the terminal, since semicolons are not special to the terminal and it&#x27;s not a simple matter of substituting one for the other in shell code. In order for the shell code to be equivalent, parsing would be required to identify if the newline terminates a command or if it&#x27;s part of another syntax structure. For example<p><pre><code>  foo\n  bar=&#x27;\n  baz\n  &#x27;\n  qux &lt;&lt; EOF\n  quux\n  EOF\n</code></pre>\nonly 2 of the newlines above can be substituted with semicolons.<p>EDIT: Maybe you have other bash configuration options playing into that substituting behavior. Bash shell options like cmdhist and lithist seem relevant. From the bash manpage:<p>&gt; lithist If set, and the cmdhist option  is  enabled,  multi-line commands are saved to the history with embedded newlines rather than using semicolon separators where possible.')