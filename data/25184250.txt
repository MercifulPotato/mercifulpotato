Item(by='codebje', descendants=None, kids=None, score=None, time=1606115238, title=None, item_type='comment', url=None, parent=25179596, text='Java&#x27;s checked exceptions aren&#x27;t (usefully) polymorphic. You can&#x27;t write, for example:<p><pre><code>    R process&lt;R, E extends Exception&gt;(ThrowingFunction&lt;Long, R, E&gt; processor) throws E { ... }\n</code></pre>\nYou could write &quot;process&quot; to the Exception base class, but it still can&#x27;t handle a &quot;processor&quot; that doesn&#x27;t throw at all.<p>Checked exceptions a &quot;bolted on&quot; effect that sits outside the usual type system in Java, and their presence on a method signature &quot;colours&quot; it in a way that an effect described inside a type system would not. More of a stain than a tint, if you will.<p>Java 8 resolved it by quietly pretending checked exceptions never happened, which works fine until (1) you get unhandled unchecked exceptions in all their glory at runtime, and (2) you want to use one of the Java 7 or earlier methods as a &quot;processor&quot; but, oh no, it throws an exception.<p>(It&#x27;s a deeper colouring than JavaScript&#x27;s async&#x2F;await keyword, which is just syntactic sugar around continuations in callbacks and returning promises - you can pass an async &quot;processor&quot; function to a &quot;process&quot; function that has no idea what it&#x27;s getting and get back the promise you&#x27;d expect from it.)')