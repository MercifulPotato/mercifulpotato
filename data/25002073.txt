Item(by='hajile', descendants=None, kids=[25003824], score=None, time=1604611073, title=None, item_type='comment', url=None, parent=24999815, text='I was specifically talking about types.<p>Java or C# decide null is bad and try very hard to add Option and non-nullables, but go&#x27;s creators just decide they must not have a good reason, so nulls everywhere.<p>The potential problem of things like empty interface escaping the type system are well known, but go&#x27;s creators decided that everyone else&#x27;s experience here didn&#x27;t really matter, so you get not only empty interface, but it becomes the only way to do certain things because of the lack of generics.<p>Speaking of generics, every popular multi-use language winds up building in generics or tacking them on later. Go&#x27;s creators denounce all other solutions as lacking.<p>What makes them think they are so incredibly special that they don&#x27;t need to learn from the experience of others? It seems to me that the only reasons are basically ignorance or arrogance and I don&#x27;t think they are ignorant.<p>&gt; So why haven’t aren’t those languages commonly used?<p>Languages don&#x27;t generally survive without a big corporation paying the bills. If Google had chosen to put their hundreds of millions into SML instead of golang, the world would be a very different place. The first company to give such a language a chance was Mozilla with Rust and we can see how popular it has become. You could view Rust as SML with c-like syntax, lifetimes, unsafe options, no GC, extra pointer complexity, macros, etc. A bit more potential power at the cost of orders of magnitude more complexity due to being targeted at a different, lower-level problem set.<p>&gt; Just to get your argument straight: nothing comes close to the level of utility and usability of StandardML, Ocaml and Haskell?<p>I would argue that SML is the best of those three languages and the most comparable to go as well. It&#x27;s designed to be pragmatic, easy for first-year students to learn, and easy for later students to implement in compiler classes.<p>Go&#x27;s headline feature (goroutines aka channels) have been implemented in PolyML or CML a decade or two before go existed and they did it in a type safe manner. Go has multi-value returns, but all that means is that it has partial tuple support unlike SML which has both tuples and pattern matching. Despite what you might think you know from Haskell, SML allows mutation complete with safe (and type safe) pointers.<p>Rather than interfaces, SML has structural typing which allows most of the same features, but with type safety and generics. There&#x27;s also sum types (basically union types) which are easy to use with pattern matching and guarantee that all union types are handled safely. Unlike go with nulls everywhere that must be checked at your own peril, SML uses option types and nothing is ever null.<p>All of that said, I don&#x27;t hate go. I believe the language could keep its existing syntax while adding most if not all of these features and retaining a decent amount of backward compatibility and making code both more terse <i>and</i> more readable. It could solve its generics issue while also solving its other type problems and potentially picking up extra performance on the way.')