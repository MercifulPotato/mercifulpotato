Item(by='danabramov', descendants=None, kids=[25500217], score=None, time=1608588128, title=None, item_type='comment', url=None, parent=25500056, text='<i>&gt;Webpack and&#x2F;or React must be very aware of what the other is doing here in order to drop the server-only JS from the bundle. Is it even possible to use alternate bundlers with this feature?</i><p>The bundler-specific code is here[1]. As you can see, it&#x27;s not much. We will happily merge PRs and tweak the infrastructure to work with other bundlers. E.g. we&#x27;re already in conversations with Parcel who are also interested. Yes, there is a cost in under-the-hood complexity, but we think you get a pretty high benefit (e.g. automatic code splitting), so we think it is worth that integration. Just like we take many other things bundlers do that we now take for granted.<p><i>&gt;The React server has to be deeply concerned with the application logic to know how to transparently pass state back and forth, presumably via some generated JSON endpoints. I guess maybe this was already the case for hybrid client&#x2F;server apps.</i><p>Not quite sure what you mean by this, but you be the judge: [2]. There is no &quot;state&quot; being passed. Server Components are completely stateless. (But they can render Client Components, which are normal React components on the client and have the lifecycle you&#x27;re familiar with.)<p><i>&gt;What&#x27;s the lifetime of &quot;persisted server-component state&quot;? A component lifecycle? A page reload? A user session?</i><p>Server Components are <i>not</i> stateful. They follow a request-response model, just like traditional server pages. The novel part is that we&#x27;re able to merge the result into the client tree (instead of .innerHTML = newHTML with old school partial templates, which destroys client state).<p><i>&gt;How did they make an asynchronous call synchronous? JS doesn&#x27;t normally allow that outside of an async&#x2F;await context. Did they wrap the JSON response object in some kind of lazy proxy or something?</i><p>We will be posting a separate RFC in the coming weeks&#x2F;months that dives into details. But the high-level answer is that we want to model it as a cache that you read synchronously. (So if the answer isn&#x27;t synchronously available, we throw and retry later.) Async&#x2F;await adds unnecessary overhead when content is already available synchronously, and especially on the server we&#x27;ll expect many synchronous cache hits because some data has already been accessed from a parent component. Think of DataLoader-like abstractions.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react&#x2F;blob&#x2F;6cbb9394d1474e3a728b49dc7f3a11d61a421ce3&#x2F;packages&#x2F;react-server-dom-webpack&#x2F;src&#x2F;ReactFlightClientWebpackBundlerConfig.js" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react&#x2F;blob&#x2F;6cbb9394d1474e3a728b4...</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;reactjs&#x2F;server-components-demo&#x2F;blob&#x2F;a8d5c72c995fb6d0f97eba9c8c1801d9fb78142a&#x2F;server&#x2F;api.server.js#L69-L94" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;reactjs&#x2F;server-components-demo&#x2F;blob&#x2F;a8d5c...</a>')