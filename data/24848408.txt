Item(by='dvdkhlng', descendants=None, kids=[24848823], score=None, time=1603291728, title=None, item_type='comment', url=None, parent=24845112, text='When I think about C++ &quot;smart&quot; pointers, I often think about easy to provoke &#x2F; difficult to spot fatal edge cases.  E.g.<p>- C++ code where some method calls std::shared_from_this(), and that method ends up being called indirectly during the object&#x27;s construction, leading to a 0-pointer dereference [1]<p>- accidentally creating two shared-pointers to the same object leading to an eventual double-free (that may just silently corrupt the heap while the program continues running)<p>- undetectable cyclic shared_ptr&lt;&gt; references somewhere deeply hidden in the code causing a memory leak<p>Modern C++ feels like a case of &quot;but we can do that in C++, too&quot; syndrome.  Stuff that &quot;just works&quot; in Java or Lisp, can now be done in C++, too, however in C++ it will only work for 95% of all use cases, and break in a spectacular manner for the remaining 5%.<p>E.g. think about the template meta-programming madness (and efficiency WRT compile-time) and compare that with what Lisp offers (see also [2]).<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;31924396&#x2F;why-shared-from-this-cant-be-used-in-constructor-from-technical-" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;31924396&#x2F;why-shared-from...</a>\nstandpoint<p>[2] <a href="http:&#x2F;&#x2F;people.cs.uchicago.edu&#x2F;~jacobm&#x2F;pubs&#x2F;templates.html" rel="nofollow">http:&#x2F;&#x2F;people.cs.uchicago.edu&#x2F;~jacobm&#x2F;pubs&#x2F;templates.html</a>')