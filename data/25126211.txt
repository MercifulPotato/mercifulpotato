Item(by='StillBored', descendants=None, kids=None, score=None, time=1605632882, title=None, item_type='comment', url=None, parent=25125240, text='It was noted years ago (<a href="https:&#x2F;&#x2F;www.hpl.hp.com&#x2F;techreports&#x2F;1999&#x2F;HPL-1999-78.html" rel="nofollow">https:&#x2F;&#x2F;www.hpl.hp.com&#x2F;techreports&#x2F;1999&#x2F;HPL-1999-78.html</a>) that dynamic runtime optimization could speed up native programs (aka x86 on x86, or in the above case pa-risc on pa-risc).<p>But in the end, the reason we don&#x27;t have similar systems everywhere today is that the vast majority of the benifit has been consumed by modern OoO machines and Profile guided optimization. If your seeing significant x86 speedups in rosetta its likely one of two things are happening.<p>So you could be running very poorly optimized x86 code, or its a system call&#x2F;graphics&#x2F;etc heavy benchmark which is spending the majority of its time in the OS. The latter was a big conversation during the early PPC years when apple was claiming their machines were faster than x86&#x27;s running x86 code because of this one x86 benchmark that ran better on a PPC mac (can&#x27;t remember the name). But it turned out it was mostly an OS benchmark, and 99% of the time it was just measuring native PPC macos performance vs windows95.<p>The former (poorly optimized x86) can happen for a number of reasons, one of the most common is people targeting the base x86-64 instruction set and ignoring avx&#x2F;etc, or just simply unoptimized builds.')