Item(by='KronisLV', descendants=None, kids=[25791798, 25791525], score=None, time=1610720246, title=None, item_type='comment', url=None, parent=25790758, text='That&#x27;s a fair argument to make, however i&#x27;m not sure that i&#x27;m able to entirely agree to this.<p>&gt; While good developers think about each one and try to find a minimal set of them.<p>(tl;dr at the bottom, things up to &quot;In short, &quot; are merely my experience, which is entirely subjective)<p>For example, suppose that i&#x27;m working on a Java project and i want to do some non-trivial operations with the filesystem. In this instance, my options for implementing the functionality would be as follows:<p><pre><code>    1. Attempt to do it myself by using the standard library\n    2. Attempt to find a really specific library that allows me to do what i need\n    3. Attempt to use one of the larger libraries out there, that provide a variety of related functionality, which may or may not be useful\n</code></pre>\nEach of them definitely should be evaluated, but for the most part, i&#x27;ve found the following to be true about these approaches:<p>1. Attempt to do it myself by using the standard library<p><pre><code>    + Will be easily customizable, because no source&#x2F;recompilation will be necessary for an external library (though mostly a problem of the toolchain and approaches to including libraries).\n    + Will result in a small distribution size, since there won&#x27;t be redundant code included.\n    - The code mostly won&#x27;t have good test coverage, since i cannot spare the time because of business&#x2F;bosses needig functionality ASAP. Neither will i be able to address the technical debt that might arise from this solution, or throw out a sub-optimal solution and rewrite it until i get it right. Ideally this wouldn&#x27;t be a problem, but i&#x27;m afraid that this is usually the case.\n    - The documentation will be sub-par, since code itself doesn&#x27;t provide many mechanisms for showing examples on how to use it (as opposed to a Wiki&#x2F;sandbox), even in the case of &quot;self-documenting code&quot;, non-trivial concepts will still require code comments, which will also need to be kept up to date by someone who&#x27;ll need to edit the code. Onboarding will be more difficult, because initially noone will be familiar with the solution.\n    - Time spent creating bespoke solutions will prevent me from implementing other solutions and addressing other concerns with the limited time i have. In addition, bugs could arise, since i&#x27;d miss certain aspects that people who are more proficient in working with IO would notice and address.\n</code></pre>\n2. Attempt to find a really specific library that allows me to do what i need<p><pre><code>    + Will result in a small distribution size, since there won&#x27;t be too much redundant code included.\n    - More often than not, minimal dependencies can result in many of the above problems (especially problematic with documentation, since i wouldn&#x27;t even have had written the code in the first place).\n    - In addition, minimalistic solutions often have relatively few contributors, which can result in them becoming abandoned some time down the road. Maybe not too important for small libraries that can be rewritten, but eventually you&#x27;ll end up with unmaintained dependencies which will need addressing.\n</code></pre>\n3. Attempt to use one of the larger libraries out there, that provide a variety of related functionality, which may or may not be useful<p><pre><code>    + Will usually be actively maintained (for example, https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;commons-io has 70 contributors and 360k users).\n    + Will usually also have reasonable test coverage (the library above has 89%, according to GitHub)\n    + Will usually have a rather good documentation that&#x27;s updated by others (sometimes in the form of a separate website, like https:&#x2F;&#x2F;commons.apache.org&#x2F;proper&#x2F;commons-io&#x2F;)\n    + Can easily be Googled with plenty of common problems (some of which are almost inevitable) addressed. This will also help others, who need to work with said code.\n    + Maintenance and technical debt won&#x27;t need to be addressed in house. Oftentimes it&#x27;ll be as easy as bumping up the version number and running the tests surrounding the integration (if any exist).\n    - Will probably include lots of bloat, which may or may not have a significant impact on the bundle size of your project.\n    - Will most likely increase the attack surface of your project in some way.\n    - Will also be difficult to audit and really get to know in entirety (if not impossible).\n</code></pre>\nIn short, i don&#x27;t think that how &quot;minimal&quot; dependencies are should be the deciding factor when choosing them, but rather the results of deliberation of the points that you&#x27;ve described above. In my experience, i&#x27;ve found that more often than not, counting on existing and popular frameworks&#x2F;libraries&#x2F;approaches is the best way to go. Though this is from the perspective of someone creating mostly business oriented solutions for external clients, thus i&#x27;m biased because of time&#x2F;resource limitations and such.<p>There was actually a rather humorous presentation a while back and while the best video i can find of it is still in pretty bad quality: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;AUYPnxv0yss" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;AUYPnxv0yss</a> (couldn&#x27;t find the exact timestamp) one of the things that stuck to me was the suggestion that you should use whatever language&#x2F;tool&#x2F;framework that your friends&#x2F;colleagues use, if possible. Essentially - use boring technology, that will be easy to reason about and that will help you more often than not.')