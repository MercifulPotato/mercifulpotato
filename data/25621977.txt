Item(by='pfalcon', descendants=None, kids=[25622157], score=None, time=1609684490, title=None, item_type='comment', url=None, parent=25620793, text='&gt; It seeks to be as simple as C<p>It seeks too, but fails. Comparing to really-simple C, it&#x27;s full of arcane stuff.<p>&gt; Zig rejects any kind of implicitness; all calls must appear as calls.<p>We already have that in C.<p>&gt; Of course, that illusion breaks as soon as you try to change code<p>That&#x27;s one of the traits of Zig too it seems. My favorite example of Zig&#x27;s poor design is following case:<p>Suppose you have a function call:<p><pre><code>    collectNoInline(gc);\n</code></pre>\nAnd you want to annotate it for being never-inlined (call-site level annotation for &quot;always inline&quot; and &quot;never inline&quot; is a customary enough task in low-level programming). So, in Zig, annotated call transforms too:<p><pre><code>    @call(.{ .modifier = .never_inline }, collectNoInline, .{gc});\n</code></pre>\nRef: <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;#call" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;#call</a><p>I&#x27;m sorry, but that&#x27;s total nonsense. Shows that not enough good faith went into Zig design. Even in C, that could be syntactically annotated as:<p><pre><code>    &#x2F;*pragma:noinline*&#x2F;\n    collectNoInline(gc);</code></pre>')