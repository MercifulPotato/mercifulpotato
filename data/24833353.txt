Item(by='codygman', descendants=None, kids=None, score=None, time=1603160135, title=None, item_type='comment', url=None, parent=24829811, text='&gt; All the magic will make them feel confused and powerless when they do anything outside of the blessed path.<p>Maybe, but what are the chances they chalk it up to a normal and acceptable learning path?<p>&gt; They can&#x27;t extrapolate that forM_ works for any monad in the future.<p>I think it&#x27;s important people know that, but how much does it matter for IHP&#x27;s intended audience?<p>&gt; Agreed, I wish we all used |&gt; instead of &amp;, but that operator is called &amp; in Haskell. You&#x27;re crippling your users&#x27; ability to read other code-bases in the future<p>I think this is an important point, but I&#x27;m not sure how much it would matter for most.<p>&gt; And that same code would be plenty readable with &amp;, don&#x27;t you agree?<p>Most would assume &amp; means something with boolean and I bet. I find &amp; readable, but even Haskellers on my team didn&#x27;t really seem to take to it.<p>&gt; There&#x27;s so much more to &quot;building&quot; than the first month of development!<p>People don&#x27;t really value the long term but default I&#x27;ve found. Then once they have committed to something to a degree, they don&#x27;t change from it.<p>If IHP makes it easy enough to get to the point of feeling like one should keep using it rather than starting over...<p>Maybe the extra learning challenge will feel &quot;normal&quot;, worth it, and otherwise motivated.<p>&gt; Haskell is an order of magnitude more productive for me than other languages (ruby), because of its differences.<p>I can relate to this, but coming from Python. Others who aren&#x27;t sold on Haskell by it&#x27;s usually toured virtues are probably likely to be sold by getting someone spun up to hack away on more quickly.<p>I find making a lot of these arguments kind of funny since I typically find myself arguing from your position :)')