Item(by='rayiner', descendants=None, kids=None, score=None, time=1606848972, title=None, item_type='comment', url=None, parent=25262899, text='&gt; Superscalar vs super-pipelining isn&#x27;t new. If there&#x27;s no magic, then a third wider would likely exactly decrease the boost clock by a third with perfect code.<p>It&#x27;s not new, but it&#x27;s surprising. You&#x27;re correct that going a third wider at the cost of a third of clockspeed is a wash with &quot;perfect code&quot; but the experience of the last 10-20 years is that most code is far from perfect: <a href="https:&#x2F;&#x2F;www.realworldtech.com&#x2F;shrinking-cpu&#x2F;2&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.realworldtech.com&#x2F;shrinking-cpu&#x2F;2&#x2F;</a><p>&gt; The first sign that the party was over was diminishing returns from wider and wider superscalar designs. As CPUs went from being capable of executing 1, to 2, to 4, to even 6 instructions per cycle, the percentage of cycles during which they actually hit their full potential was dropping rapidly as both a function of increasing width and increasing clock rate. Execution efficiency (actual instruction execution rate divided by peak execution rate) dropped with increasing superscalar issue width because the amount of instruction level parallelism (ILP) in most programs is limited.... The ILP barrier is a major reason that high end x86 MPUs went from fully pipelined scalar designs to 2-way superscalar in three years and then to 3-way superscalar in another 3 years, but have been stuck at 3-way issue superscalar for the last nine years.<p>Theoretical studies have shown that higher ILP is attainable (<a href="http:&#x2F;&#x2F;www.cse.uaa.alaska.edu&#x2F;~afkjm&#x2F;cs448&#x2F;handouts&#x2F;ILP-limitations.pdf" rel="nofollow">http:&#x2F;&#x2F;www.cse.uaa.alaska.edu&#x2F;~afkjm&#x2F;cs448&#x2F;handouts&#x2F;ILP-limi...</a>) but the M1 suggests some really notable advances in being able to actually extract higher ILP in real-world code.<p>I agree there&#x27;s probably no real x86-related limitation to going wider, if you&#x27;ve got a micro-op cache. As noted in the study referenced above, I suspect its the result of very good branch prediction, memory disambiguation, and an extremely deep reorder window. Each of those is an engineering feat. Designing a CPU that extracts 80% more ILP than Zen 3 in branch-heavy integer benchmarks like SPEC GCC is a <i>major</i> engineering feat.')