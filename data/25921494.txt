Item(by='AshamedCaptain', descendants=None, kids=[25921767], score=None, time=1611697993, title=None, item_type='comment', url=None, parent=25920096, text='&gt; For every seeing-programmer I have ever met, and I suspect strongly all seeing-programmers, that length is measured in &quot;source-code pixels&quot;. Not lines, or characters, but literal field of view.<p>By the same logic: font size affects number of bugs.<p>I still doubt it. First, the size of the mental model is definitely not related to physical source code length, but rather an abstract, hard to define &quot;operation&quot; concept. Therefore &quot;hello world&quot; is the same size, no matter how large your font size is nor how much whitespace there is between the prologue and the first statement&#x2F;expression.<p>In fact, I would even argue, one&#x27;s mental abstraction is farther from the actual on-screen code the more abbreviated your code is. If it reads like this:<p><pre><code>     MC(AV(z),AV(w),m*k);                 &#x2F;* copy old contents      *&#x2F;\n     if(b){ra(z); fa(w);}                 &#x2F;* 1=b iff w is permanent *&#x2F;\n     *AS(z)=m1=AM(z)&#x2F;k; AN(z)=m1*c;       &#x2F;* &quot;optimal&quot; use of space *&#x2F;\n</code></pre>\nIt doesn&#x27;t matter how much space it occupies on screen. The simple mapping of names to identities is going to fill the entirety of your working memory. And I wouldn&#x27;t believe you can &quot;learn&quot; this mapping. Our memory works in terms of concepts, not letters; the reason a 7 word passphrase is almost as easy to remember as a 7 character password. The identifiers here do not follow any discernible pattern (sometimes it&#x27;s memset, other times it&#x27;s MC instead of memcpy), and I would really doubt any structure can be followed at two chars per identifier. People already have problems remembering the much shorter and much more descriptive set of POSIX system calls.<p>&gt; Sometimes you can read a program, and sometimes you can&#x27;t, but when you can&#x27;t, the damage that scrolling does seems infinitely worse.<p>I&#x27;ve worked for companies that used to remote into old X11 servers for viewing the code. Latency was measured in seconds. Impact of scrolling would have been huge. It was definitely not the biggest impact to productivity. In my experience, branchy code flow was still the biggest hinder.<p>&gt; Yes, and usually by a factor of a thousand or more.<p>This would imply a &quot;power law&quot; of code reuse, where the code  you are likely to need is closer to the point where you need it. The only way I would believe such a rule is, precisely, if your code base doesn&#x27;t reuse any code at all and people just copy code &quot;close to point of use&quot; due to some arcane coding style.<p>My impression: I&#x27;m assuming people are cargo culting here.')