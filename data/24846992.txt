Item(by='murgindrag', descendants=None, kids=None, score=None, time=1603282389, title=None, item_type='comment', url=None, parent=24846270, text='ORMs completely fail for many complex domains. If your data represents an arbitrary tree hierarchy, a graph, or otherwise, relational databases have nice data architectures, but those completely misalign with how ORMs handle data.<p>You don&#x27;t even need to go that complex. Even moderately complex JOINs start to look better in SQL than in ORMs.<p>If you have an employees database, an inventory database, and a clients database, an ORM is perfect. If you have a fixed hierarchy, ORM works great too. It maps objects to the database. That&#x27;s 90% of web apps.<p>If you&#x27;re building e.g. an online CAD system with a complex data model for storing hierarchical layers of objects with complex relations, and where you need to perform complex operations on that data for e.g. simulations and optimizations, SQL will actually handle that just fine. You&#x27;ll just be doing SQL beyond what fits into an ORM. At that point, if you use an ORM, you&#x27;ll be doing complex contortions. Think back to your data structures class. Then to the grad-level data structures class. Most of those structures, SQL will handle fine, but ORMs won&#x27;t.<p>SQL has also turned out to be surprisingly resilient to different programming paradigms. SQL came out just around a half-century ago, before OO was common, and did fine with OO, functional, structured, and a whole range of other paradigms which have moved into and out of vogue over that time. ORMs, as the name implies, are specific to OO.<p>A few posts up, the poster is correct that there are design patterns around ORMs which work well, and design patterns around SQL which work well. You want to pick one and stick to it. The mess comes in when you mix layers of abstractions. One or two SQL procedures might not kill you, but when you have big chunks of code using ORM and big chunks NOT using ORM, you&#x27;ll crash-and-burn.<p>Footnote: &quot;Complex domains&quot; is also about the database layer, and the type of complexity. Right now, I&#x27;m working on a very algorithmically complex system, but that complexity isn&#x27;t in the data layer. Most of the data engineering is about moving GB of data around in realtime. All the database needs to handle are simple things like auth&#x2F;auth. That&#x27;s an ideal use-case for an ORM. I&#x27;ve also built systems with ORMs where the database layer was complex, but complex in ways which aligned well with ORMs. So this shouldn&#x27;t be read as &quot;dumb programmers who can&#x27;t handle functional use ORMS.&quot;<p>Footnote to posterity: Should someone stumble upon this in a web search: If you grew up in OO and Java, and never ventured beyond, none of the above will make sense to you. You only learned the programming paradigm ORMs were designed for.')