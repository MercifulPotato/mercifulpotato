Item(by='aardvark179', descendants=None, kids=[24947797], score=None, time=1604096802, title=None, item_type='comment', url=None, parent=24946029, text='In Loom we can make some trade offs around our knowledge of the Java stack and the standard library.<p>1. We know that no JVM frame contains a raw pointer to anywhere else in the stack.<p>2. We know which stack frames are JVM frames, and which are native frames.<p>3. We know that there are unlikely to be native frames in the portion of the stack between the point where we yield control and the point we want to yield to.<p>4. We can change the standard library to check if we are in our new lightweight thread or not and act appropriately.<p>Knowing these we can avoid function coloring and push the complex management of green threads into the standard library, and reuse existing task scheduler code to manage these virtual threads, and we can work to make thread local variables etc work seamlessly with this new concurrency abstraction.<p>This puts us in a very different design space. We can move a portion of the stack to the heap when a thread is unmounted, and we can change things about the GC and other internal systems to make them aware of this new thing that can be in the heap.<p>This type of approach would be much harder in a language like swift that tends to coexist with C and other languages that use raw pointers or a non-moving GC, so I think the question is not which is the better approach but which is the better approach within your language ecosystem.')