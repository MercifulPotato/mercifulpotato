Item(by='MaxBarraclough', descendants=None, kids=[25792105], score=None, time=1610722496, title=None, item_type='comment', url=None, parent=25790585, text='&gt; Terminals of 2020 and beyond need to have first-class support for audio, video, images, and peripheral interactivity&#x2F;customization.<p>This shouldn&#x27;t be supported in a first-class way, it should be supported as an extension where applicable, in keeping with Unix principles. We already have this with X11.<p>&gt; It should be possible to `cat` an image, or a video, or even previews of Word and Photoshop documents<p>Again this can be done with X11 if you want it.<p>&gt; Programs should be able to raise notifications without relying on third-party&#x2F;OS-provided utils that have a drastically different API and availability across platforms.<p>Interesting idea, perhaps this could be done with a metacharacter, akin to the &#x27;bell&#x27; character, or perhaps even overloading the bell character. There could be a convention along the lines of <i>BELL BELL your message here BELL BELL</i>.<p>&gt; Rich read-only visualisations of progress should be possible to call up with a few lines of code. I want to see a `dd`, `mv` or `cp` with a graphical progress bar at the bottom of my window.<p>wget and curl indicate progress in this way. I&#x27;m sure there are programs out there that would give you this.<p>&gt; We should be able to render a piece of output in 3D, if we so desire. I don&#x27;t want Crysis, but I do want a Matlab logo that I can rotate by dragging my mouse and graphs that zoom when I Ctrl+scroll at them.<p>Again we have X11 for this. It&#x27;s not easily done, which is why we have drama like Wayland which lacks network transparency. [0]<p>&gt; Support for file pickers and rich selection&#x2F;filtering of file&#x2F;directory lists. Not for sandboxing, but for convenience.<p>A file-picker could be implemented as a TUI, which is roughly what Midnight Commander gives you. Perhaps a Unix shell could support mouse-clicks for selection from its auto-completion listings. I think that would be possible, perhaps it&#x27;s already been done.<p>&gt; A command line builder (like one of the classic Apple OSes had, cannot find a reference now, or something like the one in Fish but more advanced). Only valid combinations of parameters will be supported, mutually exclusive commands are impossible to select.<p>I agree it would be great to have a system like this, akin to type safety. Perhaps applications could distribute something akin to a regex to describe their syntax. I imagine something like this is already implemented for auto-completion purposes (e.g. how Bash can auto-complete git&#x27;s verbs).<p>&gt; Terminals should be able to intake gigabytes of input per second, up to the limit of the hardware, without choking up.<p>I don&#x27;t know quite what you have in mind here but you can already do this in the way that matters. You can easily run a Unix command to tarball a local directory, then compress it, send it over SSH to a remote server, and have that remote server decompress the stream and then unpack the tarball, all &#x27;on the fly&#x27; without ever saving the intermediate streams into persistent files. This all works very well in Unix, giving you a lot of flexibility&#x2F;power and good performance too. (Doubtless the flow I described would be slightly faster if a dedicated application were used instead, but Unix pipes are pretty fast).<p>&gt; We should be seeing 60FPS and beyond as a normal feature.<p>Which command-line applications would benefit from 60fps? Better TUIs would be nice but I don&#x27;t think the frame-rates are the issue there.<p>&gt; We should finally get unlimited scrollback enabled by default<p>You can probably enable that if you want it.<p>&gt; We have the space for it, either in RAM or persistent storage<p>Not if you accidentally stream &#x2F;dev&#x2F;random.<p>&gt; If not, it should be adaptable and drop the scrollback buffer that is lower priority than other applications on the system if they need more resources.<p>This approach would have the downside of being less predictable than the current one.<p>&gt; Unicode should come as standard. Emoji should come as standard.<p>Sure. I think Unicode support is pretty good though, I believe it&#x27;s used in many TUIs.<p>&gt; End termcap. We should be able to hash out ONE standard to rule them all.<p>I imagine this is one of those things where there will always be a few legacy systems that still need to be supported.<p>&gt; end Bash<p>I agree that Bash has many unfortunate quirks that are annoying at best and are outright dangerous footguns at worst, especially when it&#x27;s used for scripting. The only advantage of writing a traditional Unix script, as opposed to say a Python script, is portability. <i>configure</i> scripts, for example, run on just about any Unix, with no dependencies.<p>&gt; consider adding hypertext support. It&#x27;s here to stay, and not just in the form of HTML<p>Not a bad idea, perhaps this too could be done with metacharacters.<p>[0] <a href="https:&#x2F;&#x2F;wayland.freedesktop.org&#x2F;faq.html#heading_toc_j_8" rel="nofollow">https:&#x2F;&#x2F;wayland.freedesktop.org&#x2F;faq.html#heading_toc_j_8</a>')