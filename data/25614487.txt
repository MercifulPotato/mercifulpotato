Item(by='mfateev', descendants=None, kids=[25614857], score=None, time=1609608945, title=None, item_type='comment', url=None, parent=25607244, text='I&#x27;m one of the original creators of temporal.io open source project.<p>Long time ago I worked with an internal Amazon workflow engine that was based on Petri nets. It worked, but I learned that for the majority of the business level workflows it was too low level. It was always a hassle to map a real use case to it.<p>The AWS Simple Workflow service was created as a replacement of that engine. It greatly elevated the lel of abstraction. The Azure Durable Functions, Uber Cadence, and our latest project temporal.io are all use this new way to represent workflows. The basic idea is to not implement the business logic using an intermediate representation. Instead rely on runtime to make any code state fully fault tolerant. Imagine that the full orchestrating program state (including threads, local variables and even blocking calls) is preserved across any process and other infrastructure failures. This allows to write production code like this:<p><pre><code>      boolean trialPeriod = true;\n      while (true) {\n        Workflow.sleep(Duration.ofDays(30));\n        activities.chargeMonthlyFee(customerId);\n        if (trialPeriod) {\n          activities.sendEndOfTrialEmail(customerId);\n          trialPeriod = false;\n        } else {\n          activities.sendMonthlyChargeEmail(customerId);\n        }\n      }\n</code></pre>\nAs the state is fault tolerant the 30 day sleep is absolutely OK. And if any of this operations takes long time (for example because a downstream service is down for a day) the code doesn&#x27;t need to change. I bet that any Petri nets based version of the above code would be much more complicated. One of the reasons that large part of the complexity of the business level workflows is not in sequencing of actions (which Petri nets solve), but in state management and argument passing (which Petri nets don&#x27;t solve at all).')