Item(by='patrec', descendants=None, kids=[25674361], score=None, time=1610039004, title=None, item_type='comment', url=None, parent=25672218, text='Ugh o&#x2F;c sorry, my bad, I should just have done it in slime to start with (esp since I&#x27;ve compared it ipython); was just too lazy:<p><pre><code>    The value\n      NIL\n    is not of type\n      (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING PATHNAME\n          SYNONYM-STREAM FILE-STREAM)\n    \n    when binding PATHNAME\n       [Condition of type TYPE-ERROR]\n    \n    Restarts:\n     0: [RETRY] Retry SLY mREPL evaluation request.\n     1: [*ABORT] Return to SLY&#x27;s top level.\n     2: [ABORT] abort thread (#&lt;THREAD &quot;sly-channel-1-mrepl-remote-1&quot; RUNNING {1004894CD3}&gt;)\n    \n    Backtrace:\n     0: (MERGE-PATHNAMES NIL 69988797066848 MERGE-PATHNAMES) [external]\n     1: (SB-INT:SIMPLE-EVAL-IN-LEXENV (MERGE-PATHNAMES NIL) #&lt;NULL-LEXENV&gt;)\n     2: (EVAL (MERGE-PATHNAMES NIL))\n     3: ((LAMBDA NIL :IN SLYNK-MREPL::MREPL-EVAL-1))\n     --more--\n</code></pre>\nThis is nicer than &quot;raw&quot; sbcl but I still have trouble seeing how anyone could prefer looking at common lisp backtraces (with the caveat that I only have used open source lisp implementations; I have no idea what allegro or lispworks are like).<p>However, as I wrote common lisp is much nicer in some other respects (as you undoubtedly know). For a few other toy examples let&#x27;s say I do:<p><pre><code>    (&#x2F; 1 (random 2))\n</code></pre>\nThis will cause DIVISION-BY-ZERO 50% of the time. But if that happens one of the possible restarts (also seen above) is just try the same thing again.  I can try as many times as necessary to get (&#x2F; 1 1). Of course this is a silly example, but realistic cases are not hard to come up: you forgot to copy a file to the right place or the disk is full and you need to make some space before retrying. Or you have a transient network failure etc. Similarly<p><pre><code>    (mapcar #&#x27;sine &#x27;(1 2 3))\n</code></pre>\nThe function sine does not exists, but one of the possible restarts allows me to supply something else instead:<p><pre><code>    The function COMMON-LISP-USER::SINE is undefined.\n       [Condition of type UNDEFINED-FUNCTION]\n\n    Restarts:\n     0: [CONTINUE] Retry using SINE.\n     1: [USE-VALUE] Use specified function\n    [...]\n</code></pre>\nIf I press 1 and then provide #&#x27;sin I&#x27;ll get (0.84147096 0.9092974 0.14112). But the more fun thing to do is to just implement the missing function there and then. Whilst the debugger window stays active, I can just write my &quot;sine&quot; function in the editor or repl and then retry, e.g. writing (defun sine (x) (sin x)) will give the same result.<p>This is pretty cool, because it means you can start writing some topdown code start running it an incrementally fill in the missing functions you are calling bad haven&#x27;t yet defined without ever losing your state.')