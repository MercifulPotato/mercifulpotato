Item(by='ddragon', descendants=None, kids=None, score=None, time=1602447366, title=None, item_type='comment', url=None, parent=24747221, text='Not sure what you mean about being a turn-off to engineers. I&#x27;m an electronic engineer currently working on production data engineering pipelines (which has no relation to the engineering in my degree) and I quite like the language. 1-based index is such a small &quot;problem&quot; compared to actual problems you encounter when developing software that is not even worth commenting in this context.<p>I work on a polyglot company, and parts of the pipeline have different demands. For low latency and fast development speed we use Elixir, for high throughput we use Scala, for data analytics in batch jobs we use Python. As I see, Julia is a language that is more concise and faster than Python for the number crunching I do, and has the potential to  match Scala&#x27;s throughput all while having multithreading&#x2F;distributed that could rival the erlang VM (not in latency, but in speed and easy to use) and Scala&#x27;s Akka eventually.<p>So as an engineer I&#x27;m excited about the potential (a single language that you can develop as fast as python that could compete with some of the top tiers in different areas of data engineering), even if it&#x27;s not yet. It needs to complete the multithreading (structured parallelism so you can safely monitor and restart threads to help with reliability and with no risk of leaking, and have some library that works at the level of abstraction as the OTP&#x2F;Akka), it needs native support for the infra-structure (Kafka, Prometheus) and a solid support for the web (and both of those last two can be done right now with Julia 1.5). For now it&#x27;s an amazing language for exploratory data analysis and research, but I can&#x27;t wait for the moment that I can safely recommend as the backend of my company&#x27;s data infra-structure.')