Item(by='Twisol', descendants=None, kids=None, score=None, time=1607684173, title=None, item_type='comment', url=None, parent=25384201, text='Even in Java, I&#x27;m rather sick of passing around types with `&lt;X, Y, ?, ?&gt;` with two honest-to-goodness generic types and two actually-chosen-by-the-implementation generic types. There&#x27;s no good way in Java to hide those visible wildcards without making a wrapper class that only exposes the meaningful ones.<p>Associated types make the distinction far clearer. They better capture the qualitative distinction that &quot;you can choose these, I get to choose those&quot;.<p>Also, associated types are inherently &quot;functionally dependent&quot; in the sense of Haskell&#x27;s multi-parameter type classes. If you have a trait `F&lt;X, Y&gt;` with an associated type Z, you <i>know</i> that given X and Y, Z is fixed. Without associated types, `F&lt;X, Y, Z&gt;` could have multiple legal implementations for the same X, Y and different Z.<p>This is extremely meaningful in languages like Haskell and Rust which implicitly thread around the trait methods. Typeclasses in Haskell can be imagined as describing concrete dictionaries of functions over the given types. Languages like Java (manually) and Scala (automatically, using &quot;implicit&quot;) reify these typeclasses as dictionaries that are threaded through functions as extra parameters. You can often define multiple implementations of a given trait for the same types, and you get to choose which implementation to pass along.<p>Rust and Haskell assert that traits have a single implementation for a given batch of types, and they automatically look up the correct implementation given the types you&#x27;ve specified. These &quot;functional dependencies&quot; mean that, in my example of `F&lt;X, Y&gt;` with associated type Z, it&#x27;s sufficient to state what X and Y are to find the right implementation of F -- Z doesn&#x27;t contribute to the lookup. If you don&#x27;t have associated types, you could have multiple implementations that simply vary on Z, so you have to tell the compiler explicitly which one to use (by stating what Z is).')