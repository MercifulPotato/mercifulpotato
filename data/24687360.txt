Item(by='chinigo', descendants=None, kids=None, score=None, time=1601902942, title=None, item_type='comment', url=None, parent=24686794, text='I don&#x27;t &quot;enforce&quot; this but I do aim for it, and yes, I do partial squashing throughout my workday.<p>As I work on a feature branch, I&#x27;ll check in WIP commits as checkpoints, especially at EOD. I don&#x27;t expect these to pass the full CI suite.<p>But as the code starts to shape up, I&#x27;ll unstage all those WIPs and start to group the changes into logical commits. As work progresses, I&#x27;ll use `git add --patch` to split new lines of code into those existing logical commits. Sometimes I&#x27;ll split one up, sometimes I&#x27;ll group two together; it&#x27;s still flexible and amorphous at this point.<p>By the time I&#x27;m ready to merge upstream, these commits tend to be neat, focused, and functional, and I <i>do</i> check to make sure they pass the relevant tests (though I don&#x27;t enforce a full CI build here).<p>Then a rebase from master, push to CI, and then a no-ff merge commit into master to retain both the low-level commits and the ability to easily revert the whole lot.<p>It might seem like a ton of busywork, but I find that staging atomic commits like this doubles as an <i>excellent</i> line-by-line review of the code I&#x27;ve written. It also forces that review step to happen <i>throughout</i> the process rather than all the way at the end when I&#x27;ve forgotten all that deep context.')