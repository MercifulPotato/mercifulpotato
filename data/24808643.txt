Item(by='cb321', descendants=None, kids=[24809220], score=None, time=1602925484, title=None, item_type='comment', url=None, parent=24807758, text='I agree that sheer package count is a weak metric especially for very hyped up &quot;can I put it on my resume&quot; prog.langs, and in the context of &quot;maturity&quot; (as opposed to &quot;popularity&quot;).  I also agree that programmer attrition rate (or its complement retention rate) are a bit better.<p>While I cannot speak to Rust&#x27;s packages, as part of testing a new Nim package manager against the published ecosystem, I happened to just a week or three ago be surveying the freshness of Nim&#x27;s ecosystem.  About 80% of those 1400 Nim packages have been updated in the past 2 years.  By last git update, 50% have not changed since 2019&#x2F;October and 30% have not had a commit since 2018&#x2F;November.  50..80% fresh (with apologies to Rotten Tomatoes!) is much higher than I would have guessed naively.  I am not sure even Python would score so highly.  I realize these above numbers are but a start down a more real analytical road.  Maybe someone could measure Rust in this way.<p>In terms of package quality, the one time I re-wrote something that existed in Rust in Nim, my Nim version ran like 10x faster than Rust.  That was a couple years ago (<a href="https:&#x2F;&#x2F;github.com&#x2F;c-blake&#x2F;suggest" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;c-blake&#x2F;suggest</a> if anyone cares) and is just one data point.  I do think Rust unfairly enjoys a presumption of performance when almost any language has ways to make code run fast.  Less ambitious or knowledgeable programmers can always make things slow, but they also seem biased against picking up Rust.  So, there is also a sample selection bias, but this has probably all been said before.')