Item(by='dgentile', descendants=None, kids=[25222619], score=None, time=1606412165, title=None, item_type='comment', url=None, parent=25220139, text='The problem is that fundamentally we always have types. We must define different types of bytes and the different things we can do with those bytes. If you can generate a binary from your programming language, it must use a form of static or inferred typing to know what assembly code to generate. A dynamic language just checks at runtime, and adds a bunch of overhead, which isn&#x27;t always necessary, and is more likely to result in weird &quot;defined&quot; behavior like we get from javascript and php. Typescript is very popular because you can make certain guarantees at compile time, instead of a vague hand-wave of &quot;the code looks good&quot;.<p>As an example of the benefits of type-checking, in the Vulkan api, there are a lot of handles. VkRenderPass, VkPipeline, VkSwapchain, VkDevice, etc. All of these are just pointers. If we take a function like:<p><pre><code>    void vkDestroyCommandPool(VkDevice,VkCommandPool,const VkAllocationCallbacks*);`\n</code></pre>\nAnd remove the type checking:<p><pre><code>    void vkDestroyCommandPool(void*,void*,const void*);\n</code></pre>\nIt is the same API, but without type-checking. Even if the parameters are labelled, with this new API I could mess up and pass the wrong thing.')