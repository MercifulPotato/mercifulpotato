Item(by='Fire-Dragon-DoL', descendants=None, kids=None, score=None, time=1606189732, title=None, item_type='comment', url=None, parent=25187310, text='Yes, I was highlighting my view.\nTo respond to the advantages mentioned:<p>- Roda (or Sinatra) gives routing. Actually it&#x27;s very advanced routing that can be composed<p>- JSON serialization can be achieved more easily with Hash + Array and a subset of basic types (boolean, numeric, string, nil), which are easier to generate than with jbuilder, and it&#x27;s also more performant. That being said, nothing stops developers from using tilt-jbuilder (gem) to get immediate support from Tilt for jbuilder, which can be used from Sinatra and Roda seamlessly, and can also be called everywhere, not just views<p>- Roda has built-in security too (I don&#x27;t know about Sinatra, but I presume it does), there is a section in the README: <a href="https:&#x2F;&#x2F;github.com&#x2F;jeremyevans&#x2F;roda#security-" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;jeremyevans&#x2F;roda#security-</a> as well as multiple plugins <a href="http:&#x2F;&#x2F;roda.jeremyevans.net&#x2F;documentation.html#external" rel="nofollow">http:&#x2F;&#x2F;roda.jeremyevans.net&#x2F;documentation.html#external</a><p>- Rails testing is actually _harder_ than normal Ruby testing. On top of my mind, a glaring example of this is the impossibility to instantiate a Controller and do dependency injection on them, which should be normal for any object. This is not a problem if dealing with just Ruby. Rack-test gives the same &quot;request specs&quot; that are present in Rails (actually it&#x27;s built on top of that). As usual, the option of choosing different testing frameworks is available, given that it&#x27;s normal Ruby. There isn&#x27;t a need for special testing framework integration, so it&#x27;s possible to use the beautiful Test Bench: <a href="http:&#x2F;&#x2F;test-bench.software&#x2F;" rel="nofollow">http:&#x2F;&#x2F;test-bench.software&#x2F;</a><p>- Devise is actually a bad choice for Rails API. It&#x27;s poorly documented when used in API fashion (authentication through token), providing a whole set of utilities for sign up that are unneeded for API. However these endpoints do expand the attack surface, reducing security. The performance is also reduced, when authentication can be achieved with Redis instead of an SQL database as backend. The amount code needed for secure and well defined authentication can be written in ~5 hours of production quality code, with extensive testing (I did this quite recently). Either way, `rodauth` is available for every need<p>- Rapid data and logic modeling, presuming I understand what it&#x27;s referring to in this context, it&#x27;s given by ActiveRecord, that gem can be used with anything, there is no necessity to use Rails. This brings data migrations. For logic modeling, that is a Ruby feature, not a Rails one: Rails doesn&#x27;t provide any utility from the logic perspective. In addition, putting logic into ActiveRecord models is very dangerous and known to be a problem by the community<p>- Rails doesn&#x27;t provide metaprogramming, Ruby does. That is available with any Ruby application<p>- Rails does provide the scaffold command, but if the amount of tables that needs to be written is so large that this command is actually providing a benefit over duplicating a file (the activerecord model. ActiveRecord already provides the command for generating migrations wherever it&#x27;s used), then the cost for writing a Rake task that generates a migration and a new file with an empty ActiveRecord model is negligible (1 hour)<p>With Roda I see other advantages:\n- Highly performant webserver (13 times faster than Rails API, 10 times smaller memory footprint: <a href="https:&#x2F;&#x2F;roda.jeremyevans.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;roda.jeremyevans.net&#x2F;</a>)<p>- Incredibly faster application load speed. Restarting the server is not a problem, running the test suite is not a problem either<p>- No autoloader, while preserving the ability to reload code. Now Ruby `load` behaves like the normal Ruby load (not monkey patched). This prevents a gigantic amount of problems reached as soon as the app starts to grow, related to how Rails loads constants: <a href="https:&#x2F;&#x2F;www.honeybadger.io&#x2F;blog&#x2F;avoid-these-traps-when-nesting-ruby-modules&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.honeybadger.io&#x2F;blog&#x2F;avoid-these-traps-when-nesti...</a><p>- Using traditional tools for handling javascript, CSS and public assets, which Frontend developers are familiar with (webpack, parcel)<p>- Very small project, with ~4-5 files the whole setup is ready<p>- A tremendously smaller API surface (API as in &quot;application programming interface&quot;, not HTTP), this greatly helps reducing bug surface and cognitive overload<p>Now if the application&#x27;s need is form-over-data (so, not a JSON API), then sure, use Rails. But in that case you <i>must be using ActiveAdmin</i>, to get real advantages. In that space, there is a large amount of competitors in other languages or no-coding tools that Rails has to face. On top of my mind: Forestadmin, Hasura, PostgREST, Django with Django Admin.')