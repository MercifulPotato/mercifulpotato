Item(by='Silhouette', descendants=None, kids=None, score=None, time=1603303525, title=None, item_type='comment', url=None, parent=24848967, text='That sort of problem is actually relatively easy to solve in itself. In essence, you don&#x27;t record the transactions on each account separately, you record the transfers between them (just as double-entry bookkeeping does). Since any transfer inherently balances, you can&#x27;t be inconsistent in crediting money somewhere without debiting it somewhere else or vice versa. If you want to know what happened to an individual account, you can still construct that information by looking at the relevant sides of all the transfers into or out of that account, but your single source of truth is always the transfer records.<p>Of course, it&#x27;s still not that simple in any realistic system, because maybe you have other important constraints such as ensuring that accounts don&#x27;t go into negative balances. In that case, before you can add any new transfer, you need to calculate the existing balance on the account you&#x27;re taking money from, which means replaying the entire transaction log selecting for that account if you just have the naive schema described above, and then you have to create the new transfer record if and only if the constraint is satisfied. All of this has to be done atomically to make sure you can&#x27;t have multiple transfers being recorded concurrently that would individually be valid but collectively leave an account overdrawn.<p>That takes you into the technicalities of how to process DB transactions with acceptable performance. Hopefully your database will help you if it&#x27;s ACID compliant, but it still can&#x27;t work miracles. For the simple two-sided transfers in this example, you can probably do a lot just using a database&#x27;s built-in transaction support, but for more complicated constraints applied to more complicated schemas, at some point you have to take the practicalities of your database engine into account when designing that schema and deciding what constraints to enforce at this level.')