Item(by='gravypod', descendants=None, kids=None, score=None, time=1606599676, title=None, item_type='comment', url=None, parent=25239827, text='I think there&#x27;s a few advantages of bazel-like systems:<p>1. Reproducible&#x2F;Hermetic: your builds cannot, say, access the network during a step or produce changing binaries for the same input. This makes sure that once you&#x27;ve downloaded your deps locally <i>everything</i> builds correctly from then on.<p>2. Caching: Because everything is reproducible in bazel-likes everything is cachable. Dependencies, builds, and even tests! If you&#x27;ve worked with Makefiles you&#x27;ve likely run `make clean; make tests` or something similar. I&#x27;ve never needed to do `bazel clean` to make sure things were working right.<p>3. Visibility: you don&#x27;t only control who can see what in your source code. Different dependencies can be marked as private&#x2F;protected&#x2F;public to control who can import them. This is a huge boon to large monorepos.<p>4. Everything is uniform: code generation, compilation, etc is all described in &quot;rules&quot; and &quot;toolchains&quot; and can &quot;easily&quot; expanded to other languages. The community manages a Rust and Golang rules set for bazel itself and they&#x27;re <i>better</i> then the Google rule sets for Java (only &quot;officially&quot; supported rule set right now) in some areas.<p>So if you have a lot of code&#x2F;internal libraries&#x2F;code generation, what to write a LOT of unit tests and cache their results, and write code in multiple languages bazel is probably for you.<p>You can also use tools like BuildBuddy [0] to share a cache with your team and extract build performance metrics to identify areas you can improve performance in.<p>[0] - <a href="https:&#x2F;&#x2F;www.buildbuddy.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.buildbuddy.io&#x2F;</a> or <a href="https:&#x2F;&#x2F;github.com&#x2F;buildbuddy-io&#x2F;buildbuddy" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;buildbuddy-io&#x2F;buildbuddy</a>')