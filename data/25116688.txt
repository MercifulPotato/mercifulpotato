Item(by='Twisol', descendants=None, kids=None, score=None, time=1605558965, title=None, item_type='comment', url=None, parent=25116085, text='&gt; Every time I read about it, I keep thinking &quot;there&#x27;s probably a much easier way to explain this&quot; and it&#x27;s frustrating.<p>That&#x27;s my sentiment, too. The descriptions I&#x27;ve seen give primacy to the code-related patterns, like &quot;Aggregate&quot; and &quot;Entity&quot;, but increasingly I think they&#x27;re the <i>result</i> of applying DDD, not the <i>starting point</i>. (And, as oft noted, they arise in a distinctly-flavored OOP context which has fallen somewhat out of favor.)<p>My team has had to pick things up as we go, but we have the benefit(?) of a complex domain, so we worked our way backwards to first principles anyway.<p>The most important part, we&#x27;ve found, is that <i>someone</i> on the team has to be a domain expert, and <i>anyone</i> planning&#x2F;designing&#x2F;architecting features must be an expert at least in the aspects they are working on. The reason is simple, if daunting: software is <i>automation</i>, and we are ultimately automating a domain process that would be undertaken, at least in principle, by a human. If we are to tell a machine what to do, we must understand the process at least as well as the human who would undertake it -- and potentially more so. It simply doesn&#x27;t make sense to have a non-expert team build a supposedly-expert system.<p>(This is of course why &quot;the customer&quot; is such an important part of an Agile team. Sometimes the customer&#x27;s expertise is enough, by proxy, to effectively design a software-based solution. But even then, that expertise gets processed by <i>somebody</i> into software-oriented tasks.)<p>Since our domain is particularly complex, we&#x27;ve found it valuable to distill our knowledge of the domain into a &quot;domain model&quot; document. This makes sure that there&#x27;s a single source of truth for domain understanding on the team, which keeps things from otherwise getting too out-of-sync. It&#x27;s particularly valuable to assign a single editor to that document, to maintain cohesion across the model.<p>The key point about a domain model is that it does <i>not</i> describe a particular software solution, and should not be especially biased toward the needs of software. On the other hand, it <i>should</i> organize the domain in ways that reduce redundancy, capture similarities and differences, etc. Put differently, software engineering is a domain of its own, and we should be able to bring our experience with abstraction and modularity to bear.<p>Whether explicit (documented) or implicit (known by experts), a domain model should illuminate the global structure of the domain. Boundaries between parts of the domain should start to become visible, and the relationships across those boundaries speak to the ownership and flow of information. This is where DDD &quot;bounded contexts&quot; emerge, and where the so-called &quot;ubiquitous language&quot; becomes meaningful.<p>The domain model doesn&#x27;t <i>solve</i> a problem, but it brings it much closer to the software engineering domain, and makes it much more tractable to use prototypes to identify gaps in the model or to try different approaches to automating different domain processes. It should be much easier to get a birds-eye view of how the whole system behaves, even before software enters the picture.')