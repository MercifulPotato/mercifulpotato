Item(by='tomxor', descendants=None, kids=[25090562, 25090081], score=None, time=1605316973, title=None, item_type='comment', url=None, parent=25089312, text='There is a critical bit of regex in between. In short this technique unpacks two ASCII characters from each unicode point of the input string. Any ASCII safe code can be packed with this dweet: <a href="https:&#x2F;&#x2F;www.dwitter.net&#x2F;d&#x2F;11852" rel="nofollow">https:&#x2F;&#x2F;www.dwitter.net&#x2F;d&#x2F;11852</a><p>The escape function [0] converts unicode values &gt; 0xFF into the string format &#x27;%uxxxx`, additionally it will produce two sequences if the unicode point is high enough to require two UTF-16 surrogate pairs. e.g escape() ing the first character &#x27;ð©¡¯&#x27; results in &#x27;%uD866%uDC6F&#x27;. The regex throws away the &#x27;uD8&#x27; parts of each sequence as we aren&#x27;t exploiting the full capacity of the unicode space, just the lower 255 values of each surrogate pair. which results in &#x27;%66%6F&#x27;. Finally this is unescaped which converts these into the separate ASCII chars that were originally packed with dweet 11852 (don&#x27;t ask me how it packs it I haven&#x27;t looked yet.)<p>In all this means it&#x27;s possible to fit 194 <i>evaluable</i> ASCII chars into a dweet (taking into consideration overhead of the unpacking code). There are also more esoteric methods of fitting more characters or data using unicode that are not generally evaluable, e.g image data. All of these techniques are using more than 140 bytes, but dwitter has a character limit not byte limit. But nothing is free, you must fit any decoders into the same dweet so there is always a balance.<p>[0] <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;escape" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a>')