Item(by='comex', descendants=None, kids=[25922132], score=None, time=1611702026, title=None, item_type='comment', url=None, parent=25921671, text='Incidentally, after inspecting doas for a few minutes, I found two near-vulnerability bugs in it.<p>The first bug lets any user cause doas to read out of bounds of an array, though not in a way that&#x27;s exploitable.<p>Well, it&#x27;s arguably a bug in libc.  If you run doas with a completely empty argv (argc = 0, so not even an executable name; the two systems I tried, Linux and macOS, both let you do this), getopt will exit with optind = 1.  Then when doas does;<p><pre><code>    argv += optind;\n    argc -= optind;\n</code></pre>\n`argc` will become <i>negative</i>, and `argv` will advance past the null terminator.  On most OSes, the `argv` array is immediately followed in memory by `environ`, so argv will now point to the list of environment variables.<p>doas will then dereference argv, and generally act as if you tried to execute a command consisting of the environment variables.  However, the environment variables are not secret, and doas doesn&#x27;t behave any differently than if you just passed the environment variables as normal command-line arguments, so this is not exploitable.<p>On an OS where argv is not followed by environ or a similar array of character pointers, doas might crash instead, although since it only reads from those pointers rather than writing to them, this still probably wouldn&#x27;t be exploitable.<p>The second bug would compromise memory safety if things were slightly different.  The bug is in configuration file parsing.  Even if it did compromise memory safety, it would not actually be exploitable, because doas normally only parses the trusted systemwide configuration file.  It can be asked to parse a configuration file passed on the command line, but it drops privileges before doing so.  This is a good example of layered defense, so kudos to doas for that!  Still, I thought the bug was worth mentioning.<p>The bug is a traditional sort of integer overflow.  parse.y grows the array of rules with<p><pre><code>    maxrules *= 2;\n</code></pre>\nbut maxrules is an int, so this will eventually overflow if the configuration file is large enough.<p>However, because maxrules happens to be signed, before doubling produces a smaller-than-expected positive value, it will first produce a negative value.  This will then get sign-extended when converting to size_t (assuming 32-bit int and 64-bit size_t), and reallocarray&#x27;s overflow check will trigger, causing reallocarray to return NULL.  doas interprets that as out-of-memory and handles it cleanly.<p>(On a system where sizeof(int) == sizeof(size_t), things are a bit different, but it will just run out of memory before maxrules gets that high.)<p>Moral of the story?  Well, as I see it:<p>Simplicity and layered defense, both featured in doas, are both effective ways to avoid vulnerabilities.  But guaranteed memory safety, which would require a different implementation language, is <i>also</i> an effective way to avoid vulnerabilities.  You aren&#x27;t forced to pick and choose.  Why not demand all three?')