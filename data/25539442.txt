Item(by='dnautics', descendants=None, kids=None, score=None, time=1608934429, title=None, item_type='comment', url=None, parent=25537916, text='it&#x27;s a linked list of utf codepoints.  It&#x27;s actually a <i>terrible</i> representation for most purposes.  More modern parts of the BEAM (e.g. tcp&#x2F;udp) typically give the option to emit a &quot;binary&quot;, which is a immutable contiguous memory region of bytes, and Elixir, which also runs on the BEAM defaults to using &quot;Strings&quot; (cap S) which are &quot;binary&quot;s, but semantically interpreted to contain UTF-8 encoded utf codepoints.<p>For some things, though lists are REALLY good.  BEAM languages constructs are generally immutable, so if you pass your string (or String), to a function that then changes the contents, it doesn&#x27;t affect the value seen by the original function after it returns.  This is a GOOD thing as it reduces the cognitive burden.<p>Conversely, performance of binaries in this immutability regime can get hairy because as you start concatenating them or editing them you have to make tons of immutable copies of stuff, which is no fun for anyone.  (Literally last month we had a problem in prod because megabytes-sized JSON strings were being copied around after minor appends).<p>The middleground is something that erlang calls an &quot;iolist&quot; which is a (list of (iolist or binaries or utf codepoints)).  Elixir has &quot;iodata&quot; which is (iolist or binary)  This is nice, because you have o(1) append, o(1) prepend, and for long stretches that aren&#x27;t going to change, you can use binaries instead of awkward utf codepoint list structures.')