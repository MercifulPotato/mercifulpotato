Item(by='Hokusai', descendants=None, kids=None, score=None, time=1603244548, title=None, item_type='comment', url=None, parent=24834965, text='&gt; But along with the term of experience goes the breadth. You see, the person who learned reference counting in 1995 and thinks that you can only really understand programming if you manually type out your own reference-changing events, presumably didn’t go on to use garbage collection in Java in 1996.<p>I think that the article misses two points. In one side the more accessible writing code is, the better. To reduce the amount of knowledge and discipline that you need to code is good.<p>On the other side, discipline is still needed to design APIs, or just to maintain consistency between calculations and data as it moves thru your system, or keep technical debt in check.<p>&gt; does that mean our tools should not let us write code for which there’s no test?<p>That depends on how your team&#x2F;company wants to work. If you are doing Test Driven Development, it seems good that the tool forces you to do the test first. But, TDD is not the only or best way of developing software, so generic tools needs to support different paradigms.<p>I love code formarters for all this reasons. They relieve developers of the need to follow some basic code style guidelines, you use less self-discipline on writing good style and more on writing good APIs. But, to have a code formatter you need an agreed standard.<p>I try to make to write code easier for myself and other people, because implementing business requirements is already hard by itself. The more time you have to spend &quot;coding&quot; and the more you can spend thinking, the better.')