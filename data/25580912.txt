Item(by='quietbritishjim', descendants=None, kids=[25582623, 25582105, 25582380], score=None, time=1609329228, title=None, item_type='comment', url=None, parent=25580703, text='It&#x27;s straightforward to use a set type as a mapping type, so long as it provides three things:<p>* Comparisons don&#x27;t have to use all members of the type e.g. if I have two Employee objects then I&#x27;m allowed to create a comparison function that only compares their employee IDs and ignores the name fields (perhaps because the name ought to be derived from employee ID). (I know this article is not about C++, but as a reference point this has always been possible in C++&#x27;s STL.)<p>* Comparisons don&#x27;t need a full-blown instance of the contained type e.g. in our employee example, the set can make use of a comparison function between int and Employee without having to construct an Employee with that ID. (This has been possible in C++ since C++11, and is often called heterogeneous lookup.)<p>* The last point is a bit fiddly: Either the set type allows mutation of the objects so long as the parts relevant to comparison don&#x27;t change, or you only wanted to store const values anyway. I mention this because in C++ if you have a std::set&lt;Foo&gt; then you can&#x27;t mutate the Foo elements at all, even if it has no effect on the comparison of the elements with other elements. (Unless there are const methods that actually mutate it... yuck!)<p>So long as you have those three things, you can have a set of (key, value) pairs where the comparitor only compares keys, and bingo you have a mapping type.')