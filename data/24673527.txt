Item(by='compsciphd', descendants=None, kids=None, score=None, time=1601746896, title=None, item_type='comment', url=None, parent=24662038, text='I agree, I don&#x27;t fault them for taking the easy way, I do think it was wrong though.  I created tools tools for converting debian packages into layers (in my research I stored these layers on a shared file system (either a multi-attach (in practice would need an fs that can have a single writer and multiple readers, which might simplify things) on a san or nfs.<p>But, debian packages aren&#x27;t really made for this directly, as they have their pre&#x2F;post install&#x2F;remove scripts.  My &quot;hack&quot; was to treat every package as an dpkg --unpack version (i.e. not configured) and then at image &quot;build&quot; time (i.e. each image is really a layer that is a manifest of dependent layers + data created at image build time), we would dpkg --configure --pending all the composed layers (with a bit of magic happening behind the scenes to make dpkg realize that the packages were unpacked but not configured yet).<p>This mostly worked well, but you could have some ordering issues.  A bigger issue is because debian doesn&#x27;t expect this to happen, it creates encryption at install time (say for ssh), not at first run time.  So for example, if one created an ssh daemon image, any instance run from it would have the same key.  not a great idea.  Of course, its possible to engineer my way out of this (simple case would be to write tooling to recognize these cases and inject it into the created images), but it goes to why a direct conversion from debian packges into layer wasn&#x27;t a silver bullet solution.  I had the thought that perhaps an Ubuntu type approach would work, where some packages are wholesale imported from Debian into Unbutu without any changes but &quot;important&quot; packages ae modified to fit Ubuntu better could work.<p>As an aside, the 2 papers referenced above were my &quot;job talk&quot; for my post doc at IBM Research, and got me the job.  I tried to get support to continue this line of work there, but that never happened (and then my manager left, and I was left working on unrelated cloud stuff for the last 1.5 years there).  Of course, this is now important to IBM (see Red Hat purchase).<p>I wasn&#x27;t approaching this from the pet&#x2F;cattle metaphor, so I also gave my system the ability to upgrade instances in place by mark removeding layers as unlinked (i.e. ignored by readdir&#x2F;lookup), and adding new layers.  A big advantage here over traditional package management is that this made upgrades &quot;atomic&quot;.  For example, when you upgrade libc in the traditional package managed world, your system is temporarily &quot;broken&quot;, in the sense that any executable that tries to run in between old libc removal and new libc installation will fail as its not on the file system.  However, in the cattle world of containers, this is probably unnecessary complexity.')