Item(by='chriswarbo', descendants=None, kids=[24896097], score=None, time=1603702773, title=None, item_type='comment', url=None, parent=24891630, text='I find there are two main problems with monads in Haskell:<p>- Monad is just an interface (with nice do-notation, to be sure), but it&#x27;s elevated to an almost mythic status. This (a) causes Monad to be used in places which would be better without (e.g. we could be more generic, like using Applicative; or more concrete by sticking to IO or Maybe, etc.) and (b) puts off new comers to the language, thinking they need to learn category theory or whatever. For this reason, I try to avoid phrases like &quot;the IO monad&quot; or &quot;the Maybe monad&quot; unless I&#x27;m specifically talking about their monadic join operation (just like I wouldn&#x27;t talk about &quot;the List monad&quot; when discussing, say, string splitting)<p>- They don&#x27;t compose. Monad on its own is a nice little abstraction, but it forces a tradeoff between narrowing down the scope of effects (e.g. with specific types like &#x27;Stdin a&#x27;, &#x27;Stdout a&#x27;, &#x27;InEnv a&#x27;, &#x27;GenRec a&#x27;, &#x27;WithClock a&#x27;, &#x27;Random a&#x27;, etc.) and avoiding the complexity of plugging all of those together. The listed advantages of SML are essentially one end of this spectrum: avoiding the complexity by ignoring the scope of effects; similar to sticking with the &#x27;IO a&#x27; type in Haskell (although even there, it&#x27;s nice that Haskell lets us distinguish between pure functions and effectful actions).<p>Haskell has some standard solutions to composing narrowly-scoped effects, like mtl, but I find them to be a complicated workaround to a self-imposed problem, rather than anything elegant. I still hold out some hope that algebraic effect systems can avoid this tradeoff, but retro-fitting them into a language can bring back the complexity they&#x27;re supposed to avoid (e.g. I&#x27;ve really enjoyed using Haskell&#x27;s polysemy library, but it requires a bunch of boilerplate, restrictions on variable names and TemplateHaskell shenanigans to work nicely).')