Item(by='josephg', descendants=None, kids=[25523478], score=None, time=1608765812, title=None, item_type='comment', url=None, parent=25523200, text='There is consensus in some ecosystems. Javascript absolutely maintains that invariant. There are (almost) no blocking functions in the javascript &#x2F; node standard libraries and we work hard to keep it that way. Go maintains similar discipline at the OS syscall level.<p>I feel like the &quot;what color is your function&quot; thing is incomplete. There are arguably 3 types of functions:<p>- Functions which do all their work synchronously and return without blocking<p>- Async functions which contain an internal state machine<p>- Functions which block on expensive IO or long computations<p>Mixing blocking functions and async functions in the same kernel thread leads to various performance disasters. Javascript is so meticulous about not having blocking IO in part because its basically impossible to tell from a function&#x27;s signature whether it will block the thread. Lua has this problem - callback oriented lua feels like a natural fit for the language, but lots of 3rd party libraries are packed with blocking calls. Writing asyncronous lua feels like fighting a river. You have to constantly guard against calling blocking code, and most API docs won&#x27;t tell you where they block.')