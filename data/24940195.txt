Item(by='reitzensteinm', descendants=None, kids=None, score=None, time=1604045937, title=None, item_type='comment', url=None, parent=24939959, text='Hardware transactional memory wouldn&#x27;t accelerate Clojure. The actual transactional bit is very cheap, built around compare and swap.<p>You first grab the current value of two refs, build two new values out of them through some process.<p>Then on commit, you lock both refs and check they&#x27;re unchanged since the start of the transaction. If they are, you swap the values, if they&#x27;re not, you grab the new values and rerun the computation (on and on until timeout).<p>The overhead comes from the lack of granularity - if two transactions change different keys in a map they&#x27;ll conflict even though in theory they could run simultaneously (and indeed can with a hash table and HTM like TSX).<p>And also because of the speed of persistent data structures. They&#x27;re not exactly slow given the flexibility they give you, but each write involves allocation.')