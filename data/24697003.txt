Item(by='anfilt', descendants=None, kids=None, score=None, time=1601987528, title=None, item_type='comment', url=None, parent=24696164, text='I mentioned as well it just was quick thought off the top my head. However, then you have the question can you trust the dice. It&#x27;s a lot easier to trust math.<p>I could sit down try to figure out a construction that adjusts&#x2F;accounts for any given N judges. Again though like I said this was just quick thought off the top of my head showing it seems possible to make a construction that can choose judges. Not something with every possible detail refined.<p>However, modular bias becomes smaller the larger your max number gets. We are not talking a small 32 bit random generator here. While it would be ideal to eliminate the bias it&#x27;s not exactly easy. One could try the method of re-rolling&#x2F;generating till you get an output in the target range. This has a massive problem because it is improbably at the scale of these numbers. Secondly, one can&#x27;t control the modulo N in this case. There are things we can try to smear the bias, but that does not eliminate it.<p>Moreover, as mentioned before the scale of max output works in our favour here. The larger your max output&#x2F;range is the smaller the bias is. Anyways there is a reason the CPRNGs will just truncate their output when you tell one to return X bytes. The range of possible bias is so small because how large cryptographic numbers are. Although some algorithms max output is a power 2 so the modulo N works out nicely.<p>The worst a bias like this can do is make partitioning cryptanalysis stronger, but unless you made some really bad choices generally should only be a theoretic break. At which point your designing primitives and not a protocol. However, that part we are using the modulus on is not secret so we are not gaining&#x2F;losing anything there. For this instance it&#x27;s just extremely tiny bias towards a certain judge.')