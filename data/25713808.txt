Item(by='ghc', descendants=None, kids=None, score=None, time=1610279753, title=None, item_type='comment', url=None, parent=25701883, text='There&#x27;s a large body of academic research on this, and many, many failures to learn from, including many that cost lives or cost hundreds of millions of dollars. In practice, there are lots and lots of bugs in any C program of any complexity. That&#x27;s why flight system software is written in Ada, not C.<p>In the military where you need to verify correctness of security controls or answer questions like &quot;does my missile guidance program terminate&quot;, you can&#x27;t use C or Assembly.<p>To achieve what you&#x27;re talking about with C or Assembly, you need this kind of process: <a href="https:&#x2F;&#x2F;www.fastcompany.com&#x2F;28121&#x2F;they-write-right-stuff" rel="nofollow">https:&#x2F;&#x2F;www.fastcompany.com&#x2F;28121&#x2F;they-write-right-stuff</a><p>To achieve it with a dynamic language like Python...well, you can&#x27;t (and shouldn&#x27;t even attempt it).<p>The trouble is, nobody has the budget for that. Not even most military groups. So instead of relying on human process, we leverage machine-driven verification through the use of type systems, provers, SAT solvers, contracts, randomized testing and other academically sound techniques for quality assurance.<p>&gt; From my experience Haskell seems to make easy things hard.<p>Haskell isn&#x27;t designed to make undergraduate programming exercises easy. It&#x27;s designed to make hard programming problems tractable. If you have an easy problem you shouldn&#x27;t use Haskell. Hell, if you have a hard problem you probably shouldn&#x27;t use Haskell.')