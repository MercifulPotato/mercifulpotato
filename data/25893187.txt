Item(by='derefr', descendants=None, kids=None, score=None, time=1611505223, title=None, item_type='comment', url=None, parent=25884441, text='I happen to know a bit about Ruby. (A lot more than I know about Java, as it happens.) Let me pick a few nits :)<p>#instance_variable_get &#x2F; #instance_variable_set is a thing. The (default) implementations of these methods on Object are just C code that do direct IVar reads&#x2F;writes. You can thus think of #instance_variable_get and #instance_variable_set as real “field access” in Ruby. It’s just that, unlike most languages, there <i>is</i> sugar† for the getter&#x2F;setter, and there <i>isn’t</i> any sugar for the “direct” field access.<p>† (The setter’s sugar is obvious — `a.b=x` is re-written by the lexer into a call `a.send(:&quot;b=&quot;, x)`. The getter’s sugar is less obvious — it’s seemingly just a regular method call. But think about why Ruby makes parens optional on arity-0 method calls in the first place. To sweeten getters into something field-access-looking!)<p>But, well, you might say, #instance_variable_get is just a method, too! I can override it as I want! Really, it’s just another <i>kind</i> of getter&#x2F;setter — sort of a categorical one.<p>Well, let’s go one level deeper — you can literally “reach into” the object to take a look at its IVars as <i>it</i> sees them:<p><pre><code>    obj.instance_eval{ @foo }\n</code></pre>\n“Objection! #instance_eval can be overridden! DRb proxy-objects do it!”<p>Well, okay, let’s get creative, and start breaking through the seemingly pure-OOP semantics of Ruby, revealing the more functional-language underpinnings:<p><pre><code>    inst_eval_fn = Object.instance_method(:instance_eval)\n    inst_eval_fn.bind(obj).call{ @foo }</code></pre>')