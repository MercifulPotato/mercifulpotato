Item(by='tikhonj', descendants=None, kids=[25205495], score=None, time=1606271621, title=None, item_type='comment', url=None, parent=25204380, text='I worked on an SMT-based superoptimizer research project[1] as an undergrad. We were targeting a weird stack-based chip so the details were pretty different, but it worked surprisingly well. Really fun project for sure!<p>SMT solvers are an incredible general-purpose tool for theses things, and we got quite far through various encoding tricks like synthesizing with much smaller bit-widths and then verifying with full widths. However, my impression is that while SMT solvers are great starting out, at some point the overhead and complexity of relying on encoding tricks starts to outweigh the advantages, to the point where either an entirely custom algorithm or some mix of existing solvers with a custom algorithm are the way to go. I don&#x27;t know if that&#x27;s fundamental, or it&#x27;s just a function of people being able to understand their own algorithms better than SMT solvers—most people I talked to saw SMT solver performance as a black box.<p>I remember reading about the Sketch synthesizer, which used a custom solver as its backend. It comes to mind because the first example of using Sketch[2] that our professor showed us involved SIMD shuffling instructions. It&#x27;s probably worth checking out on its own—I remember its input language being pretty easy to use—but I can&#x27;t find the project itself anywhere any more, probably because it used to be hosted on BitBucket :&#x2F;.<p>[1]: <a href="https:&#x2F;&#x2F;jelv.is&#x2F;chlorophyll.pdf" rel="nofollow">https:&#x2F;&#x2F;jelv.is&#x2F;chlorophyll.pdf</a><p>[2]: <a href="https:&#x2F;&#x2F;homes.cs.washington.edu&#x2F;~bodik&#x2F;ucb&#x2F;cs294&#x2F;fa12&#x2F;Lectures&#x2F;L3&#x2F;L3.pdf" rel="nofollow">https:&#x2F;&#x2F;homes.cs.washington.edu&#x2F;~bodik&#x2F;ucb&#x2F;cs294&#x2F;fa12&#x2F;Lectur...</a>')