Item(by='kodah', descendants=None, kids=None, score=None, time=1611687544, title=None, item_type='comment', url=None, parent=25915762, text='&gt; but in the case of making a real application that people will use, it seems like a lot of us can get away with a single DB, a few workers of our app, and maybe a cache.<p>A couple of points:<p>1. Kubernetes can run monoliths. It&#x27;s certainly not exclusive to microservices or SOA. It&#x27;s just a compute scheduler, quite similar to AWS&#x27;s EC2 reservations and auto-scaling groups (ASG&#x27;s).<p>2. I can&#x27;t speak for every corporation, but if you already have patterns for one platform (note: &quot;platform&quot; in this context means compute scheduling. eg: AWS, GCP, Kubernetes, Serverless) then you will inevitably try to copy patterns you already implement internally. A lot of times, for better or for worse, it&#x27;s not what fits best unless what fits best and what you have available are highly conflicting.<p>3. A lot of times &quot;scaling&quot; is actually code for multi-tenancy. As an industry, we should probably be explicit when we&#x27;re scaling for throughput, redundancy, and&#x2F;or isolation. They are not the same thing and at times at odds with each other.<p>4. I don&#x27;t really like your use of &quot;real application&quot; here as it implies some level of architectural hierarchy. My main takeaway after 10+ years of professional development is that architectures are often highly contextual to resource availability, platform access, and personal preferences. Sometimes there&#x27;s a variable of languages too, because some languages make microservice architecture quite easy while others make it a royal PITA.')