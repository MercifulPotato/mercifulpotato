Item(by='vasco', descendants=None, kids=[25801635], score=None, time=1610788996, title=None, item_type='comment', url=None, parent=25800638, text='&gt; But then why not just introduce a rule: Django ‘apps’ can only talk to each other via pure Python dicts like an interface? (rather than sharing models)?<p>1. One person or group needs to decide on what the rule should be, what the boundaries are and how to enforce those boundaries. This is  usually not an easy process, ymmv.<p>2. After a decision is made, you&#x27;ll have to decide on how to put the rule in place. Are you going to stop everything and make sure all code paths are working according to the new rule? Are you going to do it incrementally? New features = new rule, old features = common sense? Another variation?<p>3. You then start running your new rule and maybe you enforce it with some custom static checks, and when that fails you hope your code reviewers will always catch this every time.<p>4. You still need that one person or group to make sure this actually gets done and to assess if it actually has a positive impact on velocity and reliability.<p>Or you can put in an implicit &quot;rule&quot; that new code happens in a separate repository, where you don&#x27;t need to care. A developer that has to do an API call because they simply cannot &quot;import&quot; another module or &quot;query&quot; someone else&#x27;s data has no choice but to do the right thing - though many opportunities to do a lot of other wrong things too, this is not a panacea. But when we&#x27;re talking about more than ~5-6 teams, the coordination effort of making sure everyone is aligned on a monolith can be much tougher than to go to multiple services (hopefully not micro).')