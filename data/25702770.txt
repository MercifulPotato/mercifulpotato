Item(by='oxinabox', descendants=None, kids=None, score=None, time=1610215694, title=None, item_type='comment', url=None, parent=25700135, text='Arborist.jl <a href="https:&#x2F;&#x2F;github.com&#x2F;oxinabox&#x2F;Arborist.jl&#x2F;" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;oxinabox&#x2F;Arborist.jl&#x2F;</a><p>It implements one of the more advanced tricks in JuliaLang.\nWhich is the concept behind Cassette.jl (<a href="https:&#x2F;&#x2F;github.com&#x2F;jrevels&#x2F;Cassette.jl" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;jrevels&#x2F;Cassette.jl</a>) and IRTools.jl (<a href="https:&#x2F;&#x2F;github.com&#x2F;MikeInnes&#x2F;IRTools.jl" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;MikeInnes&#x2F;IRTools.jl</a>).\nwhich is this notion of a recursive source code tranformation.\nThis is the thing where you tranform code (kind of like a macro but not lexically scoped), including tranforming all function calls to also tranform their code.\nIt&#x27;s super powerful<p>For example Zygote.jl (<a href="https:&#x2F;&#x2F;github.com&#x2F;FluxML&#x2F;Zygote.jl" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;FluxML&#x2F;Zygote.jl</a>) implements reverse mode automatic differentiation, by defining a function that is a generated transformation of the function being differentiated.\nMagneticReadHead.jl (<a href="https:&#x2F;&#x2F;github.com&#x2F;oxinabox&#x2F;MagneticReadHead.jl&#x2F;" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;oxinabox&#x2F;MagneticReadHead.jl&#x2F;</a>) implements a debugger by defining a function that has been transformed to include debugger interupts.\nThis stuff also has a bunch of use for probabalistic programming languages etc.<p>The thing is Cassette and IRTools implement this at the lowered code level.\nIt runs on the SSA-form IR.\nThis IR was never really designed for the user to write it.\nThough IRTools does a noble attempt to make it nice.<p>Arborist instead runs at the Abstract Syntax Tree (AST) level.\nJust like macros.\nThis is designed to be written and manipulated by users. Users do that all the time by writing macros.<p>I haven&#x27;t touched it in a while (apparently 2 years).\nLargely because AFAICT it&#x27;s not useful outside of pedagogical purposes.<p>AST is not actually that nice for any program tranforms i want to do,\nsince there are so many ways to write the same thing.\nE.g. different kinds of loops and branches, where as in SSA form IR they all look the same.\nProbably could be made to work, but i just don&#x27;t really have a usecase that I can&#x27;t do easier on IR.\n(probably people who haven&#x27;t been deep into IR on the other hand would think of some)<p>There are a bunch of edge cases where it crashes still, for things that are not allowed to appear in generated code.\nIt wouldn&#x27;t be too hard to make it work though, not really.\nParticularly since we now have tools like\n<a href="https:&#x2F;&#x2F;github.com&#x2F;SciML&#x2F;RuntimeGeneratedFunctions.jl" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;SciML&#x2F;RuntimeGeneratedFunctions.jl</a>\n<a href="https:&#x2F;&#x2F;github.com&#x2F;JuliaStaging&#x2F;GeneralizedGenerated.jl" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;JuliaStaging&#x2F;GeneralizedGenerated.jl</a>')