Item(by='arp242', descendants=None, kids=None, score=None, time=1609846860, title=None, item_type='comment', url=None, parent=25644258, text='It depends on the project; I haven&#x27;t looked at this one in depth specifically, but it&#x27;s certainly possible to write useful things with a (much) small codebase for to replace (much) larger ones. Usually the trade-offs are:<p>1. It solves a more limited set of use cases. It&#x27;s perfectly reasonable to want to solve a wide range of use cases, but there&#x27;s value in more limited software which solves a more limited set of use cases, too.<p>2. It caters to a more limited set of users. Suckless is perhaps the epitome and most extreme flavour of this, where they just excluded things like config files in favour of a config.h file. This doesn&#x27;t make the software less stable, but it does make it less usable for some users.<p>For example, I am working on a CI system right now, as I ran out of Travis &quot;open source credits&quot; pretty fast and didn&#x27;t care much for the alternatives (or Travis, for that matter, but it did work) and I figured there&#x27;s some space for a somewhat different kind of CI. It&#x27;s currently functional but unfinished at abut 1500 lines of code, and I&#x27;d be surprised if the finished version will be more than ~3000 lines.<p>It&#x27;s smaller because it excludes features that are useful, but not for my (and I suspect many people&#x27;s) use cases, and because it makes some assumptions that you roughly know what you&#x27;re doing instead of abstracting everything. Combined, this drastically reduces the code size. This also means it&#x27;s not useful for everyone, but I&#x27;m okay with that and it&#x27;s a deliberate trade-off: not every project needs to solve all use cases or cater to all users.')