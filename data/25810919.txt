Item(by='chenglou', descendants=None, kids=None, score=None, time=1610894221, title=None, item_type='comment', url=None, parent=25804673, text='I happened to have read many of VPRIâ€™s papers and some domain expertise in a few of their topics, or know close friends with such domain expertise. Btw, my collection of their links are at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19844088" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19844088</a><p>The goal is a noble one; though it&#x27;s unclear to me if their research is the right way to go.<p>Alan Kay&#x27;s gang&#x27;s research&#x27;s end result are often great, but their implementations are usually more geared toward prototyping rather than production. For example, the GUI innovation is great, whereas its implementation using Smalltalk is clearly geared toward faster iteration and not meant to be as competitive as a production language (let&#x27;s not enter into this debate as this is another rabbit hole. Plenty of other HN threads on this). But I think so far these implementations have gotten a pass because the end result is futuristic enough for someone else to come along and implement e.g. the GUI in more production-oriented languages.<p>In the context of VPRI, however, the goal wasn&#x27;t to create more futuristic end results, but to recreate existing result using hopefully drastically more concise paradigms and DSLs. In this case, the implementation itself is the thing we should examine, and imo they kinda fall short.<p>For example:<p>- Yes, it&#x27;s very appealing that Nile can reduce the antialiasing logic by so much. Is it resilient to real world requirement changes though? Unclear (and the Nile paper still isn&#x27;t out as the author seems busy with some startup).<p>- The OMeta parser tool is cool until you encounter more complex grammar and proper error messages (most non-hand-rolled parser tools&#x27; error messages and error recoveries are treated as secondary concerns).<p>- Reusing the same state machine from OMeta (afaik) for TCP is clever, theoretically sound, but likely also not shippable in production the moment you want to tweak some low-level details.<p>- The dynamic language used for the final product, they baked in some pretty hardcore first-class features but..., this is too long to explain, though experienced folks who read this probably know what&#x27;d happen to such language in production.<p>- The bulk of the final line count reduction wouldn&#x27;t come from some language-related line count reduction, but from VPRI&#x27;s rehash of OpenDoc, aka the end product is a Word&#x2F;PowerPoint hybrid put together by massively (over)reused component. The moment such app hits the real world and a component needs to deviate from its use-case in other callsites, that amount of reuse is gonna decrease quickly. HN has plenty of comments regarding OpenDoc so we can check history here. The final use-case being an OpenDoc rehash is also slightly cheating imo. Demo a game. The line count there is a better stress test.<p>- Real-world perf requirements are gonna increase the line count by a lot. I understand they&#x27;re employing he classic PARC strategy to &quot;iterate as if you have the supercomputer of tomorrow, today&quot;, but plenty of languages today can already reduce their line count by a lot if perf wasn&#x27;t considered.<p>All in all, I&#x27;m not sure VPRI&#x27;s respectable goal can concretize through their method. I am however extremely on board with their goal (of shrinking the code size to be understandable by as few people as possible). Here&#x27;s an alternative take on the same goal: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=kZRE7HIO3vk" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=kZRE7HIO3vk</a> and of course Casey&#x27;s friend Jon Blow whose language Jai so far obsoleted a bunch of other DSLs he&#x27;d have usually needed in his workflow (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=uZgbKrDEzAs" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=uZgbKrDEzAs</a>). Now that&#x27;s a more realistic way of shrinking code and simplify, imo. Between:<p>- a great language that can demonstrably do low to high level coding and with an in-language metaprogrammmming facility that removes the need for DSLs, and<p>- VPRI&#x27;s opposite direction of proliferating many DSLs (which in real world are gonna cause nontrivial accidental complexities),<p>I&#x27;d take the former.')