Item(by='naniwaduni', descendants=None, kids=[25894627], score=None, time=1611508304, title=None, item_type='comment', url=None, parent=25893565, text='&gt; Not really. How would “.toupper()” work on a raw set of bytes, which would either contain an MP3 file or UTF8 encoded text?<p>It doesn&#x27;t. It doesn&#x27;t work with Unicode either. No, not &quot;would need giant tables&quot;, literally doesn&#x27;t work—you need to know whether your text is Turkish.<p>&gt; How would slicing work? I want the first 4 characters of a given string. That’s completely meaningless without an encoding.<p>It&#x27;s meaningless <i>with</i> an encoding: what are the first four characters of &quot;áíúéó&quot;? Do you expect &quot;áí&quot;? What are the first four characters of &quot;ﷺ&quot;? Trick question, that&#x27;s <i>one</i> unicode codepoint.<p>At least with bytes you know that your result after slicing four bytes will fit in a 4-byte buffer.<p>&gt; How would concatenation work? I’m not saying Python does this, but concatenation two graphemes together doesn’t necessarily create a string with len() == 2.<p>It doesn&#x27;t work with Unicode either. I&#x27;m sure you&#x27;ve enjoyed the results of concatenating a string with an RTL marker with unsuspecting text.<p>It gets worse if we remember try to ascribe linguistic meaning to the text. What&#x27;s the result of concatenating &quot;ranch dips&quot; with &quot;hit singles&quot;?<p>&gt; How would “.startswith()” work with regards to grapheme clusters?<p>It doesn&#x27;t. &quot;🇨&quot; is a prefix of &quot;🇨🇦&quot;; &quot;i&quot; is not a prefix of &quot;ĳ&quot;.<p>&gt; Text is different from bytes. There’s extra meaning and information attached to an arbitrary stream of 1s and 0s that allows you to do things you wouldn’t have been able to before.<p>None of the distinctions you&#x27;re trying to make are tenable.')