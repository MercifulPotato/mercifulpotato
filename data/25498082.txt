Item(by='dgb23', descendants=None, kids=None, score=None, time=1608576922, title=None, item_type='comment', url=None, parent=25497486, text='Transducers are definitely idiomatic. They are more general over &quot;similar things to transform in steps&quot; (including sequences, messages and so on), so you can apply them to collections (&quot;I have the whole data in advance&quot;) or channels (&quot;I get the data piece by piece&quot;) and so on.<p>Another idiomatic way to improve performance are transients[0]. From the outside your function is still a function, but on the inside it&#x27;s cheating by updating in place instead of using persistent data structures. See the frequencies function for a simple example[1].<p>Clojure and Rust are both very expressive languages and even though they both can be considered niche, they have _massive_ reach: Clojure taps into JVM and the JS ecosystems, Rust can also compile to WASM or be integrated with the JVM via JNI.<p>The big difference between the two, and why I think they complement each other nicely, is that Clojure is optimized for development, and does its best at runtime, but Rust is optimized for runtime, and tries its best at development. (A similar take in the article). In other words: they both achieve their secondary goal well, but resolve trade-offs by adhering to their primary in the vast majority of cases.<p>[0] <a href="https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;transients" rel="nofollow">https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;transients</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;clojure&#x2F;blob&#x2F;clojure-1.10.1&#x2F;src&#x2F;clj&#x2F;clojure&#x2F;core.clj#L7203" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;clojure&#x2F;blob&#x2F;clojure-1.10.1&#x2F;src&#x2F;c...</a>')