Item(by='mr-wendel', descendants=None, kids=None, score=None, time=1610726175, title=None, item_type='comment', url=None, parent=25784478, text='I think it really depends.<p>* How sensitive are you operations to breakage within the repo? Are there key things you can focus on that you know will give you trouble that can be readily tested with each build?<p>* Are you performing a lot of bug fixing as part of long term maintenance for an established system? I&#x27;d suggest adding tests for each thing just before you fix it and let tests demonstrate that is fixed. Look for any easy-pickings of related functionality while you&#x27;re there, as often fixing one bug just creates another (particularly with convoluted codebases).<p>* Is this a &quot;leaf&quot; or a &quot;node&quot; within your overall system architecture? I prefer to focus on the deeper bits first, as thats where you&#x27;re more likely to cause cascading failures.<p>Also, the flip side of testing is always monitoring.<p>* Have systems run background jobs to self-audit themselves and report errors. Expose these as APIs, if you can, that let you probe them on-demand to help quickly troubleshoot things.<p>* Use monitoring systems (e.g. nagios, zabbix, prometheus, etc) to audit things that are difficult (or not appropriate) to test: e.g. upstream systems, internal component health, etc. Don&#x27;t underestimate the power of a quick shell script that watchings known pain points and critical interfaces. Sometimes a few hours of hacking beats the pants off waiting for QA&#x2F;DevOps&#x2F;etc to get clearance and a few-to-several weeks to do a &quot;proper&quot; solution.<p>* Ensure you have reliable pre-production environments (e.g. at least a &quot;staging&quot; system thats generally prod-like). Sometimes you need multiple! Ensure health checks and monitoring is performed on all environments (albeit with toned-down escalations) to catch things before they go live.')