Item(by='spiffytech', descendants=None, kids=[25800689], score=None, time=1610766153, title=None, item_type='comment', url=None, parent=25799234, text='A basic ordered list of integers can cause a lot more problems than I would have expected at first glance.<p>Updating dozens&#x2F;hundreds&#x2F;thousands of records at once is obviously unnecessarily heavy to process. But depending on your storage layer&#x27;s locking model, it could cause high lock contention if concurrent actors are updating the same list and fight over large fractions of the dataset with every update.<p>If you&#x27;re working in a networked scenario, na√Øve implementations can turn into transmitting a <i>lot</i> of data across the wire for every single reposition.<p>It&#x27;s also algorithmically challenging in concurrent scenarios. If I update my local state rearrange items, and you update your local state to rearrange items in an overlapping range, when they have to sync up this quickly turns into the developer having to learn to implement CRDTs or Operational Transforms. You could implement optimistic or pessimistic locking, but you have to lock such a large fraction of the dataset that it&#x27;s easy to limit throughput.<p>Distributed&#x2F;eventual-consistency problems are particularly challenging with ordering solutions of this variety, but the difference between one operation updating a wide swath of values vs just the single updated value can make a difference in how primitive a reconciliation algorithm the develop can bring to bear.')