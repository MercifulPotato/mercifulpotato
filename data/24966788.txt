Item(by='zmix', descendants=None, kids=None, score=None, time=1604315680, title=None, item_type='comment', url=None, parent=24965513, text='&gt; The code sample is illustrative and shows off as much of the crazy, unneeded dynamism as possible rather than something that would actually work.<p>You can not make up fantasy code, in a language, that tries to look like the actual thing, but is not, and then complain about the language not working. <i>Your</i> code is not working, since that is not XPath code.<p>&gt;&gt; This was done in order to satisfy the needs of non-programmers, like in the digital humanities, the publishing industry, etc.<p>&gt; This makes no sense. “We made a weird programming language to satisfy the needs of non-programmers”?<p>It&#x27;s not weird. I am one of these people, and I enjoy it greatly! As an example for some (functioning) XQuery code, everybody is invited to check this: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;joewiz&#x2F;6762f1d8826fc291c3884cce3634eb77" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;joewiz&#x2F;6762f1d8826fc291c3884cce3634e...</a> I don&#x27;t think, that is weird. Or what about this:<p><pre><code>  for $contact in $contacts&#x2F;contact\n  where $contact&#x2F;familyname&#x2F;data() = &quot;Smith&quot;\n  group by $key := $contact&#x2F;zip\n  order by $key\n  return &lt;group&gt;{ $contact }&lt;&#x2F;group&gt;\n</code></pre>\nwhich will return all contacts named &#x27;Smith&#x27;, placed in the same &#x27;group&#x27; element as long as they live in the same location. Not weird at all! But then, this may be a matter of taste.<p>&gt; The current xpath&#x2F;xquery language is poorly supported, mostly ignored and incredibly over engineered to the point where it’s almost comically unfit for purpose.<p>As for ignored and unsupported, that has mostly psychological, social and historical reasons (the needs of programmers vs. the needs of power-users, people who fell for the hype-train and then were turned off, etc.). As for &quot;over-engineered&quot; my experience is, that XQuery is extremely lean. One may argue about some of the datatypes (i.e. dates and times), but they were requested by database&#x2F;enterprise people. XML is a technology, that had a lot of interest groups, who all wanted their share. The nice thing is: you don&#x27;t need to use it, if you don&#x27;t require it. But those, who do, they are happy. Also, these datatypes are not XPath&#x2F;XQuery, they are XML Schema. What would your example for &quot;over engineering&quot; in XPath be? I am really curios!<p>&gt; It’s pretty well understood and has valid use cases.<p>Again, my experience is very different. Most people do not know, whether to &quot;push&quot; or to &quot;pull&quot; when writing XSL-T, which is a strong indicator for them not having understood, at least, XSL-T. They just use it as a programming language and start complaining. Then there are those, who compare it with JSON, which is comparing apples to airplanes. They call it &quot;verbose&quot; while not realizing, that a complex data format, that implies a lot of logic, requires simple tools (XPath one-liner, anyone?), while simple datastructs require much more logic on the side of the programmer. Yes, something as simple as JSON is a low hanging fruit, just like &quot;make money fast&quot;. And then you realize the small print. In XML you start lowly, just as in XPath. No need to type anything. Just code on. Do the typing before production release. The rest comes over time, like everyhwere.<p>Verbosity really happens on the code and the overly complex toolchains (just think ECMAScript and all the difficulties, that stem from combining HTML with JSON, in order to be somewhat semantic)<p>&gt; However it had a history of overly complex, over engineered tooling created by a committee and stuffed full of acronyms.\nThis quite rightly puts people off, and there are just better formats and technologies to use that isn’t encumbered with XML baggage.<p>Well, lazy people, who want to speak a foreign language without learning it (best example is your XPath code). I seldomly read the W3C specs, only if I can&#x27;t help myself any further. There are some nice books on every of these technologies, which are pretty simple to understand. However, one needs to read them, rather than just &quot;coding on&quot;.<p>I do not doubt, that you are a capable programmer. However, judging by your code example, you got no clue about the XPath language. You may know how to abuse functions in a language, that access a server, and I guess, most of these attacks are pretty standard and do not require deeper knowledge of XPath. It&#x27;s just the functions, that offer access.')