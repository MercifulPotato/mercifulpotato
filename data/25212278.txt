Item(by='lern_too_spel', descendants=None, kids=None, score=None, time=1606327975, title=None, item_type='comment', url=None, parent=25211085, text='Indeed, one of the articles cited by the article that this discussion is about (<a href="https:&#x2F;&#x2F;blog.metaobject.com&#x2F;2020&#x2F;11&#x2F;m1-memory-and-performance.html" rel="nofollow">https:&#x2F;&#x2F;blog.metaobject.com&#x2F;2020&#x2F;11&#x2F;m1-memory-and-performanc...</a>) links to a paper saying that GC needs 4x the memory to match manual memory management and then makes a huge wacky leap to say that ARC could achieve that with less. It can&#x27;t. ARC will always be slower than manual memory management because it behaves the same way as naive manual memory management with some overhead on top.<p>On the other hand, that same paper shows that for every single one of their tested workloads, the generational GC <i>outperforms</i> manual memory management. Now obviously, you could do better with manual memory management if you took the time to understand the memory usage of your application to reduce fragmentation and to free entire arenas at a time, but for applications that don&#x27;t have the developer resources to apply to that (the vast majority), the GC will win.<p>I&#x27;m not saying that better memory management is the reason Android wins these launch to interactivity benchmarks because the difference is so stark relative to the hardware performance that memory management isn&#x27;t nearly enough to explain it, but it does contribute to it. (My own guess is that most of the performance difference comes from smarter process initialization from usage data. Apple is notoriously bad at using data for optimization.)')