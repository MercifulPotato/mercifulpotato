Item(by='chriswarbo', descendants=None, kids=None, score=None, time=1610370143, title=None, item_type='comment', url=None, parent=25727433, text='&gt; the author disregarded the Java&#x2F;C++ compiler as &quot;an annoyance&quot; (a quote).<p>To be fair, the context of that quote is:<p>&gt; Many programmers encounter statically typed languages like Java or C++ and find that the compiler feels like an annoyance.<p>I think this is a fair statement, although it would <i>also</i> be fair to say &quot;many Java and C++ programmers find their compiler errors useful&quot;. I&#x27;d guess these two camps would remain <i>mostly</i> the same when using Haskell.<p>You&#x27;re right that most of the article is roughly comparing a good example of static types (Haskell) against a bad example of dynamic types (PHP).<p>&gt; I&#x27;ve seen this a million times in Java, and that works fine.<p>My biggest problem with Java (and the JVM) is the existence of `null`: it completely undermines type signatures. In the above Haskell example we &quot;know&quot; (see caveat below) that a `myInvoice :: CustomerInvoice` is a `CustomerInvoice`, whilst in Java a `CustomerInvoice myInvoice` might be a `CustomerInvoice` or it might be `null`; likewise `myInvoice.billableItems` is a `[String]` in Haskell, whilst in Java it might be a `List&lt;String&gt;` or it might be `null`; in the former case, each element might be a `String` or it might be `null`.<p>Caveat: Haskell values are lazy by default, so errors may only get triggered when inspecting some deeply nested value; in that sense we might say that a Haskell expression of type `T` might be a `T` or might be an error (known as &quot;bottom&quot;). We certainly need to keep that in mind, but one nice thing about bottom is that it can&#x27;t affect the behaviour of a pure function (we can&#x27;t branch on it). In that sense returning a value containing errors, which are later triggered, is practically equivalent to triggering the error up-front (pure expressions have no inherent notion of &quot;time&quot;, unlike imperative sequences of instructions). The interesting difference is that we can also use such values <i>without</i> triggering the errors, iff the erroneous part is irrelevant to our result ;)<p>Having all types nullable by default makes &#x27;proper&#x27; null-checking incredibly verbose, not to mention tricky; the alternative is to cross our fingers and hope our assumptions are right. What makes this frustrating is that such checks are exactly the sort of thing that computers can help us with, and type systems are particularly well suited for! Hence the presence of `null` cripples Java&#x27;s type system in a way which can&#x27;t be worked around (without essentially layering a separate, null-less type system on top to check for nulls!).<p>Also note that the presence of null causes every domain model to collapse. Let&#x27;s say we want to write a conversion method, e.g. from `CustomerInvoice` to `Document`, and we don&#x27;t want to worry so much about `null`: hence we write in our javadoc that as long as the given CustomerInvoice contains no null values, this method will never return null; let&#x27;s say we throw a NullPointerException in those invalid cases. Great, our users now have fewer edge-cases to worry about; they don&#x27;t have to check for null, and they don&#x27;t have to catch NullPointerException if their input is correct.<p>Except, once we start implementing our method we find it needs to call some other helper method, e.g. `statusToTable`; if <i>that</i> method returns a null result, we would be unable to construct the `Document` value that we promised. What can we do in that case? We promised we wouldn&#x27;t return `null`, so maybe we throw a NullPointerException? If we do that, those calling our method might get a NullPointerException even if they gave valid input! We might throw a different exception instead, like AssertionError, but the effect would be the same. Hence we <i>can&#x27;t</i> guarantee to our callers that we don&#x27;t return null (or some equivalent that they must deal with, like NullPointerException or AssertionError); that, in turn, means <i>they</i> can&#x27;t provide such guarantees to their callers, and so on. At any point, we might get a null (or equivalent exception), and the whole house of cards comes crashing down.<p>Maybe we trust that helper method <i>doesn&#x27;t</i> return null, but how can we know? Maybe we check its documentation or source code to see whether it might return null; but we find that it calls other methods, so we have to check those, and so on. If we do this, we would also have to pin our requirements to the precise versions of the libraries that we checked. In case you couldn&#x27;t tell, that process is essentially manual type checking (for a very simple system with two types: &#x27;Null&#x27; and &#x27;AnythingElse&#x27;).<p>Of course, this is sometimes inherent to the problem, e.g. if a HashMap doesn&#x27;t contain the entry we need then there&#x27;s nothing we can do. However, most code <i>doesn&#x27;t</i> have such constraints (except perhaps out-of-memory), but there&#x27;s no way to tell that to Java (in mathematical language, Java weakens every statement to admit trivial proofs).')