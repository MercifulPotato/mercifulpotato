Item(by='arc776', descendants=None, kids=[24788864], score=None, time=1602768897, title=None, item_type='comment', url=None, parent=24788047, text='&gt; the tradeoffs of ORC and availability of manual memory management<p>For those not familiar with the language, Nim only uses GC for `seq` (dynamically sized lists like c++ vectors), `string`, and types declared with `ref`.<p>Everything else is a stack allocated value type, or as noted in the parent, you can manually manage with pointers.<p>&gt; won&#x27;t materially harm hard-realtime systems use-cases in practice<p>I think this is true. I already find myself rarely using GC when writing Nim, but when you want it, it&#x27;s nice yet painless.<p>Here someone is embedding an async messagepack&#x2F;JSON RPC on an ESP32: <a href="https:&#x2F;&#x2F;forum.nim-lang.org&#x2F;t&#x2F;6916" rel="nofollow">https:&#x2F;&#x2F;forum.nim-lang.org&#x2F;t&#x2F;6916</a><p>Later they compare no async, and ORC with async and find that it&#x27;s &quot;only a few ms slower than the RPC calls running with ARC and no async.&quot;<p>While this example may not be the hardest of realtime, it does show that ORC competes with manual approaches to memory management in constrained environments.')