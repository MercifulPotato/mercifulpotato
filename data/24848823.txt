Item(by='pierrebai', descendants=None, kids=[24849310], score=None, time=1603294405, title=None, item_type='comment', url=None, parent=24848408, text='Both of your first two cases exist when people convert code bases that used raw pointers to shared_ptr. The normal intended usage of shared_ptr is to use make_shared and never have a raw pointer ever exist. The need to us shared_from this (or create a new independent shared ptr) happens only because some part of the code base is still using raw pointers for that particular class.<p>OTOH, C++ needs the ability to support old code bases because of its age. Of course a new language can forego this.<p>As for cycles, for GC language using ref-counting under the hood, the same problem applies. I&#x27;ve also seen memory leak from accidental keeping of pointers in fully GC languages. I&#x27;ve seen it happens in Java multiple times. Of course, two wrongs don&#x27;t make right, but in this case GC is only solving one case.<p>But the more fundamental issue at play is that pointer cycles usually means a lack of up-front design and thought about how a program will work. As such, it is bad, but only a symptom of a lack of proper initial design which can manifest itself in all kind of places.')