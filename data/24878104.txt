Item(by='l0b0', descendants=None, kids=[24880979], score=None, time=1603533448, title=None, item_type='comment', url=None, parent=24876980, text='&gt; (1) Except when your tokens can contain newlines, which we&#x27;re stuck with for the foreseeable future. -- not sure what you mean here, because QSN strings are defined not to contain literal newlines. They&#x27;re escaped like &#x27;\\n&#x27;.<p>The tokens in question are filenames, which are (and will continue to be) allowed to contain newline characters. Sorry that wasn&#x27;t clear. This was never meant to be a critique of QSN, I&#x27;m just saying QSN is unnecessary and unnecessarily complex for between-process communication:<p>- In case of filenames, just use NUL. It already works, is supported by a bunch of tools, and will never have the overhead of encoding&#x2F;decoding.<p>- In case of arbitrary binary streams, just send the stream unaltered. Why encode&#x2F;decode it? What benefit is that? In the very rare case that I&#x27;m actually manually inspecting a stream of bytes (debugger&#x2F;printf) there&#x27;s always some easy way to encode those bytes for easy readability such as `printf &#x27;%q\\n&#x27;`.<p>&gt; (2) A QSN decoder is very easy to write. For example, here&#x27;s a ~6 line regex that validates all of QSN:<p>It would take me at least a day to write enough test cases to ensure that that regex in fact does what it says. But the point is moot: encoding and decoding should only happen at the interface with a human, not with another process.<p>&gt; (3) Oil should grow [2] an awk-like dialect [3] that understands QSN and QTSV.<p>I couldn&#x27;t comment; I don&#x27;t use awk unless I absolutely have to. Once I need to use awk a shell script is no longer the best tool for the job, except for quick once-only processing.<p>&gt; (4) Although you also don&#x27;t have to decode it for it to be useful.<p>&gt; 1. I can use wc -l on a stream of QSN strings<p>I can already use `wc --files0-from=-` on a stream of NUL-separated tokens.<p>&gt; 2. If I know the strings are QSN-encoded, I can search for NUL bytes with fgrep &#x27;\\0&#x27;<p>You can already `grep` for NUL bytes[1].<p>&gt; (5) base64 is bad for humans at the terminal, because it makes everything unreadable. QSN preserves all printable ASCII and unicode.<p>But filenames are neither ASCII nor Unicode - they are <i>bytes,</i> which can include 0x80 through 0xFF (not valid ASCII) and things like 0xFF (not valid UTF-8).<p>I still can&#x27;t see a single use case where I&#x27;d want <i>inter-process communication</i> to use QSN. Human input, sure, I&#x27;d love something more convenient that `$&#x27;&#x27;`. Human output, also sure, humans can&#x27;t read NUL characters or tell the difference between spaces and tabs after all.<p>[1] <a href="https:&#x2F;&#x2F;superuser.com&#x2F;a&#x2F;612336&#x2F;2259" rel="nofollow">https:&#x2F;&#x2F;superuser.com&#x2F;a&#x2F;612336&#x2F;2259</a>')