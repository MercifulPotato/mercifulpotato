Item(by='scott_s', descendants=None, kids=[24851003, 24851877], score=None, time=1603292780, title=None, item_type='comment', url=None, parent=24844784, text='&gt; Really, &quot;lock free&quot; programming is just locking critical sections with lower level hardware primitives.<p>I have to disagree, as the more interesting lock free algorithms use atomic operations that can <i>fail</i>. Yes, a compare-and-swap is like having a critical section on modifying that particular address. But a compare-and-swap can fail if what is currently there is unexpected. The result of that failure generally means redoing a bunch of work, rather than just trying again. Interesting lock free algorithms tend to have the structure:<p>1. Read some data.<p>2. Perform computations on that data.<p>3. Trying to commit the result of that computation. If someone else committed data to the same location after you read it in step 1, go back to step 1.<p>That&#x27;s less like a &quot;critical section,&quot; and more like a transaction. For lock free algorithms that just rely on atomic operations that cannot fail (such as an atomic increment), then yes, those are just like having a lower-level critical section. (And, on some architectures, that&#x27;s exactly what they are.)')