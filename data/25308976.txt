Item(by='tejasv', descendants=None, kids=[25310337, 25310211, 25315027, 25309848, 25312345, 25311395], score=None, time=1607120266, title=None, item_type='comment', url=None, parent=25305650, text='We&#x27;re an F#-first company and I&#x27;d like to share our experience here.<p>All our new code is in F#, we started off from a C# codebase, so that made the transition somewhat manageable, as new F# code can be directly called from C#, and vice versa (still took over 2 years). All new frontend apps are also being written in F# (using Fable), as of 6 months back, migrating away from TypeScript, this forces everyone into a &quot;design your model first, and well&quot; paradigm. We&#x27;ve written quite a bit of code to blur the lines between traditional backend and frontend development roles, so what we have now are:<p>- product engineers (who write application logic on both frontend and backend to serve business needs)<p>- platform &amp; framework engineers (who write the underlying persistence&#x2F;serialization&#x2F;versioning&#x2F;frontend-backend-sync websocket&#x2F;load balancing&#x2F;IDE extensions&#x2F;deployment etc)<p>- component designers who focus on visuals<p>Platform&#x2F;framework engineers try to encapsulate as much magic as possible into computation expressions (F#&#x27;s monads), so product engineers can focus simply on writing out business intent, with readability given very high priority. We also make ample use of quotations to do some cool tricks (like predict the future states some type can take, based on current state + available transitions).<p>Our code written in F# has an order of magnitude fewer bugs when it makes it to production, given the amount of thought we pour in modelling the problem domain accurately, and thanks to functional programming itself. They&#x27;re also more amenable to business requirements changing, simply because they&#x27;ve been modelled well to start with. Nothing that can&#x27;t be achieved in other languages, but with F#, this happens more naturally.<p>Almost everyone in our team has learnt F# on the job, and overall, everyone&#x27;s experience has been extremely positive. There&#x27;s a bit of difficulty in the first 2-3 months, as junior devs get introduced to functional thinking, but if you&#x27;ve generally being doing functional programming, this is just about learning new syntax, tooling and F#&#x27;s choice of operator naming (map&#x2F;bind&#x2F;pick&#x2F;collect&#x2F;choose&#x2F;..). Typically, based on prior experience, we ask newcomers to spend two weeks to a month, solving the first 100 problems on Project Euler in F#, without using the mutable keyword, and we assign a mentor to point out best practices and review their code.<p>The hiring pool for F# devs is much smaller than the regular applicant pool, but if a candidate shows genuine interest in F#, they are usually 10x more likely get through our interview process. If they&#x27;ve discovered F#, it means they find something lacking with mainstream languages, so they&#x27;re likely to have many years of experience under their belt, and they&#x27;ve found a way to grow. That said, we don&#x27;t restrict our hiring to simply F# devs.<p>For more info about us, see chaldal.tech (YC&#x2F;S15).')