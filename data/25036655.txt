Item(by='wtetzner', descendants=None, kids=None, score=None, time=1604940355, title=None, item_type='comment', url=None, parent=25018489, text='&gt; No, that&#x27;s a mutable value.<p>&gt; The variable is the lexical representation of a value. If you change which value your variable binds to, you have changed the representation of the variable; you have mutated it. The underlying values in memory have not changed, they are immutable.<p>I completely agree with you that values and variables are separate things. However, <i>mutable</i> variables are still memory slots that can be mutated, while <i>immutable</i> variables are not. The memory slot of a variable usually lives on the stack, and contains a pointer to a value that lives elsewhere in memory.<p>I think the difference will be clearer in a language that distinguishes between introducing a variable and setting a variable.<p><pre><code>    var foo = &quot;abcd&quot;; &#x2F;&#x2F; introduce a new variable binding\n    foo := &quot;xyz&quot;; &#x2F;&#x2F; set a variable\n</code></pre>\nHere&#x27;s an example of what you can do in a language that has mutable variables that you cannot do in a language that only supports shadowing bindings:<p><pre><code>    var strings = [&quot;str1&quot;, &quot;str2&quot;, &quot;str3&quot;];\n    var foo = &quot;abcd&quot;;\n    for (string in strings) {\n      foo := string;\n    }\n    println(foo); &#x2F;&#x2F; Prints out &quot;str3&quot;\n</code></pre>\nIn this case, foo itself <i>is</i> a memory slot that can be mutated, independently of the strings, which are immutable values. foo is a mutable slot in memory that can be updated to contain different pointer values.<p>Now, if you <i>only</i> have shadowing, you end up with this:<p><pre><code>    var strings = [&quot;str1&quot;, &quot;str2&quot;, &quot;str3&quot;];\n    var foo = &quot;abcd&quot;;\n    for (string in strings) {\n      var foo = string;\n    }\n    println(foo); &#x2F;&#x2F; Prints out &quot;abcd&quot;\n</code></pre>\nEach iteration of the loop is introducing a <i>new</i> binding with the name foo, but it is not changing or removing the <i>original</i> binding of foo. It&#x27;s just that within the loop, only the local binding is visible.<p>I think part of the confusion around Elixir is that it only supports introducing new bindings, but the syntax <i>looks</i> like it&#x27;s setting the value of a variable.<p>Another example that will hopefully help clarify:<p><pre><code>    var foo = &quot;abcd&quot;;\n    var bar = &quot;xyz&quot;;\n    println(bar);\n</code></pre>\nThat example is nearly the same as this (and in terms of what the program <i>does</i>, it&#x27;s identical):<p><pre><code>    var foo = &quot;abcd&quot;;\n    var foo = &quot;xyz&quot;;\n    println(foo);\n</code></pre>\nThe only difference is that in the second case, the first foo binding isn&#x27;t visible after the second one has been introduced. At least conceptually, they both still exist, but because of scoping rules, there&#x27;s no way to access the first one.')