Item(by='AmericanChopper', descendants=None, kids=None, score=None, time=1603157031, title=None, item_type='comment', url=None, parent=24832058, text='I don&#x27;t think a 25 year old paper on the topic would still hold that much relevance today. I&#x27;d also suggest that the difference is why software is created could be having an influence over something like this. The fundamentals of the Unix design philosophy are &quot;Make each program do one thing well&quot; and &quot;Expect the output of every program to become the input to another, as yet unknown, program&quot;. You could debate exactly how influential that has actually been over GNU design, but it&#x27;s quite different from the typical approach taken with commercial software, which is not to write programs that perform a single function, but to write programs that solve an entire category of problems for the customer. When I think about the opensource &quot;solution-oriented&quot; products that I&#x27;ve used (Elastic stack and Zabbix come to mind), I don&#x27;t get the impression that they&#x27;re more reliable than their commercial counterparts.<p>One of the things I&#x27;ve always thought about open source tooling in general, is that I expect to find a collection of highly reliable and performant utilities, and I expect it to be entirely my problem to turn them into a working system that&#x27;s going to solve my problems. With commercial software, I would just expect it to just work off the shelf and consume much less of my time to maintain. That said, it is a fantastic feeling to find a bug or missing piece of functionality and to just write a pull request for it, rather than waiting for an account manager to get back to you saying &quot;it&#x27;s on the roadmap&quot; or something else equally unhelpful.')