Item(by='ImprobableTruth', descendants=None, kids=[24881089, 24881073], score=None, time=1603560618, title=None, item_type='comment', url=None, parent=24880162, text='Haskell enforces purity, but you can still write pretty imperative looking code by using monads (e.g. some state monad). I don&#x27;t think there is any philosophical difference between say<p><pre><code>  int x = foo();\n  bar();\n  char y = baz(x);\n</code></pre>\nand<p><pre><code>  do\n    x &lt;- foo\n    bar\n    y &lt;- baz x\n</code></pre>\nI&#x27;d say the true difference is more related to how you describe state change. Imperative is about having a sequential list of instructions that all can mutate global state in some way, whereas with a functional style it&#x27;s about composing functions that depend on their arguments rather than global state. Functional purity lends itself to a functional style, but you can just explicitly pass a large (global) state around and compose functions only sequentially, which imo lands you right back in imperative territory.')