Item(by='bsder', descendants=None, kids=None, score=None, time=1602487890, title=None, item_type='comment', url=None, parent=24751953, text='&gt; If experienced developers are finding this language overwhelming, how are you going to convince the electronics guys to adopt it instead of using plain old C?<p>Because embedded software is increasingly networked (BLE, TCP&#x2F;IP, ZigBee, etc.) and you can continue writing your communication stacks in C and having memory corruption security vulnerabilities or you can suck it up and <i>try something else for once</i>.<p>&gt; Also in this world all major HALs and SDKs are written in C. The toolchains usually are very fixed, since doing embedded systems is hard...<p>1) The embedded world has effectively converged on ARM.  This means that the toolchain is whatever ARM shoves out and HALs and SDKs will comply or get no traction.<p>It also means that you can use actual, real software tooling (VSCode, Meson, Ninja, etc.) instead of &quot;Yet Another Broken Vendor IDE&quot;.  It&#x27;s <i>soooo</i> compelling that I <i>personally</i> can run rings around some vendor teams.  To be fair--this is <i>NOT</i> limited to Rust.  VSCode and its ecosystem enables even C programmers to be stupidly more productive.  However, the embedded Rust folks seem to rattle the VSCode folks cage quite a bit more than just plain embedded C folks--this keeps the VSCode guys quite a bit more honest about cross-platform support.<p>2) Anything RISC-V is in flux, and folks like Bryan Cantrill are leading the charge so the toolchain will be forced to accommodate more than &quot;just C&quot;.<p>3) Even if Rust isn&#x27;t the answer, you should root for its tooling to break the C hegemony.  If Rust finally forces C tooling to acknowledge that &quot;Hey, just maybe we should think about playing nicely in the sandbox and have some useful API&#x27;s instead of telling everybody to cope or leave because we&#x27;re the 500lb gorilla.&quot;, the successor to Rust will have a <i>vastly</i> easier time.')