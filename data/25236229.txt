Item(by='jlokier', descendants=None, kids=None, score=None, time=1606552409, title=None, item_type='comment', url=None, parent=25235190, text='I think the downvotes are because of your language.<p>First, you wrote &quot;M1 has instruction-level x86 emulation&quot; as an authoritative sounding statement, as if it&#x27;s true.<p>When you also talked about Qualcomm and MediaTek having to add lots of complexity and deal with legal pitfalls, that added to the idea that you really did mean a full x86 instruction decoder, because that&#x27;s where the legal pitfalls are expected to be.<p>But it&#x27;s false, the M1 doesn&#x27;t do instruction-level x86 emulation, so that&#x27;s a minor irritation.  Comments don&#x27;t usually get downvoted over a simple mistake, but they do if it looks like someone is saying something really misleading.<p>But then in response to being told it doesn&#x27;t do that, you wrote &quot;so, it does? thanks for clarifying!&quot;.<p>That language read like you were being <i>snarky</i>.  The phrasing &quot;so, it does?&quot; in response to a correct &quot;It doesn&#x27;t.&quot; is typical English snark, a way of sounding dismissive and challenging at the same time.<p>That interpretation invited a downvote.<p>Once you have been perceived as snarky, following it with &quot;thanks for clarifying!&quot; is doomed to come across as more snark.  The exclamation mark makes this worse.<p>If you are legit just curious, then I think what has happened is you did not understand that &quot;instruction-level x86 emulation&quot; is a very different thing than &quot;memory ordering&quot;, stating the former to be something the M1 does is misleading, and you did not realise you had written something that came across as snark.<p>I&#x27;ll legit try to explain the difference in case you&#x27;re interested.<p>A CPU doing x86 emulation at the instruction level would have the chip <i>decode</i> x86 machine instructions in hardware one by one and perform the operations they describe.  The M1 doesn&#x27;t have hardware to decode x86 though; neither does any other ARM CPU.  It could be built, but nobody has, probably for legal reasons not technical reasons.<p>For memory ordering, we probably wouldn&#x27;t call it emulation.  All multi-core CPUs have a memory ordering model, but different architectures have different models.  This means how memory accesses (reads and writes) in programs running on one core are <i>observed</i> by programs on other cores running in parallel and doing memory accesses to the same locations.  (On single-core CPUs it is irrelevant because normal CPU cores always observe their own reads and writes in program order.)<p>It&#x27;s probably not obvious how memory accesses can be observed out of order.  It happens because at some level, reads and writes inside a CPU are not instantaneous.  They become messages back and forth with the memory, messages take time to travel, and these messages get even more complicated when there are different kinds of caches all over the place as well.  With multiple cores sending and receiving memory messages, each of these taking time to travel, the result is cores see memory messages in a different order from each other.  Rather than explain, I&#x27;ll link to the Wikipedia article: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_ordering" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_ordering</a><p>ARM generally has a weak memory model, which means the order of instructions in a program on one core has little effect on the order of memory accesses seen by other cores.  This is too weak for some things to work (like locks between parallel threads), so there are also barrier instructions which force all memory accesses before and&#x2F;or after the barrier to be visible to programs on other cores in the order of instructions, as long as the programs on the other cores also use barriers.<p>On x86 you don&#x27;t need barriers, because the ISA is defined (due to the history of CPUs) so that all memory accesses by each core are visible to all the others in the exact order of instructions run by each core.  (There are some exceptions but they don&#x27;t matter).  This is a great illusion, because in reality to stay fast there are memory access messages flying around inside the CPU and between the cores and caches, getting out of order in large queues.  To maintain the effect as if everything is in order needs a bunch of extra transistors and logic on the chip, to keep track of which messages have to be queued up and waited for before others.<p>This is why when x86 programs are translated into ARM programs (by Rosetta 2 software), if it&#x27;s for a multi-threaded program the ARM code needs a lot of barrier instructions all over the place, and these tend to be slow because the chip isn&#x27;t optimised for lots of barriers.<p>On the M1, it has a non-standard (for ARM) operating mode where the weak order switches to program order, like x86.  For this to work it needs extra logic on the chip.  It seems that the M1 doesn&#x27;t use this extra logic all the time though, only when Rosetta 2 is using it.  Probably because it slows things down a bit to turn it on.<p>So when x86 programs are translated into ARM programs (by Rosetta 2 software) it doesn&#x27;t need to include lots of barrier instructions.  Maybe not any.  The resulting code which runs on the M1 is ARM code (not x86 code), but it&#x27;s special ARM code because if it&#x27;s run in parallel with other ARM code accessing the same memory on another core, it only runs correctly when the M1 turns on the non-standard program-order memory mode, which slows the CPU a little.')