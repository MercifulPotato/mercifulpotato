Item(by='Geminidog', descendants=None, kids=None, score=None, time=1608629352, title=None, item_type='comment', url=None, parent=25504253, text='I am not talking about leaky code. I am talking about code that is not modular.<p>Rest assured, I know you’re talking about a perceived  isomorphism between a function with a struct as a parameter and the same struct with a method. There are some flaws with this direction of thought.<p>It is the usage of implicit ‘this’ that breaks modularity. When a method is used outside of a class the ‘this’ is no longer implicit thereby preventing the method from ever being moved outside of the context of the class. This breaks modularity. Python does not suffer from this issue.<p>Couple this with mutation. Often methods rely on temporal phenomena (aka mutations) to work, meaning that a method cannot be used until after a constructor or setter has been called. This ties the method to the constructor or setter rendering the method less modular as the method cannot be moved or used anywhere without moving or using the constructor with it.<p>My claim is that combinators can be reorganized without dragging context around thereby eliminAting technical debt related to organization and repurposing and reusing logic.<p>Note that when I say combinator, I am not referring to a pure function.')