Item(by='masklinn', descendants=None, kids=None, score=None, time=1601663466, title=None, item_type='comment', url=None, parent=24662444, text='Aside from the last, this is all very standard stuff, I don&#x27;t mean for Rust I mean for language with sum types in general.<p>&gt; - switching on tuples (not wrapped in a var): this prevents doubly-nested switches, which I&#x27;ve always found to be a problem in control logic<p><pre><code>    match t {\n        (Some(a), Some(b)) =&gt; a + b,\n        (Some(a), None) =&gt; a,\n        (None, Some(b)) =&gt; b,\n        (None, None) =&gt; 0\n    }\n                      </code></pre>\n&gt; - unwrapping optionals<p><pre><code>    match opt {\n        Some(v) =&gt; v,\n        None =&gt; 0\n    }\n</code></pre>\nalthough it&#x27;s common to use HOFs, the `?` operator, or `if let`.<p>&gt; - matching against an enum&#x27;s associated value, and unwrapping it<p>See above.<p>- using `where` clauses as part of the pattern<p><pre><code>    match opt {\n        Some(v) if v &gt; 5 =&gt; v - 5,\n        Some(v) =&gt; v,\n        None =&gt; 0\n    }\n</code></pre>\n&gt; - matching against type casts<p>Rust doesn&#x27;t really do subtyping, so that&#x27;s not a case which would come up. I guess the closest would be matching on the result of a downcast_ref (<a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;any&#x2F;trait.Any.html#method.downcast_ref" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;any&#x2F;trait.Any.html#method.down...</a>) but that just returns an Option so there&#x27;s nothing special to it.')