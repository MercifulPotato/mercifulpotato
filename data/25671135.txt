Item(by='acdha', descendants=None, kids=[25679249], score=None, time=1610028314, title=None, item_type='comment', url=None, parent=25667591, text='&gt; Intel does lots of contributions across the OS (Linux and glibc) to compilers including their own (gcc, icc, ispc, etc). Their problems aren&#x27;t their ability, it&#x27;s that Intel is poorly managed and internal groups are constantly fighting with each other.<p>I wasn&#x27;t just talking about Intel but the concept of separate CPU and compiler vendors in general. Intel contributes a ton of open source but even if they were perfectly organized it takes time for everything to happen on different schedules before it&#x27;s generally available: get patches into something like Linux or gcc, wait possibly years for Red Hat to ship a release using the new version, etc. Certain users — e.g. game or scientific developers — might jump on a new compiler or feature faster, of course, but that&#x27;s far from a given and it means they&#x27;re not going to get the across-the-board excellent scores that Apple is showing.<p>&gt; Also, compiler support for CPUs is very overrated. Heavy compiler investment was attempted with Itanium and debunked; giant OoO CPUs like Intel&#x27;s or M1 barely care about code quality, and the compilers have very little tuning for individual models.<p>This isn&#x27;t entirely wrong but it&#x27;s definitely not complete. Itanium failed because brilliant compilers didn&#x27;t exist and it was barely faster even with hand-tuned code, especially when you adjusted for cost, but that doesn&#x27;t mean that it doesn&#x27;t matter at all. I&#x27;ve definitely seen significant improvements caused by CPU family-specific tuning and, more importantly, when new features are added (e.g. SIMD, dedicated crypto instructions, etc.) a compiler or library which knows how to use those can see huge improvements on specific benchmarks. That was more what I had in mind since those are a great example of where Apple&#x27;s integration shines: when they have a task like “Make H.265 video cheap on a phone” or “Use ML to analyze a video stream” they can profile the whole stack, decide where it makes sense to add hardware acceleration, and then update their choice of the compiler toolchain and higher-level libraries (e.g. Accelerate.framework) and ship the entire  thing at the time of their choosing whereas AMD&#x2F;Intel&#x2F;Qualcomm and maybe nVidia have to get Microsoft&#x2F;Linux and maybe someone like Adobe on board to get the same thing done.<p>That isn&#x27;t a certain win — Apple can&#x27;t work on everything at once and they certainly make mistakes — but it&#x27;s hard to match unless they do screw up.')