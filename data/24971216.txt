Item(by='one-punch', descendants=None, kids=None, score=None, time=1604341148, title=None, item_type='comment', url=None, parent=24966574, text='&gt; This might be true, but when they were making the case for constructive types they didn&#x27;t mention it.<p>Agree.<p>&gt; The discussions seems to be mostly dependent types vs refinement types, which I&#x27;d argue is a false dichotomy.<p>You are right, I think I confused two notions:<p>1. constructive vs non-constructive reasoning.<p>2. intrinsic vs extrinsic types (aka Church vs Curry types[ 1]).<p>In general, intrinsic types are constructive (because Program-is-Proof due to Brouwer–Heyting–Kolmogorov and \nCurry–Howard and others).<p>But extrinsic types could also be constructive, esp. when the external static analyzer has access to the program, such as in refinement reflection [2] (as pointed out in the above Reddit comment thread).<p>[1]: <a href="https:&#x2F;&#x2F;lispcast.com&#x2F;church-vs-curry-types&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lispcast.com&#x2F;church-vs-curry-types&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;ucsd-progsys.github.io&#x2F;liquidhaskell-blog&#x2F;2016&#x2F;09&#x2F;18&#x2F;refinement-reflection.lhs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ucsd-progsys.github.io&#x2F;liquidhaskell-blog&#x2F;2016&#x2F;09&#x2F;18...</a><p>Then I think the author is arguing for constructive proofs, which come naturally with intrinsic types, or at least with extrinsic analyzers accessing program structures; and arguing against non-constructive (extrinsic) types, or anything detached from implementation.')