Item(by='3pt14159', descendants=None, kids=[24785081, 24775446], score=None, time=1602673368, title=None, item_type='comment', url=None, parent=24770954, text='I&#x27;m a little surprised this article and none of the contents here at the time of this writing mentioned inheritance.<p>The core reason I find OOP to be superior for most classes of business application development in general—and web development in particular—is that external dependencies and other high cost interfaces can be delegated to their own method or instance variable then called. In general, I avoid inheritance if there is a way to approach a problem with composition, but testing via fakes are much more reliable to make by inheriting the original class and overriding a method or setting a default initialization parameter then calling the rest of the constructor. This takes the pain out of so many parts of testing that it&#x27;s truly hard to understate.[0]<p>For example, say a library has a class that calls out to a third party service like S3 and an instance of that class is used in a business object in order to persist data. By introducing a fake that inherits from the library&#x27;s class but overrides it&#x27;s persistence method to effectively be a noop the rest of the validation, calculation, and other side effects that the instance does is conserved without the downside of waiting on a network call. It&#x27;s not perfect, for example it could miss validation or side effects that only exist on the external service (e.g., S3 could change a mime type based on some crummy AWS logic) but it&#x27;s a hell of a lot better than a mock that constantly lies to you about what its done. Furthermore, it&#x27;s actually extremely simple to code up, unlike pure fakes that need to return hard coded values for certain method calls.<p>I know that something akin to this is theoretically possible in functional languages, but I&#x27;ve found that in practice it&#x27;s more difficult. Though I appreciate other areas where functional languages shine, including situations with testing.<p>It&#x27;s kinda hard to discuss because it really depends on so much context and good judgement and I&#x27;ve seen truly great development teams use languages like Scala in situations where I would have used Python with Numpy &#x2F; Cython for speed. So don&#x27;t take this as some hard and fast pronouncement. Just the general observations of someone that&#x27;s been coding for decades and is reasonably well paid.<p>[0] I think the primary reason that I prefer integration testing over unit testing is that I&#x27;ve adapted to its shortcomings by the above approach.')