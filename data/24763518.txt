Item(by='pimeys', descendants=None, kids=None, score=None, time=1602578214, title=None, item_type='comment', url=None, parent=24758772, text='The problem what I see with serverless, is if you need to store your state into a database, the classic relational systems will not scale well to the problem.<p>pbBouncer[0] in transaction mode tries to solve the problem of limited connections by giving a connection from the pool  to a transaction. This has a limitation of not being able to reuse statements; e.g. they have to be deleted before the transaction is released, adding an extra roundtrip for the queries. It also means you must wrap every request into a transaction, if planning to use statements. Otherwise the solution is to sanitize all your values and concatenate a single SQL query. It has the big risks of SQL injections and is against all best practices, but this is what Active Record is doing to solve the issue, and I guess it works for them quite well.<p>pgBouncer has also the statement mode. Here you can&#x27;t use transactions and with that, no prepared statements either. So you must then just use the text protocol of the database and concatenate the parameters to your query.<p>Amazon has the RDS, and I haven&#x27;t looked into it that much yet. What I kind of think I know about it, is it pins the connections when using statements. Meaning, when pinned, the connection is for one client and cannot be reused until disconnected.<p>MySQL has the serverless-mysql package[1], which is a client side library killing of stale connections and disconnecting as fast as possible when done. So, basically during the request, it reads the system tables and tries to drop the connections from other sessions. I haven&#x27;t tried this either, but more I think about it, it really doesn&#x27;t feel like a good strategy at all. For one, you need a root access to the database for every client, and then you need to modify the state of other connections from the clients. There could be a bug in the client library, that is quite nasty to find and can cause really hard-to-fix issues.<p>Then the last thing is of course the locking of traditional relational databases. They don&#x27;t scale to massive concurrency that well; the MVCC chokes when running with many parallel queries[2]. So you need a distributed system, something that can have locking mechanisms that can scale to tens of thousands of sudden connections when the serverless system gets a request peak. Hopefully something with a stateless connection. If somebody knows a system that can do this, I&#x27;d like to hear about it.<p>[0]: <a href="https:&#x2F;&#x2F;www.pgbouncer.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.pgbouncer.org&#x2F;</a><p>[1]: <a href="https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;serverless-mysql" rel="nofollow">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;serverless-mysql</a><p>[2]: <a href="https:&#x2F;&#x2F;15721.courses.cs.cmu.edu&#x2F;spring2019&#x2F;papers&#x2F;02-transactions&#x2F;p209-yu.pdf" rel="nofollow">https:&#x2F;&#x2F;15721.courses.cs.cmu.edu&#x2F;spring2019&#x2F;papers&#x2F;02-transa...</a>')