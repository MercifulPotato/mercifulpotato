Item(by='ubercow13', descendants=None, kids=None, score=None, time=1604331352, title=None, item_type='comment', url=None, parent=24968116, text='Thanks for the detailed reply.<p>So, atomically{} is basically like a SQL transaction and would repeat or signify failure if it cannot commit the changes you make inside the code block, similar to a CAS lock-free algorithm. This seems quite limited though, you are basically constrained to writing code within the atomic block that deals with value types only, and with no side-effects. Otherwise how would the compiler or runtime know how to roll it back?<p>That sounds useful but doesn&#x27;t seem to cover all the use cases of thread synchronization by a long shot. Isn&#x27;t it also the case that even knowing how to implement interesting alrogithms in a lock-free manner is an area of significant ongoing research? For example I think only recently someone worked out how to implement a lock-free ring buffer (<a href="https:&#x2F;&#x2F;ferrous-systems.com&#x2F;blog&#x2F;lock-free-ring-buffer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ferrous-systems.com&#x2F;blog&#x2F;lock-free-ring-buffer&#x2F;</a>)')