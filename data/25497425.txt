Item(by='kazinator', descendants=None, kids=None, score=None, time=1608573466, title=None, item_type='comment', url=None, parent=25495205, text='But that&#x27;s the easy part of writing a compiler anyway. All we do is, right in the lexical analyzer (not ever the parser) look up the <i>person</i> identifier in the table of declared identifiers in the current scope. It then returns the identifier as a type-identifier, object-identifier or undeclared-identifier. These are then referenced in the grammar phrase structure rules as necessary.<p>I think there was an aspect of writing a C compiler that was easier, which was namely that certain optimizations in C were just left to the programmer. To get good code out of C, you depended on the basics, like decent instruction selection and peephole optimization, and jump-threading, and maybe elimination of dead code.<p>Then to otherwise get good code out of C, you stuffed multiple side effects into a single expression, which allowed the compiler the generate the computation and storage accesses any order without analyzing whether any particular order is correct (ensuring they are <i>all</i> correct was left to the programmer, who often didn&#x27;t care as long as the one compiler he or she were using gave them the right results).<p>Even the assignment of local variables to registers was programmer-hinted: C had the (now deprecated) <i>register</i> keyword. With the <i>register</i> keyword, your compiler just had to place those variables in registers which were marked with it, and screw the rest. No analysis about which ones should be in registers: particularly good in register-starved architectures. The microcomputer world was characterized mainly by register-starved architectures, with the notable exception of the Motorola 68K series.')