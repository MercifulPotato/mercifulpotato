Item(by='scottlamb', descendants=None, kids=None, score=None, time=1609719492, title=None, item_type='comment', url=None, parent=25625707, text='Conversely, more sophisticated algorithms, and particularly monomorphization, may bloat the code size, causing icache, L2&#x2F;L3 cache, and TLB misses. (Also slows compilation.) I think this is under-appreciated because it doesn&#x27;t show in microbenchmarks. (I wish I knew of an easy way to measure how much cache pressure you&#x27;re causing from a microbenchmark.)<p>I suspect for this reason it&#x27;d be better in Rust to use a Go-like hash map implementation [1] that keeps all the key&#x2F;value information (size, Hash and Eq implementations) in a vtable-like form rather than be monomorphized, except in really hot inner loops where the specialization is worth it. There was an interesting article and discussion on reddit relating to this [2] where someone made a toy type-erased map (though not as nice as Go&#x27;s) to measure the difference in compilation times. Maybe some day I&#x27;ll make a more production-ready attempt...<p>[1] <a href="https:&#x2F;&#x2F;dave.cheney.net&#x2F;2018&#x2F;05&#x2F;29&#x2F;how-the-go-runtime-implements-maps-efficiently-without-generics" rel="nofollow">https:&#x2F;&#x2F;dave.cheney.net&#x2F;2018&#x2F;05&#x2F;29&#x2F;how-the-go-runtime-implem...</a><p>[2] <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;g1skz4&#x2F;an_experiment_with_typeerased_datastructures&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;g1skz4&#x2F;an_experiment_...</a>')