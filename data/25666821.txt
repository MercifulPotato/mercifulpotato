Item(by='tharkun__', descendants=None, kids=None, score=None, time=1609989171, title=None, item_type='comment', url=None, parent=25662365, text='IDEs and languages that an IDE can exploit are awesome. Especially if you don&#x27;t really have such a good idea of a project (yet). It helps architects or contractors tremendously (as examples of people that might jump from one code base to another quite frequently).<p>What I mean is that I personally really like statically typed languages like Java and compile time safety. I even like some of &#x27;verboseness&#x27; that people always complain about. I can take a modern IDE and a Java project that hasn&#x27;t replaced everything with runtime magic yet (Spring comes to mind) and I can simply click my way through things to get the info I need and&#x2F;or to build a mental model. However, I don&#x27;t need a finished mental model already just to be effective at every task. Also refactorings that are really braindead simple and that you don&#x27;t even have to think about are possible, precisely because they&#x27;re simple and guaranteed to be correct.<p>Contrast that with other languages, such as Javascript, Python, Perl (yeah mentioning that because I loved Perl back when I was doing almost exclusively Perl - with a bit of shell scripting and lots of SQL - at my first &#x27;real&#x27; job), where you have to have a mental model already and you have to know certain &#x27;magic&#x27; to even be able to search for all the right things. Something that stuck in my head in that regard was AngularJS. I forgot the specifics but some type of identifier was use underscores in one place but dashes in another. How the eff am I supposed to find things easily? I have to know that magic conversion and grep for it specifically. If I come to a FE project written in Angular and have never done Angular, I will not find anything whatsoever and I have zero chance but to learn Angular to do basic things. And coming back to refactorings, even a simple rename can be a pain in the rear to do (and you won&#x27;t do it and be stuck with really bad naming) because you can&#x27;t be certain that you found all the right places to change until runtime i.e. your 2 a.m. batch run failed and you have users screaming at you. That teaches you to just stick with bad naming real fast.<p>Good languages and frameworks, if you ask me, allow someone that is senior in his role but a total noob with the specific language or framework to look at existing code and easily make certain modifications.<p>I wrote a simple T-SQL (Sybase, not MS-SQL) parser that output graphviz format to get a call graph of some backend job we had that consisted of a gazillion individual stored procedures strewn across a gazillion files and printed that and hung it up on the wall, just to be able to easily navigate that thing. Queue IDE where you just Ctrl-Click for the same end result.')