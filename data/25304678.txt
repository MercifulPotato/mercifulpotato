Item(by='gregmac', descendants=None, kids=[25305302, 25305390, 25306639], score=None, time=1607101099, title=None, item_type='comment', url=None, parent=25304207, text='&gt; My controversial opinion is that most software tests should be integration tests that use randomized inputs. I doubt I&#x27;ll get very many upvotes for that idea.<p>Probably not, but largely because you used the word &quot;randomized&quot;. One of the most annoying things to deal with in a CI workflow is flaky tests (where something unchanged will randomly fail, or re-running will result in a different outcome).<p>The most common way I&#x27;ve seen this happen is with an external dependency like using a database server or calling a 3rd party API. The failure is usually temporary (eg: timeout) and so it&#x27;s a false negative. This trains developers to do a lazy workaround: re-run the build until it passes.<p>True &quot;randomized&quot; data has the possibility that you get all kinds of flaky tests, but that they cause false positives: the failures are legitimate, passing is not.<p><i>Pseudo</i>-randomized [1] data is a different story (see: fuzzing [2]), because you still have predictable tests -- the difference is a human doesn&#x27;t have to think up thousands of test cases. I&#x27;d say it&#x27;s also important to add specific test cases when you do find a specific type of failure, just to be sure that always gets tested.<p>I think if you call it &quot;pseudo-random&quot; or &quot;fuzz testing&quot; you&#x27;ll find it&#x27;s much less controversial.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pseudorandomness" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pseudorandomness</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fuzzing" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fuzzing</a>')