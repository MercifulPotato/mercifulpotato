Item(by='GlitchMr', descendants=None, kids=[24721256, 24720914], score=None, time=1602173221, title=None, item_type='comment', url=None, parent=24719996, text='Rust doesn&#x27;t prevent memory leaks.<p>However, it may help in this specific case.<p>In your example you are iterating over `m_requests_to_process`. As you are using `auto` instead of `auto &amp;` it automatically clones the elements of a vector. In Rust, it&#x27;s not possible to clone an element by accident. Objects are moved by default (think `std::move`) and if you want to clone instead you need explicitly use `.clone()`.<p>If `do_stuff` function takes ownership of a request (as in, if it takes `Request` parameter and not `&amp;mut Request` parameter) than the problem will be pointed by Rust, and so the compiler wouldn&#x27;t allow you write code like this forcing programmer to write code that removes elements from the list to take ownership of them. For example:<p><pre><code>    for req in mem::take(&amp;mut self.requests_to_process) {\n        do_stuff(req);\n    }\n</code></pre>\n`mem::take` (<a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;mem&#x2F;fn.take.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;mem&#x2F;fn.take.html</a>) replaces an object behind a mutable reference with a default value for a given type (empty vector in case of vectors) and gives you an ownership over vector.')