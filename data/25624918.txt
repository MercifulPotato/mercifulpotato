Item(by='Traster', descendants=None, kids=[25625085, 25625021, 25626149, 25627401], score=None, time=1609705691, title=None, item_type='comment', url=None, parent=25623305, text='I hate to be that bucket of cold water, but there&#x27;s <i>multiple</i> reasons FPGAs haven&#x27;t been successful in package with CPUs. Firstly, the costs of embedding the FPGA - FPGAs are relatively large and power hungry (for what they can do), if you&#x27;re sticking one on a CPU die, you&#x27;re seriously talking about trading that against other extremely useful logic. You really need to make a judgement at purchase time whether you want that dark piece of silicon instead of CPU cores for day to day use.<p>Secondly, whilst they&#x27;re reconfigurable, they&#x27;re not reoconfigurable in the time scales it takes to spawn a thread, it&#x27;s more like the same scale of time to compile a program (this is getting a little better over time). Which makes it a difficult system design problem to make sure your FPGA is programmed with the right image to run the software programme you want. If you&#x27;re at that level of optimization, why not just design your system to use a PCI-E board, it&#x27;ll give you more CPU, and way more FPGA compute and both will be cheaper because you get a stock CPU and stock FPGA, not some super custom FPGA-CPU hybrid chip.<p>Thirdly the programming model for FPGAs are fundamentally very different to CPUs, it&#x27;s dataflow, and generally the FPGA is completely deterministic. We really don&#x27;t have a good answer for writing FPGA logic to handle the sort of cache hierarchy, out of order execution that CPUs do. So you&#x27;re not getting the same sort of advantage that you&#x27;d expect from that data locality. It&#x27;s very difficult to write CPU&#x2F;FPGA programs that run concurrently, almost all solutions today run in parallel - you package up your work, send it off to the FPGA and wait for it to finish.<p>Finally, as others have said - the tools are bad. That&#x27;s relatively solvable.<p>For me, it boils down to this, if you have an application that you think would be good on the same package as a CPU, it&#x27;s probably worth hardening it into ASIC (see: error correction, Apple&#x27;s AI stuff). If you have an application that isn&#x27;t, then a PCI-E card is probably a better bet - you get more FPGA, more CPU and you&#x27;re not trading the two off.')