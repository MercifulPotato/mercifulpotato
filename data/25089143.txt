Item(by='patrec', descendants=None, kids=None, score=None, time=1605313452, title=None, item_type='comment', url=None, parent=25088199, text='&gt; Curious. To me this is the worst thing you could ever do. Talking via streams to say `cat file.txt | grep ERROR | wc -l` is cool. But you could do SOOO much more, if programs would actually output structured data streams.<p>A lot of people have had this thought over the decades, but it hasn&#x27;t really happened -- powershell exists for linux, but who&#x27;s using it? The genius of the primitive representation (stringly typed tables) is that it has just enough structure to do interesting processing but not enough to cause significant mental overhead in trying to understand, memorize and reference the structure.<p>Case in point of the difficulties of adding more structure without wrecking immediacy of manipulation is json.<p>For anything with more than 1 level of nesting, I do stuff like<p><pre><code>    blah | jq . | grep -C3 ERROR\n</code></pre>\nprobably a lot more than I do<p><pre><code>    blah | jq $SOME_EXPRESSION\n</code></pre>\nbecause it&#x27;s just so much less mental overhead -- I don&#x27;t have to think about indexing into some complex hierarchy and pulling out parts of it.<p>I&#x27;m not saying it&#x27;s not possible to get out of this local optimum, but it appears to be a lot more subtle than many people seem to think. There may be an simple and elegant solution, but it seems it has so far escaped discovery. Almost five decades later, composing pipelines of weakly structured and typed bytes (that, by convention, often are line separated tables, possibly with tab or space seperated columns) is still the only high-level software re-use via composition success story of the whole computing field.')