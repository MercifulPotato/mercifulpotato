Item(by='brundolf', descendants=None, kids=None, score=None, time=1609655258, title=None, item_type='comment', url=None, parent=25616593, text='The most insightful way I&#x27;ve ever heard Go described is as a &quot;C fanfic&quot;. It&#x27;s like a bunch of C programmers, writing software for web infrastructure, got together and made a wish-list of things they wanted to be different about C (specifically in the context of writing web infrastructure). And then they made a new language, taking the most direct path toward that wish-list, and inheriting most of C&#x27;s other traits as a matter of course.<p>Taken in this light, Go makes a ton of sense. No undefined behavior! Well-defined zero values! Duck typing! Automatic memory management with minimal overhead! Easy-to-use threading primitives and trivial cross-platform builds! A networked-C programmer&#x27;s dream.<p>But we&#x27;ve learned a whole lot about language design in the past 40 years, and combining those things we&#x27;ve learned with a loosening of C&#x27;s constraints, there are much better fundamental design decisions that can be made for a greenfield language. It just seems like Go&#x27;s designers weren&#x27;t really interested in questioning a bunch of the ones they were used to.')