Item(by='WorldMaker', descendants=None, kids=None, score=None, time=1605116328, title=None, item_type='comment', url=None, parent=25055014, text='async&#x2F;await has underpinnings in monadic computation expressions (via F#&#x2F;Haskell). There are some benefits to the model, despite a lot of its detractors in the thread here. Such as it is possible to work with multiple monads (many languages that support async&#x2F;await are not strict about which monad they rewrite for; C# supports any Monad that has a GetAwaiter() method of the right shape, JS supports any object with a then() and&#x2F;or catch() of the right shape, etc).<p>While async&#x2F;await is nowhere structurally as capable&#x2F;composable as for instance Haskell&#x27;s do notation, it&#x27;s still more composable than a lot of alternatives and a lot of manual thread management techniques.<p>The biggest thing though is that these concerns are orthogonal. You can have green threads backing an async&#x2F;await monad (with some caveats), but you can&#x27;t as easily swap in anything that follows monad rules into code written specifically just for green threads. (Python makes you explicitly define your threading model before using async&#x2F;await; the others provide methods to configure it.)<p>Which is to say &quot;late birth&quot; isn&#x27;t really a consideration in async&#x2F;await, it&#x27;s as much a consideration of flexibility&#x2F;composition of abstractions. JS, for example, needed that flexibility&#x2F;composition in the wild west of multiple disparate Promise implementations early on, and may need it again if&#x2F;when Browsers ever decide to support proper multi-threading whether it is green threads or something else. In such a future you should still be able to compose existing async&#x2F;await code without modifying it, even as you take advantage of newer threading options.')