Item(by='pradn', descendants=None, kids=None, score=None, time=1601656948, title=None, item_type='comment', url=None, parent=24662089, text='The ordering keys feature supports a large number of keys (though since the throughput limit is 1 MB&#x2F;sec per key, many applications shouldn&#x27;t have issues scaling up on a given key).<p>Imagine you have an order processing system where you have to 1) write to a database 2) write to a metrics log 3) and send an email to the customer. You can publish a message with the ordering key being the user who initiated the order. This means you are guaranteed to see message 1 before 2, which is seen before 3.<p>You do have to account for possible message re-deliveries. In this example, you can 1) write to the database with a order&#x27;s unique ID (to prevent duplicate rows) 2) be fine with duplicates for metrics since a bit of duplication is okay (or maybe you have a job later that removes duplicates offline) 3) and be okay with sending emails to customers twice (pretty harmless). You may also keep a side-cache of processed messages to reduce the processing of duplicates, but that&#x27;s a bit heavy and may not be necessary.<p>What Cloud Pub&#x2F;Sub with ordering keys gets you in this scenario is 1) durability of published messages 2) scalability across keys 3) ordering between messages in a key 4) retries in case one step fails 5) buffering in case your subscribers are slow or down 6) a fully hosted service (no dealing with your own cluster, scales automatically) 7) global availability (no need to shard your subscription by region, simplifying your app).<p>Disclaimer: I work on Cloud Pub&#x2F;Sub, but this explanation is my own.')