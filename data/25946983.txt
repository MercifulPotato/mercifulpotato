Item(by='dkersten', descendants=None, kids=None, score=None, time=1611860033, title=None, item_type='comment', url=None, parent=25943712, text='Take this contrived presudocode example:<p><pre><code>    result = []\n    for frob in Frob.get_all(where=something) {\n        if frob.foo = expected {\n            result = {\n                frob: frob,\n                quux: Quux.get_all(where=some-query-using-frob)\n            }\n            results.append(result)\n</code></pre>\nBasically, the idea is that you fetch some data and check some condition or do some calculation on it, then fetch more data based on this condition&#x2F;calculation. This entire thing could be a single logical process.<p>The only reason there&#x27;s a separation of concerns here is because some of this is done in the database and some in the application. Logically, its still part of the same calculation.<p>But the ORM hides this distinction and makes both the part that runs in the database and the part that runs locally look the exact same and super easy to intermingle. Worse still if you access properties on your ORM-result-object which actually trigger further queries to get. It looks like a field access, but is actually a database query. I&#x27;ve seen this cripple performance.<p>In many cases, if you step back and don&#x27;t think about it in terms of application code, but rather the data access and transformations that you want to achieve, then it can be rewritten as a query (joining related data in as needed etc). At the very least, it makes you aware of what the boundaries are.<p>I&#x27;m not saying that scrapping the ORM will magically make the problems go away and I know people also write terribly intermingled application and database logic when using SQL, but at least the boundary is more explicit and the different sides of the boundary actually look different instead of just looking like application code.<p>My point isn&#x27;t that there&#x27;s a silver bullet, but that we can nudge and encourage people to write better code by how the languages&#x2F;libraries&#x2F;tools structure solutions.<p>I&#x27;m also not necessarily saying that we have to use SQL instead of an ORM, that&#x27;s just one possible suggestion that I personally find works due to the mental separation. I&#x27;m sure you can design ORM&#x27;s that make the boundaries more explicit, or design frameworks that encourage thinking about application boundaries more explicitly. Same as how I&#x27;m not actually suggesting to get rid of OOP, just... if most people&#x27;s OOP is so-called <i>&quot;Bad OOP&quot;</i>, then we need to think about how to improve OOP, because changing &quot;most people&quot; is just not going to happen.')