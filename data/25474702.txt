Item(by='ncmncm', descendants=None, kids=None, score=None, time=1608348212, title=None, item_type='comment', url=None, parent=25471424, text='Any Design Pattern identifies a failing in the core language or its standard library.<p>Were the language up to the job, the pattern would have been captured in a named library component, and no longer be a Pattern at all. Use of a well-designed and -tested library component is <i>always</i> better than re-coding the pattern again at each new use.<p>A classical example is the hash table. In C, and similarly limited languages, you <i>cannot</i> write a useful hash table library. Instead, custom hash tables are re-coded over and over again in thousands of individual programs and libraries wherever they are needed.<p>In other, similarly limited languages, the pattern is pulled into the core language, as a &quot;dictionary&quot; or &quot;map&quot; type, eliminating most need to re-code it, at the expense of flexibility in its design.<p>In more expressive languages like C++ and Rust, hash table libraries arise, and the most commonly useful forms appear in the standard library.<p>We have continually added to C++ and its library as we have identified patterns. New patterns arise in composing existing features and library components, so adding to them creates new opportunties for patterns to arise. As each new pattern is identified, it may be captured. Sometimes this demands new core language support for abstraction, as is seen in new Concepts and Coroutines core features. So, we naturally expect to see new library components that use the new features in commonly seen ways.<p>The expected addition of pattern matching to core C++, similarly to what appears in Rust and certain other languages, represents a <i>lapse</i>: a failure to discover and specify core language features to add that would enable implementing usefully general pattern matching as a family of library components. Conflict over, e.g. simplicity vs  generality, in design of the core feature is unavoidable, where, were it implementable as a library, different choices could be captured as different library components.<p>Anytime we lapse and fail to discover core language primitives needed to implement a high-level construct, we shoukd remember and see each use of it as a rebuke, and motivation to invent core features that would have made it redundant.')