Item(by='NMDaniel', descendants=None, kids=None, score=None, time=1608837773, title=None, item_type='comment', url=None, parent=25522471, text='You&#x27;re talking about the runtime aspects of executing concurrent code (OS threads vs green threads) but these are orthogonal to the idea of async APIs, which are one way of modelling concurrent programming flows.<p>For example, futures in Rust can be used with both OS threads and lightweight tasks. Tokio is mostly agnostic about the choice of the executor.<p>It definitely takes some time to grok async Rust (even if you come from C#&#x2F;JS), but I think it really shines once you get to know it, similar to the benefits you get from learning\nabout iterators &amp; higher level functions as opposed to plain loops.<p>For instance, I&#x27;ve recently implemented the Raft protocol as part of a distributed algorithms course. Using Tokio and a single threaded executor made the implementation fairly readable, mostly relying on few async constructs(futures, tasks, channels and select loops) to model fairly complex behavior (bidirectional messaging, multiple states, timeouts, etc..)\nDoing so in a more traditional callback oriented style would&#x27;ve required maintaining a very complex state machine(in addition to the state machine of the algorithm itself)<p>Also, Async&#x2F;Await originated in C#, a language which already supports threads(and many other concurrency models), not JavaScript which historically relied on callbacks')