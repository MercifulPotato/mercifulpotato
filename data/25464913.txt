Item(by='SloopJon', descendants=None, kids=None, score=None, time=1608278642, title=None, item_type='comment', url=None, parent=25459846, text='I ported some null-heavy Java code to C++.  The source frequently returns an object, or null in case of error; e.g.,<p><pre><code>    BigInteger bi = rational.asBigInteger();\n    if (bi != null) {\n        ...\n    }\n</code></pre>\nOne of the classes is essentially a node in a graph, so in my first pass its objects were wrapped in a shared_ptr, which can be null.  However, objects of the other two types are typically passed by value in C++, so I had to think about that.  Exactly what std::optional was designed for, but do I want to require C++17, both in the implementation and the public interface?  The syntax looks nice enough:<p><pre><code>    if (auto bi = rational.asBigInteger()) {\n        ... &#x2F;&#x2F; bi is like a non-null pointer\n    }\n</code></pre>\nJava has java.util.Optional, but the source predates Java 8.<p>TypeScript&#x27;s type guard approach is really clever.  Once you&#x27;ve checked the value, you can use it like normal.  No need for a wrapper class, or different syntax.')