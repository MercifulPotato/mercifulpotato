Item(by='Jweb_Guru', descendants=None, kids=[24794487], score=None, time=1602795456, title=None, item_type='comment', url=None, parent=24793007, text='I enjoy pedantry too, so I guess I kind of understand why you keep making this point.  However, it&#x27;s not relevant to what the OP asked, which was about the mathematical modeling of C functions that return void, rather than trivia related to C syntax.  In the two positions in C and C++ that I discussed, the domain and codomain of a function, void is functionally identical to unit, despite your protestations to the contrary (there is literally no semantic distinction between them).  In Rust, none of these restrictions exist and we can freely use unit in all the ways you described, but in the domain and codomain of a function it still works just like void does in C (we can&#x27;t cast from arbitrary types to void, but this is more because Rust takes a hard stance against stupid casts than because it would be difficult to implement, and it has other ways of representing deliberately throwing away a value).<p>The C standard, of course, may disagree, and claim that there is no value of type &quot;void&quot; and that void functions &quot;have no return type.&quot;  That I can call and successfully return from a void function, call a function taking void, and even cast a value to void, provide ample evidence (which would also be backed up by reading the standard) that what it means by &quot;type&quot; is not the same thing as what a mathematician means by &quot;type&quot; (and &quot;completed&quot; is a complete red herring here).  The fact that you don&#x27;t explicitly return a void value doesn&#x27;t really mean anything--no return or return with no value are pure syntactic sugar for returning a void value, which is also how it&#x27;s implemented in many other languages that enjoy explicit unit types.<p>What I can&#x27;t do in C is <i>bind</i> one of the many values of type void to a variable (and do a few other things, like call `sizeof` on the type, or explicitly name the inhabitant of void as a literal, which again have pretty much nothing to do with the semantics of the thing).  That is a much weaker restriction, for the same reason that defining a binding as `const` is much weaker than a guarantee that the underlying value isn&#x27;t mutated; bindings are a largely syntactic artifact and don&#x27;t affect the mathematical model of a C function in any way.  This is especially true for unit types, since having an instance of one is completely uninformative as they both always exist and are all definitionally equal!<p>Of course, this doesn&#x27;t apply to void * , which as you point out is really its own bizarre thing that is mostly unrelated to void itself (I&#x27;d like to call it a pointer to the top type, but I&#x27;m not certain even that would cover its semantics).  I think it&#x27;s fair to say that despite some degree of overlap, void * is an unrelated concept overloading the &quot;void&quot; keyword, and that the actual interpretation of bare &quot;void&quot; is indeed equivalent to unit, not that every other use of `void` in C is completely arbitrary and unprincipled.  The reason, AFAIK, why C doesn&#x27;t just add all those void-related features it&#x27;s missing is because it has baked in decisions like &quot;every type has a nonzero size&quot; and &quot;arrays are pointers&quot; (conflicting with void * ) that make adding stuff like this after the fact very complicated, not because it wouldn&#x27;t make sense semantically (in a proper semantic model, where void * was called something like any * and zero sized types were legal, many of these issues would go away, including--I&#x27;m pretty sure--all the reasons why C and C++ must insist that void values not be completed).  In any case, none of this helps with or is relevant to reasoning about C functions as mathematical objects.<p>And just to be extra clear--even if C had no keyword at all for `void` functions and didn&#x27;t have `void` as an option for argument lists, these functions would <i>still</i> be modeled as taking &#x2F; returning values of type unit.')