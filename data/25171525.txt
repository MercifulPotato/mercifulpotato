Item(by='mildbyte', descendants=None, kids=None, score=None, time=1605982706, title=None, item_type='comment', url=None, parent=25170983, text='Couple reasons:<p>We don&#x27;t actually have a massive PostgreSQL instance with all the datasets: we store them in object storage using cstore_fdw. In addition, we can have multiple versions of the same dataset. Basically, when a REST query comes in, we build a schema made out of &quot;shim&quot; tables powered by our FDW [1] that dynamically loads table regions from object storage and point the PostgREST instance to that schema at runtime.<p>When we were writing this, PostgREST didn&#x27;t support working against multiple schemas (I think it does now but it still only does introspection once at startup), so we made a change to PostgREST code to treat the first part of the HTTP route as the schema and make it lazily crawl the new schema on demand.<p>Also, at startup, PostgREST introspects the whole database to find, besides tables and their schemas, also FK relations between tables. This is so that you can grab an entity and other entities related to it by FK with a single query [2]. In our case, we might have thousands of these &quot;shim&quot; tables in a database, pointing to actual datasets, so this introspection takes a lot of time (IIRC it does a giant join involving pg_class, pg_attribute and pg_constraint?). We don&#x27;t support FK constraints between different Splitgraph datasets anyway, so we removed that code in our fork for now.<p>[1] <a href="https:&#x2F;&#x2F;www.splitgraph.com&#x2F;docs&#x2F;large-datasets&#x2F;layered-querying" rel="nofollow">https:&#x2F;&#x2F;www.splitgraph.com&#x2F;docs&#x2F;large-datasets&#x2F;layered-query...</a><p>[2] <a href="https:&#x2F;&#x2F;postgrest.org&#x2F;en&#x2F;v7.0.0&#x2F;api.html#resource-embedding" rel="nofollow">https:&#x2F;&#x2F;postgrest.org&#x2F;en&#x2F;v7.0.0&#x2F;api.html#resource-embedding</a>')