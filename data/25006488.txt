Item(by='lipanski', descendants=None, kids=[25007065], score=None, time=1604657212, title=None, item_type='comment', url=None, parent=25005780, text='There are a couple of points where Crystal really feels cleaner and somehow more expressive than Ruby.<p>The authors of the language avoided aliases (no more size vs. length or inject vs. reduce discussions) and generally there&#x27;s only one way to do things (Strings are always wrapped in double quotes).<p>Crystal has abstract classes&#x2F;modules&#x2F;methods, generics and method overloading, three powerful techniques which are missing in Ruby entirely and which can be very helpful in some cases.<p>You can mark global methods as private and you can also mark classes as private. The latter can prevent users of your &quot;shard&quot; (gem) from accessing such classes, pretty much like how Rust modules can be marked for external use or not.<p>Constructor arguments can be turned into instance variables automatically, if you add `@` to the argument names.<p>Marking a construct as private happens inline with the definition, unlike in Ruby where it functions as a divider. This makes your code a bit easier to read and you can group methods in any way you like.<p>I find the built-in JSON, YAML and XML parsers to be very elegant. For the common use cases, you just have to define normal classes with attributes and include the JSON::Serializable module - this will also traverse attributes in search of serializable types. You can also do more complex transformations with annotations - have a look at <a href="https:&#x2F;&#x2F;crystal-lang.org&#x2F;api&#x2F;0.35.1&#x2F;JSON&#x2F;Serializable.html" rel="nofollow">https:&#x2F;&#x2F;crystal-lang.org&#x2F;api&#x2F;0.35.1&#x2F;JSON&#x2F;Serializable.html</a> - but writing an HTTP client for some random API in Crystal feels very natural. On top of that, the built-in HTTP client is more than decent (which I can&#x27;t say about Net:HTTP).<p>Generally the standard library is packed with goodies and, though the ecosystem is scarce in some areas, it&#x27;s usually easy to replace and you can get away with less dependencies.<p>The inferred static typing which allows for union types is a neat choice - it doesn&#x27;t force you to write types (most of the times) but it does give you some guarantees. I personally prefer to explicitly name my types, especially in public method definitions, because it helps document the code without having to write anything on top, but it&#x27;s up to you.<p>To be honest I&#x27;m not really missing the metaprogramming aspect. In large Ruby projects this can easily turn into a mess and it makes searching through your codebase a horrid experience. Crystal does have macros but they have some limitations (they operate at compile-time).<p>Performance is just amazing and you can also build static binaries.<p>If you like Ruby, I&#x27;d really encourage you to give it a try, at least as an experiment to an &quot;alternative Ruby&quot;.<p>To conclude, here are some code samples (shameless plug, but you can also browse <a href="https:&#x2F;&#x2F;crystalshards.xyz&#x2F;" rel="nofollow">https:&#x2F;&#x2F;crystalshards.xyz&#x2F;</a> for other projects):<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;defense-cr&#x2F;defense&#x2F;blob&#x2F;master&#x2F;src&#x2F;defense&#x2F;store.cr" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;defense-cr&#x2F;defense&#x2F;blob&#x2F;master&#x2F;src&#x2F;defens...</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;defense-cr&#x2F;defense&#x2F;blob&#x2F;master&#x2F;src&#x2F;defense&#x2F;throttle.cr" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;defense-cr&#x2F;defense&#x2F;blob&#x2F;master&#x2F;src&#x2F;defens...</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;lipanski&#x2F;kilometric&#x2F;blob&#x2F;master&#x2F;src&#x2F;kilometric.cr#L32-L58" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;lipanski&#x2F;kilometric&#x2F;blob&#x2F;master&#x2F;src&#x2F;kilom...</a>')