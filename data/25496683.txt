Item(by='abernard1', descendants=None, kids=[25498810], score=None, time=1608569551, title=None, item_type='comment', url=None, parent=25496544, text='&gt; Don&#x27;t forget that the first project to popularize distributed map-reduce, Hadoop, was a Java project.<p>Yeah, but that required everybody learning a different style of programming that wasn&#x27;t OO ;-).<p>The problem is for &quot;map&quot;, you have to get rid of shared state and the interleaving of state and time.  Interleaving state and time is basically the only thing objects do beyond providing a namespace and polymorphism.  There&#x27;s also an inherent 1-ary behavior in most OO code.  If you&#x27;ve got a complicated object graph, making something a bulk N-ary operation is non-trivial.  A lot of ORMs have this problem when trying to optimize queries.  When you&#x27;re passing a vector of &quot;state&quot; to a function, it&#x27;s much easier to make things bulk.  (Anyone who&#x27;s had to make legacy code provide a bulk API with an efficient DB insert operation knows what I&#x27;m talking about).<p>What you usually get in Ruby is a bunch of code that&#x27;s like Duck.quack() and a complex set of things below that interface.  What you need for data processing is something like quack(ducks[]).  The way of parallelizing real-deal objects keeping them objects is with actors, and then you need to worry about distributed state a lot more.<p>Anyhoo, that&#x27;s a long way of saying that the much-derided procedural or functional style of Python avoids this problem from the get-go.  You can just slap the &quot;map&quot; step onto a stream processing system without cutting your graph into pieces that don&#x27;t share state.')