Item(by='timholy', descendants=None, kids=None, score=None, time=1602319996, title=None, item_type='comment', url=None, parent=24729471, text='I appreciate your well-balanced critique, thanks.<p>&gt; Julia (at least by default) is constantly recompiling everything. This is a huge pain in a REPL style setup where you want to tweak one thing and see the changes, again and again. I know the Julia ecosystem is working on better caching etc to fix this problem but it’s a problem.<p>Maybe try Revise.jl? There are a few changes it can&#x27;t handle, but you can do a lot of development without ever restarting. (Disclaimer: I&#x27;m its main author.)<p>&gt; expertly crafted C usually beats Julia in performance<p>This isn&#x27;t generically true, and there are now quite a few examples of the converse. I linked to it above as well, but check out the benchmarks in LoopVectorization&#x27;s documentation (<a href="https:&#x2F;&#x2F;chriselrod.github.io&#x2F;LoopVectorization.jl&#x2F;latest&#x2F;examples&#x2F;matrix_multiplication&#x2F;#Matrix-Multiplication-1" rel="nofollow">https:&#x2F;&#x2F;chriselrod.github.io&#x2F;LoopVectorization.jl&#x2F;latest&#x2F;exa...</a>) for examples of beating MKL, one of the most carefully-engineered libraries in existence.<p>I think an exciting area of growth for Julia will be exploiting the fact that Julia&#x27;s compiler, written mostly in Julia, is more &quot;morphable&quot; than most and may develop its own plug-in architecture. This seems likely to provide performance opportunities that many fields seem hungry for.<p>&gt; the Julia libraries are just not as mature as python’s<p>On balance I agree. While there are already many examples where Julia makes things easier than Python, as of today there are many more examples to the contrary. Julia&#x27;s libraries are advancing rapidly, but I expect it will take a few more years of development until it&#x27;s no longer so one-sided.')