Item(by='textmode', descendants=None, kids=[24714564, 24714210], score=None, time=1602114206, title=None, item_type='comment', url=None, parent=24713008, text='Glad others are starting to articulate this issue.  HTTP&#x2F;3 is derived from HTTP&#x2F;2.  Google&#x27;s main argument for HTTP&#x2F;2&#x27;s existence, its selling point to users, is head-of-line blocking in HTTP&#x2F;1.1 pipelining.  They also complain about the size of repeated HTTP headers.<p>But no modern browsers actually use HTTP&#x2F;1.1 pipelining. Interestingly, HTTP&#x2F;1.1 pipelining works great for non-browser use.  Most web servers enable it by default.  After all, it works.  For example requesting a series of pages from multi-page website, all under a single TCP connection. I have been using HTTP&#x2F;1.1 pipeplining this way for decades.  It is fast and reliable and enables the web to be used as a non-interactive, information retrieval source.  <i>It is also 100% ad-free.</i>  The user only gets what she requests, nothing more.<p>As for HTTP headers, privacy-conscious or minimalist users might not send many headers, only the minimum to retrieve the page.  That&#x27;s usually up to three extra lines of text per page for the request headers.  (I rarely ever have to send a User-Agent header for HTTP&#x2F;1.1 pipelining.)<p><pre><code>   GET &#x2F;index.html HTTP&#x2F;1.1\n   Host: example.com\n   Connection: keep-alive\n</code></pre>\nObviously, the web advertising&#x2F;tracking industry, including companies like Google that serve this sector, use headers for <i>their own purposes</i>.  Online advertising services.  That&#x27;s when presumably they could get big.  However, as a user, I have no pressing need for the ability to send&#x2F;receive larger headers.<p>Websites (IPs represented by domain names) to which users intentionally connect, i.e., the recognisable names that they type and click on, generally don&#x27;t serve ads.  The ads come from other domains, often other servers.  Users generally do not intentionally try to connect to ad or tracking servers.  HTTP&#x2F;[01].x&#x27;s automatic loading of resources, Javascript and other techniques may be used to make those requests, conveniently under the radar and outside the user&#x27;s awareness.<p>Still, under HTTP&#x2F;1.1, ads, nor Javascript files that trigger requests for ads, generally cannnot be delivered without the user&#x27;s computer making a request first. Users can and do manage to exercise some control over their computers and they can prevent these non-interactive requests from being sent, from inside and outside the browser.<p>With HTTP&#x2F;2 and HTTP&#x2F;3, the necessity of a user-generated request disappears.  As soon as the user &quot;connects&quot; (UDP) to the website&#x27;s server, the server could for example send a Javascript file to the user&#x27;s browser which can in turn trigger requests to other domains for ads or the purpose of tracking, all without any preceding request for the ad&#x2F;tracking-related Javascript file.  This is another feature of HTTP&#x2F;[23] called &quot;server push&quot;, but interestingly it is not the feature being used to sell HTTP&#x2F;[23] to users (i.e., pipelining).<p>So, how does a user stop unwanted ads being &quot;pushed&quot; upon her in the stream (irrespective of the application, e.g., browser)?  I generally don&#x27;t use a &quot;modern&quot; browser, nor Javascript nor graphics.  I like my pipelining outside the browser and free of advertising-related cruft.<p>It&#x27;s worth considering that the motivation for speeding up websites via HTTP&#x2F;[23] is solely for the purpose of speeding the delivery of more ads, more &quot;stealthily&quot;, to users.  This is a classic case of someone trying to sell you on a &quot;solution&quot; to a problem they themselves have created (or to which they are contributing).<p>Like an ISP trying to upsell customers to faster internet in order that websites bogged down with ads will &quot;load&quot; faster.  When the ISP itself injects ads into pages of websites that are weighed down by ads.')