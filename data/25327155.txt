Item(by='wanderer2323', descendants=None, kids=None, score=None, time=1607293082, title=None, item_type='comment', url=None, parent=25326552, text='Let&#x27;s draw a list<p><pre><code>  IntListItem -&gt; IntListItem -&gt; IntListItem\n</code></pre>\nand then draw the position of the list head:<p><pre><code>  IntList -&gt; IntListItem -&gt; IntListItem -&gt; IntListItem\n</code></pre>\nYou can see that the if-branch in the cs101 answer comes because there is a (&#x27;virtual&#x27;) element of the list (the IntList head) that is different from the other elements of the list.<p>If we were to make them the same (C# code):<p><pre><code>  interface IListItem \n  {\n     IntListItem Next {get;set;}\n  }\n\n  class IntListItem : IListItem\n  {\n     int Value {get; set;}\n     IntListItem Next {get; set;}\n  }\n\n  class IntList : IListItem\n  {\n     IntListItem Head {get; set;}\n     IntListItem Next \n     {\n        get { return Head; }\n        set { Head = value; } \n     }\n  }\n</code></pre>\nthen our cs101 code simplifies itself, folding into a prettier algorithm:<p><pre><code>  void remove_cs102(IntList l, IntListItem target)\n  {\n     IListItem p = (IListItem) l;\n     while (p.Next != target) \n     { \n        p = (IListItem) p.Next;\n     }\n \n     p.Next = p.Next.Next;\n  }\n</code></pre>\nthe use of indirect pointers was masking the real issue: some algorithms <i>look</i> better if you add a virtual head (or a virtual tail) to your linked list. Emphasis on <i>look</i> though -- they work almost the same.')