Item(by='Jtsummers', descendants=None, kids=None, score=None, time=1602620826, title=None, item_type='comment', url=None, parent=24767803, text='Legacy systems aren&#x27;t just <i>old</i>. Old systems that are maintained aren&#x27;t the legacy systems that create problems, and really aren&#x27;t legacy systems at all (just old).<p>It&#x27;s the old systems that &quot;just work&quot; until they don&#x27;t. Where they run on old hardware, and the compiler is possibly on something even older. You can&#x27;t port them to a new system because you may not have a compiler or even the source code. Or the source code is heavily dependent on the original physical hardware. Maybe it runs in a VM, if it was on an IBM mainframe it probably does. But that doesn&#x27;t fix the problem of old code that can&#x27;t be easily altered at this point in time.<p>I like Michael Feathers&#x27; definition of legacy code being code without tests. But it&#x27;s not just tests, it&#x27;s comprehensibility and (to a lesser extent) portability. Tests help to make a system comprehensible and portable. Since architecting for testing requires better modularity which makes things both more portable and more comprehensible in most cases. Portability means proper abstraction over the hardware or other things so that the core logic is separable. Imagine if the IRS&#x27;s tax system were written in this way, where the hard-to-port part would be the interface with databases and networks, but the core part would be easily portable (or more easily portable) to another OS because it&#x27;d be properly separated. We could port that core to another system and change how it gets called more easily. But if you tied your software to a specific DB or a specific storage medium (like it <i>has</i> to be a tape drive, or something that behaves like one) you&#x27;ve reduced portability, and created the start of a legacy system.')