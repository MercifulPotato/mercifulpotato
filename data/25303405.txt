Item(by='ragnese', descendants=None, kids=[25303677], score=None, time=1607096198, title=None, item_type='comment', url=None, parent=25303214, text='&gt; This is not what Loom does, though. Virtual threads are not using the thread API. They are (Java) threads; no more and no less than today&#x27;s threads. Just as people don&#x27;t normally use the java.lang.Thread API directly to use today&#x27;s threads, there&#x27;s no reason why they should use it with virtual threads.<p>Right. That&#x27;s fair. They are threads, but it&#x27;s just that now you have two &quot;kinds&quot; of Thread, where before you had one (AFIAK). I like the analogy to &quot;virtual memory&quot; of an OS, but can applications ask for &quot;real RAM&quot; instead of &quot;virtual RAM&quot;? I don&#x27;t think so, but I could be wrong. So having virtual threads and &quot;raw&quot; threads under the same class has pros and cons, IMO.<p>&gt; It gives you the illusion of knowing something that you don&#x27;t really. The OS, or the Java runtime, can and do pause your thread at any point for durations that are between orders of magnitude shorter and orders of magnitude longer than blocking operations. There is no useful semantic knowledge you can extract from knowing something is &quot;blocking&quot; to the point that it&#x27;s a meaningless designation. It does mean something in &quot;single threaded&quot; languages like JavaScript, but not in Java.<p>That&#x27;s true. But it&#x27;s still a signal from the author of the function, the same way a type is. If a function makes a network call, you can be fairly sure that it will <i>usually</i> take longer to return than a function that is just flipping some bits around (even a fairly large amount of bits). Or do you still disagree? Would you say that if I&#x27;m writing JVM code, I really shouldn&#x27;t worry about what functions make network and DB calls or what thread they&#x27;re on because it really doesn&#x27;t matter? Even if I have a UI that I&#x27;d like to keep responsive?')