Item(by='megameter', descendants=None, kids=[24916719], score=None, time=1603851030, title=None, item_type='comment', url=None, parent=24911289, text='It&#x27;s actually very significant that Wirth stayed on the same track after Pascal. That indicates that he saw more to study in the realm of &quot;structured programming&quot; as it was understood in the 70&#x27;s. Later people in CS academia had careers to build and this ushered them towards pushing other paradigms, but industry has been rather pragmatic on the whole: most code, most of the time, is still structured imperative, still using the same handful of constructs, and still following the guiding forms of structured code: sequence, selection, iteration. The new languages do support many other features, but this is reflective of their role as broad toolboxes that support very large codebases, while a Wirthian language has at least one fundamentally different, well-specified benchmark of success: how efficiently the compiler compiles itself and the operating system. As an object of research, it can afford to be particular about how it gets there, while most engineering teams in industry will settle for whatever can ship.<p>And if we look at his languages at continued attempts to find the optimum of that space they represent a great resource to tap into - decades of effort to find exactly the right primitives and featureset for the task. That doesn&#x27;t mean they are the ones to use for all jobs, but &quot;what did Wirth do&quot; is a great starting point.')