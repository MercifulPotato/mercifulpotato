Item(by='pst', descendants=None, kids=None, score=None, time=1606125349, title=None, item_type='comment', url=None, parent=25180355, text='Terraform certainly has its fair share of quirks, but that&#x27;s no different from any other language.<p>However, I think it&#x27;s fair to say that the infrastructure as code ecosystem is still much younger and therefore less mature. And there are various things that are standard in application development toolchains that don&#x27;t exist for IaC yet.<p>Take my focus, use-case specific frameworks for example. If I&#x27;m building a web application, I don&#x27;t write my own request routing or authentication. But for Terraform, the majority of teams have to start from scratch, even for common use-cases. Yes, there are re-usable modules, but they&#x27;re comparable to libraries and integrating various modules is still a lot of effort.<p>If my use-case is building a Jamstack website, doing so using Gatsby gets me started faster, gives me a modern developer experience and means I can re-use community tested and maintained components to reduce the bespoke code I have to write and maintain.<p>I&#x27;m trying to do the exact same thing for Iac with Kubestack.<p>Kubestack is an open-source Terraform framework for managed Kubernetes. If your use-case is provisioning and maintaining EKS, AKS or GKE using Terraform, Kubestack may be worth trying. In my obviously creator-biased opinion.<p>It helps you with the typical framework like workflow to get started faster and scaffold a repository with one command, then bring up a local development environment with the next.<p>Yes, the long feedback cycles of IaC can be annoying. That&#x27;s why I&#x27;m trying to improve the developer experience by providing an auto updating local development environment.<p>For all modules (EKS, AKS, GKE) I maintain as part of the Kubestack framework, I also maintain a local variant. These accept the same input variables, but instead of provisioning cloud resources, provisions &quot;mock&quot; clusters locally using Docker containers as the cluster nodes.<p>The kbst CLI watches for changes in the repository, and then runs Terraform locally and dynamically replaces the module source of the real cluster module with the local variant. Here&#x27;s a video showing that in action: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;_VtakP6AdCs" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;_VtakP6AdCs</a><p>Similarly, I provide a Docker image for each framework release to provide a tested combination of versions of Terraform, it&#x27;s providers and the cloud CLI (aws, gcloud, az). The images are used to bootstrap, for CI&#x2F;CD runs and for the occasionally required manual tasks (state mv, etc.) or disaster recovery.<p>Just to name two examples from the discussion here where the developer experience of Terraform lacks behind the equivalent application development tooling.<p>Many people underestimate IaC, probably because of all the 5 minute Terraform tutorials and demos out there. But what these miss is that the real work only starts when you have to get your automation ready for day-2 operations.<p>This is where I&#x27;m trying to provide a better developer experience through re-usable use-case specific modules, inheritance based environment configuration to avoid drift, and integration into a convenient but reliable GitOps workflows for teams from local development all the way to production.<p>Kubestack&#x27;s code is open-source for two years in December. But I only got around writing documentation after leaving the DevOps consulting job that inspired the framework.<p>Anyone interested can give it a try: <a href="https:&#x2F;&#x2F;www.kubestack.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.kubestack.com&#x2F;</a> The site has links to the Slack channel (#kubestack on the Kubernetes Slack) and also the source on Github.')