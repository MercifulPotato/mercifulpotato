Item(by='moonchild', descendants=None, kids=None, score=None, time=1609145079, title=None, item_type='comment', url=None, parent=25542486, text='&gt; Sel4 is less than 9k lines of code<p>By my count, it&#x27;s approximately 86k loc.<p>&gt; That is a very, very long way from developing a general-purpose compiler for a general-purpose system language that can perform arbitrary formal verification for arbitrary code<p>Even a language like ATS (which is ‘general-purpose’) can verify a substantial majority of code which would need to be marked ‘unsafe’ under rust.  (It also proves a number of other interesting and desirable features, like bounding recursion.)<p>&gt; I doubt that [complete formal verification, as a goal] would be a particularly useful one for 99% of developers anyway<p>Why?  I find that a pretty attractive proposition.<p>Safety isn&#x27;t an end to itself; it&#x27;s means that enables a broader desire to produce more reliable, correct software.  One of the great things that rust (and, to a lesser extent, typescript) have done is to bring more expressive, powerful type systems into vogue.  Ones that can more effectively model real-world systems and verify program behaviour.  Why choose to stop, arbitrarily, with however much power rust&#x27;s type system happens to have at the moment?<p>&gt; Veloren (<a href="https:&#x2F;&#x2F;gitlab.com&#x2F;veloren&#x2F;veloren&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;veloren&#x2F;veloren&#x2F;</a>) has almost 120,000 lines of code nowadays and yet has fewer usages of unsafe code than you can count with a single hand<p>Veloren is a <i>video game</i> and arguably has no excuse for having any unsafe code.  Redox, which is probably a better case study, uses the keyword 8k times.')