Item(by='doonesbury', descendants=None, kids=None, score=None, time=1607570307, title=None, item_type='comment', url=None, parent=25369114, text='The PDF <a href="https:&#x2F;&#x2F;github.com&#x2F;rodgarrison&#x2F;tla_note1&#x2F;blob&#x2F;main&#x2F;doc&#x2F;tla.pdf" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;rodgarrison&#x2F;tla_note1&#x2F;blob&#x2F;main&#x2F;doc&#x2F;tla.p...</a> will do much better.<p>TLA is an acronym for Temporal Logic of Actions originally written by L. Lamport of PAXOS fame. The PDF contains numerous links to videos, books, docs, because TLA is widely supported and used.<p>TLA is like SPIN (<a href="http:&#x2F;&#x2F;spinroot.com&#x2F;spin&#x2F;whatispin.html" rel="nofollow">http:&#x2F;&#x2F;spinroot.com&#x2F;spin&#x2F;whatispin.html</a>) another well known model checker based on Promula not TLA syntax. And these tools fit into a larger universe of formal verification including, for example, COQ, Isabelle, Verdi, Dafny. The purpose of these tools (indeed they are all toolsets) is to:<p>- allow one to precisely state what safety and liveness properties a system should have. Sometimes we don&#x27;t even know what those conditions are until we sit down and try typing it up.<p>- find counter examples to those safety, liveness conditions e.g. does my buffer overflow? did I deadlock? is one of my threads waiting forever? did my account balance ever go wrong? where? why?<p>People like these tools esp. for concurrent and distributed work where the program paths, call sequences is highly exponential and highly combinatorial and where one wants some assurance all the threads really work and get to the right post conditions and system behaviors.')