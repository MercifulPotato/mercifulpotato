Item(by='dekhn', descendants=None, kids=None, score=None, time=1610577350, title=None, item_type='comment', url=None, parent=25767128, text='I never took a course in databases.  At some point I was expected to store some data for a webserver, looked as the BSDDB API, and went straight to mysql (this was in ~2000).  I spent the time to read the manual on how to do CRUD but didn&#x27;t really look at indices or anything exotic.  The webserver just wrote raw SQL queries against an ultra-simple schema, storing lunch orders.  It&#x27;s worked for a good 20 years and only needed minor data updates when the vendor changed and small python syntax changes to move to python3.<p>At that point I thought &quot;hmm, i guess I know databases&quot; and a few years later, attempted to store some slightly larger, more complicated data in MySQL and query it.  My query was basically &quot;join every record in this table against itself, returning only rows that satisfy some filter&quot;.  It ran incredibly slowly, but it turned out our lab secretary was actually an ex-IBM Database Engineer, and she said &quot;did you try sorting the data first?&quot;  One call to strace showed that MySQL was doing a very inefficient full table scan for each row, but by inserting the data in sorted order, the query ran much faster.  Uh, OK.  I can&#x27;t repeat the result, so I expect MySQL fixed it at some point.  She showed me the sorts of DBs &quot;real professionals&quot; designed- it was a third order normal form menu ordering system for an early meal delivery website (wayyyyy ahead of its time.  food.com).  At that point I realized that there was obviously something I didn&#x27;t know about databases, in particular that there was an entire schema theory on how to structure knowledge to take advantage of the features that databases have.<p>My next real experience with databases came when I was hired to help run Google&#x27;s MySQL databases.  Google&#x27;s Ads DB was implemented as a collection of mysql primaries with many local and remote replicas.  It was a beast to run, required many trained engineers, and never used any truly clever techniques, since the database was sharded so nobody could really do any interesting joins.<p>I gained a ton of appreciation for MySQL&#x27;s capabilities from that experience but I can&#x27;t say I really enjoy MySQL as a system.  I like PostgresQL much better; it feels like a grownup database.<p>What I can say is that after all this experience, and some recent work with ORMs, has led me to believe that while the SQL query model is very powerful, and RDBMS are very powerful, you basically have to fully buy into the mental model and retain some serious engineering talent- folks who understand database index disk structures, multithreading, etc, etc.<p>For everybody else, a simple single-machine on-disk key-value store with no schema is probably the best thing you can do.')