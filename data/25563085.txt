Item(by='Blikkentrekker', descendants=None, kids=None, score=None, time=1609188630, title=None, item_type='comment', url=None, parent=25562796, text='&gt; Okay you are right, GHC does not produce a stable ABI with dynamic libraries. But it could do so in principal, no problem with laziness itself. It just would be a lot slower without all the cross module inlining and so GHC chooses not to.<p>It could do so if it were to be willing to sacrifice having even a modicum of performance.<p>Lazy evaluation is incredibly slow without these. The theory behind lazy evaluation, is that it can gain back some of the performance it inhærently loses by allowing these kinds of aggressive hole-program optimizations because code can freely be re-ordered as no code has side-effects.<p>Without taking advantage of this re-ordering, one is only met with the pœnalties.<p>Note that in Haskell very fundamental primitive logical operations such as `||`, `&amp;&amp;` and `if` receive no special treatment from the implementation and are ordinary functions. If these were not allowed to be optimized as such, and they would be provided as a library, then the code would be prohibitively slow and would essentially require that a thunk be passed at every instance of a normal logical construct.<p>&gt; The archlinux haskell packagers could just ship programs as statically linked binaries and not recompile them on each minor dependency upgrade (except if there is a security upgrade). The binaries would not have any dependency on haskell packages themselves and you would not be forced to upgrade the whole package graph when some dependency is bumped, that would also save a lot of download bandwidth. I&#x27;m not sure that anyone really needs haskell packages (besides standalone programs) from the system package manager. No haskell dev I know builds their programs this way.<p>Indeed — no one does, because the unsung pain with <i>Haskell</i> is that it&#x27;s impossible.<p>With strict languages one has the option for dynamic linking, and dynamic linking seems to be what has won out due to it&#x27;s convenient “update once; update everywhere.” benefits — that is not available to non-strict languages, for which static linking is the only viable way of distribution.')