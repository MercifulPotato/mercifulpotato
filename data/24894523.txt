Item(by='chriswarbo', descendants=None, kids=None, score=None, time=1603707537, title=None, item_type='comment', url=None, parent=24893821, text='Macros are useful for defining things that don&#x27;t make sense &quot;within&quot; our programming language. For example, I write a lot of Scala code, and that language has a bunch of types like &#x27;Tuple2[A, B]&#x27;, &#x27;Tuple3[A, B, C]&#x27;, &#x27;Tuple4[A, B, C, D]&#x27;, etc. As a programmer we can see that these are all instances of some higher-level pattern &#x27;TupleN[T1, T2, ..., TN]&#x27; but Scala has no idea about that; hence we can&#x27;t write code which, for example, sums the first N elements of any tuple.<p>Actually, we can but it&#x27;s not safe: Scala&#x27;s tuples implement a &#x27;Product&#x27; interface which we can use to loop through the values, but this loses a lot of type safety (looking up values via Product will upcast them to type &#x27;Any&#x27;; our function&#x27;s signature will ask for a &#x27;Product&#x27; rather than specifically for tuples of numbers of at least a certain length, etc.)<p>Macros generate code at each of their call sites, which lets us automatically translate our &#x27;higher level language&#x27; (e.g. &#x27;Tuples of different lengths&#x27;) into the &#x27;real language&#x27; (e.g. Scala). For example, we can have a macro that translates &#x27;tupleSum(5, 10, foo)&#x27; into a call like &#x27;tupleSum5_10(foo)&#x27;, where the function &#x27;tupleSum5_10&#x27; is hard-coded to sum the first 5 elements of a Tuple10 (and is therefore acceptable to Scala, since it doesn&#x27;t try to abstract over tuple lengths), e.g.<p><pre><code>    def tupleSum5_10[T1, T2, T3, T4, T5](t: Tuple10[Int, Int, Int, Int, Int, T1, T2, T3, T4, T5]): Int =\n      t match {\n        case (x1, x2, x3, x4, x5, _, _, _, _, _) =&gt; x1 + x2 + x3 + x4 + x5\n      }\n</code></pre>\nOf course, we don&#x27;t want to be writing functions like &#x27;tupleSum5_10&#x27; manually. Hence we can use <i>another</i> macro to define these functions! For example, the above might be generated by a macro call like &#x27;defTupleSum(5, 10)&#x27;. If we run this macro in a loop, we can define all of the sum functions for tuples up to, say, Tuple20.<p>If we provide this in a library, users can treat tuples in a more high-level way. Since each macro call just generates some boilerplate Scala code, the result will be type-checked, etc. to make sure we&#x27;ve not done anything dodgy, e.g. since a call like &#x27;tupleSum(5, 10, foo)&#x27; expands to &#x27;tupleSum5_10(foo)&#x27;, Scala will check whether &#x27;foo&#x27; matches the type &#x27;Tuple10[Int, Int, Int, Int, Int, T1, T2, T3, T4, T5]&#x27;.<p>I think the most famous use of macros in Scala is Shapeless <a href="https:&#x2F;&#x2F;github.com&#x2F;milessabin&#x2F;shapeless&#x2F;wiki&#x2F;Feature-overview:-shapeless-2.0.0" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;milessabin&#x2F;shapeless&#x2F;wiki&#x2F;Feature-overvie...</a> (although I&#x27;ve not personally used it)<p>Note that the exact same problem with tuples happens in Haskell too, which can also be worked around using Haskell&#x27;s macro system (TemplateHaskell).')