Item(by='ordu', descendants=None, kids=None, score=None, time=1604384730, title=None, item_type='comment', url=None, parent=24969053, text='<i>&gt; The talk also discusses code repetitions: compiler makes duplicate code anyway, even for straightforward `for` loop and nested `switch`, but in our case we had much more duplicate code.</i><p>I&#x27;m unable to find measurements. I mean, the amount of code duplication is not an optimization parameter, the amount of Mb&#x2F;s of HTTP parsed is. It is obvious that the size of code leads to a greater cache use and slows down a program, but any engineer&#x27;s decision should be an educated choice between alternatives with different upsides and downsides. Spagetti code with goto jumping between branches is a bad thing from the point of view of maintainability. From other hand constantly overflowing instruction caches  also is a bad thing. Which one is worse? How to compare apples and oranges? I do not know how to quantify maintainability (pity), but throughput of a program could be quantified easily.<p><i>&gt; The thing is that we used hot&#x2F;cold labels to minimize jumps over the code and improve instruction cache usage, so calling functions isn&#x27;t good at all.</i><p>Function in C&#x2F;C++ is a high-level abstraction, would it lead to a CPU executing &#x27;call&#x27; instruction or not -- is a choice of a compiler and a programmer.<p>If we return to a premise of your article, that rust isn&#x27;t good for a systems programming, I might notice, that many wouldn&#x27;t agree with you that what you do is a systems programming worth mentioning. It is nice to know how much C++ code could be tuned for a maximum speed, but I&#x27;m not sure that I&#x27;d prefer hand crafted state machine to a parser generator, even if the latter would be much slower. If I choose hand-crafted state machine, I&#x27;d probably do it by splitting code as much as possible into a &#x27;static inline&#x27; functions (most of them would be called just once), with meaningful names and some common arguments to make it as easy to understand and to reason about as possible. Yes, I&#x27;d sacrifice some of speed by this way, but I need not the fastest program possible, I need program that is fast enough and have other properties as well. There are more then one optimization parameter: it is systems programming.<p>Of course, your way have it&#x27;s rights to exist, and probably it has it&#x27;s niche too, but as I see it, it is a small narrow niche were available computational resources are scarce while throughput needed is high. In the most cases system software needs to be highly reliable, which needs code enabling us to reason about it, audit it, change it. It needs code which could be maintained by other people, not only those who wrote it.')