Item(by='pron', descendants=None, kids=[24960476], score=None, time=1604245548, title=None, item_type='comment', url=None, parent=24959748, text='&gt; There&#x27;s no reason why one couldn&#x27;t use a &quot;code-level&quot; (end-to-end) interactive proof tool to verify TLA+-like specs.<p>Sure, and that is what TLA+, together with its tools, aim to do. The problem is the relation between the spec, that you can precisely verify, and the program it aims to abstract.<p>The advantage TLA+ has over code-level tools in this respect is that those tools use code as their specification language -- i.e. a formal language that is deterministic enough to efficiently compile&#x2F;interpret and execute. But TLA+ allows you to specify at an arbitrary level, even levels with a lot of nondeterminism that precludes compilation, hence the difference between it and code. For example, in TLA+ you can say, suppose I have a subroutine that sorts, and then build and check your specification on top of that without actually writing a sorting routine that can be executed. Similarly, you can say something like, &quot;some hashing function is used&quot; without actually writing any specific hashing function.<p>This way, you can write a specification that&#x27;s small enough to be verified, yet captures the interesting aspects of a system that&#x27;s made of too much code to verify at the code level.')