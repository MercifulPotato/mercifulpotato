Item(by='nmadden', descendants=None, kids=[25228573], score=None, time=1606467605, title=None, item_type='comment', url=None, parent=25224773, text='&gt; I see, it&#x27;s an interesting line of thought but I think trying to move type checking into the grammar is fundamentally a bad idea. You don&#x27;t want to mix grammar and semantics because that&#x27;s not how people think about code.<p>I know that it’s common to refer to type checking as “semantic analysis”, but the logician in me is not happy. There’s nothing inherently more “semantic” about types compared to grammars. As Benjamin Pierce says [1]:<p>&gt; A type system is a <i>syntactic</i> method for enforcing levels of abstraction in programs.<p>(Emphasis mine).<p>&gt; That said I agree that it is interesting to see what the &#x27;parse, don&#x27;t validate&#x27; approach to type checking would be, but I think it should still take place on the type level.<p>You can certainly write parsers at the type level, but that doesn’t change the fundamental fact that a type checker is a validator. To change a type checker into a parser it would have to output a representation which makes invalid states impossible to represent. From a programmer’s point of view (not the compiler writer), this means that the actual compiled object code would have to have this property. I can see a couple of possible ways you could do this:<p>- the compiled object code enforces invariants using dynamic checks provided by the runtime&#x2F;processor\n- the type-checker outputs something like proof-carrying code [2] that can be rigorously checked prior to execution to ensure the illegal states removed by the type system cannot be recreated.<p>[1]: <a href="https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~bcpierce&#x2F;tapl&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~bcpierce&#x2F;tapl&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proof-carrying_code" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proof-carrying_code</a>')