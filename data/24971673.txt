Item(by='nerdtime', descendants=None, kids=[24971851], score=None, time=1604343500, title=None, item_type='comment', url=None, parent=24971413, text='&gt;but you&#x27;re talking about that as though it were an inherently flawed or invalid approach,<p>This is just your bias. I never said this. I feel some people worship a paradigm so much that they see everything as an attack. FP is great however it is not a one size fits all solution. There are limitations. This is literally what I said.<p>&gt;Mathematicians have no trouble modeling change. There are many ways to do so. Some are algebraic, some are not. There is nothing wrong with modelling mutability using immutable structures: that is how you probably think about history, after all.<p>You can model change with purity but the program in the end actually has to conduct the change without the modelling. The application has to eventually perform real world actions and the purity of your program cannot protect you from potentials pitfalls of imperative style errors&#x2F;mistakes.<p>You have a database. The purity of haskell does not remove the necessity of mutating data in that database.<p>What you can do is segregate dealing with mutation&#x2F;IO to a framework or external service. This is what haskell does, but you see this is just shifting the problem to somewhere else. Someone somewhere still had to deal with the issue of mutation. Modelling mutation with purity does not eliminate the problem it only moves the problem to another location.<p>Segregation of mutation&#x2F;IO into a framework is a good thing. It makes it so that the problem can be solved one time, rather then a problem solved many times. However the main point of my post is to say that &quot;math&quot; or &quot;algebra&quot; is not a one size fits all solution. You cannot model everything this way, moving the problem into a framework does not make the problem disappear. Someone still had to use imperative primitives to deal with the issue. Think about the complexity of a SQL database.')