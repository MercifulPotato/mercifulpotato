Item(by='simias', descendants=None, kids=None, score=None, time=1607990136, title=None, item_type='comment', url=None, parent=25424309, text='I don&#x27;t find my example contrived at all, having functions assuming non-NULL pointers call other subroutines that defend against such a thing is definitely a routine thing in my experience. Maybe &quot;do_substuff&quot; is called in contexts where the pointer could be NULL, or maybe its developer was paranoid.<p>I don&#x27;t think it&#x27;s reasonable to expect compilers to issue less optimized code to defend against coders doing smart things that are well beyond the scope of the standard. If you want to play fast and loose with segfault handlers then be my guest, but if you want to play with fire you better know what you&#x27;re doing.<p>Note that many of C&#x27;s UBs are also generally effectively unportable, different systems will react differently to things like NULL pointer dereferences (segfault, access to some mapped memory, access to nothing at all or a special handler like the one you described) and signed overflow (overflow to 2s complement, saturation, trap etc...).<p>I think blaming UBs is frankly the wrong target. The problem with C is that it doesn&#x27;t let you express those constraints to let the compiler enforce them and let you know when you&#x27;re doing something wrong. I can&#x27;t tell the compiler &quot;this pointer is not nullable&quot; and have it keep track of it for me, warning me if I mess up. In contrast in a language like Rust I could use an Option&lt;&gt; type to encode this, and I get a compilation error if I have a mismatch.<p>That&#x27;s what I want to see in a more modern C, not a babysitting compiler that emits suboptimal code because it&#x27;s trying to make my coding mistakes somewhat less mistakeful.')