Item(by='aidenn0', descendants=None, kids=None, score=None, time=1603729709, title=None, item_type='comment', url=None, parent=24895517, text='It&#x27;s a fairly well accepted recommendation to not use a macro when a function will do[1].  Everything bad people say about macros applies equally to functions, the dial is just turned up a bit; they both abstract behaviors by hiding their implementations.<p>The advantages is that this reduces mental load when reading code; imagine if you had to parse a block of code and say &quot;oh yeah, that&#x27;s just a simple median of 3 quick sort&quot; every time instead of just (sort ...).  That would increase your mental load both when reading and writing.<p>On the other hand, when something goes wrong in sort (even if it&#x27;s not a bug in sort itself, maybe some garbage was passed in), the fact that it&#x27;s a function call actually <i>increases</i> the mental load when debugging.  Good tooling that lets you print stack frames and such really improves things.<p>The same is true for macros, but things are worse in both directions since macros are more powerful.  You can write better abstractions to decrease the mental load even more, but when things go wrong, more things can go wrong because macros are less constrained than functions.<p>Again, good tooling can go a long way to reducing the debugging pain.  Stepwise macro expansion is a big win and being able to do it in-place is even better.<p>1: With the exception that lispers will use macros to prevent requiring explicit lambdas.  For example, the WITH-FOO macros common in lisp can all be written using lambdas, and it would even be idiomatic to do so in many functional languages.  From what I can tell this is originally because of the extra computational expenses of using lambdas, but persists because the syntax is more uniform with LET and friends')