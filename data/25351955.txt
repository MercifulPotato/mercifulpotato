Item(by='kelnos', descendants=None, kids=[25354319], score=None, time=1607464768, title=None, item_type='comment', url=None, parent=25341476, text='&gt; <i>I also found the Some(Some(3)) example just plain wrong. In those scenarios, typically you just use chain (aka flatMap) instead of map</i><p>I think you misunderstood.  The point here was that you can represent different things using nested Options:<p>1. Some(Some(3)) = I checked it and the value is 3<p>2. Some(None) = I checked it and there is no value<p>3. None = I haven&#x27;t checked it<p>It&#x27;s very useful when building a cache, and also for things like JSON parsing (property was not present, property present but null, property present and has non-null value).<p>You just can&#x27;t represent that using Dart&#x27;s nullable types system, because &quot;int?&quot; and &quot;int??&quot; are the same, indistinguishable type.<p>Anyway...<p>One thing not mentioned in the article is that the way they&#x27;ve implemented it in dart is via &quot;magic syntax&quot;, which I consider to be a big negative.  Option&lt;T&gt; is something anyone could implement without language support (assuming the type system already supports it).  Anyone could build their own Option type and use it. (Sure, it&#x27;s best to have this sort of thing in the stdlib so the stdlib will use it itself.)  Nullable types with the &quot;?&quot; syntax makes the language itself bigger, and is something a regular user of the language couldn&#x27;t implement if they wanted to.<p>(Yes, I&#x27;m aware that the &quot;?&quot; suffix is just a shortcut for the more generalized union type syntax, but I think my argument holds.)<p>The use of these types in regular code also requires what I consider a sort of special unintuitive requirement on how you structure your code.  I have to do explicit null checks and then the compiler&#x2F;interpreter just &quot;knows&quot; that code in certain places is null-safe through flow analysis.  That kind of magic really turns me off.<p>I also don&#x27;t buy the argument that Option types are a pain to use if your language doesn&#x27;t have pattern matching.  I&#x27;ve been doing a bit of Java lately and have banned null from my code, instead using Option from the excellent Vavr library (I find java.util.Optional to be lacking, ditto for Java&#x27;s built-in collections library).  I tend not to use Vavr&#x27;s pattern matching, as I find it clunky.  But I also have no trouble using Vavr&#x27;s Option.<p>I guess I just prefer to use languages that have strong type systems where I can express constraints and safety through the types themselves, and not have to rely on language&#x2F;compiler features to implement those constraints.  I think the latter also gives you less flexibility as well.')