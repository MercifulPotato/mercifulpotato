Item(by='bmitc', descendants=None, kids=[25623661], score=None, time=1609696055, title=None, item_type='comment', url=None, parent=25622596, text='I wish he gave more examples in that response because I&#x27;m generally confused what he&#x27;s talking about. I&#x27;m familiar with Racket and F#, but not having used Clojure, I&#x27;m missing some context about the Clojure ways of doing things and examples of the problems he claims.<p>&gt; I feel about them the way I do about switch statements - they&#x27;re brittle and inextensible.<p>That is not the case in a language like F# or OCaml. I do note that F# was introduced only slightly before Clojure was, but pattern matching provides nicely extensible functions and are anything but brittle in those languages. Also, active patterns in F# allow one to extend the pattern matching functionality.<p>&gt; The binding aspect is used to rename structure components because the language throws the names away, presuming the types are enough. Again, redundantly, all over the app, with plenty of opportunity for error.<p>I&#x27;m not sure what he means here. Again in a language like F#, names of the data aren&#x27;t thrown away. They are pattern matched against, only being &quot;thrown away&quot; to do actual calculations. Nothing is ever lost where the data came from. For example:<p><pre><code>    type Shape =\n        | Circle r\n        | Square s\n\n    let area shape =\n        match shape with\n        | Circle r -&gt; System.Math.PI * r * r\n        | Square s -&gt; s * s\n</code></pre>\nThere&#x27;s no confusion here. In fact, pattern matching in a language like F# allows one to completely remove the possibility of error. For example, this really shows off in parsing applications. Once your parsing function returns a type that can be pattern matched, it&#x27;s extremely difficult to have an error in the pattern matching sections of code. These are typically the most robust parts of the application.<p>&gt; I&#x27;d much rather use (defrecord Color [r g b a]) and end up with maps with named parts than do color of<p><pre><code>    real*real*real*real,\n</code></pre>\n&gt; and have to rename the parts in patterns matches everywhere (was it rgba or argb?)<p>I don&#x27;t understand this either. In F#:<p><pre><code>    type Color = { R: float; G: float; B: float }\n\n    let colorFunction { R=r; G=g; B=b } = r * g * b\n</code></pre>\nNo names are thrown away. Also, the comment on rather using maps seems to assume the data type for every element of the data structure is the same. How do you just use maps when the underlying types of your record aren&#x27;t the same?')