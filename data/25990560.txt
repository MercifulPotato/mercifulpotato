Item(by='curryst', descendants=None, kids=None, score=None, time=1612199369, title=None, item_type='comment', url=None, parent=25984867, text='Typing validation can only check the type, but there are a lot of facets of the type that most languages don&#x27;t use.  Types are a way of encoding your assumptions about the data in a way that the language can understand.<p>Types can be defined so that only a subset of values is acceptable.  I could do something like:<p>UserID = int where value is less than 1000\nmy_user_id: UserID = query_database(username=my_username)<p>And the type system could throw an error&#x2F;warning that says &quot;my_user_id could be greater than 1000&quot; because I never check whether that value is actually valid for the type.  Or if the language and the type system are integrated, it could transparently do the assertion for you and throw an error if the data doesn&#x27;t match its type.<p>You could do likewise with regexes for strings, lengths of integers, etc, etc.  You can also encode complex relationships among objects.  If you change how user IDs are formatted and don&#x27;t migrate legacy users, you could express something like &quot;if creation_date is older than 1&#x2F;1&#x2F;2000, user_id is an integer less than 30,000. Else user_id is a string that matches this regex&quot;.')