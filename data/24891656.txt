Item(by='hajile', descendants=None, kids=[24892929, 24892131], score=None, time=1603673186, title=None, item_type='comment', url=None, parent=24891273, text='SML records are structurally typed and may be anonymous which makes a lot of things easier to write. I&#x27;ve heard Ocaml has been attempting to tack that on, but that leads to the next point of Ocaml syntax being a complete mess. Ocaml <i>needs</i> keyword arguments, but in SML, structural typing gives named arguments without all the extra syntax.<p>I find the `ref` syntax of SML much nicer to use than the mutable record syntax in Ocaml.<p>SML doesn&#x27;t have all the dotted math operators for floats.<p>SML strings are immutable which lends itself to a lot of potential optimizations (and there&#x27;s always byte arrays if you actually need to mutate).<p>Ocaml let vs let expressions are annoying to me.<p>SML has a standard. &quot;The implementation is the spec&quot; in my observation always leads to problems.<p>My wishlist for SML:<p>FIX USE COMPATIBILITY. It&#x27;s intentionally not specified by the standard. This makes portable code very hard. I&#x27;d love to see an approach more like JS, but without dynamic imports (useless) and with support for something like GO_PATH plus maybe the ability to recognize and import from URLs (especially .git and .sml).<p>JS style template strings with interpolation (the type system is at least smart enough to convert primitives to strings) and multi-line capabilities. This would also be an easy backward-compatible way to add support for unicode. Guarantee the ability to implement them as UTF-32 with the knowledge that an advanced compiler could choose to internally represent them as UTF-16 or even Latin1 to save space (JS implementations have optimized to convert their ropes from UCS-2 to latin1 when possible with huge memory savings as even Chinese sites are 90+% ASCII).<p>Module Typeclasses should keep typeclasses from happening everywhere (looking at you Haskell) while still allowing them to be used for more than equality.<p>Unofficial first-class functor support needs to be made official.<p>Pick one of the 4-5 slightly different concurrency models and standardize it.<p>Things I want that are in SuccessorML:<p>Guards, &quot;OR&quot; shorthand, optional leading pipe in matches<p>Line comments<p>Record punning, extending, and &quot;updating&quot;<p>do declaration shorthand')