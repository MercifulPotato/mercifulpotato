Item(by='tialaramex', descendants=None, kids=[24750305, 24747491, 24746143, 24747871, 24747036, 24747554, 24747801, 24746286], score=None, time=1602426757, title=None, item_type='comment', url=None, parent=24745563, text='Many years ago now we built something that used a 60-bit \ntruncated hash of URIs. So that&#x27;s far too small to be comfortable that you won&#x27;t run into collisions, but it&#x27;s big enough that for modest sizes (hundreds of millions up to billions) a collision is unlikely. So you can have a slow path for the collision case, so long as that slow path is correct. For unit testing we needed at least one collision so we could see that everything behaves as designed before some real user hits one. We had test data sets with over a billion URIs in them, but none that (as far as we could tell) had a collision.<p>So I just wrote code to mint nonsense URIs for our system based on a small integer seed (like <a href="https:&#x2F;&#x2F;foo.example&#x2F;123456789" rel="nofollow">https:&#x2F;&#x2F;foo.example&#x2F;123456789</a>), then span up a system with a bunch of RAM (maybe 8-12GB) to iterate through each seed, storing the hash and seed it was generated from, until it hit a collision after a few gigabytes of RAM, then it spat out the two URIs from the colliding seeds. Bingo, now we had data for unit testing to show that stuff works even in the unlikely case that two distinct URIs have the same hash.<p>Probably a day&#x27;s work to build that, and then I&#x27;d guess several hours every month saved debugging weird collision bugs because our unit tests would now tell us if we&#x27;d screwed up and collisions were slipping past.')