Item(by='exikyut', descendants=None, kids=None, score=None, time=1606498610, title=None, item_type='comment', url=None, parent=25225163, text='Question I possibly couldn&#x27;t ask a more appropriate person: how were the long-running server processes managed?<p>I really want to use PHP to manage backend-type, long-lived stuff... in a way that is relatively lightweight and self-managing, and idiomatically tolerates the occasional bit of unparseable syntax on script load or mis-named function call, without throwing a hissy fit.<p>Like... the only thing that&#x27;ll typically ever knock php-fpm completely over is generally a script-triggered interpreter segfault, which is Badâ„¢, exceptional, and (given php-fpm&#x27;s collective uptime on all installations everywhere) vanishingly rare. Fatal error? FCGI response message passed upstream. Script exceeded execution time? Hard timeout (and message passed upstream). CLI SAPI? Clunk; no more script execution for you. I&#x27;ve always felt a bit left out in the cold by this, just in terms of how the language itself handles this edge case.<p>I guess I probably just stop whining and go setup systemd unit files or similar. That would definitely make the most sense in a production environment; I should probably build the muscle memory.<p>It&#x27;s just that, for slower-paced and&#x2F;or prototype-stage projects that don&#x27;t have a clear direction... my brain&#x27;s trying to reach for an equivalent of `php -S` that isn&#x27;t there, and... I guess it&#x27;s really easy to get idiomaticity-sniped, heh. (&quot;But this project isn&#x27;t a <i>thing</i> yet... and systemd unit files go in &#x2F;etc, which is like, systemwide... and I forgot the unit file syntax again...&quot; etc etc)<p>TL;DR, if this made sense :), did you ever encounter this sort of scenario, and how did you handle it? A $systemd_equivalent, language-level patches, shell script wrappers, cron, ...?<p>Oh, another curiosity - whenever remembering how pcntl_fork() works I usually have to reach for `killall php` a few times :) (especially when the forks are all using 100% CPU... and I accidentally start <i>slightly</i> too many...). How was killall isolated from nuking important server processes? Shebang line? Renamed interpreter binary (...probably not)? Different user accounts?<p>Thanks very much for reading :)')