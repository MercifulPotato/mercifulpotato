Item(by='jstimpfle', descendants=None, kids=[25645129], score=None, time=1609848258, title=None, item_type='comment', url=None, parent=25644380, text='It&#x27;s a long time that I&#x27;ve tried to do anything in Haskell, but I had to use extensions such as GADTs, type families, existential quantifications, kind signatures, multiparam type classes...<p>I can&#x27;t name you any ones that are mutually incompatible because I simply don&#x27;t remember what all of those were about anymore, but I remember there was something (I&#x27;ll take back the &quot;often&quot;), and I&#x27;ll bet that some of those that I named above are now deprecated or superseded by others.<p>&gt; Can you name any extensions that are the result of &quot;just&quot; a PhD thesis (as opposed to a peer reviewed academic paper published at a top conference)?<p>Well, no, I can&#x27;t, since I don&#x27;t follow it anymore, and if I understand correctly you are making my point by stating that a PhD thesis is not the level where you already make language extensions. I know someone who&#x27;s made significant contributions to GHC also as part of their PhD work, though.<p>My actual point was simply that the idea of modelling more than basic ideas (like physical layout of data) with static types is a bad idea. You quickly get sucked in to places where you need to be able to express even more complicated typing deductions, and you&#x27;ll end up resorting to unergonomic stuff like templating, dynamic types and various RTTI approaches, and all kinds of language extensions that are really hard to grasp or that are still in the making. As a guy of modest intelligence, I feel like a dog chasing its tail (and I assume that this is how the super-smart guys out there feel like, too, a lot of the time).<p>&gt; Can you name any examples where a card house tumbled and someone had to pick a different set of extensions?<p>Really anything where you&#x27;re trying to represent a concept with compile time language primitives (which is what Haskell guys are about, a lot of the time - and take pride of). I&#x27;m convinced you know this situation yourself where you start of modelling something statically (in type language) and then you have this additional requirement coming in, and you don&#x27;t know how to represent it with compile time language feature anymore, so you end up scratching everything and building it with a more modest mindset, most of the stuff available with run time values - maybe a few more run-time case switches or asserts that invalid situations can&#x27;t happen, but overall simpler and easier to understand code.')