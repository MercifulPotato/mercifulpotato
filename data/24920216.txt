Item(by='CyberRabbi', descendants=None, kids=[24920645, 24922384, 24922083, 24920522], score=None, time=1603900353, title=None, item_type='comment', url=None, parent=24919893, text='&gt; Unfortunately, std::optional implements operator* and operator-&gt; which are UB if the optional is null -- that&#x27;s even worse than the situation with pointers,<p>Dereferencing null optionals is UB for consistency with dereferencing pointers. All uses of operator* should have the same semantics and the C++ standards committee did the right thing by ensuring that with optionals. Checking for null in operator* would break consistency.<p>If you want to dereference an optional that may be null, use the .value_or() method. For the times when you absolutely know the optional has a value use operator*.<p>If you’re wondering why you would use an optional over a pointer. The idea is that optionals allow you to pass optional data by value. Previously if you wanted to pass optional data, you’d have to do it by reference with a pointer. This is part of c++’s push towards a value-based style, which is more amenable to optimization and more efficient in general for small structs (avoiding the heap, direct access of data). Move semantics are a part of that same push.')