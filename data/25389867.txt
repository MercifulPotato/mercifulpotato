Item(by='Pxtl', descendants=None, kids=[25392229, 25393016, 25393886, 25391517, 25391358], score=None, time=1607715556, title=None, item_type='comment', url=None, parent=25389478, text='Yeah.  The Python C implementation&#x27;s simplicity is a double-edge sword.  It&#x27;s delightfully easy to extend despite being straight C, but it also has made some frustrating performance trade-offs.  Last time I checked, something as simple as<p>myObj.MyMethod()<p>would be implemented as (this is from memory and I&#x27;m rusty):<p>myObj is fetched from the local scope array by array-index.<p>Dictionary lookup on myObj failing over to dictionary lookup on myObj.__class__ to find the method MyMethod().  Or was it one merged dict?  Whichever.  All __slots__ does is mean  that myObj doesn&#x27;t need its own dictionary, it still has to go to __class__ for a dictionary hit, which can even be overridden if they&#x27;ve changed __getattr__ or __getattribute__.<p>Originally cpython even used deliberately-high-collision hashtables for lookups for reasons I no longer remember (faster sort?).<p>MyMethod() instantiates a new Method object that stores the underlying class-function and the &quot;self&quot; parameter, but the object is pooled, so it&#x27;s quick.  Still, it&#x27;s creating a reference that will have to be collected in a moment.<p>Then we actually invoke the damned function.<p>Then we decrement the refcount on the Method object, which drops it to zero and it is destroyed (returning it to object-pool).<p>Obviously, this is from my memory and it&#x27;s been over a decade, so I might be getting details wrong, but it was surprised that there were so many unoptimized layers involved in resolving a method.  That even with __slots__ dictionary hits were unavoidable, and that method invocation involved instantiating an object (from a pool, but still).')