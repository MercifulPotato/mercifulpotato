Item(by='lmilcin', descendants=None, kids=[25979814, 25981512, 25979620, 25979243, 25981210, 25986527, 25984956, 25986239, 25981506, 25979292, 25980058], score=None, time=1612103857, title=None, item_type='comment', url=None, parent=25978190, text='I think Lisp is going to live forever as a niche tool for people who &quot;get&quot; it.<p>I use Clojure on a daily basis. Not necessarily because it is best Lisp, but rather because I am working with Java applications and being able to reuse the same Java code I have already developed is a huge boon to me. If I was able to choose, I would be using Common Lisp.<p>The way I use it is to quickly develop adhoc tools and PoCs \nand more rarely small UIs in re-frame.<p>Working with Lisp is a joy for me and I always get this feeling of frustration when I have to go back to Java, especially if I have to translate to Java what I just prototyped in Clojure.<p>Unfortunately, where I work (financial systems for financial institutions), I have trouble finding enough people, mature enough to be able to even propose working projects in Clojure.<p>Close in my org structure there is a set of Clojure projects where the company got badly burnt. The code is a mess and a huge headache for management. The guys who wrote it were either promoted (claiming outstanding work on the project but not wanting to maintain it) or left. Now new developers are barely able to change anything without blowing it up.<p>This underlines the fact that Lisp projects can very easily end in spectacular disasters. You have to be really incompetent to write a typical Java service in a way where it is no longer possible to develop it at all, but in Clojure it is just enough to get couple of people that are intelligent enough to write macros but not experienced enough to understand the dangers of lack framework forcing the structure of your application.')