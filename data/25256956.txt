Item(by='jbay808', descendants=None, kids=[25258249], score=None, time=1606760123, title=None, item_type='comment', url=None, parent=25256452, text='Sympy is great for this, because you can manipulate the equations symbolically, cancel terms, and then convert the result to a numerical routine using lambdify.<p>In my case, I&#x27;d build up a model of a motor control system using subsystems (motor model, inverter, current sensors, delay elements, noise sources, etc). Then design a feedback&#x2F;feedforward control system (eg. PID) and connect that in as another block.<p>Each block has simulation code associated with it, and a matching symbolic sympy transfer function from each input to each output was derived.<p>When you connect them together with various feedback loops, it creates a directed graph that it then resolves using NetworkX to find the various loops, and using Mason&#x27;s rule to solve the system transfer functions. For discrete time systems cycles were automatically resolved by inserting additional delay elements.<p>Each system composed internally of such parts could also be used as a single part in a larger feedback system, so for example, you can build up a current control loop around your motor and inverter, and then plug that as a subsystem into a velocity control loop.<p>You only have to write out the symbolic model of the base level components (inductors, resistors, etc). The equation for each transfer function along each signal path gets built up by Sympy, using the normal rules; for example a feedback loop with gain A becomes 1&#x2F;(1+A). For a big system the equation gets quite complicated to write out in full.<p>Once you&#x27;ve assembled your system that way, you&#x27;ll have a lot of parameters to tune. You can run the the resulting system in simulation and play with it but for tuning many variables at once, you&#x27;ll want a more robust solution.<p>So from control theory we can derive certain objectives that we want to maximize, and constraints that we want to satisfy. The constraints might include a maximum value on the transfer function from a noise input to the motor current, or something like that, and of course Nyquist stability. The objective might include minimizing sensitivity to disturbances within a frequency band or minimizing time to converge to a target.<p>In such cases, you could perhaps simulate the system and derive those numerically, but it would be slow to do that. Much faster to solve them symbolically -- the expression for a sensitivity is easy when you know the transfer functions; you&#x27;ll just have to take some limits as certain terms go to zero or infinity and take derivatives of those and so on. Then you get a function of your tuning parameters to optimize under constraints.<p>That can then get passed to an optimizer routine, to solve for your tuning parameters. Then you simulate the system to check that the performance is good.')