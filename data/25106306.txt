Item(by='lucb1e', descendants=None, kids=None, score=None, time=1605485173, title=None, item_type='comment', url=None, parent=25105970, text='&gt; a third party [...] cannot know whether Alice really sent that message, or it was a forgery from Bob<p>But realistically, how often does Bob create and store forgeries of all of Alice&#x27;s messages to protect her just in case his device gets hacked? This seems even less likely than the blackmail scenario proposed in a sibling thread and your second paragraph.<p>I&#x27;m not saying &quot;let&#x27;s not add features that are not absolutely essential&quot; (I&#x27;m one of the people in favor of client-side hashing, which other security people seem to reject for having too small a benefit), but rather that I&#x27;ve seen the amount of complexity it adds and I just really can&#x27;t think of scenarios that are plausible enough to be worth the potential false sense of security and added complexity in an already complex protocol. TLS is simpler and we see how many ways that got hacked. (Come to think of it, it is curious that I can name various old TLS&#x2F;SSL flaws but not any in previous versions of OTR, Axolotl&#x2F;Signal&#x2F;Wire, etc. Protocol versions, that is; not implementations. But perhaps they&#x27;re just publicized less.)<p>&gt; unlike non-deniable encryption, this is not retroactive (a government cannot order a ISP to setup a tap in the past)<p>There are much simpler solutions to prevent retroactive proving. Barring just throwing away the chat log, the receiving client could discard the signature after verification. That maintains plausible deniability for the messages because there is no signature of Alice&#x27;s and adds literally zero complexity to the protocol. That&#x27;s just an idea I randomly came up with on the spot so perhaps it&#x27;s really stupid for some reason, but why don&#x27;t we just do that?<p>&gt; if padding is used, not even that<p>This is about minor details now but, padding is at most as large as the block size and modern modes like GCM don&#x27;t use padding at all. The protocol would need to mix in random garbage and limit the rate at which you can send bytes to prevent time and size correlation, which can otherwise both be independently matched against the chat log. Unless specifically thwarted with a sizeable amount of noise, traffic correlation is going to be possible. Correct me if I&#x27;m wrong but I would not expect any general purpose chat protocol in 2020 to consider this to be within its scope.')