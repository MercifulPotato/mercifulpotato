Item(by='hedora', descendants=None, kids=None, score=None, time=1605115167, title=None, item_type='comment', url=None, parent=25053238, text='Modern Linux kernel APIs are asynchronous spaghetti. Someone realized blocking userspace could be a performance issue (you need to spawn a thread to invoke the kernel API if you want to stay responsive while the kernel does stuff), and that using the setuid bit in large daemons is dangerous (they had already decided to abandon the unix way, where there are small binaries, and each does one thing well).\nThe solution was to make everything asynchronous without providing proper barrier operations, expose it via local network daemons, and to layer a new permissions system atop it.\nTo see why this makes things hard, consider using modprobe to load a hardware driver. It has to detect and initialize hardware, and this can take some time.\nThat happens in the background, so you need to be able to ask the driver if the hardware has “settled” before proceeding. Otherwise, you can’t differentiate between “zero wifi cards” and “wifi card is almost ready”.\nThat’s probably fixable, but hardware isn’t attached to a flat bus. What if the wifi is on a usb bus that’s initializing? What if it’s plugged into a usb hub that’s initializing?\nThe “solution” is to double down on the problem: Introduce an event bus that anything can talk to, and have it asynchronously forward messages between processes and the kernel.\nIt eventually tells userspace when new hardware arrives, but that creates a new problem. How long should the startup scripts wait to start things like ntp and nfs clients? You can’t interaxt safely with the filesystem until those daemons are ready. What about X11? Locking users out when there’s no video card is bad. So is dropping to a text prompt for a few seconds.\nAnyway, it’s clear this was never thought through to a clean solution. Clean solutions exist in other systems, of course, but not here.\nBefore systemd became the spearhead of this train wreck, people frequently complained about dbus (the subject of this article) for exactly these reasons. So, it’s not surprising there are security holes like this.\nWe’re currently in a situation where Linux’s userspace has reimplemented unix permissions in a way that only a few understand, and manages a sprawling multi-process asynchronous state machine on top of that. The authors of this mess didn’t bother to write manpages for the underlying daemons, so the inner workings of this stuff is extremely obscure and unvetted.\nWorse, it has hooks into everything in the Linux desktop, and has been spreading like cancer for over a decade.')