Item(by='Fire-Dragon-DoL', descendants=None, kids=None, score=None, time=1603075482, title=None, item_type='comment', url=None, parent=24822675, text='I have to disagree on this point.<p>Formatting could be beneficial, but it gets abused so fast that it becomes a problem.<p>First thing, no one challenges the choices made by the formatter, which is a problem in the long term. \nThe other thing is how far the formatter goes. Rubocop in ruby is a clear example of this, they went way too far with it and producing a readable rspec test is impossible without violating at least one of the rules.<p>A few days ago, I ended up writing something along these lines:<p>```<p>def something\n  err, obj1 = dependency1.call(someargs) \n  return err, obj1 if err.nil?<p><pre><code>  err, obj2 = dependency2.call(obj1) \n  return err, obj2 if err.nil?\n\n  err, obj3 = dependency3.call(obj2) \n  return err, obj3 if err.nil?\n\n  err, obj4 = dependency4.call(obj3) \n  return err, obj4 if err.nil?\n\n  err, obj5 = dependency5.call(obj4) \n  return err, obj5 if err.nil?\n\n  [nil, obj5]</code></pre>\nend<p>```<p>This is a pipeline, to a human being it looks simple because the &quot;return line&quot; after reading the first time and understanding it&#x27;s an early exit in case of errors, it&#x27;s identical in all 5 steps. Human brain just excludes those returns after having understood that.<p>Rubocop however claims that there is too much complexity going on here due to 5 if branches. That&#x27;s a machine reading the code.<p>If I have to rewrite the code according to rubocop standards, it ends up being a lot less readable and with a lot more indirection for no particular advantage.<p>I find it funny, we use styleguides to ease human interactions with code, but we let the machine evaluating that. It&#x27;s problematic, the machine doesn&#x27;t see the code as us.')