Item(by='KMag', descendants=None, kids=[25683233, 25684113], score=None, time=1610095875, title=None, item_type='comment', url=None, parent=25682469, text='Speaking of TCO constraints, all of the common C&#x2F;C++ calling conventions[0] have a fixed size stack cleanup.  Some are caller-cleanup and some are callee-cleanup, but they all have amounts of stack cleanup that are constant (cdecl,stdcall,thiscal, etc.) or at least fixed at call time (varargs).<p>This means that TCO can&#x27;t be done across calls where the amount of stack space used for arguments in the callee is larger than that of the caller.  (In cases where the stack space used by the callee is less than the caller, the caller just needs to leave &quot;wasted&quot; stack space as if amount of stack space used by arguments were the same.)  It wouldn&#x27;t be much of a point on architectures where the cdecl calling convention passes enough arguments in registers to cover the majority of functions, except that some of these ABIs (notably Windows x64 calling convetion, but not Linux x64_64 SysV ABI) require the caller to allocate shadow space on the stack for all register-passed arguments.  (Edit: I was wrong, the Windows shadow space on the stack is a fixed 32 bytes, regardless of the number of register-passed arguments.)<p>This motivates a couple of ABI questions:<p>1. Why does the Windows x64 ABI require the caller to pre-allocate &quot;shadow space&quot; to potentially spill register-passed arguments?  It&#x27;s wasteful if it&#x27;s not needed (especially in ABIs with a redzone), and it reduces opportunities for TCO.  (Edit: ahh, unlike Linux, the Windows x64 calling convention has no redzone.  I guess this then becomes &quot;Why doesn&#x27;t Windows x64 provide a redzone?&quot;)<p>2. Why not define a calling convention that is callee-cleanup where the post-cleanup stack pointer is passed in a designated register (or at the top of the stack) to the callee?  I understand that it might not make sense to pay the cost (fewer arguments passed in registers, and often an extra stack spill) for the majority of functions, but it seems an oversight that there&#x27;s not a calling convention that (in the absence of destructors) always allows tail calls to be optimized.<p>I guess the answer to both questions is that most TCO opportunities are within a single DLL, so the compiler is free to create non-exported versions of functions with custom calling conventions.  Is this right?<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86_calling_conventions" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86_calling_conventions</a> plus their variants on other architectures')