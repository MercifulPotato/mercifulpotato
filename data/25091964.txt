Item(by='andrewjl', descendants=None, kids=None, score=None, time=1605357628, title=None, item_type='comment', url=None, parent=25091708, text='&gt; because we&#x27;re always learning, and we can always do <i>better</i><p>I think this is a very important point, but it should IMO be considered along with context. Languages are always used with a particular tech stack, targeting particular hardware, all with its own performance characteristics. For example languages with garbage collection will have to have a different design from languages that use reference counting. And that&#x27;s OK!<p>It&#x27;s useful IMO to think of languages in terms of the use cases they&#x27;re effective in. Some are good for resource constrained environments, others are highly flexible, others are great at expressing mathematical concepts. All those are unique use-cases and it shouldn&#x27;t be surprising that the best languages for each are very different.<p>Where I think languages can run into trouble is where they try to be all things to all people. A universal tool sounds cool in theory, in reality they risk becoming mediocre at everything or developing what are affectionately named <i>footguns</i>. These steepen the learning curve and can also cause problems in real-world deployments of software in that language.')