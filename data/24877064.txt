Item(by='echelon', descendants=None, kids=[24877560, 24878542], score=None, time=1603515514, title=None, item_type='comment', url=None, parent=24877020, text='C++ has a ton of baggage and is a very difficult language to use. There are too many language features and they all have years of warts.<p>Imagine PHP, but not memory safe. Mistakes cause segfaults, memory leaks, and can enable attackers write memory they shouldn&#x27;t be able to access. To top it off, a lot of libraries are still written in &quot;PHP4 style&quot; and you&#x27;ve got to make use of them. C++ is really hard.<p>Both C and C++ require consideration of memory semantics, and they are both &quot;hard&quot; in this sense. You have to allocate and free memory deliberately and be conscious about what memory you&#x27;re passing around. C is much simpler in design than C++. It doesn&#x27;t have as many features, so it&#x27;s harder to trip over. It doesn&#x27;t necessarily make it easier to program, though.<p>Rust targets the same domains that C and C++ do: systems programing (operating systems and drivers), real time programming (robotics and control software), graphics and games, etc. These are places where explicit memory management is important. Rust does so while being much easier to write. The language leverages new programming language theory and design to protect memory from being written incorrectly. The memory semantics are baked into the language design and checked at compile time. Bad code (in terms of memory and async) simply doesn&#x27;t compile.<p>Rust does this while being just as fast as C and C++.<p>In addition, Rust has a ton of modern features that make it feel like Ruby. Functional idioms, zero-cost abstractions, a modern trait-based type system, generics, macros, and a beautiful package manager and package ecosystem that is better than Ruby and npm.<p>Rust is going to beat both of these languages.')