Item(by='jerf', descendants=None, kids=None, score=None, time=1607353525, title=None, item_type='comment', url=None, parent=25331836, text='One of the things I&#x27;ve taken to doing on the semi-annual &quot;Hey HN I&#x27;ve Fixed All Programming Problems Forever with $THIS&quot; posts is encouraging people to head straight at these hard problems. I&#x27;ve also been encouraging the commenters writing the writing the &quot;dear lord it&#x27;s so obvious that we just need to drop everything and use $THIS&quot; to be thinking more about the hard problems.<p>I believe I&#x27;ve now issued my challenge to the Visual Language of the Day developers to three different people to not show me how to add 1 over a list, but to implement Quicksort (or an equivalently complex algorithm of your choice) in your new graphical language and show me how it&#x27;s at least <i>as</i> easy to understand as the current paradigm. I chose that one on purpose on the grounds that it&#x27;s actually not that understandable in normal notation, so I didn&#x27;t choose that to be difficult exactly, I chose it as something that has some space for improvement, and, like I said, I&#x27;ll accept any other non-trivial algorithm that you can make a decent case for being easier. I think only one of them actually drew it out, and it wasn&#x27;t terribly nice; the others have ignored me.<p>Bret Victor&#x27;s &quot;live views of the variables updating&quot; stuff looks amazeballs in a crafted demo where only a couple of entities have their X+Y positions displayed in real time, with real-time modification. But it&#x27;s actually not as new as some people think; I&#x27;ve used debuggers with that capability for a while now. It gets a lot less &quot;ooo.... aaaa...&quot; when you&#x27;ve got hundreds of live-updating values on the screen, and when you&#x27;ve got <i>structured</i> values being manipulated, like, something is adding values to a list as you go, or adding entries to a hash or something. It&#x27;s actually still really useful and perhaps underused by some people (debuggers, people, I&#x27;m down with claims you shouldn&#x27;t live in them but you need to learn how to use them when you need them!), but it&#x27;s been around for a long time actually and in practice it isn&#x27;t quite as game-changing as it looks, because it doesn&#x27;t solve the problem of finding the <i>important</i> data. Figuring out which parts of a log are important and figuring out which of the hundreds of changing, complicated variables are important aren&#x27;t <i>that</i> different in terms of effort.<p>In a nutshell, it&#x27;s scale. A lot of these alternate &quot;Solutions to Everything&quot; <i>don&#x27;t scale</i>. For all the faults of &quot;text based programming&quot; (instead of a richer manipulation system, or a visual system, or whatever) and our documentation schemes and the way we debug and how we write our code guarantees and so on and so on... they <i>work</i>. We build large systems with them at scale, routinely. The large systems are perhaps ugly, prone to failures, coughing smoke out of many orifices, and often built of complete garbage, but they <i>work</i>. These &quot;Solutions to Everything&quot; tend to break down at scales multiple orders of magnitude smaller than the current-practice competition.<p>By no means does that mean nobody should be working on new ideas, be they revolutionary rewrites of the entire status quo, or small improvements to make a lot of people&#x27;s code a little better. My point is more that especially if you want to rewrite the status quo, you have <i>got</i> to focus above all else on how your solution is going to <i>scale</i>. Your cute little demo that fits on a screen is still going to be necessary to introduce people to your idea, but show me how your system looks with several thousand of whatever it is you are doing, at the very least. I also tell you that my standard isn&#x27;t &quot;does that look good&quot;, because honestly, at that scale nothing looks good because it no longer fits in human cognition; my standard is that you need to have something <i>better</i> than the current standard, which also doesn&#x27;t fit into human cognition. You don&#x27;t need to propose something that we can rewrite operating systems or office suites in, there&#x27;s plenty of other niches, but you <i>do</i> need to propose something that can go beyond a single screen.<p>The main function programming languages face is not serving up bite-size bits of functionality in comprehensible ways, it&#x27;s providing ways to slice things into bite-sized bits that fit into my pathetically limited human cognition in the first place. I don&#x27;t need a better way to understand that this bit of code adds one to everything in the list, I need better ways of breaking problems down into smaller pieces without incurring disadvantages in system organization, performance, composability, etc.')