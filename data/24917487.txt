Item(by='jefftk', descendants=None, kids=[24917911], score=None, time=1603884044, title=None, item_type='comment', url=None, parent=24913735, text='For the opposite perspective, I work at one of the FAANGs and I&#x27;ve given about 200 interviews. A mix of initial screening interviews and full evaluative interviews. At the screening stage I&#x27;ve interviewed several people who looked great on their resume and were really good about talking about programming and what they liked, but couldn&#x27;t code even my warm-up problem on the whiteboard. These weren&#x27;t people who were too anxious to code well in this setting, [1] these were experts in BS. Because the company is very careful&#x2F; slow to with firing people, which I generally think has really positive effects on employee well-being, hiring someone like this would be really bad.<p>Much less extreme, but I&#x27;ve also seen many people who looked very similar in their resumes but were worlds apart in how the coding interview went. Some of them could quickly flush out specifications, asking good questions, talk about why they want to solve the problem the way they did, and fluently write code, while many others struggled in different areas or sometimes all of the areas. This is also really important for figuring out which of them we want to hire, and how badly we want to hire them.<p>How the interview is run matters a lot, and also what sorts of problems you choose. I think it&#x27;s really important to choose problems that aren&#x27;t essentially spending 45 minutes on one narrow knowledge test (especially of the &quot;have you already seen this before&quot; variety), but instead test as many aspects of the person&#x27;s skills as possible. I want to see how they handle incomplete requirements, simple design, thinking about how to create an output format that is maximally useful to a consumer on another team, naming things, thinking about the runtime of different approaches, thinking about big-O space usage, thinking about back of the envelope space usage in bytes, coding, thinking about edge cases, etc. If I had more time I would want to check code reading, testing, and debugging as well, since these are so important to being an effective programmer, but they&#x27;re unfortunately much slower to evaluate.<p>[1] I&#x27;ve interviewed people like that as well, and within the confines of the interview I&#x27;ve been asked to run the best I can do is note that I don&#x27;t think we&#x27;re able to evaluate them well this way.')