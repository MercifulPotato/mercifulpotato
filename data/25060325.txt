Item(by='hajile', descendants=None, kids=[25061883], score=None, time=1605115129, title=None, item_type='comment', url=None, parent=25048238, text='I&#x27;d kill for them adding support for structurally typed, non-nullable immutable tuples and records, destructuring, and pattern matching. This would make sharing data across channels much safer and seems like it could be implemented with minimal syntactic changes. I envision something like the following.<p><pre><code>    &#x2F;&#x2F;full-blown tuple support\n    var person (string, string) = (&quot;John&quot;, &quot;Doe&quot;)\n\n    &#x2F;&#x2F;records are just tuples with named fields, but can use existing struct access syntax.\n    var point #{x: int, y: int, z: int} = #{x: 1, y: 2, z: 3}\n\n    &#x2F;&#x2F;due to structural typing, we can just use a type alias\n    type Person = (string, string)\n    type Point = #{x: int, y: int, z: int}\n\n    var person Person = (&quot;John&quot;, &quot;Doe&quot;)\n    var point Point = #{x: 1, y: 2, z: 3}\n\n    &#x2F;&#x2F;or just infer\n    person := (&quot;John&quot;, &quot;Doe&quot;)\n    point := #{x: 1, y: 2, z: 3}\n\n    &#x2F;&#x2F;destructure\n    fname, lname := person\n    \n    &#x2F;&#x2F;destructure record&#x2F;tuple\n    {x, y, z} := point\n\n    &#x2F;&#x2F;destructure array or slice (c is always slice)\n    [a, b, ...c] := myArray\n\n    &#x2F;&#x2F;pattern matching on tuple\n    switch person {\n        case (&quot;John&quot;, &quot;Doe&quot;): &#x2F;&#x2F;do exact match\n        case (&quot;John&quot;, _): &#x2F;&#x2F;only match first name\n        case (fname, lname): &#x2F;&#x2F;use new variables\n        default: &#x2F;&#x2F;this is the same as `case _:`\n    }\n\n    &#x2F;&#x2F;pattern matching on record or struct\n    switch point {\n        case {x, y, 0}: &#x2F;&#x2F;do stuff with variable match\n        case {1, 1, 1}: &#x2F;&#x2F;do stuff with exact match\n        default: &#x2F;&#x2F;do stuff\n    }\n\n    \n    &#x2F;&#x2F;same style of error handling with more flexibility\n    switch getPointWithPossibleError(point1, point2) {\n        case (_, {type: &quot;error1&quot;, msg}): &#x2F;&#x2F;handle error 1\n        case (_, {type: &quot;errorN&quot;, msg}): &#x2F;&#x2F;handle error N\n        case ({x, 0, 0}, _): &#x2F;&#x2F;handle exceptional case\n        case ({x, y, z}, _): &#x2F;&#x2F;handle default case\n    }</code></pre>')