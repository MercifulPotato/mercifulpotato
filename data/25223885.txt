Item(by='erincandescent', descendants=None, kids=[25225579], score=None, time=1606428625, title=None, item_type='comment', url=None, parent=25222240, text='You have a task to build a Thing, which involves creating the basic &quot;Thing framework&quot; and then implementing subfeatures A, B and C of into&#x2F;on top of it<p>Maybe you&#x27;ll build the framework &amp; subfeature A together, because you need some bit of meat in there to properly figure things out and be able to test things<p>On Gerrit you&#x27;d probably create two commits which get pushed as two CLs<p>* CL1 Create Thing framework\n* CL2 Implement A for Thing<p>They&#x27;re now pushed for people to review. While they&#x27;re looking at them, you continue working on, making CL3 implementing B<p>* CL3 Implement B for Thing<p>One of your coworkers points out an issue in CL1, so you fix it (by amending the commit) and repush the stack. Now your stack is<p>* CL1 Create Thing framework [v2]\n* CL2 Implement A for Thing\n* CL3 Implement B for Thing<p>CL1 &amp; CL2 get approved so you merge them (though typically with Gerrit they&#x27;re cherry picked - CLs are individual Git commits). You push up an implementation of CL4, so your stack now looks like<p>* CL3 Implement B for Thing\n* CL3 Implement C for Thing<p>The important point is that CLs are atomic (and are reviewed atomically) even if they depend upon each other (i.e. are a part of a stack). When you&#x27;re working in Git you typically (unless for whatever reason you have multiple unrelated stacks on the go, which is relatively rare) just work off of the master branch, so all the commits between `origin&#x2F;master` and `master` - i.e. the set that automatically show up in `git rebase -i` and similar tooling - are your stack. When you pull, you `git pull --rebase` (or rather set the config for your machine or repo to default to that). When you&#x27;ve revised something in your stack or want to add something to it, you just do &quot;git push HEAD:origin&#x2F;refs&#x2F;for&#x2F;master&quot; update Gerrit with the latest version of your stack<p>It takes a little time to get used to (and you have to learn how to hold `git rebase -i` properly), but when you&#x27;re used to it it&#x27;s <i>immensely</i> more productive than the Github&#x2F;clones PR flow (and doesn&#x27;t involve manual branch juggling, etc). I can&#x27;t express just how badly they deal at handling reviews of stacked PRs - either you create your stacked PR targeting master (and it gets all of the changes from the underlying PRs merged into its changes list, which makes reviewing it harder) or you target it at the branch of the underlying PR (which is non-obvious and painful and you have to manually remember to shift it across when the PR beneath it gets merged)<p>When I&#x27;m in this situation when dealing with something which is PR based, I tend to end up merging CL1 &amp; CL2 (because its easier to review things when you have an example) and hang on to CL3 &amp; CL4 on my local machine until the first one gets merged')