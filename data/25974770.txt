Item(by='jlokier', descendants=None, kids=None, score=None, time=1612055858, title=None, item_type='comment', url=None, parent=25970298, text='&gt; solving the TCP ossification issues by decoupling protocol upgrades from OS upgrades<p>QUIC explicitly addresses <i>&quot;network middlebox</i> ossification&quot; of TCP, by encrypting almost everything about the protocol.  This type of ossification is where the network blocks or corrupts any deviations that it doesn&#x27;t recognise but thinks it does.<p>TCP &quot;OS ossification&quot; is a different kind.  By itself, this could have been overcome by streaming TCP-in-UDP and amending it from there.  Even that is only because of OS APIs.  If OSes allowed applications to bind to a TCP port and process the raw packets, applications that want to could implement TCP themselves.<p>If that kind of dual-binding seems strange, I think it&#x27;s actually more or less what we&#x27;ll end up with with QUIC in the end: The OS providing QUIC sockets (socket(AF_INET,SOCK_QUIC,...)) to applications that don&#x27;t care to implement the QUIC stack themselves, while allowing other applications to bind to UDP in the usual way and implement their own application-level QUIC.<p>I think current QUIC solves application vs. OS ossification issues in the short term, allowing things to evolve beyond TCP, but it&#x27;s a temporary benefit.<p>In time I think we will see QUIC ossify when it&#x27;s implemented in many applications that don&#x27;t get updated.<p>Most browsers are updated often.  But I&#x27;m seeing more obscure applications starting to include QUIC and depend on it (without any TCP fallback even) - leading eventually to hundreds of &quot;hand-written quality&quot; QUIC implementations, all destined to get out of date.  Various languages are implementing their own QUIC libraries, and these aren&#x27;t all going to be maintained the same way.  Shipped applications ossify too.<p>That&#x27;s why I think it&#x27;ll end up in the OS kernels eventually.')