Item(by='pdonis', descendants=None, kids=[25393440, 25392480], score=None, time=1607725459, title=None, item_type='comment', url=None, parent=25389867, text='You left out a couple of extra steps. :-)<p><i>&gt; myObj is fetched from the local scope array by array-index</i><p>That&#x27;s true if myObj is a known local variable (assuming you&#x27;re inside a function or class block--in global scope there is no &quot;local scope array&quot; to begin with). But if it&#x27;s not, myObj has to be looked up in the dictionary of global variables, which is slower than the fast local array indexing. (And there is also the nonlocal keyword, which further complicates the lookup since enclosing non-global scopes also have to be included.)<p><i>&gt;  Or was it one merged dict?</i><p>No, it&#x27;s separate. And it&#x27;s further complicated by descriptors; first the lookup needs to check if MyMethod is a descriptor (such as a property) on the class, and if it is and the descriptor is a data descriptor (i.e., has a setter method), it overrides the lookup in the instance dictionary.<p><i>&gt;  All __slots__ does is mean that myObj doesn&#x27;t need its own dictionary, it still has to go to __class__ for a dictionary hit</i><p>Yes, __slots__ is an optimization to reduce memory consumption, not to increase speed.<p><i>&gt; surprised that there were so many unoptimized layers involved in resolving a method</i><p>They can&#x27;t be optimized in the general case without sacrificing the dynamic attributes of the language, which would defeat the purpose.<p>Optimizers like PyPy focus on optimizing these layers in the special cases where particular dynamic attributes aren&#x27;t being used in particular parts of the code. Cython, which does as much static analysis at compile time as possible to enable eliminating the extra lookups when they&#x27;re not going to end up changing anything, is another example of the same idea.')