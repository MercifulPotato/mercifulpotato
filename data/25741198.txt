Item(by='ghc', descendants=None, kids=None, score=None, time=1610415791, title=None, item_type='comment', url=None, parent=25735691, text='&gt; Was going to respond that I recall the F-35 uses C++<p>AFAIK its critical flight systems are still in Ada, but it&#x27;s a beast of a software platform. My company joined the effort last year and found that even our tiny area was an incredible mess of different technologies.<p>&gt; Regarding choice of language, I&#x27;ve reached a level of general competence where I don&#x27;t really find any intractable problems that I can&#x27;t handle with my toolset. So part of this may be just personal preference where there&#x27;s no justification for slogging through the cost of learning yet another language, especially if I don&#x27;t find it fun to program in. I used to invest a lot of time in learning new languages but I no longer find this a good use of my time.<p>Personally I wouldn&#x27;t learn new tools unless your existing toolset proved inadequate. But I&#x27;m pretty jaded at this point. Learning new techniques, on the other hand, I would never stop doing. Everything from design patterns to compiler design, from dynamic programming to category theory - it all has made me a better programmer regardless of the tools I have at my disposal.<p>&gt; !) &amp; 2)<p>I agree on 1, to a certain extent. The trouble with that approach is the development time of solutions is pretty excessive. Ironically probabilistic programming suffers from this same issue. I would be satisfied is software engineering was just <i>actual engineering</i>, which it isn&#x27;t.<p>I don&#x27;t think we&#x27;ll achieve the transition of software into an engineering discipline until we have better methods of communicating to both the human and computer in parallel. My guess is we might be 50 to 100 years away still.')