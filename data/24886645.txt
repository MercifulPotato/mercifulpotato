Item(by='MauranKilom', descendants=None, kids=[24887182], score=None, time=1603637013, title=None, item_type='comment', url=None, parent=24867610, text='I really enjoyed this writing!<p>The only thing that I find weird is the description of the leaky abstractions for the pin interface in &quot;traditional&quot; OOP. I understand the general sentiment, but this particular case is a prime example where polymorphy expresses the exact same thing just as well (here in C++):<p><pre><code>    class Pin\n    {\n    public:\n      Pin(std::uint8_t pin) : _pin(pin) {}\n      virtual ~Pin() = default; &#x2F;&#x2F; base class could also be made abstract here\n    private:\n      std::uint8_t _pin;\n    };\n\n    class ReadPin : public Pin\n    {\n    public:\n      ReadPin(std::uint8_t pin) : Pin(pin) {}\n      double read();\n    };\n\n    class WritePin : public Pin\n    {\n    public:\n      WritePin(std::uint8_t pin) : Pin(pin) {}\n      void write(double level);\n    };\n</code></pre>\nYou can then end up either with<p><pre><code>    ReadPin sensor_pin = gpio.getReadPin(SENSOR);\n</code></pre>\nor, if you for some reason want to keep the chaining, nothing prevents you from having a<p><pre><code>    ReadPin sensor_pin = gpio.getPin(SENSOR).asReadPin();\n</code></pre>\nMaybe it&#x27;s just not the right kind of example, but I don&#x27;t really understand how OOP&#x27;s failure is that you can call write on a ReadPin. The author says:<p>&gt; This kind of compromise happens often in the &quot;kitchen sink&quot; approach of OOP, where a child class might have access to inappropriate data or behaviour. Perhaps that data is relevant to a sibling class, but this is a sign of the abstraction leaking.<p>...which boils down to &quot;if you violate the Liskov Substitution Principle, you are not using OOP correctly&quot;. I concede that this can and occasionally does happen in practice, but it&#x27;s not like other languages are incapable of following the SOLID. It might just be easier to not do so.')