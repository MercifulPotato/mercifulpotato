Item(by='dragontamer', descendants=None, kids=[25823660], score=None, time=1610985718, title=None, item_type='comment', url=None, parent=25822869, text='Since you asked this question in two different locations, I&#x27;ll give a 2nd answer here.<p>One way to construct a Reed Solomon code is to create a Vandemonde Matrix.<p><pre><code>    1 a^1 a^2 a^3 a^4 a^5 ...\n    1 a^2 a^4 a^6 a^8 a^10 ...\n    1 a^3 a^6 a^9 a^12 a^15 ...\n    ...\n</code></pre>\nAll of the &quot;1&quot; values are from a^0.<p>As long as a^1, a^2, a^3... are distinct, then this matrix is invertible (aka: all rows &#x2F; columns are linearly independent). In a GF(2^8) field, there are 2^8-1 distinct values (the values 0x01 through 0xFF), making a 255x255 matrix. The polynomial &quot;x&quot; (aka: 0x02) is often chosen to be the value of &quot;a&quot;, but it can be any primitive element that loops around all 255 non-zero numbers and still work.<p>This Vandemonde Matrix has a very simple construction, but it is non-systematic (the data is &quot;mangled&quot; in encoded form, so we need to invert the matrix to decode). However, this non-systematic form is easier to see some patterns. Now lets take the 1st column:<p><pre><code>    1\n    1\n    1\n    1\n    1\n    ...\n</code></pre>\nHmmm... look familiar? What happens when we multiply the data vector with this column?? It becomes a bit more obvious:<p><pre><code>                       1\n                       1\n                       1\n    [d0 d1 d2 d3...] * 1\n                       1\n                       1\n                       1\n                       1\n                       1\n</code></pre>\nRemember, in Reed-Solomon, you perform operations over GF(2^blah). So all multiplications are GF-multiplications. But these are all multiplications by 1, so we can just ignore the complications of GF-multiplication entirely. (Even in GF(): a multiplication by 1 is just the identity).<p>To finish the matrix-multiply, we add everything together. But we do GF-addition (not regular addition). A GF-addition is also known as XOR. So the ultimate answer is:<p><pre><code>    d0 XOR d1 XOR d2 ...\n</code></pre>\nWhich so happens to be the first parity bit of the non-systematic Reed Solomon code. As such, we&#x27;ve proven the relationship between the &quot;XOR trick&quot; and Reed Solomon (Vandemonde construction).<p>------------<p>The hamming-distance between codes is 1. We can correct floor(1&#x2F;2) errors (aka 0 errors) and 1 erasure. As such, this &quot;all 1s matrix&quot; is a 1-erasure punctured Reed Solomon code.')