Item(by='Jach', descendants=None, kids=[25294628], score=None, time=1607018575, title=None, item_type='comment', url=None, parent=25290348, text='SBCL has a manual, your main questions are answered in it: <a href="http:&#x2F;&#x2F;www.sbcl.org&#x2F;manual&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.sbcl.org&#x2F;manual&#x2F;</a><p>Under the dev-tools&#x2F;editor section you&#x27;ll see slime mentioned. It too has a manual: <a href="https:&#x2F;&#x2F;www.common-lisp.net&#x2F;project&#x2F;slime&#x2F;doc&#x2F;html&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.common-lisp.net&#x2F;project&#x2F;slime&#x2F;doc&#x2F;html&#x2F;</a><p>It&#x27;s common to use slime with emacs, but vim and atom work too. Slime includes a lisp program called swank which sets up a simple server that clients like emacs can open a socket to. In Common Lisp, &quot;compile&quot;, &quot;eval&quot;, &quot;load&quot;, &quot;break&quot;, etc. are built-in functions. Lisp programs are &#x27;alive&#x27; and can be constructed or debugged and updated by compiling and executing bit by bit without having to suspend or restart the process, using the socket to communicate how to grow. Some examples are in this several part series you can take 10 mins to browse through: <a href="https:&#x2F;&#x2F;malisper.me&#x2F;debugging-lisp-part-1-recompilation&#x2F;" rel="nofollow">https:&#x2F;&#x2F;malisper.me&#x2F;debugging-lisp-part-1-recompilation&#x2F;</a> Going beyond that into say developing a full application with version pinning of dependencies and tests is documented in books&#x2F;in pieces on the web (CL cookbook has a lot).<p>But manuals tell a lot too. Under SBCL&#x27;s Saving a Core Image, you can see a standalone executable can be made with save-lisp-and-die. But you can also load things with --script if you want a python or node like experience.')