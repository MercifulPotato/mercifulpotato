Item(by='Tuna-Fish', descendants=None, kids=[25263931, 25263580, 25264050, 25263584], score=None, time=1606810931, title=None, item_type='comment', url=None, parent=25262919, text='The reason it doesn&#x27;t help them that much in performance is that the difference in the way x86&#x2F;ARM manage memory is not that ARM reorders more and x86 reorders less, but that ARM reorders openly and x86 reorders things behind your back but makes sure everything is where you think they should be if&#x2F;when you look.<p>This is the reason that the relatively primitive memory model of x86 has turned out to be so successful despite the consensus in the field being that it&#x27;s way to restrictive for performance way back in the 90&#x27;s. It turns out that the x86 memory model is an easy target for a complex reordering backend to provide as a &quot;facade&quot;, between what is actually happening the in CPU&#x27;s own L1 and buffers and what everything else thinks it&#x27;s doing.<p>The only way weaker memory orderings benefit is that they don&#x27;t need as large buffers and queues on the backend, as they can retire memory operations earlier. Except that if you just implement the ARM memory model as specified and without a similar facade, it will actually lose to modern x86, because the x86 chip can make use of the freedom provided by it&#x27;s machinery to reorder even more without any of it ever being visible to the software. So you end up implementing a similar system as the x86, with only very minor gains from the fact that you can sometimes properly retire accesses earlier and thus get a little more use out of your buffers.<p>ARM, especially 64-bit ARM, has genuine advantages over x86. (Notably, decode.) The weak memory model is not one of them, outside the very weakest and tiniest cores (where it allows some reordering with a tiny load-store backend).')