Item(by='pgt', descendants=None, kids=[24945424, 24944699, 24947952, 24943572], score=None, time=1604058618, title=None, item_type='comment', url=None, parent=24940838, text='Having built remote monitoring and firmware updating systems for high-current LiFePO4 batteries in Rust for low-level STM32 and ESP32 integrations, Clojure for backend and ClojureScript on the frontend - I can corroborate this.<p>The dynamism of Clojure and the memory safety of Rust are a strong combination, especially for streaming EDN data over websockets to Clojure or ClojureScript frontend.<p>However, neither Rust nor Clojure is the end-game. Eventually all languages will IMO adopt memory lifecycle management (lookahead guarantees) and borrow-checking as language features to do runtime optimization.<p>An interesting language in this regard is Carp, a high-performance statically-typed Lisp implemented in Haskell with borrow-checking: <a href="https:&#x2F;&#x2F;github.com&#x2F;carp-lang&#x2F;Carp" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;carp-lang&#x2F;Carp</a><p>It&#x27;s a shame they did not opt to follow Clojure syntax more closely, or it would make the transition much easier for the growing Clojure community. Clojure seems to be winning the Lisp language wars.<p>Rust could have be so much more if it used S-expressions or M-expressions. The macro language is an abomination compared to Lisp, but I understand they had to lure the embedded C crowd.')