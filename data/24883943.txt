Item(by='bluk', descendants=None, kids=[24885330, 24884202, 24885286], score=None, time=1603602034, title=None, item_type='comment', url=None, parent=24867610, text='FWIW, for the process_item function, I&#x27;ve found writing it like:<p><pre><code>  struct Item {\n      value: u32,\n  }\n\n  fn process_item(input: Option&lt;Item&gt;) -&gt; Option&lt;Item&gt; {\n      input.map(|mut item| {\n          item.value += 3;\n          item\n      })\n  }\n</code></pre>\nto be more &quot;idiomatic&quot; instead of doing the match on the Option. The methods like &quot;unwrap_or...()&quot;, &quot;map...()&quot;, &quot;ok...()&quot;, &quot;and_then()&quot;, etc. on Result&#x2F;Option are very useful, if not a bit difficult to find the right one to use sometimes. Deeply nested match, &quot;if let Some&quot;, etc. code becomes like a straight chain of method calls. In the end, I find that the Result&#x2F;Option methods shorten code considerably and improve readability.<p>Also, instead of doing an unwrap() on optional values for assertion, sometimes I like:<p><pre><code>  let my_list = vec![1,2,3]; \n  assert_eq!(Some(&amp;my_list[0]), my_list.first());\n</code></pre>\nMostly just depends though since I don&#x27;t care too much in tests.')