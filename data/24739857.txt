Item(by='tzs', descendants=None, kids=[24740049, 24742612, 24740999, 24740117, 24740416], score=None, time=1602346029, title=None, item_type='comment', url=None, parent=24737789, text='In example #6, he gives this as the unreasonable approach:<p><pre><code>  var repo = new CustomerRepository();\n  var customer = repo.GetById(42);\n  Console.WriteLine(customer.Id);\n</code></pre>\nwith the issue being customer can be null, which is not being accounted for. The reasonable approach he says is to use a sum type:<p><pre><code>  var repo = new CustomerRepository();\n  var customerOrError = repo.GetById(42);\n  if (customerOrError.IsCustomer)\n      Console.WriteLine(customerOrError.Customer.Id);\n  if (customerOrError.IsError)\n      Console.WriteLine(customerOrError.ErrorMessage);\n</code></pre>\nDo most (or any) languages in which people take this approach actually enforce handling of all cases? Or could a programmer write that this way:<p><pre><code>  var repo = new CustomerRepository();\n  var customerOrError = repo.GetById(42);\n  Console.WriteLine(customerOrError.Customer.Id);\n</code></pre>\nand still have the same problem as the original?<p>It seems to me that the &quot;reasonable&quot; version is getting its reasonableness from naming the variable that gets the GetById return &quot;customerOrError&quot; which reminds the reader that there is an error case, not from the language having sum types. That&#x27;s just a convention. Nothing stops you from naming it &quot;customer&quot; just like in the &quot;unreasonable&quot; language.<p>(I&#x27;d actually expect that from a lot of people, because you are probably going to have a lot more code in the case that you have gotten the Customer variant than in the Error variant case, and you probably don&#x27;t want to be calling it customerOrError in the 99% of the code where you <i>know</i> that it is a Customer).')