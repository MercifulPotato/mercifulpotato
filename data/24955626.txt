Item(by='formerly_proven', descendants=None, kids=None, score=None, time=1604182373, title=None, item_type='comment', url=None, parent=24955083, text='Transactions give varying degrees of &quot;isolation&quot; between them, depending on the database (and its version + configuration). For example, in what SQL would call READ COMMITTED, where transactions will only read data that has been committed, read-modify-write updates are generally bugs. The classic example:<p><pre><code>    - Intent: both transactions deduct 50 money\n    - transaction 1: SELECT balance FROM account; &#x2F;&#x2F; = 100\n    - transaction 2: SELECT balance FROM account: &#x2F;&#x2F; = 100\n    - transaction 1: UPDATE account SET balance = 50\n    - transaction 1: COMMIT\n    - transaction 2: UPDATE account SET balance = 50\n    - transaction 2: COMMIT\n    - Result: balance is 50, but should be 0\n</code></pre>\nWith serializabile transactions (not all databases have this, particularly if you look beyond SQL):<p><pre><code>    - Intent: both transactions deduct 50 money\n    - transaction 1: SELECT balance FROM account; &#x2F;&#x2F; = 100\n    - transaction 2: SELECT balance FROM account: &#x2F;&#x2F; = 100\n    - transaction 1: UPDATE account SET balance = 50\n    - transaction 1: COMMIT\n    - transaction 2: UPDATE account SET balance = 50\n    - transaction 2: COMMIT -&gt; Fails, needs to retry\n    - transaction 2b: SELECT balance FROM account: &#x2F;&#x2F; = 50\n    - transaction 2b: UPDATE account SET balance = 0\n    - transaction 2b: COMMIT -&gt; Ok!\n    - Result: balance is 0\n</code></pre>\nBecause this is needed so frequently, databases have calculated updates, basically atomic operations:<p><pre><code>    - transaction 1: UPDATE account SET balance = balance - 50; &#x2F;&#x2F; values indeterminate\n    - transaction 2: UPDATE account SET balance = balance - 50; &#x2F;&#x2F; values indeterminate\n    - transactions 1,2: COMMIT\n    - Result: balance is 0\n</code></pre>\nOr, one could lock the rows, like so:<p><pre><code>    - transaction 1: SELECT FOR UPDATE balance FROM account; &#x2F;&#x2F; = 100\n    - transaction 2: SELECT FOR UPDATE balance FROM account: &#x2F;&#x2F; = transaction 2 is stalled until transaction 1 commits or rollbacks\n    - transaction 1: UPDATE account SET balance = 50\n    - transaction 1: COMMIT\n    &#x2F;&#x2F; transaction 2 can now continue and gets balance = 50\n    - transaction 2: UPDATE account SET balance = 00\n    - transaction 2: COMMIT\n    - Result: balance is 0\n</code></pre>\nAnd this is just one simple example of the problems you can have concurrently accessing <i>one</i> table, even while using transactions. Not to speak of the issues you can run into when interacting with systems outside a single database, which don&#x27;t interact with the transaction semantics of the DB.<p>Concurrency is just very non-trivial regardless the abstraction.')