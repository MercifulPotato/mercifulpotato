Item(by='Twisol', descendants=None, kids=None, score=None, time=1606796158, title=None, item_type='comment', url=None, parent=25262008, text='Although I agree with the core of your argument, I think this position is a little reductionist. Yes, you really do need to understand what&#x27;s going on under the hood (though, choose your hood). But you&#x27;re also almost-but-not-explicitly saying that analogies and metaphors are <i>not</i> valuable tools for engineering. I really strongly disagree with that.<p>As one example, I find analogies downright <i>necessary</i> when working with a complex domain -- you have to find ways to speak domainese in the software world, or speak programese in the domain world, and analogies are precisely the tool for that job. It&#x27;s easy to think that domain concepts should have a 1-1 representation in the software world, but in my experience, that&#x27;s neither true nor productive. You <i>do</i> need to understand (and document for others!) the mappings between those concepts, but they shouldn&#x27;t be so rigid.<p>On a related note, I&#x27;m reminded of Terence Tao&#x27;s thoughts on rigor in mathematics [0]. He divides expertice into pre-rigor, rigor, and post-rigor phases. It&#x27;s necessary to understand the rigorous elements, but those (a) build on intuititons built up over time in the pre-rigor phase and (b) support expert, formalizable intuitions in the post-rigor phase.<p>[0] <a href="https:&#x2F;&#x2F;terrytao.wordpress.com&#x2F;career-advice&#x2F;theres-more-to-mathematics-than-rigour-and-proofs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;terrytao.wordpress.com&#x2F;career-advice&#x2F;theres-more-to-...</a><p>&gt; So... if you want to become a decent software engineer, start with learning digital electronics and assembly.<p>I disagree here too, though less strongly. I think it&#x27;s important to have approximate intuitions that can be refined, rather than trying to manufacture a precise understanding out of nothing. Those intuitions can be built up by trying, failing, and accomplishing projects that you&#x27;re motivated by. Even if Djikstra is right about &quot;radical novelty&quot;, you obtain a certain amount of mechanical sympathy just by fighting with the computer and learning its needs.<p>The &quot;Purpose-First Programming&quot; research [1] that this article&#x27;s submitter also submitted today seems relevant.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25256874" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25256874</a>')