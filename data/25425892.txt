Item(by='temac', descendants=None, kids=[25431002], score=None, time=1607995532, title=None, item_type='comment', url=None, parent=25423703, text='Everybody seems to agree it is an LLVM bug, but &quot;UB&quot; is overloaded. There is no &quot;C&#x2F;C++ UB&quot; in the original program, but the optimizers can introduce &quot;LLVM UB&quot; in IR form, which then results in something substantially equivalent to what the mock transformed source codes shown for illustration would probably be compiled to. And introducing UB when there was none in the source code means there is a compiler bug.<p>On your remark about char*, it is an universal type alias, but I don&#x27;t think it is an universal provenance alias, sadly I don&#x27;t think such a thing even exist de-facto, and it will not even exist more formally when considering the PVNI-ae-ud model that is being cooked. Probably unwise to lean as usual on the aggressive optimisations side without even proving that the perf impact is that much interesting, evaluating the security &#x2F; quality and education impact, if you ask me. And even more problematic without even providing an escape hatch (1). But I know very well that state of mind has just won for now and I have to cope with it. Even more C programs will be retroactively declared completely incorrect (and not even just not-portable) because the compilers went too agressive at one point and the standard just standardized their aggressiveness instead of telling implementers to just stop being crazy.<p>(1) beyond, for some potential programs that would be otherwise impossible to express in C&#x2F;C++, exposing all the pointers. Well exposing all the pointers would be cute but the result would not be that much different from not having that kind of &quot;opti&quot;. Plus you would have to actually expose all your target pointers, so it is not really source compatible with unmodified existing codebases. So a per-access or at least per-pointer-doing-the-accesses universal provenance alias is needed to get a serious escape hatch.\nI&#x27;m also not extremely sure we can actually implement a memory allocator in C or C++ today (with whatever the modern compiler are &quot;optimizing&quot; with their partly informal provenance rules), nor that we will be able to with PVNI-ae-ud (broadly same thing except slightly debugged). (Or maybe it will merely constrain the implementation? not sure anyway)')