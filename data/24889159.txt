Item(by='one2know', descendants=None, kids=[24889248], score=None, time=1603654166, title=None, item_type='comment', url=None, parent=24889033, text='return values don&#x27;t say anything about possible code paths.  If you are saying the function should document what could go wrong when it is called, Java solved this 24 years ago when each method lists the exceptions they throw.  If you need to know what the back trace&#x2F;call stack was when the error happened, well that is stored in the exception.<p>People that use return codes simply don&#x27;t check every possible value, otherwise they would see that it increases program length by at least 50% and makes the code unreadable.  A common pattern in Go is this<p>if (err == MY_ERROR) {\n   log my error;\n   notify user;\n   return MY_ENCAPSULATING_ERROR_CODE\n}<p>for high quality code this has to occur for every function call in the entire codebase.  So you&#x27;ll get huge functions which are mostly &#x27;if&#x27; statements checking error codes, logging the results, and returning another error code that has to be checked again one step up the call stack.<p>moving from c++ to java 20 years ago it was clear that the c&#x2F;c++ community didn&#x27;t really know what they were doing in this regard.  A lot of c&#x2F;c++ dogma boilerplate code was holding it back.  Too bad some of it made it into golang.')