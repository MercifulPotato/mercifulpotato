Item(by='klodolph', descendants=None, kids=[25426006], score=None, time=1607979357, title=None, item_type='comment', url=None, parent=25423098, text='I&#x27;ve heard this proposal thrown around a lot on  HN, but how would that even work? Can you describe how the compiler would do this, what patterns it would look for, and what error messages it would produce? For example, consider this:<p><pre><code>    int factorial(int n) {\n        int r = 1;\n        for (int i = 1; i &lt;= n; i++) {\n           r *= i;\n        }\n        return r;\n    }\n</code></pre>\nSince there are two instances of possible UB in the above function, what error messages would you like the compiler to produce?<p>First of all, the compiler can assume that the loop terminates. This is a reasonable assumption from a human perspective—the loop is almost certainly <i>intended</i> to run N times. However, if n = INT_MAX, then there’s UB… and there’s no real way to know that n ≠ INT_MAX.<p>You could argue that you want -fsanitize=undefined, where the compiler inserts checks at runtime.<p>I don’t think this proposal is well formulated enough to be viable.<p>Or consider something like this:<p><pre><code>    void puts_safe(const char *s) {\n      puts(s == NULL ? &quot;(null)&quot; : s)\n    }\n\n    void puts_with_len(const char *s) {\n      printf(&quot;len = %zu\\n&quot;, strlen(s));\n      puts_safe(s);\n    }\n</code></pre>\nDo you want something like,<p><pre><code>    Warning: puts_safe replaced with puts, because s != NULL, because strlen(NULL) is undefined\n</code></pre>\nI suspect there would be a mountain of false positives, and I would rather just use a static analyzer.')