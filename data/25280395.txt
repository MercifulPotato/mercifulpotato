Item(by='cb321', descendants=None, kids=None, score=None, time=1606937348, title=None, item_type='comment', url=None, parent=25279996, text='One possibility is the almost dirt-simple solution wherein you just have a &quot;make&quot;&#x2F;&quot;Makefile&quot; (or your favorite other build system) maintain a shadow tree of parallel pre-translated files.  You get parallelism via `make -j$(nproc)` or its equivalent.<p>Every name in the shadow is built from the name in the origin but maybe with &quot;.txt&quot; added (or .txt.gz if you want to keep the compressed with whatever is the fastest decompressor builtin to ripgrep as a library not called as a program).  Untranslated names can be just symbolic&#x2F;hard links back to the origin.  Build rules become as flexible as your build system.<p>This also scales to deployments that have more disk space than memory.  Admittedly, in that case, the whole procedure probably becomes disk-IO bound, but maybe not.  Maybe some translations cannot even keep up with disk IO - NVMe storage is pretty fast, for example.  Or available memory may vary dynamically a lot, sometimes allowing the shadow to be fully in the buffer cache, other times not.  It strikes me as less presumptuous to assume you can find disk space vs. having that much memory available. (EDIT2: though I may be confused about how `rga` operates - your doc says &quot;memory cache&quot;, though.)<p>On the pro-side, but for updating the shadows based on origins, the user could even just `rg` from within the shadow and translate filenames &quot;in their head&quot;, although stripping an always present string is obviously trivial.  Indeed, you won&#x27;t need `rg --pre` at all and the grep itself could become pluggable.  I doubt any of your other `fzf`&#x2F;etc. integrations would be made more complicated by this design, either.<p>This all strikes me as simple&#x2F;nice enough that someone has probably already done it...EDIT1: Oh, I see from thumbs ups and other comments over at [1] and [2] that @phiresky is probably already aware of this design idea, but maybe some HN person knows of an existing solution along these lines.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&#x2F;issues&#x2F;978" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&#x2F;issues&#x2F;978</a>\n[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&#x2F;pull&#x2F;981" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&#x2F;pull&#x2F;981</a>')