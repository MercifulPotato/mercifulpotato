Item(by='pron', descendants=None, kids=[25305574, 25302358], score=None, time=1607085150, title=None, item_type='comment', url=None, parent=25301449, text='It&#x27;s like saying the article goes out of its way not to mention Scala&#x2F;Haskell&#x27;s IO type. Syntactic coroutines, monadic IO, and threads are different constructs, although they are different ways to address a similar problem -- expressing sequential (and, in contrast, parallel) composition. Virtual threads <i>are</i> Java threads; there&#x27;s nothing &quot;bolted&quot;. Syntactic coroutines are a kind of syntactic code-unit similar to subroutines.<p>Which one you prefer as a coding style is a matter of taste, but threads have some objective advantages over syntactic coroutines that go beyond syntax. For one, they don&#x27;t require a split API (C# and Kotlin have two copies of their synchronization and IO APIs that do the same thing but are intended for different kinds of units, subroutines or coroutines); for another, they seamlessly integrate with the platform and its tooling, allowing use of exceptions, debuggers and profilers with little or no change to those tools. The Java platform -- the standard library, the VM, and its built-in profiling and debugging mechanisms -- has been designed around threads.<p>BTW, Java&#x27;s strategy for targeting platforms like iOS and, later, the browser, is through AOT compilation of Java bytecode using things like Native Image (e.g. <a href="https:&#x2F;&#x2F;gluonhq.com&#x2F;java-on-ios-for-real&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gluonhq.com&#x2F;java-on-ios-for-real&#x2F;</a>). This allows you to employ the standard library as well. Kotlin&#x27;s approach is different, and requires different libraries when targeting different platforms.')