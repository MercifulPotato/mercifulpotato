Item(by='patrec', descendants=None, kids=None, score=None, time=1604959919, title=None, item_type='comment', url=None, parent=25028022, text='I think if you&#x27;re setting up a personal machine, your reasoning completely applies and a fairly superficial difference, like scheme being a more familiar language can indeed make a big difference. But I think NixOS or Guix-SD vs Ubuntu or Arch as your daily driver is mostly window dressing, you will not unlock significant productivity benefits by this choice alone unless you leverage it for setting up e.g. a unified dev&#x2F;ci&#x2F;prod setup with reproducible builds. At least streamlining artefact creation is where the real productivity benefits tend to come from in my experience.<p>However, from my own production experience with nix I find that language related overheads and frictions are just completely in the noise compared to grokking e.g. the many different flavors of overriding stuff or working out good workflows for pinning and bumping nixpkgs and individual dependencies, providing suitable overlays and integrating native language tooling (poetry, yarn, cargo etc.) with nix etc. etc. Now the language itself does have some psychological effect on wider adoption, but effectively scheme is equally obscure to almost any target audience and, IMO, an inferior design for this problem space, that presents a larger rather than smaller hurdle for most people. I guess the debugging experience at least must be better?<p>Don&#x27;t get me wrong, I&#x27;d prefer 99% of shitty DSLs (cmake, make, pom, jinja, moustache, chef and so on and so forth) had just used even a mediocre internal lisp&#x2F;scheme DSL. However, I&#x27;d say Nix is a bit of an outlier: it&#x27;s IMO a remarkably elegant design that really pulls its own weight. Most of my complaints  (poor debugging experience and error messages) are quality of implemenation rather than language design as such â€“ I am not quite sure to what extent this applies to lack of static typing.<p>In any case one of the main usability defects of nix is shared by guix: 90% of cases should be declarative toml or similar, not some weirdo turing complete language. It&#x27;s great to have a powerful language for the bits that actually need it, but a lot off stuff really shouldn&#x27;t. In particular mixing metadata (description, hashes, version numbers, urls etc.) with build descriptions is just a dumb and painful way to do things and completely screws up tooling. There are tools to help with that (e.g. niv), but this should just be fixed at the source.')