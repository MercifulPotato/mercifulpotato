Item(by='chriswarbo', descendants=None, kids=[25252982], score=None, time=1606478575, title=None, item_type='comment', url=None, parent=25224494, text='&gt; I cannot seem to find what changes by knowing that piece of information<p>The most common change is that writing convertion functions between &#x27;foo(bar, baz)&#x27;, &#x27;foo(bar)(baz)&#x27; and &#x27;foo((bar, baz))&#x27; calling conventions becomes more annoying. It&#x27;s not that I find myself doing it any more or less, it&#x27;s that knowing they&#x27;re equivalent makes it even more frustrating.<p>There can also be a difference in efficiency, e.g. in &#x27;foo(bar)(baz)&#x27; we can have &#x27;foo(bar)&#x27; pre-calculate something expensive, which will get re-used if we do things like &#x27;f = foo(bar); f(a); f(b); f(c); myList.map(foo(baz)); etc. whilst the &#x27;foo(bar, baz)&#x27; version will generally re-calculate such things every time.<p>Of course, this varies depending on compiler optimisations and other language features, but the nice thing about the &#x27;foo(bar)(baz)&#x27; version is that it can simply be a matter of scope, e.g. in Haskell:<p><pre><code>    foo1 x y = let cached = expensive x\n                in ...\n\n    foo2 x = let cached = expensive x\n              in \\y -&gt; ...\n</code></pre>\nWe can achieve a similar result in other ways and in many languages, but many of those alternatives (e.g. &#x27;static variables&#x27;, intermediate classes, mutable variables, etc.) require much more ceremony and boilerplate.')