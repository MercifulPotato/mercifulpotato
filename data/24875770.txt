Item(by='krytarowski', descendants=None, kids=None, score=None, time=1603498609, title=None, item_type='comment', url=None, parent=24875484, text='&gt; Are there multiple stop kinds that are somewhat difficult to distinguish against and keep track of?<p>Every type of an event has a dedicated pair of SIGNAL + SI_CODE (in siginfo_t).<p>The types of events are as follows: regular signals (usually not interesting for a debugger - NetBSD can mask them with PT_SET_SIGPASS), crashes (SIGSEGV, SIGFPE, SIGILL, SIGBUS) and debugger related events (SIGTRAP). Then, each debugger related event is distinguishable with checking si_code inside siginfo_t (TRAP_TRACE, TRAP_BRKP, TRAP_CHLD, TRAP_LWP, TRAP_DBREG, TRAP_SCE, TRAP_SCX) and in a few more cases with the additional ptrace(2) call PT_GET_PROCESS_STATE that can query additional information (spawned&#x2F;exited thread; forked&#x2F;vforked&#x2F;spawned process).<p>Thus we always have the exact thread + type of event.<p>There is one tricky case that is harder to code. It&#x27;s related to hardware assisted watchpoints, especially in multi-threaded processes with concurrent events of all kinds. We need to diligently handle the context of x86 Debug Registers that delivers the additional information about the fired hardware assisted watchpoint&#x2F;breakpoint.<p>&gt; How you handle a child dying while stopped, or is this not possible?<p>A stopped and traced child cannot just die, but it could be killed with SIGKILL. Then further ptrace(2) calls fail on it.<p>&gt; I don&#x27;t think NetBSD has the same &quot;tasks&quot; model that Linux does, how do you distinguish between requests targeting threads and requests targeting the whole process?<p>Generally, we have a pair of PID (process) + LWP (thread). We have got per-process + per-thread ptrace(2) operations. Whenever a thread is meaningful, like in the management of register contexts, we pass LWP as the 4th argument of the ptrace(2) call or embed in a structure transmitted from&#x2F;to the kernel.<p>In Linux, the ptrace(2) call is per-thread only, which allows some flexibility (the GDB non-stop mode), but introduces the complexity of the management. The NetBSD kernel serializes the events inside the kernel and stops all the threads before returning to the debugger.<p>&gt; How do the rest of the OS APIs interact with a ptrace stopped process?<p>It&#x27;s an internal detail whether a process is stopped by a debugger, by the terminal or actively running. This is orthogonal to other system APIs. Generally we try to make the fact of being traced to be transparent to other applications, for example we fake the parent PID (after reparenting, that happens after attach). There are some corner cases and real bugs in applications that are exposed under a debugger, such as missing EINTR handling.<p>The NetBSD Project over the past few years significantly improved in the domain of debuggers (GDB, LLDB) and developer-oriented tooling (sanitizers, compilers). Thus, there is still room for improvement!')