Item(by='nullc', descendants=None, kids=None, score=None, time=1607097516, title=None, item_type='comment', url=None, parent=25302843, text='Depending on your communications cost model there is no reason to use an <i>exponential</i> backoff with pinsketch: you can just send one (or N) more sketch-entries at a time. At a cost of one or two extra entries total, you can tell if you have enough before doing the costly computation.<p>[There are some utility functions in minisketch that tell you how much overhead you need to make all failures fast-detectable with a cryptographic level of certainty, it&#x27;s typically a tiny amount]<p>Your application may also know by construction that the symmetric difference won&#x27;t be larger than expected.  This is the case for e.g. biometric key generation-- if the difference larger than expected it just means the auth failed. Likewise for using pinsketch for anonymous communication.<p>If you notice on our graphs IBLT never gets to particularly low overhead-- at least for small keys, even when you accept low reliability.<p>Efficient fallback also doesn&#x27;t work quite as well for iblt:<p>For pinsketch when the sketch is too small you can send more entries (a shorter sketch is just a prefix of a longer sketch), which is perfectly efficient (+&#x2F;- rtt costs).<p>You can also bisect the sketch by splitting into two sketches with an arbitrary hash function and conserve your prior communication: you send the sketch of just the left half and the receiver can get the sketch of the right half by xoring the left with the parent sketch. Bisection has communications overhead because splitting will not distribute items perfectly equally.<p>For pinsketch the only reason you&#x27;d do the bisection thing instead of extending the sketch is because decoding has O(N^2) computational cost, but for IBLT bisection is the only option on failure other than totally start over with a bigger sketch (and waste all the prior bandwidth).<p>Unfortunately the bisection approach doesn&#x27;t work as well on IBLT because while pinsketch will be successful in every split segment as soon as that segment is under capacity,  IBLT will also continue to fail until the splitting removes all cycles from each segment. So you get inefficiency both from imbalance and from the need to eliminate cycles.<p>Obviously, what trade-offs will make the most sense depends on the application.  We&#x27;ve contemplated adding IBLT to minisketch as an option, particularly because the two approaches can be combined in several different ways: e.g. IBLTs where the buckets are small pinsketches just works(tm)) or e.g. when IBLTs fail they often decode most differences but have a few cycles, a small parallel pinsketch can have the known differences removed and resolve the cycles.')