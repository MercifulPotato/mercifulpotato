Item(by='daanx', descendants=None, kids=[25181197], score=None, time=1606069215, title=None, item_type='comment', url=None, parent=25178483, text='(Daan here, creator of [Koka](<a href="https:&#x2F;&#x2F;github.com&#x2F;koka-lang&#x2F;koka" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;koka-lang&#x2F;koka</a>)<p>This is an interesting point and comes down to the question -- what is an effect really? I argue that effect types tell you the type signature of the mathematical function that models your program (the denotational semantics). For example, the function<p><pre><code>  fun sqr(x : int) : total int { x*x }\n</code></pre>\nhas no effect at all. The math function that gives semantics to `sqr` would have a type signature that can be directly\nderived from the effect type:<p><pre><code>  [[int -&gt; total int]]  = Z -&gt; Z\n</code></pre>\n(with Z the set of integers). Now, for a function that raises an exception, it would be:<p><pre><code>  [[int -&gt; exn int]] = Z -&gt; (Z + 1)\n</code></pre>\nThat is, either an integer (Z), <i>or</i> (+), a unit value (1) if an exception is raised. Similarly, a function that modifies a global heap h, would look like:<p><pre><code>  [[int -&gt; st&lt;h&gt; int]] =  (H,Z) -&gt; (H,Z)\n</code></pre>\nthat is, it takes an initial heap H (besides the integer) and returns an updated heap with the result.<p>Now, non-termination as an effect makes sense: a function\nlike &quot;turing-machine&quot; may diverge, so:<p><pre><code>  [[int -&gt; div int]] = Z -&gt; Z_\\bot\n</code></pre>\nThat is, its mathematical result is the set of integers (Z) together with an injected bottom value that represents non-termination. (note: We don&#x27;t use &quot;Z + \\bot&quot; here since we cannot distinguish if a function is not terminating or not (in contrast to exceptions)).<p>In a language like Haskell\nevery value may not terminate or cause an exception -- that is a value `x :: Int` really has type `Int_\\bot`, and we cannot replace for example `x*0` with `0` in Haskell.<p>Note that in almost all other languages, the semantic function is very complex with a global heap etc, any function `[[int -&gt; int]]` becomes something like `(H,Z_32) -&gt; (H,(Z_32 + 1))_\\bot`. This is the essence of why it much harder for compilers and humans to reason about such functions (and why effect types can really help both programmers and compilers to do effective local reasoning)')