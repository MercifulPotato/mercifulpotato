Item(by='aidenn0', descendants=None, kids=[25433869], score=None, time=1608054665, title=None, item_type='comment', url=None, parent=25428621, text='I can&#x27;t stand pipefail, and I&#x27;m ambivalent about set -e.  It <i>usually</i> does what you want, which is sometimes worse than never doing what you want.  It&#x27;s usually fairly straightforward to test for failure at the toplevel manually with something like &quot;|| die &#x27;useful message&#x27;&quot;<p>What I would really like is if set -e would return from a function with an error (and if you wrap your entire function body in a subshell that&#x27;s how it works).  There are still some gotchas though: &quot;false &amp;&amp; true&quot; will not cause an error exit, nor will &quot;if someFunction; then ...&quot; exit if someFunction encounters an error, which is a problem if you have e.g.:<p><pre><code>    someFunction() {\n      cd &#x2F;some&#x2F;path\n      rm -rf *\n    }\n</code></pre>\nAnd expect &quot;set -e&quot; to prevent the remove command from running in the event of the CD failure.<p>Most shell scripts are short enough that you will notice the missing die in something like<p><pre><code>    foo || die\n    bar\n    baz || die\n</code></pre>\nAnd tools like shellcheck will flag dangerous commands that are missing an error check.<p>So, given a fairly short toplevel, set -e has minimal advantages, and it can&#x27;t be trusted to work inside a function.  Sounds pretty questionable to me.')